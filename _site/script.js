(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// http://stackoverflow.com/questions/839899/how-do-i-calculate-a-point-on-a-circles-circumference
// radians = degrees * (pi/180)
// https://github.com/bjornharrtell/jsts/blob/master/examples/buffer.html

var helpers = require('@turf/helpers');
var featureCollection = helpers.featureCollection;
var jsts = require('jsts');
var normalize = require('geojson-normalize');

/**
 * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
 *
 * @name buffer
 * @param {(Feature|FeatureCollection)} feature input to be buffered
 * @param {number} radius distance to draw the buffer
 * @param {string} units any of the options supported by turf units
 * @return {FeatureCollection<Polygon>|FeatureCollection<MultiPolygon>|Polygon|MultiPolygon} buffered features
 *
 * @example
 * var pt = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-90.548630, 14.616599]
 *   }
 * };
 * var unit = 'miles';
 *
 * var buffered = turf.buffer(pt, 500, unit);
 * var result = turf.featurecollection([buffered, pt]);
 *
 * //=result
 */

module.exports = function (feature, radius, units) {

    var degrees = helpers.distanceToDegrees(radius, units);
    var fc = normalize(feature);
    var buffered = normalize(featureCollection(fc.features.map(function (f) {
        return bufferOp(f, degrees);
    })));

    if (buffered.features.length > 1) return buffered;
    else if (buffered.features.length === 1) return buffered.features[0];
};

function bufferOp(feature, radius) {
    var reader = new jsts.io.GeoJSONReader();
    var geom = reader.read(feature.geometry);
    var buffered = geom.buffer(radius);
    var writer = new jsts.io.GeoJSONWriter();
    buffered = writer.write(buffered);

    return {
        type: 'Feature',
        geometry: buffered,
        properties: {}
    };
}

},{"@turf/helpers":3,"geojson-normalize":6,"jsts":8}],2:[function(require,module,exports){
var each = require('@turf/meta').coordEach;
var point = require('@turf/helpers').point;

/**
 * Takes one or more features and calculates the centroid using
 * the mean of all vertices.
 * This lessens the effect of small islands and artifacts when calculating
 * the centroid of a set of polygons.
 *
 * @name centroid
 * @param {(Feature|FeatureCollection)} features input features
 * @return {Feature<Point>} the centroid of the input features
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [105.818939,21.004714],
 *       [105.818939,21.061754],
 *       [105.890007,21.061754],
 *       [105.890007,21.004714],
 *       [105.818939,21.004714]
 *     ]]
 *   }
 * };
 *
 * var centroidPt = turf.centroid(poly);
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [poly, centroidPt]
 * };
 *
 * //=result
 */
module.exports = function (features) {
    var xSum = 0, ySum = 0, len = 0;
    each(features, function (coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
    }, true);
    return point([xSum / len, ySum / len]);
};

},{"@turf/helpers":3,"@turf/meta":4}],3:[function(require,module,exports){
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} properties properties
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var geometry = {
 *      "type": "Point",
 *      "coordinates": [
 *        67.5,
 *        32.84267363195431
 *      ]
 *    }
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties) {
    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

module.exports.feature = feature;

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object=} properties an Object that is used as the {@link Feature}'s
 * properties
 * @returns {Feature<Point>} a Point feature
 * @example
 * var pt1 = turf.point([-75.343, 39.984]);
 *
 * //=pt1
 */
module.exports.point = function (coordinates, properties) {
    if (!Array.isArray(coordinates)) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    return feature({
        type: 'Point',
        coordinates: coordinates.slice()
    }, properties);
};

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object=} properties a properties object
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the
 * beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *  [-2.275543, 53.464547],
 *  [-2.275543, 53.489271],
 *  [-2.215118, 53.489271],
 *  [-2.215118, 53.464547],
 *  [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
module.exports.polygon = function (coordinates, properties) {

    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *	[-21.964416, 64.148203],
 *	[-21.956176, 64.141316],
 *	[-21.93901, 64.135924],
 *	[-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *	[-21.929054, 64.127985],
 *	[-21.912918, 64.134726],
 *	[-21.916007, 64.141016],
 * 	[-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
module.exports.lineString = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties);
};

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var fc = turf.featureCollection(features);
 *
 * //=fc
 */
module.exports.featureCollection = function (features) {
    return {
        type: 'FeatureCollection',
        features: features
    };
};

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 *
 */
module.exports.multiLineString = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 *
 */
module.exports.multiPoint = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties);
};


/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]);
 *
 * //=multiPoly
 *
 */
module.exports.multiPolygon = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<{Geometry}>} geometries an array of GeoJSON Geometries
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
module.exports.geometryCollection = function (geometries, properties) {
    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties);
};

var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    kilometers: 6373,
    kilometres: 6373
};

/*
 * Convert a distance measurement from radians to a more friendly unit.
 *
 * @name radiansToDistance
 * @param {number} distance in radians across the sphere
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
module.exports.radiansToDistance = function (radians, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return radians * factor;
};

/*
 * Convert a distance measurement from a real-world unit into radians
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
module.exports.distanceToRadians = function (distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return distance / factor;
};

/*
 * Convert a distance measurement from a real-world unit into degrees
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
module.exports.distanceToDegrees = function (distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return (distance / factor) * 57.2958;
};

},{}],4:[function(require,module,exports){
/**
 * Iterate over coordinates in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name coordEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var point = { type: 'Point', coordinates: [0, 0] };
 * coordEach(point, function(coords) {
 *   // coords is equal to [0, 0]
 * });
 */
function coordEach(layer, callback, excludeWrapCoord) {
    var i, j, k, g, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        isGeometryCollection,
        isFeatureCollection = layer.type === 'FeatureCollection',
        isFeature = layer.type === 'Feature',
        stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            coords = geometry.coordinates;

            wrapShrink = (excludeWrapCoord &&
                (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
                1 : 0;

            if (geometry.type === 'Point') {
                callback(coords);
            } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
                for (j = 0; j < coords.length; j++) callback(coords[j]);
            } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length - wrapShrink; k++)
                        callback(coords[j][k]);
            } else if (geometry.type === 'MultiPolygon') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++)
                            callback(coords[j][k][l]);
            } else if (geometry.type === 'GeometryCollection') {
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
            } else {
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}
module.exports.coordEach = coordEach;

/**
 * Reduce coordinates in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all coordinates is unnecessary.
 *
 * @name coordReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, value) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} combined value
 */
function coordReduce(layer, callback, memo, excludeWrapCoord) {
    coordEach(layer, function (coord) {
        memo = callback(memo, coord);
    }, excludeWrapCoord);
    return memo;
}
module.exports.coordReduce = coordReduce;

/**
 * Iterate over property objects in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name propEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };
 * propEach(point, function(props) {
 *   // props is equal to { foo: 1}
 * });
 */
function propEach(layer, callback) {
    var i;
    switch (layer.type) {
    case 'FeatureCollection':
        for (i = 0; i < layer.features.length; i++) {
            callback(layer.features[i].properties);
        }
        break;
    case 'Feature':
        callback(layer.properties);
        break;
    }
}
module.exports.propEach = propEach;

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, coord) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 * @returns {*} combined value
 * @example
 * // an example of an even more advanced function that gives you the
 * // javascript type of each property of every feature
 * function propTypes (layer) {
 *   opts = opts || {}
 *   return propReduce(layer, function (prev, props) {
 *     for (var prop in props) {
 *       if (prev[prop]) continue
 *       prev[prop] = typeof props[prop]
 *     }
 *   }, {})
 * }
 */
function propReduce(layer, callback, memo) {
    propEach(layer, function (prop) {
        memo = callback(memo, prop);
    });
    return memo;
}
module.exports.propReduce = propReduce;

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var feature = { type: 'Feature', geometry: null, properties: {} };
 * featureEach(feature, function(feature) {
 *   // feature == feature
 * });
 */
function featureEach(layer, callback) {
    if (layer.type === 'Feature') {
        callback(layer);
    } else if (layer.type === 'FeatureCollection') {
        for (var i = 0; i < layer.features.length; i++) {
            callback(layer.features[i]);
        }
    }
}
module.exports.featureEach = featureEach;

/**
 * Get all coordinates from any GeoJSON object, returning an array of coordinate
 * arrays.
 *
 * @name coordAll
 * @param {Object} layer any GeoJSON object
 * @returns {Array<Array<Number>>} coordinate position array
 */
function coordAll(layer) {
    var coords = [];
    coordEach(layer, function (coord) {
        coords.push(coord);
    });
    return coords;
}
module.exports.coordAll = coordAll;

},{}],5:[function(require,module,exports){
function corslite(url, callback, cors) {
    var sent = false;

    if (typeof window.XMLHttpRequest === 'undefined') {
        return callback(Error('Browser not supported'));
    }

    if (typeof cors === 'undefined') {
        var m = url.match(/^\s*https?:\/\/[^\/]*/);
        cors = m && (m[0] !== location.protocol + '//' + location.domain +
                (location.port ? ':' + location.port : ''));
    }

    var x = new window.XMLHttpRequest();

    function isSuccessful(status) {
        return status >= 200 && status < 300 || status === 304;
    }

    if (cors && !('withCredentials' in x)) {
        // IE8-9
        x = new window.XDomainRequest();

        // Ensure callback is never called synchronously, i.e., before
        // x.send() returns (this has been observed in the wild).
        // See https://github.com/mapbox/mapbox.js/issues/472
        var original = callback;
        callback = function() {
            if (sent) {
                original.apply(this, arguments);
            } else {
                var that = this, args = arguments;
                setTimeout(function() {
                    original.apply(that, args);
                }, 0);
            }
        }
    }

    function loaded() {
        if (
            // XDomainRequest
            x.status === undefined ||
            // modern browsers
            isSuccessful(x.status)) callback.call(x, null, x);
        else callback.call(x, x, null);
    }

    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`
    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).
    if ('onload' in x) {
        x.onload = loaded;
    } else {
        x.onreadystatechange = function readystate() {
            if (x.readyState === 4) {
                loaded();
            }
        };
    }

    // Call the callback with the XMLHttpRequest object as an error and prevent
    // it from ever being called again by reassigning it to `noop`
    x.onerror = function error(evt) {
        // XDomainRequest provides no evt parameter
        callback.call(this, evt || true, null);
        callback = function() { };
    };

    // IE9 must have onprogress be set to a unique function.
    x.onprogress = function() { };

    x.ontimeout = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };

    x.onabort = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };

    // GET is the only supported HTTP Verb by XDomainRequest and is the
    // only one supported here.
    x.open('GET', url, true);

    // Send the request. Sending data is not supported.
    x.send(null);
    sent = true;

    return x;
}

if (typeof module !== 'undefined') module.exports = corslite;

},{}],6:[function(require,module,exports){
module.exports = normalize;

var types = {
    Point: 'geometry',
    MultiPoint: 'geometry',
    LineString: 'geometry',
    MultiLineString: 'geometry',
    Polygon: 'geometry',
    MultiPolygon: 'geometry',
    GeometryCollection: 'geometry',
    Feature: 'feature',
    FeatureCollection: 'featurecollection'
};

/**
 * Normalize a GeoJSON feature into a FeatureCollection.
 *
 * @param {object} gj geojson data
 * @returns {object} normalized geojson data
 */
function normalize(gj) {
    if (!gj || !gj.type) return null;
    var type = types[gj.type];
    if (!type) return null;

    if (type === 'geometry') {
        return {
            type: 'FeatureCollection',
            features: [{
                type: 'Feature',
                properties: {},
                geometry: gj
            }]
        };
    } else if (type === 'feature') {
        return {
            type: 'FeatureCollection',
            features: [gj]
        };
    } else if (type === 'featurecollection') {
        return gj;
    }
}

},{}],7:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],8:[function(require,module,exports){
// JSTS. See https://github.com/bjornharrtell/jsts
// Licenses:
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.jsts=t.jsts||{})}(this,function(t){"use strict";function e(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}function n(){}function i(){}function r(){}function s(){}function o(){}function a(){}function u(){}function l(t){this.name="RuntimeException",this.message=t,this.stack=(new Error).stack,Error.call(this,t)}function h(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}function c(){if(0===arguments.length)l.call(this);else if(1===arguments.length){var t=arguments[0];l.call(this,t)}}function f(){}function g(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.call(this,0,0);else if(1===arguments.length){var t=arguments[0];g.call(this,t.x,t.y,t.z)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];g.call(this,e,n,g.NULL_ORDINATE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.x=i,this.y=r,this.z=s}}function d(){if(this.dimensionsToTest=2,0===arguments.length)d.call(this,2);else if(1===arguments.length){var t=arguments[0];if(2!==t&&3!==t)throw new i("only 2 or 3 dimensions may be specified");this.dimensionsToTest=t}}function p(){}function v(){}function m(t){this.message=t||""}function y(){}function x(t){this.message=t||""}function E(t){this.message=t||""}function I(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function N(){if(I.apply(this),0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.ensureCapacity(e.length),this.add(e,n)}}function C(){if(this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.init(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];this.init(r,s,o,a)}}function S(){}function w(){S.call(this,"Projective point not representable on the Cartesian plane.")}function L(){}function R(t,e){return t.interfaces_&&t.interfaces_().indexOf(e)>-1}function T(){}function P(t){this.str=t}function b(t){this.value=t}function O(){}function _(){if(this.hi=0,this.lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.init(t)}else if(arguments[0]instanceof _){var e=arguments[0];this.init(e)}else if("string"==typeof arguments[0]){var n=arguments[0];_.call(this,_.parse(n))}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.init(i,r)}}function M(){}function D(){}function A(){}function F(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var e=arguments[0],n=arguments[1];this.x=e,this.y=n,this.w=1}else if(arguments[0]instanceof F&&arguments[1]instanceof F){var i=arguments[0],r=arguments[1];this.x=i.y*r.w-r.y*i.w,this.y=r.x*i.w-i.x*r.w,this.w=i.x*r.y-r.x*i.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1];this.x=s.y-o.y,this.y=o.x-s.x,this.w=s.x*o.y-o.x*s.y}}else if(3===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2];this.x=a,this.y=u,this.w=l}else if(4===arguments.length){var h=arguments[0],c=arguments[1],f=arguments[2],d=arguments[3],p=h.y-c.y,v=c.x-h.x,m=h.x*c.y-c.x*h.y,y=f.y-d.y,x=d.x-f.x,E=f.x*d.y-d.x*f.y;this.x=v*E-x*m,this.y=y*m-p*E,this.w=p*x-y*v}}function G(){}function q(){}function B(){this.envelope=null,this.factory=null,this.SRID=null,this.userData=null;var t=arguments[0];this.factory=t,this.SRID=t.getSRID()}function z(){}function V(){}function k(){}function Y(){}function U(){}function X(){}function H(){}function W(){}function j(){}function K(){}function Z(){}function Q(){}function J(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function $(t){return null==t?$s:t.color}function tt(t){return null==t?null:t.parent}function et(t,e){null!==t&&(t.color=e)}function nt(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}function st(){}function ot(){}function at(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function ut(){}function lt(){}function ht(){}function ct(){}function ft(){this.geometries=null;var t=arguments[0],e=arguments[1];if(B.call(this,e),null===t&&(t=[]),B.hasNullElements(t))throw new i("geometries must not contain null elements");this.geometries=t}function gt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function dt(){if(this.geom=null,this.geomFact=null,this.bnRule=null,this.endpointMap=null,1===arguments.length){var t=arguments[0];dt.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.geom=e,this.geomFact=e.getFactory(),this.bnRule=n}}function pt(){this.count=null}function vt(){}function mt(){}function yt(){}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}function St(){this.points=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function wt(){}function Lt(){this.coordinates=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function Rt(){}function Tt(){this.shell=null,this.holes=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(B.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),B.hasNullElements(e))throw new i("holes must not contain null elements");if(t.isEmpty()&&B.hasNonEmptyElements(e))throw new i("shell is empty but holes are not");this.shell=t,this.holes=e}function Pt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function bt(){if(arguments[0]instanceof g&&arguments[1]instanceof ie){var t=arguments[0],e=arguments[1];bt.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(R(arguments[0],D)&&arguments[1]instanceof ie){var n=arguments[0],i=arguments[1];St.call(this,n,i),this.validateConstruction()}}function Ot(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function _t(){if(this.factory=null,this.isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.factory=t}}function Mt(){}function Dt(){}function At(){}function Ft(){}function Gt(){if(this.dimension=3,this.coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];Gt.call(this,t,3)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.coordinates=new Array(e).fill(null);for(var n=0;e>n;n++)this.coordinates[n]=new g}else if(R(arguments[0],D)){var i=arguments[0];if(null===i)return this.coordinates=new Array(0).fill(null),null;this.dimension=i.getDimension(),this.coordinates=new Array(i.size()).fill(null);for(var n=0;n<this.coordinates.length;n++)this.coordinates[n]=i.getCoordinateCopy(n)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var r=arguments[0],s=arguments[1];this.coordinates=r,this.dimension=s,null===r&&(this.coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var o=arguments[0],a=arguments[1];this.coordinates=new Array(o).fill(null),this.dimension=a;for(var n=0;o>n;n++)this.coordinates[n]=new g}}function qt(){}function Bt(t,e){return t===e||t!==t&&e!==e}function zt(t,e){function n(t){return this&&this.constructor===n?(this._keys=[],this._values=[],this._itp=[],this.objectOnly=e,void(t&&Vt.call(this,t))):new n(t)}return e||io(t,"size",{get:Jt}),t.constructor=n,n.prototype=t,n}function Vt(t){this.add?t.forEach(this.add,this):t.forEach(function(t){this.set(t[0],t[1])},this)}function kt(t){return this.has(t)&&(this._keys.splice(no,1),this._values.splice(no,1),this._itp.forEach(function(t){no<t[0]&&t[0]--})),no>-1}function Yt(t){return this.has(t)?this._values[no]:void 0}function Ut(t,e){if(this.objectOnly&&e!==Object(e))throw new TypeError("Invalid value used as weak collection key");if(e!==e||0===e)for(no=t.length;no--&&!Bt(t[no],e););else no=t.indexOf(e);return no>-1}function Xt(t){return Ut.call(this,this._keys,t)}function Ht(t,e){return this.has(t)?this._values[no]=e:this._values[this._keys.push(t)-1]=e,this}function Wt(){(this._keys||0).length=this._values.length=0}function jt(){return Qt(this._itp,this._keys)}function Kt(){return Qt(this._itp,this._values)}function Zt(){return Qt(this._itp,this._keys,this._values)}function Qt(t,e,n){var i=[0],r=!1;return t.push(i),{next:function(){var s,o=i[0];return!r&&o<e.length?(s=n?[e[o],n[o]]:e[o],i[0]++):(r=!0,t.splice(t.indexOf(i),1)),{done:r,value:s}}}}function Jt(){return this._values.length}function $t(t,e){for(var n=this.entries();;){var i=n.next();if(i.done)break;t.call(e,i.value[1],i.value[0],this)}}function te(){this.map_=new so}function ee(){if(this.modelType=null,this.scale=null,0===arguments.length)this.modelType=ee.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ne){var t=arguments[0];this.modelType=t,t===ee.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var e=arguments[0];this.modelType=ee.FIXED,this.setScale(e)}else if(arguments[0]instanceof ee){var n=arguments[0];this.modelType=n.modelType,this.scale=n.scale}}function ne(){this.name=null;var t=arguments[0];this.name=t,ne.nameToTypeMap.put(t,this)}function ie(){if(this.precisionModel=null,this.coordinateSequenceFactory=null,this.SRID=null,0===arguments.length)ie.call(this,new ee,0);else if(1===arguments.length){if(R(arguments[0],G)){var t=arguments[0];ie.call(this,new ee,0,t)}else if(arguments[0]instanceof ee){var e=arguments[0];ie.call(this,e,0,ie.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];ie.call(this,n,i,ie.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.precisionModel=r,this.coordinateSequenceFactory=o,this.SRID=s}}function re(t){this.geometryFactory=t||new ie}function se(t){this.parser=new re(t)}function oe(){this.result=null,this.inputLines=Array(2).fill().map(function(){return Array(2)}),this.intPt=new Array(2).fill(null),this.intLineIndex=null,this._isProper=null,this.pa=null,this.pb=null,this.precisionModel=null,this.intPt[0]=new g,this.intPt[1]=new g,this.pa=this.intPt[0],this.pb=this.intPt[1],this.result=0}function ae(){oe.apply(this)}function ue(){}function le(){this.p=null,this.crossingCount=0,this.isPointOnSegment=!1;var t=arguments[0];this.p=t}function he(){}function ce(){if(this.p0=null,this.p1=null,0===arguments.length)ce.call(this,new g,new g);else if(1===arguments.length){var t=arguments[0];ce.call(this,t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0=e,this.p1=n}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];ce.call(this,new g(i,r),new g(s,o))}}function fe(){if(this.matrix=null,0===arguments.length)this.matrix=Array(3).fill().map(function(){return Array(3)}),this.setAll(lt.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){var t=arguments[0];fe.call(this),this.set(t)}else if(arguments[0]instanceof fe){var e=arguments[0];fe.call(this),this.matrix[L.INTERIOR][L.INTERIOR]=e.matrix[L.INTERIOR][L.INTERIOR],this.matrix[L.INTERIOR][L.BOUNDARY]=e.matrix[L.INTERIOR][L.BOUNDARY],this.matrix[L.INTERIOR][L.EXTERIOR]=e.matrix[L.INTERIOR][L.EXTERIOR],this.matrix[L.BOUNDARY][L.INTERIOR]=e.matrix[L.BOUNDARY][L.INTERIOR],this.matrix[L.BOUNDARY][L.BOUNDARY]=e.matrix[L.BOUNDARY][L.BOUNDARY],this.matrix[L.BOUNDARY][L.EXTERIOR]=e.matrix[L.BOUNDARY][L.EXTERIOR],this.matrix[L.EXTERIOR][L.INTERIOR]=e.matrix[L.EXTERIOR][L.INTERIOR],this.matrix[L.EXTERIOR][L.BOUNDARY]=e.matrix[L.EXTERIOR][L.BOUNDARY],this.matrix[L.EXTERIOR][L.EXTERIOR]=e.matrix[L.EXTERIOR][L.EXTERIOR]}}function ge(){this.areaBasePt=null,this.triangleCent3=new g,this.areasum2=0,this.cg3=new g,this.lineCentSum=new g,this.totalLength=0,this.ptCount=0,this.ptCentSum=new g;var t=arguments[0];this.areaBasePt=null,this.add(t)}function de(t){this.message=t||""}function pe(){this.array_=[]}function ve(){this.treeSet=new at,this.list=new I}function me(){if(this.geomFactory=null,this.inputPts=null,1===arguments.length){var t=arguments[0];me.call(this,me.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputPts=ve.filterCoordinates(e),this.geomFactory=n}}function ye(){this.origin=null;var t=arguments[0];this.origin=t}function xe(){this.inputGeom=null,this.factory=null,this.pruneEmptyGeometry=!0,this.preserveGeometryCollectionType=!0,this.preserveCollections=!1,this.preserveType=!1}function Ee(){if(this.snapTolerance=0,this.srcPts=null,this.seg=new ce,this.allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof St&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];Ee.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1];this.srcPts=n,this._isClosed=Ee.isClosed(n),this.snapTolerance=i}}function Ie(){this.srcGeom=null;var t=arguments[0];this.srcGeom=t}function Ne(){if(xe.apply(this),this.snapTolerance=null,this.snapPts=null,this.isSelfSnap=!1,2===arguments.length){var t=arguments[0],e=arguments[1];this.snapTolerance=t,this.snapPts=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.snapTolerance=n,this.snapPts=i,this.isSelfSnap=r}}function Ce(){this.isFirst=!0,this.commonMantissaBitsCount=53,this.commonBits=0,this.commonSignExp=null}function Se(){this.commonCoord=null,this.ccFilter=new we}function we(){this.commonBitsX=new Ce,this.commonBitsY=new Ce}function Le(){this.trans=null;var t=arguments[0];this.trans=t}function Re(){this.parent=null,this.atStart=null,this.max=null,this.index=null,this.subcollectionIterator=null;var t=arguments[0];this.parent=t,this.atStart=!0,this.index=0,this.max=t.getNumGeometries()}function Te(){if(this.boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this.isIn=null,this.numBoundaries=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];if(null===t)throw new i("Rule must be non-null");this.boundaryRule=t}}function Pe(){}function be(){}function Oe(){this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function _e(){}function Me(){this.bounds=null,this.item=null;var t=arguments[0],e=arguments[1];this.bounds=t,this.item=e}function De(){this._size=null,this.items=null,this._size=0,this.items=new I,this.items.add(null)}function Ae(){}function Fe(){}function Ge(){if(this.childBoundables=new I,this.bounds=null,this.level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.level=t}}function qe(){this.boundable1=null,this.boundable2=null,this._distance=null,this.itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.boundable1=t,this.boundable2=e,this.itemDistance=n,this._distance=this.distance()}function Be(){if(this.root=null,this.built=!1,this.itemBoundables=new I,this.nodeCapacity=null,0===arguments.length)Be.call(this,Be.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];f.isTrue(t>1,"Node capacity must be greater than 1"),this.nodeCapacity=t}}function ze(){}function Ve(){}function ke(){if(0===arguments.length)ke.call(this,ke.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];Be.call(this,t)}}function Ye(){var t=arguments[0];Ge.call(this,t)}function Ue(){}function Xe(){this.segString=null,this.coord=null,this.segmentIndex=null,this.segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.segString=t,this.coord=new g(e),this.segmentIndex=n,this.segmentOctant=i,this._isInterior=!e.equals2D(t.getCoordinate(n))}function He(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function We(){this.nodeList=null,this.edge=null,this.nodeIt=null,this.currNode=null,this.nextNode=null,this.currSegIndex=0;var t=arguments[0];this.nodeList=t,this.edge=t.getEdge(),this.nodeIt=t.iterator(),this.readNextNode()}function je(){}function Ke(){this.nodeList=new He(this),this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function Ze(){this.tempEnv1=new C,this.tempEnv2=new C,this.overlapSeg1=new ce,this.overlapSeg2=new ce}function Qe(){this.pts=null,this.start=null,this.end=null,this.env=null,this.context=null,this.id=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.pts=t,this.start=e,this.end=n,this.context=i}function Je(){}function $e(){}function tn(){}function en(){if(this.segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t)}}function nn(){if(this.monoChains=new I,this.index=new ke,this.idCounter=0,this.nodedSegStrings=null,this.nOverlaps=0,0===arguments.length);else if(1===arguments.length){var t=arguments[0];en.call(this,t)}}function rn(){Ze.apply(this),this.si=null;var t=arguments[0];this.si=t}function sn(){if(this.pt=null,1===arguments.length){var t=arguments[0];l.call(this,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];l.call(this,sn.msgWithCoord(e,n)),this.name="TopologyException",this.pt=new g(n)}}function on(){}function an(){this.findAllIntersections=!1,this.isCheckEndSegmentsOnly=!1,this.li=null,this.interiorIntersection=null,this.intSegments=null,this.intersections=new I,this.intersectionCount=0,this.keepIntersections=!0;var t=arguments[0];this.li=t,this.interiorIntersection=null}function un(){this.li=new ae,this.segStrings=null,this.findAllIntersections=!1,this.segInt=null,this._isValid=!0;var t=arguments[0];this.segStrings=t}function ln(){this.nv=null;var t=arguments[0];this.nv=new un(ln.toSegmentStrings(t))}function hn(){this.mapOp=null;var t=arguments[0];this.mapOp=t}function cn(){}function fn(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.init(1),this.location[cn.ON]=e}else if(arguments[0]instanceof fn){var n=arguments[0];if(this.init(n.location.length),null!==n)for(var i=0;i<this.location.length;i++)this.location[i]=n.location[i]}}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.init(3),this.location[cn.ON]=r,this.location[cn.LEFT]=s,this.location[cn.RIGHT]=o}}function gn(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var t=arguments[0];this.elt[0]=new fn(t),this.elt[1]=new fn(t)}else if(arguments[0]instanceof gn){var e=arguments[0];this.elt[0]=new fn(e.elt[0]),this.elt[1]=new fn(e.elt[1])}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.elt[0]=new fn(L.NONE),this.elt[1]=new fn(L.NONE),this.elt[n].setLocation(i)}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.elt[0]=new fn(r,s,o),this.elt[1]=new fn(r,s,o)}else if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3];this.elt[0]=new fn(L.NONE,L.NONE,L.NONE),this.elt[1]=new fn(L.NONE,L.NONE,L.NONE),this.elt[a].setLocations(u,l,h)}}function dn(){this.startDe=null,this.maxNodeDegree=-1,this.edges=new I,this.pts=new I,this.label=new gn(L.NONE),this.ring=null,this._isHole=null,this.shell=null,this.holes=new I,this.geometryFactory=null;var t=arguments[0],e=arguments[1];this.geometryFactory=e,this.computePoints(t),this.computeRing()}function pn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function vn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function mn(){if(this.label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.label=t}}function yn(){mn.apply(this),this.coord=null,this.edges=null;var t=arguments[0],e=arguments[1];this.coord=t,this.edges=e,this.label=new gn(0,L.NONE)}function xn(){this.nodeMap=new rt,this.nodeFact=null;var t=arguments[0];this.nodeFact=t}function En(){if(this.edge=null,this.label=null,this.node=null,this.p0=null,this.p1=null,this.dx=null,this.dy=null,this.quadrant=null,1===arguments.length){var t=arguments[0];this.edge=t}else if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];En.call(this,e,n,i,null)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];En.call(this,r),this.init(s,o),this.label=a}}function In(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this.sym=null,this.next=null,this.nextMin=null,this.edgeRing=null,this.minEdgeRing=null,this.depth=[0,-999,-999];var t=arguments[0],e=arguments[1];if(En.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{var n=t.getNumPoints()-1;this.init(t.getCoordinate(n),t.getCoordinate(n-1))}this.computeDirectedLabel()}function Nn(){}function Cn(){if(this.edges=new I,this.nodes=null,this.edgeEndList=new I,0===arguments.length)this.nodes=new xn(new Nn);else if(1===arguments.length){var t=arguments[0];this.nodes=new xn(t)}}function Sn(){this.geometryFactory=null,this.shellList=new I;var t=arguments[0];this.geometryFactory=t}function wn(){this.op=null,this.geometryFactory=null,this.ptLocator=null,this.lineEdgesList=new I,this.resultLineList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.op=t,this.geometryFactory=e,this.ptLocator=n}function Ln(){this.op=null,this.geometryFactory=null,this.resultPointList=new I;var t=arguments[0],e=arguments[1];arguments[2];this.op=t,this.geometryFactory=e}function Rn(){}function Tn(){this.geom=null;var t=arguments[0];this.geom=t}function Pn(){this.edgeMap=new rt,this.edgeList=null,this.ptInAreaLocation=[L.NONE,L.NONE]}function bn(){Pn.apply(this),this.resultAreaEdgeList=null,this.label=null,this.SCANNING_FOR_INCOMING=1,this.LINKING_TO_OUTGOING=2}function On(){Nn.apply(this)}function _n(){this.mce=null,this.chainIndex=null;var t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}function Mn(){if(this.label=null,this.xValue=null,this.eventType=null,this.insertEvent=null,this.deleteEventIndex=null,this.obj=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.eventType=Mn.DELETE,this.xValue=t,this.insertEvent=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.eventType=Mn.INSERT,this.label=n,this.xValue=i,this.obj=r}}function Dn(){}function An(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.properIntersectionPoint=null,this.li=null,this.includeProper=null,this.recordIsolated=null,this.isSelfIntersection=null,this.numIntersections=0,this.numTests=0,this.bdyNodes=null,this._isDone=!1,this.isDoneWhenProperInt=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.li=t,this.includeProper=e,this.recordIsolated=n}function Fn(){Dn.apply(this),this.events=new I,this.nOverlaps=null}function Gn(){this.min=r.POSITIVE_INFINITY,this.max=r.NEGATIVE_INFINITY}function qn(){}function Bn(){Gn.apply(this),this.item=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.min=t,this.max=e,this.item=n}function zn(){Gn.apply(this),this.node1=null,this.node2=null;var t=arguments[0],e=arguments[1];this.node1=t,this.node2=e,this.buildExtent(this.node1,this.node2)}function Vn(){this.leaves=new I,this.root=null,this.level=0}function kn(){if(this.lines=null,this.isForcedToLineString=!1,1===arguments.length){var t=arguments[0];this.lines=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.lines=e,this.isForcedToLineString=n}}function Yn(){this.items=new I}function Un(){this.index=null;var t=arguments[0];if(!R(t,Rt))throw new i("Argument must be Polygonal");this.index=new Hn(t)}function Xn(){this.counter=null;var t=arguments[0];this.counter=t}function Hn(){this.index=new Vn;var t=arguments[0];this.init(t)}function Wn(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n}function jn(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function Kn(){}function Zn(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new C,this.env2=new C;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}function Qn(){this.depth=Array(2).fill().map(function(){return Array(3)});for(var t=0;2>t;t++)for(var e=0;3>e;e++)this.depth[t][e]=Qn.NULL_VALUE}function Jn(){if(mn.apply(this),this.pts=null,this.env=null,this.eiList=new jn(this),this.name=null,this.mce=null,this._isIsolated=!0,this.depth=new Qn,this.depthDelta=0,1===arguments.length){var t=arguments[0];Jn.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pts=e,this.label=n}}function $n(){if(Cn.apply(this),this.parentGeom=null,this.lineEdgeMap=new te,this.boundaryNodeRule=null,this.useBoundaryDeterminationRule=!0,this.argIndex=null,this.boundaryNodes=null,this._hasTooFewPoints=!1,this.invalidPoint=null,this.areaPtLocator=null,this.ptLocator=new Te,2===arguments.length){var t=arguments[0],e=arguments[1];$n.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.argIndex=n,this.parentGeom=i,this.boundaryNodeRule=r,null!==i&&this.add(i)}}function ti(){if(this.li=new ae,this.resultPrecisionModel=null,this.arg=null,1===arguments.length){var t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this.arg=new Array(1).fill(null),this.arg[0]=new $n(0,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];ti.call(this,e,n,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];i.getPrecisionModel().compareTo(r.getPrecisionModel())>=0?this.setComputationPrecision(i.getPrecisionModel()):this.setComputationPrecision(r.getPrecisionModel()),this.arg=new Array(2).fill(null),this.arg[0]=new $n(0,i,s),this.arg[1]=new $n(1,r,s)}}function ei(){this.pts=null,this._orientation=null;var t=arguments[0];this.pts=t,this._orientation=ei.orientation(t)}function ni(){this.edges=new I,this.ocaMap=new rt}function ii(){this.ptLocator=new Te,this.geomFact=null,this.resultGeom=null,this.graph=null,this.edgeList=new ni,this.resultPolyList=new I,this.resultLineList=new I,this.resultPointList=new I;var t=arguments[0],e=arguments[1];ti.call(this,t,e),this.graph=new Cn(new On),this.geomFact=t.getFactory()}function ri(){this.geom=new Array(2).fill(null),this.snapTolerance=null,this.cbr=null;var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e,this.computeSnapTolerance()}function si(){this.geom=new Array(2).fill(null);var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e}function oi(){this.factory=null,this.interiorPoint=null,this.maxWidth=0;var t=arguments[0];this.factory=t.getFactory(),this.add(t)}function ai(){this.poly=null,this.centreY=null,this.hiY=r.MAX_VALUE,this.loY=-r.MAX_VALUE;var t=arguments[0];this.poly=t,this.hiY=t.getEnvelopeInternal().getMaxY(),this.loY=t.getEnvelopeInternal().getMinY(),this.centreY=oi.avg(this.loY,this.hiY)}function ui(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.addInterior(t),null===this.interiorPoint&&this.addEndpoints(t)}function li(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.add(t)}function hi(){this.tempEnv1=new C,this.selectedSegment=new ce}function ci(){this.items=new I,this.subnode=[null,null]}function fi(){if(this.min=null,this.max=null,0===arguments.length)this.min=0,this.max=0;else if(1===arguments.length){var t=arguments[0];this.init(t.min,t.max)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.init(e,n)}}function gi(){}function di(t,e){var n,i,r,s,o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},a={32:8,64:11}[t];if(s||(n=0>e||0>1/e,isFinite(e)||(s=o[t],n&&(s.d+=1<<t/4-1),i=Math.pow(2,a)-1,r=0)),!s){for(i={32:127,64:1023}[t],r=Math.abs(e);r>=2;)i++,r/=2;for(;1>r&&i>0;)i--,r*=2;0>=i&&(r/=2),32===t&&i>254&&(s={d:n?255:127,c:128,b:0,a:0},i=Math.pow(2,a)-1,r=0)}return i}function pi(){this.pt=0,this.level=0,this.interval=null;var t=arguments[0];this.computeKey(t)}function vi(){ci.apply(this),this.interval=null,this.centre=null,this.level=null;var t=arguments[0],e=arguments[1];this.interval=t,this.level=e,this.centre=(t.getMin()+t.getMax())/2}function mi(){}function yi(){ci.apply(this)}function xi(){this.root=null,this.minExtent=1,this.root=new yi}function Ei(){}function Ii(){this.ring=null,this.tree=null,this.crossings=0,this.interval=new fi;var t=arguments[0];this.ring=t,this.buildIndex()}function Ni(){hi.apply(this),this.mcp=null,this.p=null;var t=arguments[0],e=arguments[1];this.mcp=t,this.p=e}function Ci(){}function Si(){this.p0=null,this.p1=null,this.p2=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}function wi(){this.input=null,this.extremalPts=null,this.centre=null,this.radius=0;var t=arguments[0];this.input=t}function Li(){if(this.inputGeom=null,this.isConvex=null,this.convexHullPts=null,this.minBaseSeg=new ce,this.minWidthPt=null,this.minPtIndex=null,this.minWidth=0,1===arguments.length){var t=arguments[0];Li.call(this,t,!1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isConvex=n}}function Ri(){this.inputGeom=null,this.distanceTolerance=null;var t=arguments[0];this.inputGeom=t}function Ti(){xe.apply(this),this.distanceTolerance=null;var t=arguments[0];this.distanceTolerance=t}function Pi(){this._orig=null,this._sym=null,this._next=null;var t=arguments[0];this._orig=t}function bi(){this._isMarked=!1;var t=arguments[0];Pi.call(this,t)}function Oi(){this.vertexMap=new te}function _i(){this._isStart=!1;var t=arguments[0];bi.call(this,t)}function Mi(){Oi.apply(this)}function Di(){this.result=null,this.factory=null,this.graph=null,this.lines=new I,this.nodeEdgeStack=new pe,this.ringStartEdge=null,this.graph=new Mi}function Ai(){this.items=new I,this.subnode=new Array(4).fill(null)}function Fi(){this.pt=new g,this.level=0,this.env=null;var t=arguments[0];this.computeKey(t)}function Gi(){Ai.apply(this),this.env=null,this.centrex=null,this.centrey=null,this.level=null;var t=arguments[0],e=arguments[1];this.env=t,this.level=e,this.centrex=(t.getMinX()+t.getMaxX())/2,this.centrey=(t.getMinY()+t.getMaxY())/2}function qi(){Ai.apply(this)}function Bi(){this.root=null,this.minExtent=1,this.root=new qi}function zi(t){this.geometryFactory=t||new ie}function Vi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new zi(this.geometryFactory)}function ki(){this.parser=new zi(this.geometryFactory)}function Yi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new re(this.geometryFactory)}function Ui(t){return[t.x,t.y]}function Xi(t){this.geometryFactory=t||new ie}function Hi(){if(this.noder=null,this.scaleFactor=null,this.offsetX=null,this.offsetY=null,this.isScaled=!1,2===arguments.length){var t=arguments[0],e=arguments[1];Hi.call(this,t,e,0,0)}else if(4===arguments.length){var n=arguments[0],i=arguments[1];arguments[2],arguments[3];this.noder=n,this.scaleFactor=i,this.isScaled=!this.isIntegerPrecision()}}function Wi(){if(this.inputGeom=null,this.isClosedEndpointsInInterior=!0,this.nonSimpleLocation=null,1===arguments.length){var t=arguments[0];this.inputGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,
this.isClosedEndpointsInInterior=!n.isInBoundary(2)}}function ji(){this.pt=null,this.isClosed=null,this.degree=null;var t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}function Ki(){if(this.quadrantSegments=Ki.DEFAULT_QUADRANT_SEGMENTS,this.endCapStyle=Ki.CAP_ROUND,this.joinStyle=Ki.JOIN_ROUND,this.mitreLimit=Ki.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this.simplifyFactor=Ki.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.setQuadrantSegments(e),this.setEndCapStyle(n)}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];this.setQuadrantSegments(i),this.setEndCapStyle(r),this.setJoinStyle(s),this.setMitreLimit(o)}}function Zi(){this.minIndex=-1,this.minCoord=null,this.minDe=null,this.orientedDe=null}function Qi(){this.array_=[]}function Ji(){this.finder=null,this.dirEdgeList=new I,this.nodes=new I,this.rightMostCoord=null,this.env=null,this.finder=new Zi}function $i(){this.inputLine=null,this.distanceTol=null,this.isDeleted=null,this.angleOrientation=he.COUNTERCLOCKWISE;var t=arguments[0];this.inputLine=t}function tr(){this.ptList=null,this.precisionModel=null,this.minimimVertexDistance=0,this.ptList=new I}function er(){this.maxCurveSegmentError=0,this.filletAngleQuantum=null,this.closingSegLengthFactor=1,this.segList=null,this.distance=0,this.precisionModel=null,this.bufParams=null,this.li=null,this.s0=null,this.s1=null,this.s2=null,this.seg0=new ce,this.seg1=new ce,this.offset0=new ce,this.offset1=new ce,this.side=0,this._hasNarrowConcaveAngle=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.precisionModel=t,this.bufParams=e,this.li=new ae,this.filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===Ki.JOIN_ROUND&&(this.closingSegLengthFactor=er.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}function nr(){this.distance=0,this.precisionModel=null,this.bufParams=null;var t=arguments[0],e=arguments[1];this.precisionModel=t,this.bufParams=e}function ir(){this.subgraphs=null,this.seg=new ce,this.cga=new he;var t=arguments[0];this.subgraphs=t}function rr(){this.upwardSeg=null,this.leftDepth=null;var t=arguments[0],e=arguments[1];this.upwardSeg=new ce(t),this.leftDepth=e}function sr(){this.inputGeom=null,this.distance=null,this.curveBuilder=null,this.curveList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.inputGeom=t,this.distance=e,this.curveBuilder=n}function or(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.hasInterior=!1,this.properIntersectionPoint=null,this.li=null,this.isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this.li=t}function ar(){this.bufParams=null,this.workingPrecisionModel=null,this.workingNoder=null,this.geomFact=null,this.graph=null,this.edgeList=new ni;var t=arguments[0];this.bufParams=t}function ur(){this.li=new ae,this.segStrings=null;var t=arguments[0];this.segStrings=t}function lr(){this.li=null,this.pt=null,this.originalPt=null,this.ptScaled=null,this.p0Scaled=null,this.p1Scaled=null,this.scaleFactor=null,this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,this.corner=new Array(4).fill(null),this.safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this.originalPt=t,this.pt=t,this.scaleFactor=e,this.li=n,0>=e)throw new i("Scale factor must be non-zero");1!==e&&(this.pt=new g(this.scale(t.x),this.scale(t.y)),this.p0Scaled=new g,this.p1Scaled=new g),this.initCorners(this.pt)}function hr(){this.index=null;var t=arguments[0];this.index=t}function cr(){hi.apply(this),this.hotPixel=null,this.parentEdge=null,this.hotPixelVertexIndex=null,this._isNodeAdded=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.hotPixel=t,this.parentEdge=e,this.hotPixelVertexIndex=n}function fr(){this.li=null,this.interiorIntersections=null;var t=arguments[0];this.li=t,this.interiorIntersections=new I}function gr(){this.pm=null,this.li=null,this.scaleFactor=null,this.noder=null,this.pointSnapper=null,this.nodedSegStrings=null;var t=arguments[0];this.pm=t,this.li=new ae,this.li.setPrecisionModel(t),this.scaleFactor=t.getScale()}function dr(){if(this.argGeom=null,this.distance=null,this.bufParams=new Ki,this.resultGeometry=null,this.saveException=null,1===arguments.length){var t=arguments[0];this.argGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.argGeom=e,this.bufParams=n}}function pr(){this.comps=null;var t=arguments[0];this.comps=t}function vr(){if(this.component=null,this.segIndex=null,this.pt=null,2===arguments.length){var t=arguments[0],e=arguments[1];vr.call(this,t,vr.INSIDE_AREA,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.component=n,this.segIndex=i,this.pt=r}}function mr(){this.pts=null;var t=arguments[0];this.pts=t}function yr(){this.locations=null;var t=arguments[0];this.locations=t}function xr(){if(this.geom=null,this.terminateDistance=0,this.ptLocator=new Te,this.minDistanceLocation=null,this.minDistance=r.MAX_VALUE,2===arguments.length){var t=arguments[0],e=arguments[1];xr.call(this,t,e,0)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],s=arguments[2];this.geom=new Array(2).fill(null),this.geom[0]=n,this.geom[1]=i,this.terminateDistance=s}}function Er(){this.factory=null,this.directedEdges=new I,this.coordinates=null;var t=arguments[0];this.factory=t}function Ir(){this._isMarked=!1,this._isVisited=!1,this.data=null}function Nr(){Ir.apply(this),this.parentEdge=null,this.from=null,this.to=null,this.p0=null,this.p1=null,this.sym=null,this.edgeDirection=null,this.quadrant=null,this.angle=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.from=t,this.to=e,this.edgeDirection=i,this.p0=t.getCoordinate(),this.p1=n;var r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y;this.quadrant=Je.quadrant(r,s),this.angle=Math.atan2(s,r)}function Cr(){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];Nr.call(this,t,e,n,i)}function Sr(){if(Ir.apply(this),this.dirEdge=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}function wr(){this.outEdges=new I,this.sorted=!1}function Lr(){if(Ir.apply(this),this.pt=null,this.deStar=null,1===arguments.length){var t=arguments[0];Lr.call(this,t,new wr)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pt=e,this.deStar=n}}function Rr(){Sr.apply(this),this.line=null;var t=arguments[0];this.line=t}function Tr(){this.nodeMap=new rt}function Pr(){this.edges=new J,this.dirEdges=new J,this.nodeMap=new Tr}function br(){Pr.apply(this)}function Or(){this.graph=new br,this.mergedLineStrings=null,this.factory=null,this.edgeStrings=null}function _r(){this.edgeRing=null,this.next=null,this.label=-1;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];Nr.call(this,t,e,n,i)}function Mr(){Sr.apply(this),this.line=null;var t=arguments[0];this.line=t}function Dr(){this.factory=null,this.deList=new I,this.lowestEdge=null,this.ring=null,this.ringPts=null,this.holes=null,this.shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;var t=arguments[0];this.factory=t}function Ar(){}function Fr(){Pr.apply(this),this.factory=null;var t=arguments[0];this.factory=t}function Gr(){if(this.lineStringAdder=new qr(this),this.graph=null,this.dangles=new I,this.cutEdges=new I,this.invalidRingLines=new I,this.holeList=null,this.shellList=null,this.polyList=null,this.isCheckingRingsValid=!0,this.extractOnlyPolygonal=null,this.geomFactory=null,0===arguments.length)Gr.call(this,!1);else if(1===arguments.length){var t=arguments[0];this.extractOnlyPolygonal=t}}function qr(){this.p=null;var t=arguments[0];this.p=t}function Br(){}function zr(){if(this.edgeEnds=new I,1===arguments.length){var t=arguments[0];zr.call(this,null,t)}else if(2===arguments.length){var e=(arguments[0],arguments[1]);En.call(this,e.getEdge(),e.getCoordinate(),e.getDirectedCoordinate(),new gn(e.getLabel())),this.insert(e)}}function Vr(){Pn.apply(this)}function kr(){var t=arguments[0],e=arguments[1];yn.call(this,t,e)}function Yr(){Nn.apply(this)}function Ur(){this.li=new ae,this.ptLocator=new Te,this.arg=null,this.nodes=new xn(new Yr),this.im=null,this.isolatedEdges=new I,this.invalidPoint=null;var t=arguments[0];this.arg=t}function Xr(){this.rectEnv=null;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal()}function Hr(){this.li=new ae,this.rectEnv=null,this.diagUp0=null,this.diagUp1=null,this.diagDown0=null,this.diagDown1=null;var t=arguments[0];this.rectEnv=t,this.diagUp0=new g(t.getMinX(),t.getMinY()),this.diagUp1=new g(t.getMaxX(),t.getMaxY()),this.diagDown0=new g(t.getMinX(),t.getMaxY()),this.diagDown1=new g(t.getMaxX(),t.getMinY())}function Wr(){this._isDone=!1}function jr(){this.rectangle=null,this.rectEnv=null;var t=arguments[0];this.rectangle=t,this.rectEnv=t.getEnvelopeInternal()}function Kr(){Wr.apply(this),this.rectEnv=null,this._intersects=!1;var t=arguments[0];this.rectEnv=t}function Zr(){Wr.apply(this),this.rectSeq=null,this.rectEnv=null,this._containsPoint=!1;var t=arguments[0];this.rectSeq=t.getExteriorRing().getCoordinateSequence(),this.rectEnv=t.getEnvelopeInternal()}function Qr(){Wr.apply(this),this.rectEnv=null,this.rectIntersector=null,this.hasIntersection=!1,this.p0=new g,this.p1=new g;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal(),this.rectIntersector=new Hr(this.rectEnv)}function Jr(){if(this._relate=null,2===arguments.length){var t=arguments[0],e=arguments[1];ti.call(this,t,e),this._relate=new Ur(this.arg)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];ti.call(this,n,i,r),this._relate=new Ur(this.arg)}}function $r(){this.geomFactory=null,this.skipEmpty=!1,this.inputGeoms=null;var t=arguments[0];this.geomFactory=$r.extractFactory(t),this.inputGeoms=t}function ts(){this.pointGeom=null,this.otherGeom=null,this.geomFact=null;var t=arguments[0],e=arguments[1];this.pointGeom=t,this.otherGeom=e,this.geomFact=e.getFactory()}function es(){this.sortIndex=-1,this.comps=null;var t=arguments[0],e=arguments[1];this.sortIndex=t,this.comps=e}function ns(){this.inputPolys=null,this.geomFactory=null;var t=arguments[0];this.inputPolys=t,null===this.inputPolys&&(this.inputPolys=new I)}function is(){if(this.polygons=new I,this.lines=new I,this.points=new I,this.geomFact=null,1===arguments.length){if(R(arguments[0],v)){var t=arguments[0];this.extract(t)}else if(arguments[0]instanceof B){var e=arguments[0];this.extract(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.geomFact=i,this.extract(n)}}function rs(){this.geometryFactory=new ie,this.geomGraph=null,this.disconnectedRingcoord=null;var t=arguments[0];this.geomGraph=t}function ss(){this.nodes=new xn(new Yr)}function os(){this.li=new ae,this.geomGraph=null,this.nodeGraph=new ss,this.invalidPoint=null;var t=arguments[0];this.geomGraph=t}function as(){this.graph=null,this.rings=new I,this.totalEnv=new C,this.index=null,this.nestedPt=null;var t=arguments[0];this.graph=t}function us(){if(this.errorType=null,this.pt=null,1===arguments.length){var t=arguments[0];us.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.errorType=e,null!==n&&(this.pt=n.copy())}}function ls(){this.parentGeometry=null,this.isSelfTouchingRingFormingHoleValid=!1,this.validErr=null;var t=arguments[0];this.parentGeometry=t}function hs(){_t.CoordinateOperation.apply(this),this.targetPM=null,this.removeCollapsed=!0;var t=arguments[0],e=arguments[1];this.targetPM=t,this.removeCollapsed=e}function cs(){this.targetPM=null,this.removeCollapsed=!0,this.changePrecisionModel=!1,this.isPointwise=!1;var t=arguments[0];this.targetPM=t}function fs(){this.pts=null,this.usePt=null,this.distanceTolerance=null,this.seg=new ce;var t=arguments[0];this.pts=t}function gs(){this.inputGeom=null,this.distanceTolerance=null,this.isEnsureValidTopology=!0;var t=arguments[0];this.inputGeom=t}function ds(){xe.apply(this),this.isEnsureValidTopology=!0,this.distanceTolerance=null;var t=arguments[0],e=arguments[1];this.isEnsureValidTopology=t,this.distanceTolerance=e}function ps(){if(this.parent=null,this.index=null,2===arguments.length){var t=arguments[0],e=arguments[1];ps.call(this,t,e,null,-1)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=arguments[3];ce.call(this,n,i),this.parent=r,this.index=s}}function vs(){if(this.parentLine=null,this.segs=null,this.resultSegs=new I,this.minimumSize=null,1===arguments.length){var t=arguments[0];vs.call(this,t,2)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.parentLine=e,this.minimumSize=n,this.init()}}function ms(){this.index=new Bi}function ys(){this.querySeg=null,this.items=new I;var t=arguments[0];this.querySeg=t}function xs(){this.li=new ae,this.inputIndex=new ms,this.outputIndex=new ms,this.line=null,this.linePts=null,this.distanceTolerance=0;var t=arguments[0],e=arguments[1];this.inputIndex=t,this.outputIndex=e}function Es(){this.inputIndex=new ms,this.outputIndex=new ms,this.distanceTolerance=0}function Is(){this.inputGeom=null,this.lineSimplifier=new Es,this.linestringMap=null;var t=arguments[0];this.inputGeom=t}function Ns(){xe.apply(this),this.linestringMap=null;var t=arguments[0];this.linestringMap=t}function Cs(){this.tps=null;var t=arguments[0];this.tps=t}function Ss(){this.seg=null,this.segLen=null,this.splitPt=null,this.minimumLen=0;var t=arguments[0];this.seg=t,this.segLen=t.getLength()}function ws(){}function Ls(){}function Rs(){}function Ts(){if(this.p=null,1===arguments.length){var t=arguments[0];this.p=new g(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p=new g(e,n)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.p=new g(i,r,s)}}function Ps(){this._isOnConstraint=null,this.constraint=null;var t=arguments[0];Ts.call(this,t)}function bs(){this._rot=null,this.vertex=null,this.next=null,this.data=null}function Os(){this.subdiv=null,this.isUsingTolerance=!1;var t=arguments[0];this.subdiv=t,this.isUsingTolerance=t.getTolerance()>0}function _s(){}function Ms(){this.subdiv=null,this.lastEdge=null;var t=arguments[0];this.subdiv=t,this.init()}function Ds(){if(this.seg=null,1===arguments.length){if("string"==typeof arguments[0]){var t=arguments[0];l.call(this,t)}else if(arguments[0]instanceof ce){var e=arguments[0];l.call(this,"Locate failed to converge (at edge: "+e+").  Possible causes include invalid Subdivision topology or very close sites"),this.seg=new ce(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];l.call(this,Ds.msgWithSpatial(n,i)),this.seg=new ce(i)}}function As(){}function Fs(){this.visitedKey=0,this.quadEdges=new I,this.startingEdge=null,this.tolerance=null,this.edgeCoincidenceTolerance=null,this.frameVertex=new Array(3).fill(null),this.frameEnv=null,this.locator=null,this.seg=new ce,this.triEdges=new Array(3).fill(null);var t=arguments[0],e=arguments[1];this.tolerance=e,this.edgeCoincidenceTolerance=e/Fs.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this.startingEdge=this.initSubdiv(),this.locator=new Ms(this)}function Gs(){}function qs(){this.triList=new I}function Bs(){this.triList=new I}function zs(){this.coordList=new N,this.triCoords=new I}function Vs(){if(this.ls=null,this.data=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.ls=new ce(t,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.ls=new ce(n,i),this.data=r}else if(6===arguments.length){var s=arguments[0],o=arguments[1],a=arguments[2],u=arguments[3],l=arguments[4],h=arguments[5];Vs.call(this,new g(s,o,a),new g(u,l,h))}else if(7===arguments.length){var c=arguments[0],f=arguments[1],d=arguments[2],p=arguments[3],v=arguments[4],m=arguments[5],y=arguments[6];Vs.call(this,new g(c,f,d),new g(p,v,m),y)}}function ks(){}function Ys(){if(this.p=null,this.data=null,this.left=null,this.right=null,this.count=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.p=new g(t),this.left=null,this.right=null,this.count=1,this.data=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.p=new g(n,i),this.left=null,this.right=null,this.count=1,this.data=r}}function Us(){if(this.root=null,this.numberOfNodes=null,this.tolerance=null,0===arguments.length)Us.call(this,0);else if(1===arguments.length){var t=arguments[0];this.tolerance=t}}function Xs(){this.tolerance=null,this.matchNode=null,this.matchDist=0,this.p=null;var t=arguments[0],e=arguments[1];this.p=t,this.tolerance=e}function Hs(){this.initialVertices=null,this.segVertices=null,this.segments=new I,this.subdiv=null,this.incDel=null,this.convexHull=null,this.splitFinder=new Ls,this.kdt=null,this.vertexFactory=null,this.computeAreaEnv=null,this.splitPt=null,this.tolerance=null;var t=arguments[0],e=arguments[1];this.initialVertices=new I(t),this.tolerance=e,this.kdt=new Us(e)}function Ws(){this.siteCoords=null,this.tolerance=0,this.subdiv=null}function js(){this.siteCoords=null,this.constraintLines=null,this.tolerance=0,this.subdiv=null,this.constraintVertexMap=new rt}function Ks(){this.siteCoords=null,this.tolerance=0,this.subdiv=null,this.clipEnv=null,this.diagramEnv=null}function Zs(){}Array.prototype.fill||(Array.prototype.fill=function(t){for(var e=Object(this),n=parseInt(e.length,10),i=arguments[1],r=parseInt(i,10)||0,s=0>r?Math.max(n+r,0):Math.min(r,n),o=arguments[2],a=void 0===o?n:parseInt(o,10)||0,u=0>a?Math.max(n+a,0):Math.min(a,n);u>s;s++)e[s]=t;return e}),Number.isFinite=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)},Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(t){return t!==t},Math.trunc=Math.trunc||function(t){return 0>t?Math.ceil(t):Math.floor(t)},e(n.prototype,{interfaces_:function(){return[]},getClass:function(){return n}}),n.equalsWithTolerance=function(t,e,n){return Math.abs(t-e)<=n},r.isNaN=function(t){return Number.isNaN(t)},r.doubleToLongBits=function(t){return t},r.longBitsToDouble=function(t){return t},r.isInfinite=function(t){return!Number.isFinite(t)},r.MAX_VALUE=Number.MAX_VALUE,l.prototype=Object.create(Error.prototype),l.prototype.constructor=Error,h(c,l),e(c.prototype,{interfaces_:function(){return[]},getClass:function(){return c}}),e(f.prototype,{interfaces_:function(){return[]},getClass:function(){return f}}),f.shouldNeverReachHere=function(){if(0===arguments.length)f.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new c("Should never reach here"+(null!==t?": "+t:""))}},f.isTrue=function(){if(1===arguments.length){var t=arguments[0];f.isTrue(t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!e)throw null===n?new c:new c(n)}},f.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];f.equals(t,e,null)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(!i.equals(n))throw new c("Expected "+n+" but encountered "+i+(null!==r?": "+r:""))}},e(g.prototype,{setOrdinate:function(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new i("Invalid ordinate index: "+t)}},equals2D:function(){if(1===arguments.length){var t=arguments[0];return this.x!==t.x?!1:this.y===t.y}if(2===arguments.length){var e=arguments[0],i=arguments[1];return n.equalsWithTolerance(this.x,e.x,i)?!!n.equalsWithTolerance(this.y,e.y,i):!1}},getOrdinate:function(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new i("Invalid ordinate index: "+t)},equals3D:function(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||r.isNaN(this.z)&&r.isNaN(t.z))},equals:function(t){return t instanceof g?this.equals2D(t):!1},equalInZ:function(t,e){return n.equalsWithTolerance(this.z,t.z,e)},compareTo:function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0},clone:function(){try{var t=null;return t}catch(e){if(e instanceof CloneNotSupportedException)return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw e}finally{}},copy:function(){return new g(this)},toString:function(){return"("+this.x+", "+this.y+", "+this.z+")"},distance3D:function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)},distance:function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y)},setCoordinate:function(t){this.x=t.x,this.y=t.y,this.z=t.z},interfaces_:function(){return[s,o,u]},getClass:function(){return g}}),g.hashCode=function(){if(1===arguments.length){var t=arguments[0],e=r.doubleToLongBits(t);return Math.trunc(e^e>>>32)}},e(d.prototype,{compare:function(t,e){var n=t,i=e,r=d.compare(n.x,i.x);if(0!==r)return r;var s=d.compare(n.y,i.y);if(0!==s)return s;if(this.dimensionsToTest<=2)return 0;var o=d.compare(n.z,i.z);return o},interfaces_:function(){return[a]},getClass:function(){return d}}),d.compare=function(t,e){return e>t?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0},g.DimensionalComparator=d,g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=r.NaN,g.X=0,g.Y=1,g.Z=2,p.prototype.hasNext=function(){},p.prototype.next=function(){},p.prototype.remove=function(){},v.prototype.add=function(){},v.prototype.addAll=function(){},v.prototype.isEmpty=function(){},v.prototype.iterator=function(){},v.prototype.size=function(){},v.prototype.toArray=function(){},v.prototype.remove=function(){},m.prototype=new Error,m.prototype.name="IndexOutOfBoundsException",y.prototype=Object.create(v.prototype),y.prototype.constructor=y,y.prototype.get=function(){},y.prototype.set=function(){},y.prototype.isEmpty=function(){},x.prototype=new Error,x.prototype.name="NoSuchElementException",E.prototype=new Error,E.prototype.name="OperationNotSupported",I.prototype=Object.create(y.prototype),I.prototype.constructor=I,I.prototype.ensureCapacity=function(){},I.prototype.interfaces_=function(){return[y,v]},I.prototype.add=function(t){return 1===arguments.length?this.array_.push(t):this.array_.splice(arguments[0],arguments[1]),!0},I.prototype.clear=function(){this.array_=[]},I.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},I.prototype.set=function(t,e){var n=this.array_[t];return this.array_[t]=e,n},I.prototype.iterator=function(){return new Qs(this)},I.prototype.get=function(t){if(0>t||t>=this.size())throw new m;return this.array_[t]},I.prototype.isEmpty=function(){return 0===this.array_.length},I.prototype.size=function(){return this.array_.length},I.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},I.prototype.remove=function(t){for(var e=!1,n=0,i=this.array_.length;i>n;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e};var Qs=function(t){this.arrayList_=t,this.position_=0};Qs.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new x;return this.arrayList_.get(this.position_++)},Qs.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},Qs.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},Qs.prototype.remove=function(){throw new E},h(N,I),e(N.prototype,{getCoordinate:function(t){return this.get(t)},addAll:function(){if(2===arguments.length){for(var t=arguments[0],e=arguments[1],n=!1,i=t.iterator();i.hasNext();)this.add(i.next(),e),n=!0;return n}return I.prototype.addAll.apply(this,arguments)},clone:function Go(){for(var Go=I.prototype.clone.call(this),t=0;t<this.size();t++)Go.add(t,this.get(t).copy());return Go},toCoordinateArray:function(){return this.toArray(N.coordArrayType)},add:function(){if(1===arguments.length){var t=arguments[0];I.prototype.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var e=arguments[0],n=arguments[1];return this.add(e,n,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){var i=arguments[0],r=arguments[1];if(!r&&this.size()>=1){var s=this.get(this.size()-1);if(s.equals2D(i))return null}I.prototype.add.call(this,i)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],a=arguments[1];return this.add(o,a),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2];if(h)for(var c=0;c<u.length;c++)this.add(u[c],l);else for(var c=u.length-1;c>=0;c--)this.add(u[c],l);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){var f=arguments[0],d=arguments[1],p=arguments[2];if(!p){var v=this.size();if(v>0){if(f>0){var m=this.get(f-1);if(m.equals2D(d))return null}if(v>f){var y=this.get(f);if(y.equals2D(d))return null}}}I.prototype.add.call(this,f,d)}}else if(4===arguments.length){var x=arguments[0],E=arguments[1],N=arguments[2],C=arguments[3],S=1;N>C&&(S=-1);for(var c=N;c!==C;c+=S)this.add(x[c],E);return!0}},closeRing:function(){this.size()>0&&this.add(new g(this.get(0)),!1)},interfaces_:function(){return[]},getClass:function(){return N}}),N.coordArrayType=new Array(0).fill(null),e(C.prototype,{getArea:function(){return this.getWidth()*this.getHeight()},equals:function(t){if(!(t instanceof C))return!1;var e=t;return this.isNull()?e.isNull():this.maxx===e.getMaxX()&&this.maxy===e.getMaxY()&&this.minx===e.getMinX()&&this.miny===e.getMinY()},intersection:function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new C;var e=this.minx>t.minx?this.minx:t.minx,n=this.miny>t.miny?this.miny:t.miny,i=this.maxx<t.maxx?this.maxx:t.maxx,r=this.maxy<t.maxy?this.maxy:t.maxy;return new C(e,i,n,r)},isNull:function(){return this.maxx<this.minx},getMaxX:function(){return this.maxx},covers:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof C){var e=arguments[0];return this.isNull()||e.isNull()?!1:e.getMinX()>=this.minx&&e.getMaxX()<=this.maxx&&e.getMinY()>=this.miny&&e.getMaxY()<=this.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:n>=this.minx&&n<=this.maxx&&i>=this.miny&&i<=this.maxy}},intersects:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.isNull()||t.isNull()?!1:!(t.minx>this.maxx||t.maxx<this.minx||t.miny>this.maxy||t.maxy<this.miny)}if(arguments[0]instanceof g){var e=arguments[0];return this.intersects(e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:!(n>this.maxx||n<this.minx||i>this.maxy||i<this.miny)}},getMinY:function(){return this.miny},getMinX:function(){return this.minx},expandToInclude:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];if(e.isNull())return null;this.isNull()?(this.minx=e.getMinX(),this.maxx=e.getMaxX(),this.miny=e.getMinY(),this.maxy=e.getMaxY()):(e.minx<this.minx&&(this.minx=e.minx),e.maxx>this.maxx&&(this.maxx=e.maxx),e.miny<this.miny&&(this.miny=e.miny),e.maxy>this.maxy&&(this.maxy=e.maxy))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.isNull()?(this.minx=n,this.maxx=n,this.miny=i,this.maxy=i):(n<this.minx&&(this.minx=n),n>this.maxx&&(this.maxx=n),i<this.miny&&(this.miny=i),i>this.maxy&&(this.maxy=i))}},minExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return e>t?t:e},getWidth:function(){return this.isNull()?0:this.maxx-this.minx},compareTo:function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this.minx<e.minx?-1:this.minx>e.minx?1:this.miny<e.miny?-1:this.miny>e.miny?1:this.maxx<e.maxx?-1:this.maxx>e.maxx?1:this.maxy<e.maxy?-1:this.maxy>e.maxy?1:0},translate:function(t,e){return this.isNull()?null:void this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)},toString:function(){return"Env["+this.minx+" : "+this.maxx+", "+this.miny+" : "+this.maxy+"]"},setToNull:function(){this.minx=0,this.maxx=-1,this.miny=0,this.maxy=-1},getHeight:function(){return this.isNull()?0:this.maxy-this.miny},maxExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e},expandBy:function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this.minx-=e,this.maxx+=e,this.miny-=n,this.maxy+=n,(this.minx>this.maxx||this.miny>this.maxy)&&this.setToNull()}},contains:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.covers(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.covers(n,i)}},centre:function(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},init:function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.minx=e.minx,this.maxx=e.maxx,this.miny=e.miny,this.maxy=e.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];s>r?(this.minx=r,this.maxx=s):(this.minx=s,this.maxx=r),a>o?(this.miny=o,this.maxy=a):(this.miny=a,this.maxy=o)}},getMaxY:function(){return this.maxy},distance:function(t){if(this.intersects(t))return 0;var e=0;this.maxx<t.minx?e=t.minx-this.maxx:this.minx>t.maxx&&(e=this.minx-t.maxx);var n=0;return this.maxy<t.miny?n=t.miny-this.maxy:this.miny>t.maxy&&(n=this.miny-t.maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.minx),t=37*t+g.hashCode(this.maxx),t=37*t+g.hashCode(this.miny),t=37*t+g.hashCode(this.maxy)},interfaces_:function(){return[s,u]},getClass:function(){return C}}),C.intersects=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=Math.min(s.x,o.x),u=Math.max(s.x,o.x),l=Math.min(i.x,r.x),h=Math.max(i.x,r.x);return l>u?!1:a>h?!1:(a=Math.min(s.y,o.y),u=Math.max(s.y,o.y),l=Math.min(i.y,r.y),h=Math.max(i.y,r.y),l>u?!1:!(a>h))}},C.serialVersionUID=0x51845cd552189800,h(w,S),e(w.prototype,{interfaces_:function(){return[]},getClass:function(){return w}}),e(L.prototype,{interfaces_:function(){return[]},getClass:function(){return L}}),L.toLocationSymbol=function(t){switch(t){case L.EXTERIOR:return"e";case L.BOUNDARY:return"b";case L.INTERIOR:return"i";case L.NONE:return"-"}throw new i("Unknown location value: "+t)},L.INTERIOR=0,L.BOUNDARY=1,L.EXTERIOR=2,L.NONE=-1,e(T.prototype,{interfaces_:function(){return[]},getClass:function(){return T}}),T.log10=function(t){var e=Math.log(t);return r.isInfinite(e)?e:r.isNaN(e)?e:e/T.LOG_10},T.min=function(t,e,n,i){var r=t;return r>e&&(r=e),r>n&&(r=n),r>i&&(r=i),r},T.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];return e>t?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var i=arguments[0],r=arguments[1],s=arguments[2];return r>i?r:i>s?s:i}},T.wrap=function(t,e){return 0>t?e- -t%e:t%e},T.max=function(){
if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=t;return e>i&&(i=e),n>i&&(i=n),i}if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],i=r;return s>i&&(i=s),o>i&&(i=o),a>i&&(i=a),i}},T.average=function(t,e){return(t+e)/2},T.LOG_10=Math.log(10),P.prototype.append=function(t){this.str+=t},P.prototype.setCharAt=function(t,e){return this.str.substr(0,t)+e+this.str.substr(t+1)},P.prototype.toString=function(t){return this.str},b.prototype.intValue=function(){return this.value},b.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},b.isNaN=function(t){return Number.isNaN(t)},O.isWhitespace=function(t){return 32>=t&&t>=0||127==t},O.toUpperCase=function(t){return t.toUpperCase()},e(_.prototype,{le:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<=t.lo},extractSignificantDigits:function(t,e){var n=this.abs(),i=_.magnitude(n.hi),r=_.TEN.pow(i);n=n.divide(r),n.gt(_.TEN)?(n=n.divide(_.TEN),i+=1):n.lt(_.ONE)&&(n=n.multiply(_.TEN),i-=1);for(var s=i+1,o=new P,a=_.MAX_PRINT_DIGITS-1,u=0;a>=u;u++){t&&u===s&&o.append(".");var l=Math.trunc(n.hi);if(0>l)break;var h=!1,c=0;l>9?(h=!0,c="9"):c="0"+l,o.append(c),n=n.subtract(_.valueOf(l)).multiply(_.TEN),h&&n.selfAdd(_.TEN);var f=!0,g=_.magnitude(n.hi);if(0>g&&Math.abs(g)>=a-u&&(f=!1),!f)break}return e[0]=i,o.toString()},sqr:function(){return this.multiply(this)},doubleValue:function(){return this.hi+this.lo},subtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var e=arguments[0];return this.add(-e)}},equals:function(){if(1===arguments.length){var t=arguments[0];return this.hi===t.hi&&this.lo===t.lo}},isZero:function(){return 0===this.hi&&0===this.lo},selfSubtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t.hi,-t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.isNaN()?this:this.selfAdd(-e,0)}},getSpecialNumberString:function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},min:function(t){return this.le(t)?this:t},selfDivide:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfDivide(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfDivide(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null,h=null,c=null;return u=this.hi/n,l=_.SPLIT*u,r=l-u,c=_.SPLIT*n,r=l-r,s=u-r,o=c-n,h=u*n,o=c-o,a=n-o,c=r*o-h+r*a+s*o+s*a,l=(this.hi-h-c+this.lo-u*i)/n,c=u+l,this.hi=c,this.lo=u-c+l,this}},dump:function(){return"DD<"+this.hi+", "+this.lo+">"},divide:function(){if(arguments[0]instanceof _){var t=arguments[0],e=null,n=null,i=null,s=null,o=null,a=null,u=null,l=null;o=this.hi/t.hi,a=_.SPLIT*o,e=a-o,l=_.SPLIT*t.hi,e=a-e,n=o-e,i=l-t.hi,u=o*t.hi,i=l-i,s=t.hi-i,l=e*i-u+e*s+n*i+n*s,a=(this.hi-u-l+this.lo-o*t.lo)/t.hi,l=o+a;var h=l,c=o-l+a;return new _(h,c)}if("number"==typeof arguments[0]){var f=arguments[0];return r.isNaN(f)?_.createNaN():_.copy(this).selfDivide(f,0)}},ge:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>=t.lo},pow:function(t){if(0===t)return _.valueOf(1);var e=new _(this),n=_.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2===1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return 0>t?n.reciprocal():n},ceil:function(){if(this.isNaN())return _.NaN;var t=Math.ceil(this.hi),e=0;return t===this.hi&&(e=Math.ceil(this.lo)),new _(t,e)},compareTo:function(t){var e=t;return this.hi<e.hi?-1:this.hi>e.hi?1:this.lo<e.lo?-1:this.lo>e.lo?1:0},rint:function(){if(this.isNaN())return this;var t=this.add(.5);return t.floor()},setValue:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var e=arguments[0];return this.init(e),this}},max:function(t){return this.ge(t)?this:t},sqrt:function(){if(this.isZero())return _.valueOf(0);if(this.isNegative())return _.NaN;var t=1/Math.sqrt(this.hi),e=this.hi*t,n=_.valueOf(e),i=this.subtract(n.sqr()),r=i.hi*(.5*t);return n.add(r)},selfAdd:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfAdd(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0],n=null,i=null,r=null,s=null,o=null,a=null;return r=this.hi+e,o=r-this.hi,s=r-o,s=e-o+(this.hi-s),a=s+this.lo,n=r+a,i=a+(r-n),this.hi=n+i,this.lo=i+(n-this.hi),this}}else if(2===arguments.length){var u=arguments[0],l=arguments[1],n=null,i=null,h=null,c=null,r=null,s=null,o=null,a=null;r=this.hi+u,h=this.lo+l,o=r-this.hi,a=h-this.lo,s=r-o,c=h-a,s=u-o+(this.hi-s),c=l-a+(this.lo-c),o=s+h,n=r+o,i=o+(r-n),o=c+i;var f=n+o,g=o+(n-f);return this.hi=f,this.lo=g,this}},selfMultiply:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfMultiply(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfMultiply(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null;u=_.SPLIT*this.hi,r=u-this.hi,l=_.SPLIT*n,r=u-r,s=this.hi-r,o=l-n,u=this.hi*n,o=l-o,a=n-o,l=r*o-u+r*a+s*o+s*a+(this.hi*i+this.lo*n);var h=u+l;r=u-h;var c=l+r;return this.hi=h,this.lo=c,this}},selfSqr:function(){return this.selfMultiply(this)},floor:function(){if(this.isNaN())return _.NaN;var t=Math.floor(this.hi),e=0;return t===this.hi&&(e=Math.floor(this.lo)),new _(t,e)},negate:function(){return this.isNaN()?this:new _(-this.hi,-this.lo)},clone:function(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}finally{}},multiply:function(){if(arguments[0]instanceof _){var t=arguments[0];return t.isNaN()?_.createNaN():_.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var e=arguments[0];return r.isNaN(e)?_.createNaN():_.copy(this).selfMultiply(e,0)}},isNaN:function(){return r.isNaN(this.hi)},intValue:function(){return Math.trunc(this.hi)},toString:function(){var t=_.magnitude(this.hi);return t>=-3&&20>=t?this.toStandardNotation():this.toSciNotation()},toStandardNotation:function(){var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1,r=n;if("."===n.charAt(0))r="0"+n;else if(0>i)r="0."+_.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){var s=i-n.length,o=_.stringOfChar("0",s);r=n+o+".0"}return this.isNegative()?"-"+r:r},reciprocal:function(){var t=null,e=null,n=null,i=null,r=null,s=null,o=null,a=null;r=1/this.hi,s=_.SPLIT*r,t=s-r,a=_.SPLIT*this.hi,t=s-t,e=r-t,n=a-this.hi,o=r*this.hi,n=a-n,i=this.hi-n,a=t*n-o+t*i+e*n+e*i,s=(1-o-a-r*this.lo)/this.hi;var u=r+s,l=r-u+s;return new _(u,l)},toSciNotation:function(){if(this.isZero())return _.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=_.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);var r="";n.length>1&&(r=n.substring(1));var s=n.charAt(0)+"."+r;return this.isNegative()?"-"+s+i:s+i},abs:function(){return this.isNaN()?_.NaN:this.isNegative()?this.negate():new _(this)},isPositive:function(){return this.hi>0||0===this.hi&&this.lo>0},lt:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<t.lo},add:function(){if(arguments[0]instanceof _){var t=arguments[0];return _.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var e=arguments[0];return _.copy(this).selfAdd(e)}},init:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.hi=t,this.lo=0}else if(arguments[0]instanceof _){var e=arguments[0];this.hi=e.hi,this.lo=e.lo}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.hi=n,this.lo=i}},gt:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>t.lo},isNegative:function(){return this.hi<0||0===this.hi&&this.lo<0},trunc:function(){return this.isNaN()?_.NaN:this.isPositive()?this.floor():this.ceil()},signum:function(){return this.hi>0?1:this.hi<0?-1:this.lo>0?1:this.lo<0?-1:0},interfaces_:function(){return[u,s,o]},getClass:function(){return _}}),_.sqr=function(t){return _.valueOf(t).selfMultiply(t)},_.valueOf=function(){if("string"==typeof arguments[0]){var t=arguments[0];return _.parse(t)}if("number"==typeof arguments[0]){var e=arguments[0];return new _(e)}},_.sqrt=function(t){return _.valueOf(t).sqrt()},_.parse=function(t){for(var e=0,n=t.length;O.isWhitespace(t.charAt(e));)e++;var i=!1;if(n>e){var r=t.charAt(e);"-"!==r&&"+"!==r||(e++,"-"===r&&(i=!0))}for(var s=new _,o=0,a=0,u=0;;){if(e>=n)break;var l=t.charAt(e);if(e++,O.isDigit(l)){var h=l-"0";s.selfMultiply(_.TEN),s.selfAdd(h),o++}else{if("."!==l){if("e"===l||"E"===l){var c=t.substring(e);try{u=b.parseInt(c)}catch(f){throw f instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+c+" in string "+t):f}finally{}break}throw new NumberFormatException("Unexpected character '"+l+"' at position "+e+" in string "+t)}a=o}}var g=s,d=o-a-u;if(0===d)g=s;else if(d>0){var p=_.TEN.pow(d);g=s.divide(p)}else if(0>d){var p=_.TEN.pow(-d);g=s.multiply(p)}return i?g.negate():g},_.createNaN=function(){return new _(r.NaN,r.NaN)},_.copy=function(t){return new _(t)},_.magnitude=function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),i=Math.trunc(Math.floor(n)),r=Math.pow(10,i);return e>=10*r&&(i+=1),i},_.stringOfChar=function(t,e){for(var n=new P,i=0;e>i;i++)n.append(t);return n.toString()},_.PI=new _(3.141592653589793,1.2246467991473532e-16),_.TWO_PI=new _(6.283185307179586,2.4492935982947064e-16),_.PI_2=new _(1.5707963267948966,6.123233995736766e-17),_.E=new _(2.718281828459045,1.4456468917292502e-16),_.NaN=new _(r.NaN,r.NaN),_.EPS=1.23259516440783e-32,_.SPLIT=134217729,_.MAX_PRINT_DIGITS=32,_.TEN=_.valueOf(10),_.ONE=_.valueOf(1),_.SCI_NOT_EXPONENT_CHAR="E",_.SCI_NOT_ZERO="0.0E0",e(M.prototype,{interfaces_:function(){return[]},getClass:function(){return M}}),M.orientationIndex=function(t,e,n){var i=M.orientationIndexFilter(t,e,n);if(1>=i)return i;var r=_.valueOf(e.x).selfAdd(-t.x),s=_.valueOf(e.y).selfAdd(-t.y),o=_.valueOf(n.x).selfAdd(-e.x),a=_.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum()},M.signOfDet2x2=function(t,e,n,i){var r=t.multiply(i).selfSubtract(e.multiply(n));return r.signum()},M.intersection=function(t,e,n,i){var r=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(e.x).selfSubtract(t.x)),s=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(e.y).selfSubtract(t.y)),o=r.subtract(s),a=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),u=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),l=a.subtract(u),h=l.selfDivide(o).doubleValue(),c=_.valueOf(t.x).selfAdd(_.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),f=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),d=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),p=f.subtract(d),v=p.selfDivide(o).doubleValue(),m=_.valueOf(n.y).selfAdd(_.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();return new g(c,m)},M.orientationIndexFilter=function(t,e,n){var i=null,r=(t.x-n.x)*(e.y-n.y),s=(t.y-n.y)*(e.x-n.x),o=r-s;if(r>0){if(0>=s)return M.signum(o);i=r+s}else{if(!(0>r))return M.signum(o);if(s>=0)return M.signum(o);i=-r-s}var a=M.DP_SAFE_EPSILON*i;return o>=a||-o>=a?M.signum(o):2},M.signum=function(t){return t>0?1:0>t?-1:0},M.DP_SAFE_EPSILON=1e-15,e(D.prototype,{setOrdinate:function(t,e,n){},size:function(){},getOrdinate:function(t,e){},getCoordinate:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},getCoordinateCopy:function(t){},getDimension:function(){},getX:function(t){},clone:function(){},expandEnvelope:function(t){},copy:function(){},getY:function(t){},toCoordinateArray:function(){},interfaces_:function(){return[o]},getClass:function(){return D}}),D.X=0,D.Y=1,D.Z=2,D.M=3,A.arraycopy=function(t,e,n,i,r){for(var s=0,o=e;e+r>o;o++)n[i+s]=t[o],s++},A.getProperty=function(t){return{"line.separator":"\n"}[t]},e(F.prototype,{getY:function(){var t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getX:function(){var t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getCoordinate:function(){var t=new g;return t.x=this.getX(),t.y=this.getY(),t},interfaces_:function(){return[]},getClass:function(){return F}}),F.intersection=function(t,e,n,i){var s=t.y-e.y,o=e.x-t.x,a=t.x*e.y-e.x*t.y,u=n.y-i.y,l=i.x-n.x,h=n.x*i.y-i.x*n.y,c=o*h-l*a,f=u*a-s*h,d=s*l-u*o,p=c/d,v=f/d;if(r.isNaN(p)||r.isInfinite(p)||r.isNaN(v)||r.isInfinite(v))throw new w;return new g(p,v)},e(G.prototype,{create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){arguments[0]}else if(R(arguments[0],D)){arguments[0]}}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return G}}),e(q.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return q}}),e(B.prototype,{isGeometryCollection:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION},getFactory:function(){return this.factory},getGeometryN:function(t){return this},getArea:function(){return 0},isRectangle:function(){return!1},equals:function(){if(1===arguments.length){if(arguments[0]instanceof B){var t=arguments[0];return null===t?!1:this.equalsTopo(t)}if(arguments[0]instanceof Object){var e=arguments[0];if(!(e instanceof B))return!1;var n=e;return this.equalsExact(n)}}},equalsExact:function(t){return this===t||this.equalsExact(t,0)},geometryChanged:function(){this.apply(B.geometryChangedFilter)},geometryChangedAction:function(){this.envelope=null},equalsNorm:function(t){return null===t?!1:this.norm().equalsExact(t.norm())},getLength:function(){return 0},getNumGeometries:function(){return 1},compareTo:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(n,i)}},getUserData:function(){return this.userData},getSRID:function(){return this.SRID},getEnvelope:function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},checkNotGeometryCollection:function(t){if(t.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION)throw new i("This method does not support GeometryCollection arguments")},equal:function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n},norm:function(){var t=this.copy();return t.normalize(),t},getPrecisionModel:function(){return this.factory.getPrecisionModel()},getEnvelopeInternal:function(){return null===this.envelope&&(this.envelope=this.computeEnvelopeInternal()),new C(this.envelope)},setSRID:function(t){this.SRID=t},setUserData:function(t){this.userData=t},compare:function(t,e){for(var n=t.iterator(),i=e.iterator();n.hasNext()&&i.hasNext();){var r=n.next(),s=i.next(),o=r.compareTo(s);if(0!==o)return o}return n.hasNext()?1:i.hasNext()?-1:0},hashCode:function(){return this.getEnvelopeInternal().hashCode()},isGeometryCollectionOrDerived:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===B.SORTINDEX_MULTIPOINT||this.getSortIndex()===B.SORTINDEX_MULTILINESTRING||this.getSortIndex()===B.SORTINDEX_MULTIPOLYGON},interfaces_:function(){return[o,s,u]},getClass:function(){return B}}),B.hasNonEmptyElements=function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1},B.hasNullElements=function(t){for(var e=0;e<t.length;e++)if(null===t[e])return!0;return!1},B.serialVersionUID=0x799ea46522854c00,B.SORTINDEX_POINT=0,B.SORTINDEX_MULTIPOINT=1,B.SORTINDEX_LINESTRING=2,B.SORTINDEX_LINEARRING=3,B.SORTINDEX_MULTILINESTRING=4,B.SORTINDEX_POLYGON=5,B.SORTINDEX_MULTIPOLYGON=6,B.SORTINDEX_GEOMETRYCOLLECTION=7,B.geometryChangedFilter={interfaces_:function(){return[q]},filter:function(t){t.geometryChangedAction()}},e(z.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return z}}),e(V.prototype,{isInBoundary:function(t){},interfaces_:function(){return[]},getClass:function(){return V}}),e(k.prototype,{isInBoundary:function(t){return t%2===1},interfaces_:function(){return[V]},getClass:function(){return k}}),e(Y.prototype,{isInBoundary:function(t){return t>0},interfaces_:function(){return[V]},getClass:function(){return Y}}),e(U.prototype,{isInBoundary:function(t){return t>1},interfaces_:function(){return[V]},getClass:function(){return U}}),e(X.prototype,{isInBoundary:function(t){return 1===t},interfaces_:function(){return[V]},getClass:function(){return X}}),V.Mod2BoundaryNodeRule=k,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=X,V.MOD2_BOUNDARY_RULE=new k,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new X,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE,e(H.prototype,{interfaces_:function(){return[]},getClass:function(){return H}}),H.isRing=function(t){return t.length<4?!1:!!t[0].equals2D(t[t.length-1])},H.ptNotInList=function(t,e){for(var n=0;n<t.length;n++){var i=t[n];if(H.indexOf(i,e)<0)return i}return null},H.scroll=function(t,e){var n=H.indexOf(e,t);if(0>n)return null;var i=new Array(t.length).fill(null);A.arraycopy(t,n,i,0,t.length-n),A.arraycopy(t,0,i,t.length-n,n),A.arraycopy(i,0,t,0,t.length)},H.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];if(i===r)return!0;if(null===i||null===r)return!1;if(i.length!==r.length)return!1;for(var n=0;n<i.length;n++)if(0!==s.compare(i[n],r[n]))return!1;return!0}},H.intersection=function(t,e){for(var n=new N,i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()},H.hasRepeatedPoints=function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1},H.removeRepeatedPoints=function(t){if(!H.hasRepeatedPoints(t))return t;var e=new N(t,!1);return e.toCoordinateArray()},H.reverse=function(t){for(var e=t.length-1,n=Math.trunc(e/2),i=0;n>=i;i++){var r=t[i];t[i]=t[e-i],t[e-i]=r}},H.removeNull=function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var i=new Array(e).fill(null);if(0===e)return i;for(var r=0,n=0;n<t.length;n++)null!==t[n]&&(i[r++]=t[n]);return i},H.copyDeep=function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length)for(var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=arguments[4],n=0;a>n;n++)s[o+n]=new g(i[r+n])},H.isEqualReversed=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[t.length-n-1];if(0!==i.compareTo(r))return!1}return!0},H.envelope=function(t){for(var e=new C,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e},H.toCoordinateArray=function(t){return t.toArray(H.coordArrayType)},H.atLeastNCoordinatesOrNothing=function(t,e){return e.length>=t?e:[]},H.indexOf=function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1},H.increasingDirection=function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1},H.compare=function(t,e){for(var n=0;n<t.length&&n<e.length;){var i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0},H.minCoordinate=function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e},H.extract=function(t,e,n){e=T.clamp(e,0,t.length),n=T.clamp(n,-1,t.length);var i=n-e+1;0>n&&(i=0),e>=t.length&&(i=0),e>n&&(i=0);var r=new Array(i).fill(null);if(0===i)return r;for(var s=0,o=e;n>=o;o++)r[s++]=t[o];return r},e(W.prototype,{compare:function(t,e){var n=t,i=e;return H.compare(n,i)},interfaces_:function(){return[a]},getClass:function(){return W}}),e(j.prototype,{compare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;var r=H.compare(n,i),s=H.isEqualReversed(n,i);return s?0:r},OLDcompare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;for(var r=H.increasingDirection(n),s=H.increasingDirection(i),o=r>0?0:n.length-1,a=s>0?0:n.length-1,u=0;u<n.length;u++){var l=n[o].compareTo(i[a]);if(0!==l)return l;o+=r,a+=s}return 0},interfaces_:function(){return[a]},getClass:function(){return j}}),H.ForwardComparator=W,H.BidirectionalComparator=j,H.coordArrayType=new Array(0).fill(null),K.prototype.get=function(){},K.prototype.put=function(){},K.prototype.size=function(){},K.prototype.values=function(){},K.prototype.entrySet=function(){},Z.prototype=new K,Q.prototype=new v,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(i===t)return!0}return!1},J.prototype.add=function(t){return this.contains(t)?!1:(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new javascript.util.OperationNotSupported},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new Js(this)};var Js=function(t){this.hashSet_=t,this.position_=0};Js.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new x;return this.hashSet_.array_[this.position_++]},Js.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},Js.prototype.remove=function(){throw new E};var $s=0,to=1;rt.prototype=new Z,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(0>n)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,i,r=this.root_;do if(n=r,i=t.compareTo(r.key),0>i)r=r.left;else{if(!(i>0)){var s=r.value;return r.value=e,s}r=r.right}while(null!==r);var o={key:t,left:null,right:null,value:e,parent:n,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}};return 0>i?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){for(t.color=to;null!=t&&t!=this.root_&&t.parent.color==to;)if(tt(t)==nt(tt(tt(t)))){var e=it(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==it(tt(t))&&(t=tt(t),this.rotateLeft(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateRight(tt(tt(t))))}else{var e=nt(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==nt(tt(t))&&(t=tt(t),this.rotateRight(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateLeft(tt(tt(t))))}this.root_.color=$s},rt.prototype.values=function(){var t=new I,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left==t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right==t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){if(null===t)return null;if(null!==t.right){for(var e=t.right;null!==e.left;)e=e.left;return e}for(var e=t.parent,n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},e(st.prototype,{interfaces_:function(){return[]},getClass:function(){return st}}),ot.prototype=new Q,at.prototype=new ot,at.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(0===i.compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(1===i.compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new E},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new eo(this)};var eo=function(t){this.treeSet_=t,this.position_=0};eo.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new x;return this.treeSet_.array_[this.position_++]},eo.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},eo.prototype.remove=function(){throw new E},ut.sort=function(){var t,e,n,i,r=arguments[0];if(1===arguments.length)return i=function(t,e){return t.compareTo(e)},void r.sort(i);if(2===arguments.length)n=arguments[1],i=function(t,e){return n.compare(t,e)},r.sort(i);else{if(3===arguments.length){e=r.slice(arguments[1],arguments[2]),e.sort();var s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length));for(r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}if(4===arguments.length){for(e=r.slice(arguments[1],arguments[2]),n=arguments[3],i=function(t,e){return n.compare(t,e)},e.sort(i),s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length)),r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}}},ut.asList=function(t){for(var e=new I,n=0,i=t.length;i>n;n++)e.add(t[n]);return e},e(lt.prototype,{interfaces_:function(){return[]},getClass:function(){return lt}}),lt.toDimensionSymbol=function(t){switch(t){case lt.FALSE:return lt.SYM_FALSE;case lt.TRUE:return lt.SYM_TRUE;case lt.DONTCARE:return lt.SYM_DONTCARE;case lt.P:return lt.SYM_P;case lt.L:return lt.SYM_L;case lt.A:return lt.SYM_A}throw new i("Unknown dimension value: "+t)},lt.toDimensionValue=function(t){switch(O.toUpperCase(t)){case lt.SYM_FALSE:return lt.FALSE;case lt.SYM_TRUE:return lt.TRUE;case lt.SYM_DONTCARE:return lt.DONTCARE;case lt.SYM_P:return lt.P;case lt.SYM_L:return lt.L;case lt.SYM_A:return lt.A}throw new i("Unknown dimension symbol: "+t)},lt.P=0,lt.L=1,lt.A=2,lt.FALSE=-1,lt.TRUE=-2,lt.DONTCARE=-3,lt.SYM_FALSE="F",lt.SYM_TRUE="T",lt.SYM_DONTCARE="*",lt.SYM_P="0",lt.SYM_L="1",lt.SYM_A="2",e(ht.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return ht}}),e(ct.prototype,{filter:function(t,e){},isDone:function(){},isGeometryChanged:function(){},interfaces_:function(){return[]},getClass:function(){return ct}}),h(ft,B),e(ft.prototype,{computeEnvelopeInternal:function(){for(var t=new C,e=0;e<this.geometries.length;e++)t.expandToInclude(this.geometries[e].getEnvelopeInternal());return t},getGeometryN:function(t){return this.geometries[t]},getSortIndex:function(){return B.SORTINDEX_GEOMETRYCOLLECTION},getCoordinates:function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this.geometries.length;n++)for(var i=this.geometries[n].getCoordinates(),r=0;r<i.length;r++)e++,t[e]=i[r];return t},getArea:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getArea();return t},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.geometries.length!==n.geometries.length)return!1;for(var i=0;i<this.geometries.length;i++)if(!this.geometries[i].equalsExact(n.geometries[i],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<this.geometries.length;t++)this.geometries[t].normalize();ut.sort(this.geometries)},getCoordinate:function(){return this.isEmpty()?null:this.geometries[0].getCoordinate()},getBoundaryDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getBoundaryDimension());return t},getDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getDimension());return t},getLength:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getLength();return t},getNumPoints:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getNumPoints();return t},getNumGeometries:function(){return this.geometries.length},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createGeometryCollection(e)},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=new at(ut.asList(this.geometries)),n=new at(ut.asList(t.geometries));return this.compare(e,n)}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s=i,o=this.getNumGeometries(),a=s.getNumGeometries(),u=0;o>u&&a>u;){var l=this.getGeometryN(u),h=s.getGeometryN(u),c=l.compareToSameClass(h,r);if(0!==c)return c;u++}return o>u?1:a>u?-1:0}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.geometries.length;e++)this.geometries[e].apply(t);else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.geometries.length)return null;for(var e=0;e<this.geometries.length&&(this.geometries[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(i)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(r)}},getBoundary:function(){return this.checkNotGeometryCollection(this),f.shouldNeverReachHere(),null},clone:function(){var t=B.prototype.clone.call(this);t.geometries=new Array(this.geometries.length).fill(null);for(var e=0;e<this.geometries.length;e++)t.geometries[e]=this.geometries[e].clone();return t},getGeometryType:function(){return"GeometryCollection"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new ft(t,this.factory)},isEmpty:function(){for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isEmpty())return!1;return!0},interfaces_:function(){return[]},getClass:function(){return ft}}),ft.serialVersionUID=-0x4f07bcb1f857d800,h(gt,ft),e(gt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTILINESTRING},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){if(this.isEmpty())return!1;for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isClosed())return!1;return!0},getDimension:function(){return 1},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[t-1-n]=this.geometries[n].reverse();return this.getFactory().createMultiLineString(e)},getBoundary:function(){
return new dt(this).getBoundary()},getGeometryType:function(){return"MultiLineString"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new gt(t,this.factory)},interfaces_:function(){return[st]},getClass:function(){return gt}}),gt.serialVersionUID=0x7155d2ab4afa8000,e(dt.prototype,{boundaryMultiLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();var e=this.computeBoundaryCoordinates(t);return 1===e.length?this.geomFact.createPoint(e[0]):this.geomFact.createMultiPointFromCoords(e)},getBoundary:function(){return this.geom instanceof St?this.boundaryLineString(this.geom):this.geom instanceof gt?this.boundaryMultiLineString(this.geom):this.geom.getBoundary()},boundaryLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){var e=this.bnRule.isInBoundary(2);return e?t.getStartPoint():this.geomFact.createMultiPoint()}return this.geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])},getEmptyMultiPoint:function(){return this.geomFact.createMultiPoint()},computeBoundaryCoordinates:function(t){var e=new I;this.endpointMap=new rt;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);0!==i.getNumPoints()&&(this.addEndpoint(i.getCoordinateN(0)),this.addEndpoint(i.getCoordinateN(i.getNumPoints()-1)))}for(var r=this.endpointMap.entrySet().iterator();r.hasNext();){var s=r.next(),o=s.getValue(),a=o.count;this.bnRule.isInBoundary(a)&&e.add(s.getKey())}return H.toCoordinateArray(e)},addEndpoint:function(t){var e=this.endpointMap.get(t);null===e&&(e=new pt,this.endpointMap.put(t,e)),e.count++},interfaces_:function(){return[]},getClass:function(){return dt}}),dt.getBoundary=function(){if(1===arguments.length){var t=arguments[0],e=new dt(t);return e.getBoundary()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new dt(n,i);return e.getBoundary()}},e(pt.prototype,{interfaces_:function(){return[]},getClass:function(){return pt}}),e(Nt.prototype,{interfaces_:function(){return[]},getClass:function(){return Nt}}),Nt.chars=function(t,e){for(var n=new Array(e).fill(null),i=0;e>i;i++)n[i]=t;return new String(n)},Nt.getStackTrace=function(){if(1===arguments.length){var t=arguments[0],e=new xt,n=new vt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s="",o=new mt(Nt.getStackTrace(i)),a=new It(o),u=0;r>u;u++)try{s+=a.readLine()+Nt.NEWLINE}catch(l){if(!(l instanceof Et))throw l;f.shouldNeverReachHere()}finally{}return s}},Nt.split=function(t,e){for(var n=e.length,i=new I,r=""+t,s=r.indexOf(e);s>=0;){var o=r.substring(0,s);i.add(o),r=r.substring(s+n),s=r.indexOf(e)}r.length>0&&i.add(r);for(var a=new Array(i.size()).fill(null),u=0;u<a.length;u++)a[u]=i.get(u);return a},Nt.toString=function(){if(1===arguments.length){var t=arguments[0];return Nt.SIMPLE_ORDINATE_FORMAT.format(t)}},Nt.spaces=function(t){return Nt.chars(" ",t)},Nt.NEWLINE=A.getProperty("line.separator"),Nt.SIMPLE_ORDINATE_FORMAT=new yt("0.#"),e(Ct.prototype,{interfaces_:function(){return[]},getClass:function(){return Ct}}),Ct.copyCoord=function(t,e,n,i){for(var r=Math.min(t.getDimension(),n.getDimension()),s=0;r>s;s++)n.setOrdinate(i,s,t.getOrdinate(e,s))},Ct.isRing=function(t){var e=t.size();return 0===e?!0:3>=e?!1:t.getOrdinate(0,D.X)===t.getOrdinate(e-1,D.X)&&t.getOrdinate(0,D.Y)===t.getOrdinate(e-1,D.Y)},Ct.isEqual=function(t,e){var n=t.size(),i=e.size();if(n!==i)return!1;for(var s=Math.min(t.getDimension(),e.getDimension()),o=0;n>o;o++)for(var a=0;s>a;a++){var u=t.getOrdinate(o,a),l=e.getOrdinate(o,a);if(!(t.getOrdinate(o,a)===e.getOrdinate(o,a)||r.isNaN(u)&&r.isNaN(l)))return!1}return!0},Ct.extend=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();if(Ct.copy(e,0,i,0,r),r>0)for(var s=r;n>s;s++)Ct.copy(e,r-1,i,s,1);return i},Ct.reverse=function(t){for(var e=t.size()-1,n=Math.trunc(e/2),i=0;n>=i;i++)Ct.swap(t,i,e-i)},Ct.swap=function(t,e,n){if(e===n)return null;for(var i=0;i<t.getDimension();i++){var r=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,r)}},Ct.copy=function(t,e,n,i,r){for(var s=0;r>s;s++)Ct.copyCoord(t,e+s,n,i+s)},Ct.toString=function(){if(1===arguments.length){var t=arguments[0],e=t.size();if(0===e)return"()";var n=t.getDimension(),i=new P;i.append("(");for(var r=0;e>r;r++){r>0&&i.append(" ");for(var s=0;n>s;s++)s>0&&i.append(","),i.append(Nt.toString(t.getOrdinate(r,s)))}return i.append(")"),i.toString()}},Ct.ensureValidRing=function(t,e){var n=e.size();if(0===n)return e;if(3>=n)return Ct.createClosedRing(t,e,4);var i=e.getOrdinate(0,D.X)===e.getOrdinate(n-1,D.X)&&e.getOrdinate(0,D.Y)===e.getOrdinate(n-1,D.Y);return i?e:Ct.createClosedRing(t,e,n+1)},Ct.createClosedRing=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();Ct.copy(e,0,i,0,r);for(var s=r;n>s;s++)Ct.copy(e,0,i,s,1);return i},h(St,B),e(St.prototype,{computeEnvelopeInternal:function(){return this.isEmpty()?new C:this.points.expandEnvelope(new C)},isRing:function(){return this.isClosed()&&this.isSimple()},getSortIndex:function(){return B.SORTINDEX_LINESTRING},getCoordinates:function(){return this.points.toCoordinateArray()},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.points.size()!==n.points.size())return!1;for(var i=0;i<this.points.size();i++)if(!this.equal(this.points.getCoordinate(i),n.points.getCoordinate(i),e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<Math.trunc(this.points.size()/2);t++){var e=this.points.size()-1-t;if(!this.points.getCoordinate(t).equals(this.points.getCoordinate(e)))return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e))>0&&Ct.reverse(this.points),null}},getCoordinate:function(){return this.isEmpty()?null:this.points.getCoordinate(0)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){return this.isEmpty()?!1:this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},getEndPoint:function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},getDimension:function(){return 1},getLength:function(){return he.computeLength(this.points)},getNumPoints:function(){return this.points.size()},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLineString(t);return e},compareToSameClass:function(){if(1===arguments.length){for(var t=arguments[0],e=t,n=0,i=0;n<this.points.size()&&i<e.points.size();){var r=this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));if(0!==r)return r;n++,i++}return n<this.points.size()?1:i<e.points.size()?-1:0}if(2===arguments.length){var s=arguments[0],o=arguments[1],e=s;return o.compare(this.points,e.points)}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.points.size();e++)t.filter(this.points.getCoordinate(e));else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.points.size())return null;for(var e=0;e<this.points.size()&&(n.filter(this.points,e),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this)}},getBoundary:function(){return new dt(this).getBoundary()},isEquivalentClass:function(t){return t instanceof St},clone:function(){var t=B.prototype.clone.call(this);return t.points=this.points.clone(),t},getCoordinateN:function(t){return this.points.getCoordinate(t)},getGeometryType:function(){return"LineString"},copy:function(){return new St(this.points.copy(),this.factory)},getCoordinateSequence:function(){return this.points},isEmpty:function(){return 0===this.points.size()},init:function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new i("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this.points=t},isCoordinate:function(t){for(var e=0;e<this.points.size();e++)if(this.points.getCoordinate(e).equals(t))return!0;return!1},getStartPoint:function(){return this.isEmpty()?null:this.getPointN(0)},getPointN:function(t){return this.getFactory().createPoint(this.points.getCoordinate(t))},interfaces_:function(){return[st]},getClass:function(){return St}}),St.serialVersionUID=0x2b2b51ba435c8e00,e(wt.prototype,{interfaces_:function(){return[]},getClass:function(){return wt}}),h(Lt,B),e(Lt.prototype,{computeEnvelopeInternal:function(){if(this.isEmpty())return new C;var t=new C;return t.expandToInclude(this.coordinates.getX(0),this.coordinates.getY(0)),t},getSortIndex:function(){return B.SORTINDEX_POINT},getCoordinates:function(){return this.isEmpty()?[]:[this.getCoordinate()]},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?this.isEmpty()&&t.isEmpty()?!0:this.isEmpty()!==t.isEmpty()?!1:this.equal(t.getCoordinate(),this.getCoordinate(),e):!1}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){},getCoordinate:function(){return 0!==this.coordinates.size()?this.coordinates.getCoordinate(0):null},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getNumPoints:function(){return this.isEmpty()?0:1},reverse:function(){return this.copy()},getX:function(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getCoordinate().compareTo(e.getCoordinate())}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return i.compare(this.coordinates,e.coordinates)}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(R(arguments[0],ct)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this.coordinates,0),e.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var n=arguments[0];n.filter(this)}else if(R(arguments[0],q)){var i=arguments[0];i.filter(this)}},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},clone:function(){var t=B.prototype.clone.call(this);return t.coordinates=this.coordinates.clone(),t},getGeometryType:function(){return"Point"},copy:function(){return new Lt(this.coordinates.copy(),this.factory)},getCoordinateSequence:function(){return this.coordinates},getY:function(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y},isEmpty:function(){return 0===this.coordinates.size()},init:function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),f.isTrue(t.size()<=1),this.coordinates=t},isSimple:function(){return!0},interfaces_:function(){return[wt]},getClass:function(){return Lt}}),Lt.serialVersionUID=0x44077bad161cbc00,e(Rt.prototype,{interfaces_:function(){return[]},getClass:function(){return Rt}}),h(Tt,B),e(Tt.prototype,{computeEnvelopeInternal:function(){return this.shell.getEnvelopeInternal()},getSortIndex:function(){return B.SORTINDEX_POLYGON},getCoordinates:function(){if(this.isEmpty())return[];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this.shell.getCoordinates(),i=0;i<n.length;i++)e++,t[e]=n[i];for(var r=0;r<this.holes.length;r++)for(var s=this.holes[r].getCoordinates(),o=0;o<s.length;o++)e++,t[e]=s[o];return t},getArea:function(){var t=0;t+=Math.abs(he.signedArea(this.shell.getCoordinateSequence()));for(var e=0;e<this.holes.length;e++)t-=Math.abs(he.signedArea(this.holes[e].getCoordinateSequence()));return t},isRectangle:function(){if(0!==this.getNumInteriorRing())return!1;if(null===this.shell)return!1;if(5!==this.shell.getNumPoints())return!1;for(var t=this.shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;5>n;n++){var i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;var r=t.getY(n);if(r!==e.getMinY()&&r!==e.getMaxY())return!1}for(var s=t.getX(0),o=t.getY(0),n=1;4>=n;n++){var i=t.getX(n),r=t.getY(n),a=i!==s,u=r!==o;if(a===u)return!1;s=i,o=r}return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t,i=this.shell,r=n.shell;if(!i.equalsExact(r,e))return!1;if(this.holes.length!==n.holes.length)return!1;for(var s=0;s<this.holes.length;s++)if(!this.holes[s].equalsExact(n.holes[s],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){if(0===arguments.length){this.normalize(this.shell,!0);for(var t=0;t<this.holes.length;t++)this.normalize(this.holes[t],!1);ut.sort(this.holes)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var i=new Array(e.getCoordinates().length-1).fill(null);A.arraycopy(e.getCoordinates(),0,i,0,i.length);var r=H.minCoordinate(e.getCoordinates());H.scroll(i,r),A.arraycopy(i,0,e.getCoordinates(),0,i.length),e.getCoordinates()[i.length]=i[0],he.isCCW(e.getCoordinates())===n&&H.reverse(e.getCoordinates())}},getCoordinate:function(){return this.shell.getCoordinate()},getNumInteriorRing:function(){return this.holes.length},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},getLength:function(){var t=0;t+=this.shell.getLength();for(var e=0;e<this.holes.length;e++)t+=this.holes[e].getLength();return t},getNumPoints:function(){for(var t=this.shell.getNumPoints(),e=0;e<this.holes.length;e++)t+=this.holes[e].getNumPoints();return t},reverse:function(){var t=this.copy();t.shell=this.shell.copy().reverse(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].copy().reverse();return t},convexHull:function(){return this.getExteriorRing().convexHull()},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=this.shell,n=t.shell;return e.compareToSameClass(n)}if(2===arguments.length){var i=arguments[0],r=arguments[1],s=i,e=this.shell,n=s.shell,o=e.compareToSameClass(n,r);if(0!==o)return o;for(var a=this.getNumInteriorRing(),u=s.getNumInteriorRing(),l=0;a>l&&u>l;){var h=this.getInteriorRingN(l),c=s.getInteriorRingN(l),f=h.compareToSameClass(c,r);if(0!==f)return f;l++}return a>l?1:u>l?-1:0}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];this.shell.apply(t);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(t)}else if(R(arguments[0],ct)){var n=arguments[0];if(this.shell.apply(n),!n.isDone())for(var e=0;e<this.holes.length&&(this.holes[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this),this.shell.apply(r);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(r)}},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this.holes.length+1).fill(null);t[0]=this.shell;for(var e=0;e<this.holes.length;e++)t[e+1]=this.holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)},clone:function(){var t=B.prototype.clone.call(this);t.shell=this.shell.clone(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].clone();return t},getGeometryType:function(){return"Polygon"},copy:function(){for(var t=this.shell.copy(),e=new Array(this.holes.length).fill(null),n=0;n<e.length;n++)e[n]=this.holes[n].copy();return new Tt(t,e,this.factory)},getExteriorRing:function(){return this.shell},isEmpty:function(){return this.shell.isEmpty()},getInteriorRingN:function(t){return this.holes[t]},interfaces_:function(){return[Rt]},getClass:function(){return Tt}}),Tt.serialVersionUID=-0x307ffefd8dc97200,h(Pt,ft),e(Pt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOINT},isValid:function(){return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.geometries[t].getCoordinate()}return ft.prototype.getCoordinate.apply(this,arguments)},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},getGeometryType:function(){return"MultiPoint"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Pt(t,this.factory)},interfaces_:function(){return[wt]},getClass:function(){return Pt}}),Pt.serialVersionUID=-0x6fb1ed4162e0fc00,h(bt,St),e(bt.prototype,{getSortIndex:function(){return B.SORTINDEX_LINEARRING},getBoundaryDimension:function(){return lt.FALSE},isClosed:function(){return this.isEmpty()?!0:St.prototype.isClosed.call(this)},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLinearRing(t);return e},validateConstruction:function(){if(!this.isEmpty()&&!St.prototype.isClosed.call(this))throw new i("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<bt.MINIMUM_VALID_SIZE)throw new i("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},getGeometryType:function(){return"LinearRing"},copy:function(){return new bt(this.points.copy(),this.factory)},interfaces_:function(){return[]},getClass:function(){return bt}}),bt.MINIMUM_VALID_SIZE=4,bt.serialVersionUID=-0x3b229e262367a600,h(Ot,ft),e(Ot.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOLYGON},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createMultiPolygon(e)},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new I,e=0;e<this.geometries.length;e++)for(var n=this.geometries[e],i=n.getBoundary(),r=0;r<i.getNumGeometries();r++)t.add(i.getGeometryN(r));var s=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s))},getGeometryType:function(){return"MultiPolygon"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Ot(t,this.factory)},interfaces_:function(){return[Rt]},getClass:function(){return Ot}}),Ot.serialVersionUID=-0x7a5aa1369171980,e(_t.prototype,{setCopyUserData:function(t){this.isUserDataCopied=t},edit:function(t,e){if(null===t)return null;var n=this.editInternal(t,e);return this.isUserDataCopied&&n.setUserData(t.getUserData()),n},editInternal:function(t,e){return null===this.factory&&(this.factory=t.getFactory()),t instanceof ft?this.editGeometryCollection(t,e):t instanceof Tt?this.editPolygon(t,e):t instanceof Lt?e.edit(t,this.factory):t instanceof St?e.edit(t,this.factory):(f.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)},editGeometryCollection:function(t,e){for(var n=e.edit(t,this.factory),i=new I,r=0;r<n.getNumGeometries();r++){var s=this.edit(n.getGeometryN(r),e);null===s||s.isEmpty()||i.add(s)}return n.getClass()===Pt?this.factory.createMultiPoint(i.toArray([])):n.getClass()===gt?this.factory.createMultiLineString(i.toArray([])):n.getClass()===Ot?this.factory.createMultiPolygon(i.toArray([])):this.factory.createGeometryCollection(i.toArray([]))},editPolygon:function(t,e){var n=e.edit(t,this.factory);if(null===n&&(n=this.factory.createPolygon(null)),n.isEmpty())return n;var i=this.edit(n.getExteriorRing(),e);if(null===i||i.isEmpty())return this.factory.createPolygon();for(var r=new I,s=0;s<n.getNumInteriorRing();s++){var o=this.edit(n.getInteriorRingN(s),e);null===o||o.isEmpty()||r.add(o)}return this.factory.createPolygon(i,r.toArray([]))},interfaces_:function(){return[]},getClass:function(){return _t}}),_t.GeometryEditorOperation=Mt,e(Dt.prototype,{edit:function(t,e){return t},interfaces_:function(){return[Mt]},getClass:function(){return Dt}}),e(At.prototype,{edit:function(t,e){if(t instanceof bt)return e.createLinearRing(this.editCoordinates(t.getCoordinates(),t));if(t instanceof St)return e.createLineString(this.editCoordinates(t.getCoordinates(),t));if(t instanceof Lt){var n=this.editCoordinates(t.getCoordinates(),t);return n.length>0?e.createPoint(n[0]):e.createPoint()}return t},interfaces_:function(){return[Mt]},getClass:function(){return At}}),e(Ft.prototype,{edit:function(t,e){return t instanceof bt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof St?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Lt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t},interfaces_:function(){return[Mt]},getClass:function(){return Ft}}),_t.NoOpGeometryOperation=Dt,_t.CoordinateOperation=At,_t.CoordinateSequenceOperation=Ft,e(Gt.prototype,{setOrdinate:function(t,e,n){switch(e){case D.X:this.coordinates[t].x=n;break;case D.Y:this.coordinates[t].y=n;break;case D.Z:this.coordinates[t].z=n;break;default:throw new i("invalid ordinateIndex")}},size:function(){return this.coordinates.length},getOrdinate:function(t,e){switch(e){case D.X:return this.coordinates[t].x;case D.Y:return this.coordinates[t].y;case D.Z:return this.coordinates[t].z}return r.NaN},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.coordinates[t]}if(2===arguments.length){var e=arguments[0],n=arguments[1];n.x=this.coordinates[e].x,n.y=this.coordinates[e].y,n.z=this.coordinates[e].z}},getCoordinateCopy:function(t){return new g(this.coordinates[t])},getDimension:function(){return this.dimension},getX:function(t){return this.coordinates[t].x},clone:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].clone();return new Gt(t,this.dimension)},expandEnvelope:function(t){for(var e=0;e<this.coordinates.length;e++)t.expandToInclude(this.coordinates[e]);return t},copy:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].copy();return new Gt(t,this.dimension)},toString:function(){if(this.coordinates.length>0){var t=new P(17*this.coordinates.length);t.append("("),t.append(this.coordinates[0]);for(var e=1;e<this.coordinates.length;e++)t.append(", "),t.append(this.coordinates[e]);return t.append(")"),t.toString()}return"()"},getY:function(t){return this.coordinates[t].y},toCoordinateArray:function(){return this.coordinates},interfaces_:function(){return[D,u]},getClass:function(){return Gt}}),Gt.serialVersionUID=-0xcb44a778db18e00,e(qt.prototype,{readResolve:function(){return qt.instance()},create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Gt(t)}if(R(arguments[0],D)){var e=arguments[0];return new Gt(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return i>3&&(i=3),2>i?new Gt(n):new Gt(n,i)}},interfaces_:function(){return[G,u]},getClass:function(){return qt}}),qt.instance=function(){return qt.instanceObject},qt.serialVersionUID=-0x38e49fa6cf6f2e00,qt.instanceObject=new qt;var no,io=Object.defineProperty,ro=zt({"delete":kt,has:Xt,get:Yt,set:Ht,keys:jt,values:Kt,entries:Zt,forEach:$t,clear:Wt}),so="undefined"!=typeof Map&&Map.prototype.values?Map:ro;te.prototype=new K,te.prototype.get=function(t){return this.map_.get(t)||null},te.prototype.put=function(t,e){return this.map_.set(t,e),e},te.prototype.values=function(){for(var t=new I,e=this.map_.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t},te.prototype.entrySet=function(){var t=new J;return this.map_.entries().forEach(function(e){return t.add(e)}),t},te.prototype.size=function(){return this.map_.size()},e(ee.prototype,{equals:function(t){if(!(t instanceof ee))return!1;var e=t;return this.modelType===e.modelType&&this.scale===e.scale},compareTo:function(t){var e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return new b(n).compareTo(new b(i))},getScale:function(){return this.scale},isFloating:function(){return this.modelType===ee.FLOATING||this.modelType===ee.FLOATING_SINGLE},getType:function(){return this.modelType},toString:function(){var t="UNKNOWN";return this.modelType===ee.FLOATING?t="Floating":this.modelType===ee.FLOATING_SINGLE?t="Floating-Single":this.modelType===ee.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t},makePrecise:function(){if("number"==typeof arguments[0]){var t=arguments[0];if(r.isNaN(t))return t;if(this.modelType===ee.FLOATING_SINGLE){var e=t;return e}return this.modelType===ee.FIXED?Math.round(t*this.scale)/this.scale:t}if(arguments[0]instanceof g){var n=arguments[0];if(this.modelType===ee.FLOATING)return null;n.x=this.makePrecise(n.x),n.y=this.makePrecise(n.y)}},getMaximumSignificantDigits:function(){var t=16;return this.modelType===ee.FLOATING?t=16:this.modelType===ee.FLOATING_SINGLE?t=6:this.modelType===ee.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t},setScale:function(t){this.scale=Math.abs(t)},interfaces_:function(){return[u,s]},getClass:function(){return ee}}),ee.mostPrecise=function(t,e){return t.compareTo(e)>=0?t:e},e(ne.prototype,{readResolve:function(){return ne.nameToTypeMap.get(this.name)},toString:function(){return this.name},interfaces_:function(){return[u]},getClass:function(){return ne}}),ne.serialVersionUID=-552860263173159e4,ne.nameToTypeMap=new te,ee.Type=ne,ee.serialVersionUID=0x6bee6404e9a25c00,ee.FIXED=new ne("FIXED"),ee.FLOATING=new ne("FLOATING"),ee.FLOATING_SINGLE=new ne("FLOATING SINGLE"),ee.maximumPreciseValue=9007199254740992,e(ie.prototype,{toGeometry:function(t){return t.isNull()?this.createPoint(null):t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)},createLineString:function(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new St(e,this)}}},createMultiLineString:function(){if(0===arguments.length)return new gt(null,this);if(1===arguments.length){var t=arguments[0];return new gt(t,this)}},buildGeometry:function(t){for(var e=null,n=!1,i=!1,r=t.iterator();r.hasNext();){var s=r.next(),o=s.getClass();null===e&&(e=o),o!==e&&(n=!0),s.isGeometryCollectionOrDerived()&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(ie.toGeometryArray(t));var a=t.iterator().next(),u=t.size()>1;if(u){if(a instanceof Tt)return this.createMultiPolygon(ie.toPolygonArray(t));if(a instanceof St)return this.createMultiLineString(ie.toLineStringArray(t));if(a instanceof Lt)return this.createMultiPoint(ie.toPointArray(t));f.shouldNeverReachHere("Unhandled class: "+a.getClass().getName())}return a},createMultiPointFromCoords:function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)},createPoint:function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(R(arguments[0],D)){var e=arguments[0];return new Lt(e,this)}}},getCoordinateSequenceFactory:function(){return this.coordinateSequenceFactory},createPolygon:function(){if(0===arguments.length)return new Tt(null,null,this);if(1===arguments.length){if(R(arguments[0],D)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof bt){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];return new Tt(i,r,this)}},getSRID:function(){return this.SRID},createGeometryCollection:function(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){var t=arguments[0];return new ft(t,this)}},createGeometry:function(t){var e=new _t(this);return e.edit(t,{edit:function(){if(2===arguments.length){var t=arguments[0];arguments[1];return this.coordinateSequenceFactory.create(t)}}})},getPrecisionModel:function(){return this.precisionModel},createLinearRing:function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new bt(e,this)}}},createMultiPolygon:function(){if(0===arguments.length)return new Ot(null,this);if(1===arguments.length){var t=arguments[0];return new Ot(t,this)}},createMultiPoint:function(){if(0===arguments.length)return new Pt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Pt(t,this)}if(arguments[0]instanceof Array){var e=arguments[0];return this.createMultiPoint(null!==e?this.getCoordinateSequenceFactory().create(e):null)}if(R(arguments[0],D)){var n=arguments[0];if(null===n)return this.createMultiPoint(new Array(0).fill(null));for(var i=new Array(n.size()).fill(null),r=0;r<n.size();r++){var s=this.getCoordinateSequenceFactory().create(1,n.getDimension());Ct.copy(n,r,s,0,1),i[r]=this.createPoint(s)}return this.createMultiPoint(i)}}},interfaces_:function(){return[u]},getClass:function(){return ie}}),ie.toMultiPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toGeometryArray=function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.getDefaultCoordinateSequenceFactory=function(){return qt.instance()},ie.toMultiLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toMultiPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLinearRingArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},ie.serialVersionUID=-0x5ea75f2051eeb400;var oo={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};e(re.prototype,{read:function(t){var e,n,i;t=t.replace(/[\n\r]/g," ");var r=oo.typeStr.exec(t);if(-1!==t.search("EMPTY")&&(r=oo.emptyTypeStr.exec(t),r[2]=void 0),r&&(n=r[1].toLowerCase(),i=r[2],uo[n]&&(e=uo[n].apply(this,[i]))),void 0===e)throw new Error("Could not parse WKT "+t);return e},write:function(t){return this.extractGeometry(t);
},extractGeometry:function(t){var e=t.getGeometryType().toLowerCase();if(!ao[e])return null;var n,i=e.toUpperCase();return n=t.isEmpty()?i+" EMPTY":i+"("+ao[e].apply(this,[t])+")"}});var ao={coordinate:function(t){return t.x+" "+t.y},point:function(t){return ao.coordinate.call(this,t.coordinates.coordinates[0])},multipoint:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.point.apply(this,[t.geometries[n]])+")");return e.join(",")},linestring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},linearring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},multilinestring:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.geometries[n]])+")");return e.join(",")},polygon:function(t){var e=[];e.push("("+ao.linestring.apply(this,[t.shell])+")");for(var n=0,i=t.holes.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.holes[n]])+")");return e.join(",")},multipolygon:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.polygon.apply(this,[t.geometries[n]])+")");return e.join(",")},geometrycollection:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push(this.extractGeometry(t.geometries[n]));return e.join(",")}},uo={point:function(t){if(void 0===t)return this.geometryFactory.createPoint();var e=t.trim().split(oo.spaces);return this.geometryFactory.createPoint(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])))},multipoint:function(t){if(void 0===t)return this.geometryFactory.createMultiPoint();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.point.apply(this,[e]));return this.geometryFactory.createMultiPoint(i)},linestring:function(t){if(void 0===t)return this.geometryFactory.createLineString();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i)},linearring:function(t){if(void 0===t)return this.geometryFactory.createLinearRing();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i)},multilinestring:function(t){if(void 0===t)return this.geometryFactory.createMultiLineString();for(var e,n=t.trim().split(oo.parenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.linestring.apply(this,[e]));return this.geometryFactory.createMultiLineString(i)},polygon:function(t){if(void 0===t)return this.geometryFactory.createPolygon();for(var e,n,i,r,s=t.trim().split(oo.parenComma),o=[],a=0,u=s.length;u>a;++a)e=s[a].replace(oo.trimParens,"$1"),n=uo.linestring.apply(this,[e]),i=this.geometryFactory.createLinearRing(n.points),0===a?r=i:o.push(i);return this.geometryFactory.createPolygon(r,o)},multipolygon:function(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();for(var e,n=t.trim().split(oo.doubleParenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.polygon.apply(this,[e]));return this.geometryFactory.createMultiPolygon(i)},geometrycollection:function(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();t=t.replace(/,\s*([A-Za-z])/g,"|$1");for(var e=t.trim().split("|"),n=[],i=0,r=e.length;r>i;++i)n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n)}};e(se.prototype,{write:function(t){return this.parser.write(t)}}),e(se,{toLineString:function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}),e(oe.prototype,{getIndexAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intLineIndex[t][e]},getTopologySummary:function(){var t=new P;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()},computeIntersection:function(t,e,n,i){this.inputLines[0][0]=t,this.inputLines[0][1]=e,this.inputLines[1][0]=n,this.inputLines[1][1]=i,this.result=this.computeIntersect(t,e,n,i)},getIntersectionNum:function(){return this.result},computeIntLineIndex:function(){if(0===arguments.length)null===this.intLineIndex&&(this.intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0],e=this.getEdgeDistance(t,0),n=this.getEdgeDistance(t,1);e>n?(this.intLineIndex[t][0]=0,this.intLineIndex[t][1]=1):(this.intLineIndex[t][0]=1,this.intLineIndex[t][1]=0)}},isProper:function(){return this.hasIntersection()&&this._isProper},setPrecisionModel:function(t){this.precisionModel=t},isInteriorIntersection:function(){if(0===arguments.length)return this.isInteriorIntersection(0)?!0:!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this.result;e++)if(!this.intPt[e].equals2D(this.inputLines[t][0])&&!this.intPt[e].equals2D(this.inputLines[t][1]))return!0;return!1}},getIntersection:function(t){return this.intPt[t]},isEndPoint:function(){return this.hasIntersection()&&!this._isProper},hasIntersection:function(){return this.result!==oe.NO_INTERSECTION},getEdgeDistance:function(t,e){var n=oe.computeEdgeDistance(this.intPt[e],this.inputLines[t][0],this.inputLines[t][1]);return n},isCollinear:function(){return this.result===oe.COLLINEAR_INTERSECTION},toString:function(){return se.toLineString(this.inputLines[0][0],this.inputLines[0][1])+" - "+se.toLineString(this.inputLines[1][0],this.inputLines[1][1])+this.getTopologySummary()},getEndpoint:function(t,e){return this.inputLines[t][e]},isIntersection:function(t){for(var e=0;e<this.result;e++)if(this.intPt[e].equals2D(t))return!0;return!1},getIntersectionAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intPt[this.intLineIndex[t][e]]},interfaces_:function(){return[]},getClass:function(){return oe}}),oe.computeEdgeDistance=function(t,e,n){var i=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),s=-1;if(t.equals(e))s=0;else if(t.equals(n))s=i>r?i:r;else{var o=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);s=i>r?o:a,0!==s||t.equals(e)||(s=Math.max(o,a))}return f.isTrue(!(0===s&&!t.equals(e)),"Bad distance calculation"),s},oe.nonRobustComputeEdgeDistance=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=Math.sqrt(i*i+r*r);return f.isTrue(!(0===s&&!t.equals(e)),"Invalid distance calculation"),s},oe.DONT_INTERSECT=0,oe.DO_INTERSECT=1,oe.COLLINEAR=2,oe.NO_INTERSECTION=0,oe.POINT_INTERSECTION=1,oe.COLLINEAR_INTERSECTION=2,h(ae,oe),e(ae.prototype,{isInSegmentEnvelopes:function(t){var e=new C(this.inputLines[0][0],this.inputLines[0][1]),n=new C(this.inputLines[1][0],this.inputLines[1][1]);return e.contains(t)&&n.contains(t)},computeIntersection:function(){if(3!==arguments.length)return oe.prototype.computeIntersection.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2];return this._isProper=!1,C.intersects(e,n,t)&&0===he.orientationIndex(e,n,t)&&0===he.orientationIndex(n,e,t)?(this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this.result=oe.POINT_INTERSECTION,null):void(this.result=oe.NO_INTERSECTION)},normalizeToMinimum:function(t,e,n,i,r){r.x=this.smallestInAbsValue(t.x,e.x,n.x,i.x),r.y=this.smallestInAbsValue(t.y,e.y,n.y,i.y),t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},safeHCoordinateIntersection:function(t,e,n,i){var r=null;try{r=F.intersection(t,e,n,i)}catch(s){if(!(s instanceof w))throw s;r=ae.nearestEndpoint(t,e,n,i)}finally{}return r},intersection:function(t,e,n,i){var r=this.intersectionWithNormalization(t,e,n,i);return this.isInSegmentEnvelopes(r)||(r=new g(ae.nearestEndpoint(t,e,n,i))),null!==this.precisionModel&&this.precisionModel.makePrecise(r),r},smallestInAbsValue:function(t,e,n,i){var r=t,s=Math.abs(r);return Math.abs(e)<s&&(r=e,s=Math.abs(e)),Math.abs(n)<s&&(r=n,s=Math.abs(n)),Math.abs(i)<s&&(r=i),r},checkDD:function(t,e,n,i,r){var s=M.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(s);A.out.println("DD in env = "+o+"  --------------------- "+s),r.distance(s)>1e-4&&A.out.println("Distance = "+r.distance(s))},intersectionWithNormalization:function(t,e,n,i){var r=new g(t),s=new g(e),o=new g(n),a=new g(i),u=new g;this.normalizeToEnvCentre(r,s,o,a,u);var l=this.safeHCoordinateIntersection(r,s,o,a);return l.x+=u.x,l.y+=u.y,l},computeCollinearIntersection:function(t,e,n,i){var r=C.intersects(t,e,n),s=C.intersects(t,e,i),o=C.intersects(n,i,t),a=C.intersects(n,i,e);return r&&s?(this.intPt[0]=n,this.intPt[1]=i,oe.COLLINEAR_INTERSECTION):o&&a?(this.intPt[0]=t,this.intPt[1]=e,oe.COLLINEAR_INTERSECTION):r&&o?(this.intPt[0]=n,this.intPt[1]=t,!n.equals(t)||s||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):r&&a?(this.intPt[0]=n,this.intPt[1]=e,!n.equals(e)||s||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&o?(this.intPt[0]=i,this.intPt[1]=t,!i.equals(t)||r||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&a?(this.intPt[0]=i,this.intPt[1]=e,!i.equals(e)||r||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):oe.NO_INTERSECTION},normalizeToEnvCentre:function(t,e,n,i,r){var s=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,a=t.x>e.x?t.x:e.x,u=t.y>e.y?t.y:e.y,l=n.x<i.x?n.x:i.x,h=n.y<i.y?n.y:i.y,c=n.x>i.x?n.x:i.x,f=n.y>i.y?n.y:i.y,g=s>l?s:l,d=c>a?a:c,p=o>h?o:h,v=f>u?u:f,m=(g+d)/2,y=(p+v)/2;r.x=m,r.y=y,t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},computeIntersect:function(t,e,n,i){if(this._isProper=!1,!C.intersects(t,e,n,i))return oe.NO_INTERSECTION;var r=he.orientationIndex(t,e,n),s=he.orientationIndex(t,e,i);if(r>0&&s>0||0>r&&0>s)return oe.NO_INTERSECTION;var o=he.orientationIndex(n,i,t),a=he.orientationIndex(n,i,e);if(o>0&&a>0||0>o&&0>a)return oe.NO_INTERSECTION;var u=0===r&&0===s&&0===o&&0===a;return u?this.computeCollinearIntersection(t,e,n,i):(0===r||0===s||0===o||0===a?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this.intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this.intPt[0]=e:0===r?this.intPt[0]=new g(n):0===s?this.intPt[0]=new g(i):0===o?this.intPt[0]=new g(t):0===a&&(this.intPt[0]=new g(e))):(this._isProper=!0,this.intPt[0]=this.intersection(t,e,n,i)),oe.POINT_INTERSECTION)},interfaces_:function(){return[]},getClass:function(){return ae}}),ae.nearestEndpoint=function(t,e,n,i){var r=t,s=he.distancePointLine(t,n,i),o=he.distancePointLine(e,n,i);return s>o&&(s=o,r=e),o=he.distancePointLine(n,t,e),s>o&&(s=o,r=n),o=he.distancePointLine(i,t,e),s>o&&(s=o,r=i),r},e(ue.prototype,{interfaces_:function(){return[]},getClass:function(){return ue}}),ue.orientationIndex=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-e.x,o=n.y-e.y;return ue.signOfDet2x2(i,r,s,o)},ue.signOfDet2x2=function(t,e,n,i){var r=null,s=null,o=null,a=0;if(r=1,0===t||0===i)return 0===e||0===n?0:e>0?n>0?-r:r:n>0?r:-r;if(0===e||0===n)return i>0?t>0?r:-r:t>0?-r:r;if(e>0?i>0?i>=e||(r=-r,s=t,t=n,n=s,s=e,e=i,i=s):-i>=e?(r=-r,n=-n,i=-i):(s=t,t=-n,n=s,s=e,e=-i,i=s):i>0?i>=-e?(r=-r,t=-t,e=-e):(s=-t,t=n,n=s,s=-e,e=i,i=s):e>=i?(t=-t,e=-e,n=-n,i=-i):(r=-r,s=-t,t=-n,n=s,s=-e,e=-i,i=s),t>0){if(!(n>0))return r;if(!(n>=t))return r}else{if(n>0)return-r;if(!(t>=n))return-r;r=-r,t=-t,n=-n}for(;;){if(a+=1,o=Math.floor(n/t),n-=o*t,i-=o*e,0>i)return-r;if(i>e)return r;if(t>n+n){if(i+i>e)return r}else{if(e>i+i)return-r;n=t-n,i=e-i,r=-r}if(0===i)return 0===n?0:-r;if(0===n)return r;if(o=Math.floor(t/n),t-=o*n,e-=o*i,0>e)return r;if(e>i)return-r;if(n>t+t){if(e+e>i)return-r}else{if(i>e+e)return r;t=n-t,e=i-e,r=-r}if(0===e)return 0===t?0:r;if(0===t)return-r}},e(le.prototype,{countSegment:function(t,e){if(t.x<this.p.x&&e.x<this.p.x)return null;if(this.p.x===e.x&&this.p.y===e.y)return this.isPointOnSegment=!0,null;if(t.y===this.p.y&&e.y===this.p.y){var n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this.p.x>=n&&this.p.x<=i&&(this.isPointOnSegment=!0),null}if(t.y>this.p.y&&e.y<=this.p.y||e.y>this.p.y&&t.y<=this.p.y){var r=t.x-this.p.x,s=t.y-this.p.y,o=e.x-this.p.x,a=e.y-this.p.y,u=ue.signOfDet2x2(r,s,o,a);if(0===u)return this.isPointOnSegment=!0,null;s>a&&(u=-u),u>0&&this.crossingCount++}},isPointInPolygon:function(){return this.getLocation()!==L.EXTERIOR},getLocation:function(){return this.isPointOnSegment?L.BOUNDARY:this.crossingCount%2===1?L.INTERIOR:L.EXTERIOR},isOnSegment:function(){return this.isPointOnSegment},interfaces_:function(){return[]},getClass:function(){return le}}),le.locatePointInRing=function(){if(arguments[0]instanceof g&&R(arguments[1],D)){for(var t=arguments[0],e=arguments[1],n=new le(t),i=new g,r=new g,s=1;s<e.size();s++)if(e.getCoordinate(s,i),e.getCoordinate(s-1,r),n.countSegment(i,r),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){for(var o=arguments[0],a=arguments[1],n=new le(o),s=1;s<a.length;s++){var i=a[s],r=a[s-1];if(n.countSegment(i,r),n.isOnSegment())return n.getLocation()}return n.getLocation()}},e(he.prototype,{interfaces_:function(){return[]},getClass:function(){return he}}),he.orientationIndex=function(t,e,n){return M.orientationIndex(t,e,n)},he.signedArea=function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,i=1;i<t.length-1;i++){var r=t[i].x-n,s=t[i+1].y,o=t[i-1].y;e+=r*(o-s)}return e/2}if(R(arguments[0],D)){var a=arguments[0],u=a.size();if(3>u)return 0;var l=new g,h=new g,c=new g;a.getCoordinate(0,h),a.getCoordinate(1,c);var n=h.x;c.x-=n;for(var e=0,i=1;u-1>i;i++)l.y=h.y,h.x=c.x,h.y=c.y,a.getCoordinate(i+1,c),c.x-=n,e+=h.x*(l.y-c.y);return e/2}},he.distanceLineLine=function(t,e,n,i){if(t.equals(e))return he.distancePointLine(t,n,i);if(n.equals(i))return he.distancePointLine(i,t,e);var r=!1;if(C.intersects(t,e,n,i)){var s=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===s)r=!0;else{var o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),a=(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y),u=a/s,l=o/s;(0>l||l>1||0>u||u>1)&&(r=!0)}}else r=!0;return r?T.min(he.distancePointLine(t,n,i),he.distancePointLine(e,n,i),he.distancePointLine(n,t,e),he.distancePointLine(i,t,e)):0},he.isPointInRing=function(t,e){return he.locatePointInRing(t,e)!==L.EXTERIOR},he.computeLength=function(t){var e=t.size();if(1>=e)return 0;var n=0,i=new g;t.getCoordinate(0,i);for(var r=i.x,s=i.y,o=1;e>o;o++){t.getCoordinate(o,i);var a=i.x,u=i.y,l=a-r,h=u-s;n+=Math.sqrt(l*l+h*h),r=a,s=u}return n},he.isCCW=function(t){var e=t.length-1;if(3>e)throw new i("Ring has fewer than 4 points, so orientation cannot be determined");for(var n=t[0],r=0,s=1;e>=s;s++){var o=t[s];o.y>n.y&&(n=o,r=s)}var a=r;do a-=1,0>a&&(a=e);while(t[a].equals2D(n)&&a!==r);var u=r;do u=(u+1)%e;while(t[u].equals2D(n)&&u!==r);var l=t[a],h=t[u];if(l.equals2D(n)||h.equals2D(n)||l.equals2D(h))return!1;var c=he.computeOrientation(l,n,h),f=!1;return f=0===c?l.x>h.x:c>0},he.locatePointInRing=function(t,e){return le.locatePointInRing(t,e)},he.distancePointLinePerpendicular=function(t,e,n){var i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)},he.computeOrientation=function(t,e,n){return he.orientationIndex(t,e,n)},he.distancePointLine=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(0===e.length)throw new i("Line array must contain at least one vertex");for(var n=t.distance(e[0]),r=0;r<e.length-1;r++){var s=he.distancePointLine(t,e[r],e[r+1]);n>s&&(n=s)}return n}if(3===arguments.length){var o=arguments[0],a=arguments[1],u=arguments[2];if(a.x===u.x&&a.y===u.y)return o.distance(a);var l=(u.x-a.x)*(u.x-a.x)+(u.y-a.y)*(u.y-a.y),h=((o.x-a.x)*(u.x-a.x)+(o.y-a.y)*(u.y-a.y))/l;if(0>=h)return o.distance(a);if(h>=1)return o.distance(u);var c=((a.y-o.y)*(u.x-a.x)-(a.x-o.x)*(u.y-a.y))/l;return Math.abs(c)*Math.sqrt(l)}},he.isOnLine=function(t,e){for(var n=new ae,i=1;i<e.length;i++){var r=e[i-1],s=e[i];if(n.computeIntersection(t,r,s),n.hasIntersection())return!0}return!1},he.CLOCKWISE=-1,he.RIGHT=he.CLOCKWISE,he.COUNTERCLOCKWISE=1,he.LEFT=he.COUNTERCLOCKWISE,he.COLLINEAR=0,he.STRAIGHT=he.COLLINEAR,e(ce.prototype,{minX:function(){return Math.min(this.p0.x,this.p1.x)},orientationIndex:function(){if(arguments[0]instanceof ce){var t=arguments[0],e=he.orientationIndex(this.p0,this.p1,t.p0),n=he.orientationIndex(this.p0,this.p1,t.p1);return e>=0&&n>=0?Math.max(e,n):0>=e&&0>=n?Math.max(e,n):0}if(arguments[0]instanceof g){var i=arguments[0];return he.orientationIndex(this.p0,this.p1,i)}},toGeometry:function(t){return t.createLineString([this.p0,this.p1])},isVertical:function(){return this.p0.x===this.p1.x},equals:function(t){if(!(t instanceof ce))return!1;var e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)},intersection:function(t){var e=new ae;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null},project:function(){if(arguments[0]instanceof g){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);var e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ce){var i=arguments[0],r=this.projectionFactor(i.p0),s=this.projectionFactor(i.p1);if(r>=1&&s>=1)return null;if(0>=r&&0>=s)return null;var o=this.project(i.p0);0>r&&(o=this.p0),r>1&&(o=this.p1);var a=this.project(i.p1);return 0>s&&(a=this.p0),s>1&&(a=this.p1),new ce(o,a)}},normalize:function(){this.p1.compareTo(this.p0)<0&&this.reverse()},angle:function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},getCoordinate:function(t){return 0===t?this.p0:this.p1},distancePerpendicular:function(t){return he.distancePointLinePerpendicular(t,this.p0,this.p1)},minY:function(){return Math.min(this.p0.y,this.p1.y)},midPoint:function(){return ce.midPoint(this.p0,this.p1)},projectionFactor:function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(0>=i)return r.NaN;var s=((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i;return s},closestPoints:function(t){var e=this.intersection(t);if(null!==e)return[e,e];var n=new Array(2).fill(null),i=r.MAX_VALUE,s=null,o=this.closestPoint(t.p0);i=o.distance(t.p0),n[0]=o,n[1]=t.p0;var a=this.closestPoint(t.p1);s=a.distance(t.p1),i>s&&(i=s,n[0]=a,n[1]=t.p1);var u=t.closestPoint(this.p0);s=u.distance(this.p0),i>s&&(i=s,n[0]=this.p0,n[1]=u);var l=t.closestPoint(this.p1);return s=l.distance(this.p1),i>s&&(i=s,n[0]=this.p1,n[1]=l),n},closestPoint:function(t){var e=this.projectionFactor(t);if(e>0&&1>e)return this.project(t);var n=this.p0.distance(t),i=this.p1.distance(t);return i>n?this.p0:this.p1},maxX:function(){return Math.max(this.p0.x,this.p1.x)},getLength:function(){return this.p0.distance(this.p1)},compareTo:function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)},reverse:function(){var t=this.p0;this.p0=this.p1,this.p1=t},equalsTopo:function(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)},lineIntersection:function(t){try{var e=F.intersection(this.p0,this.p1,t.p0,t.p1);return e}catch(n){if(!(n instanceof w))throw n}finally{}return null},maxY:function(){return Math.max(this.p0.y,this.p1.y)},pointAlongOffset:function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y,o=Math.sqrt(r*r+s*s),a=0,u=0;if(0!==e){if(0>=o)throw new IllegalStateException("Cannot compute offset from zero-length line segment");a=e*r/o,u=e*s/o}var l=n-u,h=i+a,c=new g(l,h);return c},setCoordinates:function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y}},segmentFraction:function(t){var e=this.projectionFactor(t);return 0>e?e=0:(e>1||r.isNaN(e))&&(e=1),e},toString:function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},isHorizontal:function(){return this.p0.y===this.p1.y},distance:function(){if(arguments[0]instanceof ce){var t=arguments[0];return he.distanceLineLine(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){var e=arguments[0];return he.distancePointLine(e,this.p0,this.p1)}},pointAlong:function(t){var e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e},hashCode:function(){var t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=java.lang.Double.doubleToLongBits(this.p1.x);n^=31*java.lang.Double.doubleToLongBits(this.p1.y);var i=Math.trunc(n)^Math.trunc(n>>32);return e^i},interfaces_:function(){return[s,u]},getClass:function(){return ce}}),ce.midPoint=function(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)},ce.serialVersionUID=0x2d2172135f411c00,e(fe.prototype,{isIntersects:function(){return!this.isDisjoint()},isCovers:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},isCoveredBy:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},set:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.matrix[n][i]=lt.toDimensionValue(t.charAt(e))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]=o}},isContains:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},setAtLeast:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,lt.toDimensionValue(t.charAt(e)))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]<o&&(this.matrix[r][s]=o)}},setAtLeastIfValid:function(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)},isWithin:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},isTouches:function(t,e){return t>e?this.isTouches(e,t):t===lt.A&&e===lt.A||t===lt.L&&e===lt.L||t===lt.L&&e===lt.A||t===lt.P&&e===lt.A||t===lt.P&&e===lt.L?this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&(fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY])):!1},isOverlaps:function(t,e){return t===lt.P&&e===lt.P||t===lt.A&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?1===this.matrix[L.INTERIOR][L.INTERIOR]&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):!1},isEquals:function(t,e){return t!==e?!1:fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},toString:function(){for(var t=new P("123456789"),e=0;3>e;e++)for(var n=0;3>n;n++)t.setCharAt(3*e+n,lt.toDimensionSymbol(this.matrix[e][n]));return t.toString()},setAll:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.matrix[e][n]=t},get:function(t,e){return this.matrix[t][e]},transpose:function(){var t=this.matrix[1][0];return this.matrix[1][0]=this.matrix[0][1],this.matrix[0][1]=t,t=this.matrix[2][0],this.matrix[2][0]=this.matrix[0][2],this.matrix[0][2]=t,t=this.matrix[2][1],this.matrix[2][1]=this.matrix[1][2],this.matrix[1][2]=t,this},matches:function(t){if(9!==t.length)throw new i("Should be length 9: "+t);for(var e=0;3>e;e++)for(var n=0;3>n;n++)if(!fe.matches(this.matrix[e][n],t.charAt(3*e+n)))return!1;return!0},add:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.setAtLeast(e,n,t.get(e,n))},isDisjoint:function(){return this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.INTERIOR][L.BOUNDARY]===lt.FALSE&&this.matrix[L.BOUNDARY][L.INTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.BOUNDARY]===lt.FALSE},isCrosses:function(t,e){return t===lt.P&&e===lt.L||t===lt.P&&e===lt.A||t===lt.L&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]):t===lt.L&&e===lt.P||t===lt.A&&e===lt.P||t===lt.A&&e===lt.L?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?0===this.matrix[L.INTERIOR][L.INTERIOR]:!1},interfaces_:function(){return[o]},getClass:function(){return fe}}),fe.matches=function(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){var t=arguments[0],e=arguments[1];return e===lt.SYM_DONTCARE?!0:e===lt.SYM_TRUE&&(t>=0||t===lt.TRUE)?!0:e===lt.SYM_FALSE&&t===lt.FALSE?!0:e===lt.SYM_P&&t===lt.P?!0:e===lt.SYM_L&&t===lt.L?!0:e===lt.SYM_A&&t===lt.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){var n=arguments[0],i=arguments[1],r=new fe(n);return r.matches(i)}},fe.isTrue=function(t){return t>=0||t===lt.TRUE};var lo=Object.freeze({Coordinate:g,CoordinateList:N,Envelope:C,LineSegment:ce,GeometryFactory:ie,Geometry:B,Point:Lt,LineString:St,LinearRing:bt,Polygon:Tt,GeometryCollection:ft,MultiPoint:Pt,MultiLineString:gt,MultiPolygon:Ot,Dimension:lt,IntersectionMatrix:fe});e(ge.prototype,{addPoint:function(t){this.ptCount+=1,this.ptCentSum.x+=t.x,this.ptCentSum.y+=t.y},setBasePoint:function(t){null===this.areaBasePt&&(this.areaBasePt=t)},addLineSegments:function(t){for(var e=0,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);if(0!==i){e+=i;var r=(t[n].x+t[n+1].x)/2;this.lineCentSum.x+=i*r;var s=(t[n].y+t[n+1].y)/2;this.lineCentSum.y+=i*s}}this.totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])},addHole:function(t){for(var e=he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},getCentroid:function(){var t=new g;if(Math.abs(this.areasum2)>0)t.x=this.cg3.x/3/this.areasum2,t.y=this.cg3.y/3/this.areasum2;else if(this.totalLength>0)t.x=this.lineCentSum.x/this.totalLength,t.y=this.lineCentSum.y/this.totalLength;else{if(!(this.ptCount>0))return null;t.x=this.ptCentSum.x/this.ptCount,t.y=this.ptCentSum.y/this.ptCount}return t},addShell:function(t){t.length>0&&this.setBasePoint(t[0]);for(var e=!he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},addTriangle:function(t,e,n,i){var r=i?1:-1;ge.centroid3(t,e,n,this.triangleCent3);var s=ge.area2(t,e,n);this.cg3.x+=r*s*this.triangleCent3.x,this.cg3.y+=r*s*this.triangleCent3.y,this.areasum2+=r*s},add:function(){if(arguments[0]instanceof Tt){var t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(var e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof B){var n=arguments[0];if(n.isEmpty())return null;if(n instanceof Lt)this.addPoint(n.getCoordinate());else if(n instanceof St)this.addLineSegments(n.getCoordinates());else if(n instanceof Tt){var i=n;this.add(i)}else if(n instanceof ft)for(var r=n,e=0;e<r.getNumGeometries();e++)this.add(r.getGeometryN(e))}},interfaces_:function(){return[]},getClass:function(){return ge}}),ge.area2=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)},ge.centroid3=function(t,e,n,i){return i.x=t.x+e.x+n.x,i.y=t.y+e.y+n.y,null},ge.getCentroid=function(t){var e=new ge(t);return e.getCentroid()},de.prototype=new Error,de.prototype.name="EmptyStackException",pe.prototype=new y,pe.prototype.add=function(t){return this.array_.push(t),!0},pe.prototype.get=function(t){if(0>t||t>=this.size())throw new IndexOutOfBoundsException;return this.array_[t]},pe.prototype.push=function(t){return this.array_.push(t),t},pe.prototype.pop=function(t){if(0===this.array_.length)throw new de;return this.array_.pop()},pe.prototype.peek=function(){if(0===this.array_.length)throw new de;return this.array_[this.array_.length-1]},pe.prototype.empty=function(){return 0===this.array_.length},pe.prototype.isEmpty=function(){return this.empty()},pe.prototype.search=function(t){return this.array_.indexOf(t)},pe.prototype.size=function(){return this.array_.length},pe.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},e(ve.prototype,{filter:function(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))},getCoordinates:function(){var t=new Array(this.list.size()).fill(null);return this.list.toArray(t)},interfaces_:function(){return[z]},getClass:function(){return ve}}),ve.filterCoordinates=function(t){for(var e=new ve,n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()},e(me.prototype,{preSort:function(t){for(var e=null,n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ut.sort(t,1,t.length,new ye(t[0])),t},computeOctRing:function(t){var e=this.computeOctPts(t),n=new N;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())},lineOrPolygon:function(t){if(t=this.cleanRing(t),3===t.length)return this.geomFactory.createLineString([t[0],t[1]]);var e=this.geomFactory.createLinearRing(t);return this.geomFactory.createPolygon(e,null)},cleanRing:function(t){f.equals(t[0],t[t.length-1]);for(var e=new I,n=null,i=0;i<=t.length-2;i++){var r=t[i],s=t[i+1];r.equals(s)||null!==n&&this.isBetween(n,r,s)||(e.add(r),n=r)}e.add(t[t.length-1]);var o=new Array(e.size()).fill(null);return e.toArray(o)},isBetween:function(t,e,n){if(0!==he.computeOrientation(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1},reduce:function(t){var e=this.computeOctRing(t);if(null===e)return t;for(var n=new at,i=0;i<e.length;i++)n.add(e[i]);for(var i=0;i<t.length;i++)he.isPointInRing(t[i],e)||n.add(t[i]);var r=H.toCoordinateArray(n);return r.length<3?this.padArray3(r):r},getConvexHull:function(){if(0===this.inputPts.length)return this.geomFactory.createGeometryCollection(null);if(1===this.inputPts.length)return this.geomFactory.createPoint(this.inputPts[0]);if(2===this.inputPts.length)return this.geomFactory.createLineString(this.inputPts);var t=this.inputPts;this.inputPts.length>50&&(t=this.reduce(this.inputPts));var e=this.preSort(t),n=this.grahamScan(e),i=this.toCoordinateArray(n);return this.lineOrPolygon(i)},padArray3:function(t){for(var e=new Array(3).fill(null),n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e},computeOctPts:function(t){for(var e=new Array(8).fill(null),n=0;n<e.length;n++)e[n]=t[0];for(var i=1;i<t.length;i++)t[i].x<e[0].x&&(e[0]=t[i]),t[i].x-t[i].y<e[1].x-e[1].y&&(e[1]=t[i]),t[i].y>e[2].y&&(e[2]=t[i]),t[i].x+t[i].y>e[3].x+e[3].y&&(e[3]=t[i]),t[i].x>e[4].x&&(e[4]=t[i]),t[i].x-t[i].y>e[5].x-e[5].y&&(e[5]=t[i]),t[i].y<e[6].y&&(e[6]=t[i]),t[i].x+t[i].y<e[7].x+e[7].y&&(e[7]=t[i]);return e},toCoordinateArray:function(t){for(var e=new Array(t.size()).fill(null),n=0;n<t.size();n++){var i=t.get(n);e[n]=i}return e},grahamScan:function(t){var e=null,n=new pe;e=n.push(t[0]),e=n.push(t[1]),e=n.push(t[2]);for(var i=3;i<t.length;i++){for(e=n.pop();!n.empty()&&he.computeOrientation(n.peek(),e,t[i])>0;)e=n.pop();e=n.push(e),e=n.push(t[i])}return e=n.push(t[0]),n},interfaces_:function(){return[]},getClass:function(){return me}}),me.extractCoordinates=function(t){var e=new ve;return t.apply(e),e.getCoordinates();
},e(ye.prototype,{compare:function(t,e){var n=t,i=e;return ye.polarCompare(this.origin,n,i)},interfaces_:function(){return[a]},getClass:function(){return ye}}),ye.polarCompare=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-t.x,o=n.y-t.y,a=he.computeOrientation(t,e,n);if(a===he.COUNTERCLOCKWISE)return 1;if(a===he.CLOCKWISE)return-1;var u=i*i+r*r,l=s*s+o*o;return l>u?-1:u>l?1:0},me.RadialComparator=ye,e(xe.prototype,{transformPoint:function(t,e){return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))},transformPolygon:function(t,e){var n=!0,i=this.transformLinearRing(t.getExteriorRing(),t);null!==i&&i instanceof bt&&!i.isEmpty()||(n=!1);for(var r=new I,s=0;s<t.getNumInteriorRing();s++){var o=this.transformLinearRing(t.getInteriorRingN(s),t);null===o||o.isEmpty()||(o instanceof bt||(n=!1),r.add(o))}if(n)return this.factory.createPolygon(i,r.toArray([]));var a=new I;return null!==i&&a.add(i),a.addAll(r),this.factory.buildGeometry(a)},createCoordinateSequence:function(t){return this.factory.getCoordinateSequenceFactory().create(t)},getInputGeometry:function(){return this.inputGeom},transformMultiLineString:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformLineString(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformCoordinates:function(t,e){return this.copy(t)},transformLineString:function(t,e){return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))},transformMultiPoint:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPoint(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformMultiPolygon:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPolygon(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},copy:function(t){return t.copy()},transformGeometryCollection:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transform(t.getGeometryN(i));null!==r&&(this.pruneEmptyGeometry&&r.isEmpty()||n.add(r))}return this.preserveGeometryCollectionType?this.factory.createGeometryCollection(ie.toGeometryArray(n)):this.factory.buildGeometry(n)},transform:function(t){if(this.inputGeom=t,this.factory=t.getFactory(),t instanceof Lt)return this.transformPoint(t,null);if(t instanceof Pt)return this.transformMultiPoint(t,null);if(t instanceof bt)return this.transformLinearRing(t,null);if(t instanceof St)return this.transformLineString(t,null);if(t instanceof gt)return this.transformMultiLineString(t,null);if(t instanceof Tt)return this.transformPolygon(t,null);if(t instanceof Ot)return this.transformMultiPolygon(t,null);if(t instanceof ft)return this.transformGeometryCollection(t,null);throw new i("Unknown Geometry subtype: "+t.getClass().getName())},transformLinearRing:function(t,e){var n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this.factory.createLinearRing(null);var i=n.size();return i>0&&4>i&&!this.preserveType?this.factory.createLineString(n):this.factory.createLinearRing(n)},interfaces_:function(){return[]},getClass:function(){return xe}}),e(Ee.prototype,{snapVertices:function(t,e){for(var n=this._isClosed?t.size()-1:t.size(),i=0;n>i;i++){var r=t.get(i),s=this.findSnapForVertex(r,e);null!==s&&(t.set(i,new g(s)),0===i&&this._isClosed&&t.set(t.size()-1,new g(s)))}},findSnapForVertex:function(t,e){for(var n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this.snapTolerance)return e[n]}return null},snapTo:function(t){var e=new N(this.srcPts);this.snapVertices(e,t),this.snapSegments(e,t);var n=e.toCoordinateArray();return n},snapSegments:function(t,e){if(0===e.length)return null;var n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(var i=0;n>i;i++){var r=e[i],s=this.findSegmentIndexToSnap(r,t);s>=0&&t.add(s+1,new g(r),!1)}},findSegmentIndexToSnap:function(t,e){for(var n=r.MAX_VALUE,i=-1,s=0;s<e.size()-1;s++){if(this.seg.p0=e.get(s),this.seg.p1=e.get(s+1),this.seg.p0.equals2D(t)||this.seg.p1.equals2D(t)){if(this.allowSnappingToSourceVertices)continue;return-1}var o=this.seg.distance(t);o<this.snapTolerance&&n>o&&(n=o,i=s)}return i},setAllowSnappingToSourceVertices:function(t){this.allowSnappingToSourceVertices=t},interfaces_:function(){return[]},getClass:function(){return Ee}}),Ee.isClosed=function(t){return t.length<=1?!1:t[0].equals2D(t[t.length-1])},e(Ie.prototype,{snapTo:function(t,e){var n=this.extractTargetCoordinates(t),i=new Ne(e,n);return i.transform(this.srcGeom)},snapToSelf:function(t,e){var n=this.extractTargetCoordinates(this.srcGeom),i=new Ne(t,n,!0),r=i.transform(this.srcGeom),s=r;return e&&R(s,Rt)&&(s=r.buffer(0)),s},computeSnapTolerance:function(t){var e=this.computeMinimumSegmentLength(t),n=e/10;return n},extractTargetCoordinates:function(t){for(var e=new at,n=t.getCoordinates(),i=0;i<n.length;i++)e.add(n[i]);return e.toArray(new Array(0).fill(null))},computeMinimumSegmentLength:function(t){for(var e=r.MAX_VALUE,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);e>i&&(e=i)}return e},interfaces_:function(){return[]},getClass:function(){return Ie}}),Ie.snap=function(t,e,n){var i=new Array(2).fill(null),r=new Ie(t);i[0]=r.snapTo(e,n);var s=new Ie(e);return i[1]=s.snapTo(i[0],n),i},Ie.computeOverlaySnapTolerance=function(){if(1===arguments.length){var t=arguments[0],e=Ie.computeSizeBasedSnapTolerance(t),n=t.getPrecisionModel();if(n.getType()===ee.FIXED){var i=1/n.getScale()*2/1.415;i>e&&(e=i)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1];return Math.min(Ie.computeOverlaySnapTolerance(r),Ie.computeOverlaySnapTolerance(s))}},Ie.computeSizeBasedSnapTolerance=function(t){var e=t.getEnvelopeInternal(),n=Math.min(e.getHeight(),e.getWidth()),i=n*Ie.SNAP_PRECISION_FACTOR;return i},Ie.snapToSelf=function(t,e,n){var i=new Ie(t);return i.snapToSelf(e,n)},Ie.SNAP_PRECISION_FACTOR=1e-9,h(Ne,xe),e(Ne.prototype,{snapLine:function(t,e){var n=new Ee(t,this.snapTolerance);return n.setAllowSnappingToSourceVertices(this.isSelfSnap),n.snapTo(e)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=this.snapLine(n,this.snapPts);return this.factory.getCoordinateSequenceFactory().create(i)},interfaces_:function(){return[]},getClass:function(){return Ne}}),e(Ce.prototype,{getCommon:function(){return r.longBitsToDouble(this.commonBits)},add:function(t){var e=r.doubleToLongBits(t);if(this.isFirst)return this.commonBits=e,this.commonSignExp=Ce.signExpBits(this.commonBits),this.isFirst=!1,null;var n=Ce.signExpBits(e);return n!==this.commonSignExp?(this.commonBits=0,null):(this.commonMantissaBitsCount=Ce.numCommonMostSigMantissaBits(this.commonBits,e),void(this.commonBits=Ce.zeroLowerBits(this.commonBits,64-(12+this.commonMantissaBitsCount))))},toString:function(){if(1===arguments.length){var t=arguments[0],e=r.longBitsToDouble(t),n=Long.toBinaryString(t),i="0000000000000000000000000000000000000000000000000000000000000000"+n,s=i.substring(i.length-64),o=s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]";return o}},interfaces_:function(){return[]},getClass:function(){return Ce}}),Ce.getBit=function(t,e){var n=1<<e;return 0!==(t&n)?1:0},Ce.signExpBits=function(t){return t>>52},Ce.zeroLowerBits=function(t,e){var n=(1<<e)-1,i=~n,r=t&i;return r},Ce.numCommonMostSigMantissaBits=function(t,e){for(var n=0,i=52;i>=0;i--){if(Ce.getBit(t,i)!==Ce.getBit(e,i))return n;n++}return 52},e(Se.prototype,{addCommonBits:function(t){var e=new Le(this.commonCoord);t.apply(e),t.geometryChanged()},removeCommonBits:function(t){if(0===this.commonCoord.x&&0===this.commonCoord.y)return t;var e=new g(this.commonCoord);e.x=-e.x,e.y=-e.y;var n=new Le(e);return t.apply(n),t.geometryChanged(),t},getCommonCoordinate:function(){return this.commonCoord},add:function(t){t.apply(this.ccFilter),this.commonCoord=this.ccFilter.getCommonCoordinate()},interfaces_:function(){return[]},getClass:function(){return Se}}),e(we.prototype,{filter:function(t){this.commonBitsX.add(t.x),this.commonBitsY.add(t.y)},getCommonCoordinate:function(){return new g(this.commonBitsX.getCommon(),this.commonBitsY.getCommon())},interfaces_:function(){return[z]},getClass:function(){return we}}),e(Le.prototype,{filter:function(t,e){var n=t.getOrdinate(e,0)+this.trans.x,i=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,i)},isDone:function(){return!1},isGeometryChanged:function(){return!0},interfaces_:function(){return[ct]},getClass:function(){return Le}}),Se.CommonCoordinateFilter=we,Se.Translater=Le,e(Re.prototype,{next:function(){if(this.atStart)return this.atStart=!1,Re.isAtomic(this.parent)&&this.index++,this.parent;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return this.subcollectionIterator.next();this.subcollectionIterator=null}if(this.index>=this.max)throw new x;var t=this.parent.getGeometryN(this.index++);return t instanceof ft?(this.subcollectionIterator=new Re(t),this.subcollectionIterator.next()):t},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){if(this.atStart)return!0;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return!0;this.subcollectionIterator=null}return!(this.index>=this.max)},interfaces_:function(){return[p]},getClass:function(){return Re}}),Re.isAtomic=function(t){return!(t instanceof ft)},e(Te.prototype,{locateInternal:function(){if(arguments[0]instanceof g&&arguments[1]instanceof Tt){var t=arguments[0],e=arguments[1];if(e.isEmpty())return L.EXTERIOR;var n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===L.EXTERIOR)return L.EXTERIOR;if(i===L.BOUNDARY)return L.BOUNDARY;for(var r=0;r<e.getNumInteriorRing();r++){var s=e.getInteriorRingN(r),o=this.locateInPolygonRing(t,s);if(o===L.INTERIOR)return L.EXTERIOR;if(o===L.BOUNDARY)return L.BOUNDARY}return L.INTERIOR}if(arguments[0]instanceof g&&arguments[1]instanceof St){var a=arguments[0],u=arguments[1];if(!u.getEnvelopeInternal().intersects(a))return L.EXTERIOR;var l=u.getCoordinates();return u.isClosed()||!a.equals(l[0])&&!a.equals(l[l.length-1])?he.isOnLine(a,l)?L.INTERIOR:L.EXTERIOR:L.BOUNDARY}if(arguments[0]instanceof g&&arguments[1]instanceof Lt){var h=arguments[0],c=arguments[1],f=c.getCoordinate();return f.equals2D(h)?L.INTERIOR:L.EXTERIOR}},locateInPolygonRing:function(t,e){return e.getEnvelopeInternal().intersects(t)?he.locatePointInRing(t,e.getCoordinates()):L.EXTERIOR},intersects:function(t,e){return this.locate(t,e)!==L.EXTERIOR},updateLocationInfo:function(t){t===L.INTERIOR&&(this.isIn=!0),t===L.BOUNDARY&&this.numBoundaries++},computeLocation:function(t,e){if(e instanceof Lt&&this.updateLocationInfo(this.locateInternal(t,e)),e instanceof St)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof Tt)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof gt)for(var n=e,i=0;i<n.getNumGeometries();i++){var r=n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,r))}else if(e instanceof Ot)for(var s=e,i=0;i<s.getNumGeometries();i++){var o=s.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,o))}else if(e instanceof ft)for(var a=new Re(e);a.hasNext();){var u=a.next();u!==e&&this.computeLocation(t,u)}},locate:function(t,e){return e.isEmpty()?L.EXTERIOR:e instanceof St?this.locateInternal(t,e):e instanceof Tt?this.locateInternal(t,e):(this.isIn=!1,this.numBoundaries=0,this.computeLocation(t,e),this.boundaryRule.isInBoundary(this.numBoundaries)?L.BOUNDARY:this.numBoundaries>0||this.isIn?L.INTERIOR:L.EXTERIOR)},interfaces_:function(){return[]},getClass:function(){return Te}}),e(Pe.prototype,{interfaces_:function(){return[]},getClass:function(){return Pe}}),Pe.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the octant for point ( "+t+", "+e+" )");var n=Math.abs(t),r=Math.abs(e);return t>=0?e>=0?n>=r?0:1:n>=r?7:6:e>=0?n>=r?3:2:n>=r?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1],a=o.x-s.x,u=o.y-s.y;if(0===a&&0===u)throw new i("Cannot compute the octant for two identical points "+s);return Pe.octant(a,u)}},e(be.prototype,{getCoordinates:function(){},size:function(){},getCoordinate:function(t){},isClosed:function(){},setData:function(t){},getData:function(){},interfaces_:function(){return[]},getClass:function(){return be}}),e(Oe.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:Pe.octant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},getData:function(){return this.data},toString:function(){return se.toLineString(new Gt(this.pts))},interfaces_:function(){return[be]},getClass:function(){return Oe}}),e(_e.prototype,{getBounds:function(){},interfaces_:function(){return[]},getClass:function(){return _e}}),e(Me.prototype,{getItem:function(){return this.item},getBounds:function(){return this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Me}}),e(De.prototype,{poll:function(){if(this.isEmpty())return null;var t=this.items.get(1);return this.items.set(1,this.items.get(this._size)),this._size-=1,this.reorder(1),t},size:function(){return this._size},reorder:function(t){for(var e=null,n=this.items.get(t);2*t<=this._size&&(e=2*t,e!==this._size&&this.items.get(e+1).compareTo(this.items.get(e))<0&&e++,this.items.get(e).compareTo(n)<0);t=e)this.items.set(t,this.items.get(e));this.items.set(t,n)},clear:function(){this._size=0,this.items.clear()},isEmpty:function(){return 0===this._size},add:function(t){this.items.add(null),this._size+=1;var e=this._size;for(this.items.set(0,t);t.compareTo(this.items.get(Math.trunc(e/2)))<0;e/=2)this.items.set(e,this.items.get(Math.trunc(e/2)));this.items.set(e,t)},interfaces_:function(){return[]},getClass:function(){return De}}),e(Ae.prototype,{visitItem:function(t){},interfaces_:function(){return[]},getClass:function(){return Ae}}),e(Fe.prototype,{insert:function(t,e){},remove:function(t,e){},query:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return Fe}}),e(Ge.prototype,{getLevel:function(){return this.level},size:function(){return this.childBoundables.size()},getChildBoundables:function(){return this.childBoundables},addChildBoundable:function(t){f.isTrue(null===this.bounds),this.childBoundables.add(t)},isEmpty:function(){return this.childBoundables.isEmpty()},getBounds:function(){return null===this.bounds&&(this.bounds=this.computeBounds()),this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Ge}}),Ge.serialVersionUID=0x5a1e55ec41369800;var ho={reverseOrder:function(){return{compare:function(t,e){return e.compareTo(t)}}},min:function(t){return ho.sort(t),t.get(0)},sort:function(t,e){var n=t.toArray();e?ut.sort(n,e):ut.sort(n);for(var i=t.iterator(),r=0,s=n.length;s>r;r++)i.next(),i.set(n[r])},singletonList:function(t){var e=new I;return e.add(t),e}};e(qe.prototype,{expandToQueue:function(t,e){var n=qe.isComposite(this.boundable1),r=qe.isComposite(this.boundable2);if(n&&r)return qe.area(this.boundable1)>qe.area(this.boundable2)?(this.expand(this.boundable1,this.boundable2,t,e),null):(this.expand(this.boundable2,this.boundable1,t,e),null);if(n)return this.expand(this.boundable1,this.boundable2,t,e),null;if(r)return this.expand(this.boundable2,this.boundable1,t,e),null;throw new i("neither boundable is composite")},isLeaves:function(){return!(qe.isComposite(this.boundable1)||qe.isComposite(this.boundable2))},compareTo:function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0},expand:function(t,e,n,i){for(var r=t.getChildBoundables(),s=r.iterator();s.hasNext();){var o=s.next(),a=new qe(o,e,this.itemDistance);a.getDistance()<i&&n.add(a)}},getBoundable:function(t){return 0===t?this.boundable1:this.boundable2},getDistance:function(){return this._distance},distance:function(){return this.isLeaves()?this.itemDistance.distance(this.boundable1,this.boundable2):this.boundable1.getBounds().distance(this.boundable2.getBounds())},interfaces_:function(){return[s]},getClass:function(){return qe}}),qe.area=function(t){return t.getBounds().getArea()},qe.isComposite=function(t){return t instanceof Ge},e(Be.prototype,{getNodeCapacity:function(){return this.nodeCapacity},lastNode:function(t){return t.get(t.size()-1)},size:function qo(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this.root));if(1===arguments.length){for(var t=arguments[0],qo=0,e=t.getChildBoundables().iterator();e.hasNext();){var n=e.next();n instanceof Ge?qo+=this.size(n):n instanceof Me&&(qo+=1)}return qo}},removeItem:function(t,e){for(var n=null,i=t.getChildBoundables().iterator();i.hasNext();){var r=i.next();r instanceof Me&&r.getItem()===e&&(n=r)}return null!==n?(t.getChildBoundables().remove(n),!0):!1},itemsTree:function(){if(0===arguments.length){this.build();var t=this.itemsTree(this.root);return null===t?new I:t}if(1===arguments.length){for(var e=arguments[0],n=new I,i=e.getChildBoundables().iterator();i.hasNext();){var r=i.next();if(r instanceof Ge){var s=this.itemsTree(r);null!==s&&n.add(s)}else r instanceof Me?n.add(r.getItem()):f.shouldNeverReachHere()}return n.size()<=0?null:n}},insert:function(t,e){f.isTrue(!this.built,"Cannot insert items into an STR packed R-tree after it has been built."),this.itemBoundables.add(new Me(t,e))},boundablesAtLevel:function(){if(1===arguments.length){var t=arguments[0],e=new I;return this.boundablesAtLevel(t,this.root,e),e}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(f.isTrue(n>-2),i.getLevel()===n)return r.add(i),null;for(var s=i.getChildBoundables().iterator();s.hasNext();){var o=s.next();o instanceof Ge?this.boundablesAtLevel(n,o,r):(f.isTrue(o instanceof Me),-1===n&&r.add(o))}return null}},query:function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new I;return this.isEmpty()?e:(this.getIntersectsOp().intersects(this.root.getBounds(),t)&&this.query(t,this.root,e),e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this.root.getBounds(),n)&&this.query(n,this.root,i)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var r=arguments[0],s=arguments[1],o=arguments[2],a=s.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),r)&&(l instanceof Ge?this.query(r,l,o):l instanceof Me?o.visitItem(l.getItem()):f.shouldNeverReachHere())}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var h=arguments[0],c=arguments[1],g=arguments[2],a=c.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),h)&&(l instanceof Ge?this.query(h,l,g):l instanceof Me?g.add(l.getItem()):f.shouldNeverReachHere())}},build:function(){return this.built?null:(this.root=this.itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this.itemBoundables,-1),this.itemBoundables=null,void(this.built=!0))},getRoot:function(){return this.build(),this.root},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),this.getIntersectsOp().intersects(this.root.getBounds(),t)?this.remove(t,this.root,e):!1}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=this.removeItem(i,r);if(s)return!0;for(var o=null,a=i.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&u instanceof Ge&&(s=this.remove(n,u,r))){o=u;break}}return null!==o&&o.getChildBoundables().isEmpty()&&i.getChildBoundables().remove(o),s}},createHigherLevels:function(t,e){f.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)},depth:function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this.root));if(1===arguments.length){for(var t=arguments[0],e=0,n=t.getChildBoundables().iterator();n.hasNext();){var i=n.next();if(i instanceof Ge){var r=this.depth(i);r>e&&(e=r)}}return e+1}},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=new I;n.add(this.createNode(e));var i=new I(t);ho.sort(i,this.getComparator());for(var r=i.iterator();r.hasNext();){var s=r.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n},isEmpty:function(){return this.built?this.root.isEmpty():this.itemBoundables.isEmpty()},interfaces_:function(){return[u]},getClass:function(){return Be}}),Be.compareDoubles=function(t,e){return t>e?1:e>t?-1:0},Be.IntersectsOp=ze,Be.serialVersionUID=-0x35ef64c82d4c5400,Be.DEFAULT_NODE_CAPACITY=10,e(Ve.prototype,{distance:function(t,e){},interfaces_:function(){return[]},getClass:function(){return Ve}}),h(ke,Be),e(ke.prototype,{createParentBoundablesFromVerticalSlices:function(t,e){f.isTrue(t.length>0);for(var n=new I,i=0;i<t.length;i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i],e));return n},createNode:function(t){return new Ye(t)},size:function(){return 0===arguments.length?Be.prototype.size.call(this):Be.prototype.size.apply(this,arguments)},insert:function(){if(2!==arguments.length)return Be.prototype.insert.apply(this,arguments);var t=arguments[0],e=arguments[1];return t.isNull()?null:void Be.prototype.insert.call(this,t,e)},getIntersectsOp:function(){return ke.intersectsOp},verticalSlices:function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),i=new Array(e).fill(null),r=t.iterator(),s=0;e>s;s++){i[s]=new I;for(var o=0;r.hasNext()&&n>o;){var a=r.next();i[s].add(a),o++}}return i},query:function(){if(1===arguments.length){var t=arguments[0];return Be.prototype.query.call(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];Be.prototype.query.call(this,e,n)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var i=arguments[0],r=arguments[1],s=arguments[2];Be.prototype.query.call(this,i,r,s)}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var o=arguments[0],a=arguments[1],u=arguments[2];Be.prototype.query.call(this,o,a,u)}},getComparator:function(){return ke.yComparator},createParentBoundablesFromVerticalSlice:function(t,e){return Be.prototype.createParentBoundables.call(this,t,e)},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Be.prototype.remove.call(this,t,e)}return Be.prototype.remove.apply(this,arguments)},depth:function(){return 0===arguments.length?Be.prototype.depth.call(this):Be.prototype.depth.apply(this,arguments)},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),i=new I(t);ho.sort(i,ke.xComparator);var r=this.verticalSlices(i,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(r,e)},nearestNeighbour:function(){if(1===arguments.length){if(R(arguments[0],Ve)){var t=arguments[0],e=new qe(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe){var n=arguments[0];return this.nearestNeighbour(n,r.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof ke&&R(arguments[1],Ve)){var i=arguments[0],s=arguments[1],e=new qe(this.getRoot(),i.getRoot(),s);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe&&"number"==typeof arguments[1]){var o=arguments[0],a=arguments[1],u=a,l=null,h=new De;for(h.add(o);!h.isEmpty()&&u>0;){var c=h.poll(),f=c.getDistance();if(f>=u)break;c.isLeaves()?(u=f,l=c):c.expandToQueue(h,u)}return[l.getBoundable(0).getItem(),l.getBoundable(1).getItem()]}}else if(3===arguments.length){var g=arguments[0],d=arguments[1],p=arguments[2],v=new Me(g,d),e=new qe(this.getRoot(),v,p);return this.nearestNeighbour(e)[0]}},interfaces_:function(){return[Fe,u]},getClass:function(){return ke}}),ke.centreX=function(t){return ke.avg(t.getMinX(),t.getMaxX())},ke.avg=function(t,e){return(t+e)/2},ke.centreY=function(t){return ke.avg(t.getMinY(),t.getMaxY())},h(Ye,Ge),e(Ye.prototype,{computeBounds:function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new C(n.getBounds()):t.expandToInclude(n.getBounds())}return t},interfaces_:function(){return[]},getClass:function(){return Ye}}),ke.STRtreeNode=Ye,ke.serialVersionUID=0x39920f7d5f261e0,ke.xComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreX(t.getBounds()),ke.centreX(e.getBounds()))}},ke.yComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreY(t.getBounds()),ke.centreY(e.getBounds()))}},ke.intersectsOp={interfaces_:function(){return[IntersectsOp]},intersects:function(t,e){return t.intersects(e)}},ke.DEFAULT_NODE_CAPACITY=10,e(Ue.prototype,{interfaces_:function(){return[]},getClass:function(){return Ue}}),Ue.relativeSign=function(t,e){return e>t?-1:t>e?1:0},Ue.compare=function(t,e,n){if(e.equals2D(n))return 0;var i=Ue.relativeSign(e.x,n.x),r=Ue.relativeSign(e.y,n.y);switch(t){case 0:return Ue.compareValue(i,r);case 1:return Ue.compareValue(r,i);case 2:return Ue.compareValue(r,-i);case 3:return Ue.compareValue(-i,r);case 4:return Ue.compareValue(-i,-r);case 5:return Ue.compareValue(-r,-i);case 6:return Ue.compareValue(-r,i);case 7:return Ue.compareValue(i,-r)}return f.shouldNeverReachHere("invalid octant value"),0},Ue.compareValue=function(t,e){return 0>t?-1:t>0?1:0>e?-1:e>0?1:0},e(Xe.prototype,{getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)},compareTo:function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:Ue.compare(this.segmentOctant,this.coord,e.coord)},isEndPoint:function(t){return 0!==this.segmentIndex||this._isInterior?this.segmentIndex===t:!0},isInterior:function(){return this._isInterior},interfaces_:function(){return[s]},getClass:function(){return Xe}}),e(He.prototype,{getSplitCoordinates:function(){var t=new N;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next();this.addEdgeCoordinates(n,i,t),n=i}return t.toCoordinateArray()},addCollapsedNodes:function(){var t=new I;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this.edge.getCoordinate(n),n)}},print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},findCollapsesFromExistingVertices:function(t){for(var e=0;e<this.edge.size()-2;e++){var n=this.edge.getCoordinate(e),i=(this.edge.getCoordinate(e+1),this.edge.getCoordinate(e+2));n.equals2D(i)&&t.add(new b(e+1))}},addEdgeCoordinates:function(t,e,n){var i=e.segmentIndex-t.segmentIndex+2,r=this.edge.getCoordinate(e.segmentIndex),s=e.isInterior()||!e.coord.equals2D(r);s||i--;n.add(new g(t.coord),!1);for(var o=t.segmentIndex+1;o<=e.segmentIndex;o++)n.add(this.edge.getCoordinate(o));s&&n.add(new g(e.coord))},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},findCollapseIndex:function(t,e,n){if(!t.coord.equals2D(e.coord))return!1;var i=e.segmentIndex-t.segmentIndex;return e.isInterior()||i--,1===i?(n[0]=t.segmentIndex+1,!0):!1},findCollapsesFromInsertedNodes:function(t){for(var e=new Array(1).fill(null),n=this.iterator(),i=n.next();n.hasNext();){var r=n.next(),s=this.findCollapseIndex(i,r,e);s&&t.add(new b(e[0])),i=r}},getEdge:function(){return this.edge},addEndpoints:function(){var t=this.edge.size()-1;this.add(this.edge.getCoordinate(0),0),this.add(this.edge.getCoordinate(t),t)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.getCoordinate(a);return r&&(s[o]=new g(e.coord)),new Ke(s,this.edge.getData())},add:function(t,e){var n=new Xe(this.edge,t,e,this.edge.getSegmentOctant(e)),i=this.nodeMap.get(n);return null!==i?(f.isTrue(i.coord.equals2D(t),"Found equal nodes with different coordinates"),i):(this.nodeMap.put(n,n),n)},checkSplitEdgesCorrectness:function(t){var e=this.edge.getCoordinates(),n=t.get(0),i=n.getCoordinate(0);if(!i.equals2D(e[0]))throw new l("bad split edge start point at "+i);var r=t.get(t.size()-1),s=r.getCoordinates(),o=s[s.length-1];if(!o.equals2D(e[e.length-1]))throw new l("bad split edge end point at "+o)},interfaces_:function(){return[]},getClass:function(){return He}}),e(We.prototype,{next:function(){return null===this.currNode?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):null===this.nextNode?null:this.nextNode.segmentIndex===this.currNode.segmentIndex?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):(this.nextNode.segmentIndex>this.currNode.segmentIndex,null)},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){return null!==this.nextNode},readNextNode:function(){this.nodeIt.hasNext()?this.nextNode=this.nodeIt.next():this.nextNode=null},interfaces_:function(){return[p]},getClass:function(){return We}}),e(je.prototype,{addIntersection:function(t,e){},interfaces_:function(){return[be]},getClass:function(){return je}}),e(Ke.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},safeOctant:function(t,e){return t.equals2D(e)?0:Pe.octant(t,e)},getData:function(){return this.data},addIntersection:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=(arguments[2],arguments[3]),s=new g(n.getIntersection(r));this.addIntersection(s,i)}},toString:function(){return se.toLineString(new Gt(this.pts))},getNodeList:function(){return this.nodeList},addIntersectionNode:function(t,e){var n=e,i=n+1;if(i<this.pts.length){var r=this.pts[i];t.equals2D(r)&&(n=i)}var s=this.nodeList.add(t,n);return s},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[je]},getClass:function(){return Ke}}),Ke.getNodedSubstrings=function(){if(1===arguments.length){var t=arguments[0],e=new I;return Ke.getNodedSubstrings(t,e),e}if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){var s=r.next();s.getNodeList().addSplitEdges(i)}},e(Ze.prototype,{overlap:function(){if(2===arguments.length){arguments[0],arguments[1]}else if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t.getLineSegment(e,this.overlapSeg1),n.getLineSegment(i,this.overlapSeg2),this.overlap(this.overlapSeg1,this.overlapSeg2)}},interfaces_:function(){return[]},getClass:function(){return Ze}}),
e(Qe.prototype,{getLineSegment:function(t,e){e.p0=this.pts[t],e.p1=this.pts[t+1]},computeSelect:function(t,e,n,i){var r=this.pts[e],s=this.pts[n];if(i.tempEnv1.init(r,s),n-e===1)return i.select(this,e),null;if(!t.intersects(i.tempEnv1))return null;var o=Math.trunc((e+n)/2);o>e&&this.computeSelect(t,e,o,i),n>o&&this.computeSelect(t,o,n,i)},getCoordinates:function(){for(var t=new Array(this.end-this.start+1).fill(null),e=0,n=this.start;n<=this.end;n++)t[e++]=this.pts[n];return t},computeOverlaps:function(t,e){this.computeOverlapsInternal(this.start,this.end,t,t.start,t.end,e)},setId:function(t){this.id=t},select:function(t,e){this.computeSelect(t,this.start,this.end,e)},getEnvelope:function(){if(null===this.env){var t=this.pts[this.start],e=this.pts[this.end];this.env=new C(t,e)}return this.env},getEndIndex:function(){return this.end},getStartIndex:function(){return this.start},getContext:function(){return this.context},getId:function(){return this.id},computeOverlapsInternal:function(t,e,n,i,r,s){var o=this.pts[t],a=this.pts[e],u=n.pts[i],l=n.pts[r];if(e-t===1&&r-i===1)return s.overlap(this,t,n,i),null;if(s.tempEnv1.init(o,a),s.tempEnv2.init(u,l),!s.tempEnv1.intersects(s.tempEnv2))return null;var h=Math.trunc((t+e)/2),c=Math.trunc((i+r)/2);h>t&&(c>i&&this.computeOverlapsInternal(t,h,n,i,c,s),r>c&&this.computeOverlapsInternal(t,h,n,c,r,s)),e>h&&(c>i&&this.computeOverlapsInternal(h,e,n,i,c,s),r>c&&this.computeOverlapsInternal(h,e,n,c,r,s))},interfaces_:function(){return[]},getClass:function(){return Qe}}),e(Je.prototype,{interfaces_:function(){return[]},getClass:function(){return Je}}),Je.isNorthern=function(t){return t===Je.NE||t===Je.NW},Je.isOpposite=function(t,e){if(t===e)return!1;var n=(t-e+4)%4;return 2===n},Je.commonHalfPlane=function(t,e){if(t===e)return t;var n=(t-e+4)%4;if(2===n)return-1;var i=e>t?t:e,r=t>e?t:e;return 0===i&&3===r?3:i},Je.isInHalfPlane=function(t,e){return e===Je.SE?t===Je.SE||t===Je.SW:t===e||t===e+1},Je.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Je.NE:Je.SE:e>=0?Je.NW:Je.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){var n=arguments[0],r=arguments[1];if(r.x===n.x&&r.y===n.y)throw new i("Cannot compute the quadrant for two identical points "+n);return r.x>=n.x?r.y>=n.y?Je.NE:Je.SE:r.y>=n.y?Je.NW:Je.SW}},Je.NE=0,Je.NW=1,Je.SW=2,Je.SE=3,e($e.prototype,{interfaces_:function(){return[]},getClass:function(){return $e}}),$e.getChainStartIndices=function(t){var e=0,n=new I;n.add(new b(e));do{var i=$e.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=$e.toIntArray(n);return r},$e.findChainEnd=function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var i=Je.quadrant(t[n],t[n+1]),r=e+1;r<t.length;){if(!t[r-1].equals2D(t[r])){var s=Je.quadrant(t[r-1],t[r]);if(s!==i)break}r++}return r-1},$e.getChains=function(){if(1===arguments.length){var t=arguments[0];return $e.getChains(t,null)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new I,r=$e.getChainStartIndices(e),s=0;s<r.length-1;s++){var o=new Qe(e,r[s],r[s+1],n);i.add(o)}return i}},$e.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(tn.prototype,{computeNodes:function(t){},getNodedSubstrings:function(){},interfaces_:function(){return[]},getClass:function(){return tn}}),e(en.prototype,{setSegmentIntersector:function(t){this.segInt=t},interfaces_:function(){return[tn]},getClass:function(){return en}}),h(nn,en),e(nn.prototype,{getMonotoneChains:function(){return this.monoChains},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},getIndex:function(){return this.index},add:function(t){for(var e=$e.getChains(t.getCoordinates(),t),n=e.iterator();n.hasNext();){var i=n.next();i.setId(this.idCounter++),this.index.insert(i.getEnvelope(),i),this.monoChains.add(i)}},computeNodes:function(t){this.nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()},intersectChains:function(){for(var t=new rn(this.segInt),e=this.monoChains.iterator();e.hasNext();)for(var n=e.next(),i=this.index.query(n.getEnvelope()),r=i.iterator();r.hasNext();){var s=r.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this.nOverlaps++),this.segInt.isDone())return null}},interfaces_:function(){return[]},getClass:function(){return nn}}),h(rn,Ze),e(rn.prototype,{overlap:function(){if(4!==arguments.length)return Ze.prototype.overlap.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],r=t.getContext(),s=n.getContext();this.si.processIntersections(r,e,s,i)},interfaces_:function(){return[]},getClass:function(){return rn}}),nn.SegmentOverlapAction=rn,h(sn,l),e(sn.prototype,{getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return sn}}),sn.msgWithCoord=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(on.prototype,{processIntersections:function(t,e,n,i){},isDone:function(){},interfaces_:function(){return[]},getClass:function(){return on}}),e(an.prototype,{getInteriorIntersection:function(){return this.interiorIntersection},setCheckEndSegmentsOnly:function(t){this.isCheckEndSegmentsOnly=t},getIntersectionSegments:function(){return this.intSegments},count:function(){return this.intersectionCount},getIntersections:function(){return this.intersections},setFindAllIntersections:function(t){this.findAllIntersections=t},setKeepIntersections:function(t){this.keepIntersections=t},processIntersections:function(t,e,n,i){if(!this.findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===i)return null;if(this.isCheckEndSegmentsOnly){var r=this.isEndSegment(t,e)||this.isEndSegment(n,i);if(!r)return null}var s=t.getCoordinates()[e],o=t.getCoordinates()[e+1],a=n.getCoordinates()[i],u=n.getCoordinates()[i+1];this.li.computeIntersection(s,o,a,u),this.li.hasIntersection()&&this.li.isInteriorIntersection()&&(this.intSegments=new Array(4).fill(null),this.intSegments[0]=s,this.intSegments[1]=o,this.intSegments[2]=a,this.intSegments[3]=u,this.interiorIntersection=this.li.getIntersection(0),this.keepIntersections&&this.intersections.add(this.interiorIntersection),this.intersectionCount++)},isEndSegment:function(t,e){return 0===e?!0:e>=t.size()-2},hasIntersection:function(){return null!==this.interiorIntersection},isDone:function(){return this.findAllIntersections?!1:null!==this.interiorIntersection},interfaces_:function(){return[on]},getClass:function(){return an}}),an.createAllIntersectionsFinder=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e},an.createAnyIntersectionFinder=function(t){return new an(t)},an.createIntersectionCounter=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e},e(un.prototype,{execute:function(){return null!==this.segInt?null:void this.checkInteriorIntersections()},getIntersections:function(){return this.segInt.getIntersections()},isValid:function(){return this.execute(),this._isValid},setFindAllIntersections:function(t){this.findAllIntersections=t},checkInteriorIntersections:function(){this._isValid=!0,this.segInt=new an(this.li),this.segInt.setFindAllIntersections(this.findAllIntersections);var t=new nn;return t.setSegmentIntersector(this.segInt),t.computeNodes(this.segStrings),this.segInt.hasIntersection()?(this._isValid=!1,null):void 0},checkValid:function(){if(this.execute(),!this._isValid)throw new sn(this.getErrorMessage(),this.segInt.getInteriorIntersection())},getErrorMessage:function(){if(this._isValid)return"no intersections found";var t=this.segInt.getIntersectionSegments();return"found non-noded intersection between "+se.toLineString(t[0],t[1])+" and "+se.toLineString(t[2],t[3])},interfaces_:function(){return[]},getClass:function(){return un}}),un.computeIntersections=function(t){var e=new un(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()},e(ln.prototype,{checkValid:function(){this.nv.checkValid()},interfaces_:function(){return[]},getClass:function(){return ln}}),ln.toSegmentStrings=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Oe(i.getCoordinates(),i))}return e},ln.checkValid=function(t){var e=new ln(t);e.checkValid()},e(hn.prototype,{map:function(t){for(var e=new I,n=0;n<t.getNumGeometries();n++){var i=this.mapOp.map(t.getGeometryN(n));i.isEmpty()||e.add(i)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(e))},interfaces_:function(){return[]},getClass:function(){return hn}}),hn.map=function(t,e){var n=new hn(e);return n.map(t)},e(cn.prototype,{interfaces_:function(){return[]},getClass:function(){return cn}}),cn.opposite=function(t){return t===cn.LEFT?cn.RIGHT:t===cn.RIGHT?cn.LEFT:t},cn.ON=0,cn.LEFT=1,cn.RIGHT=2,e(fn.prototype,{setAllLocations:function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t},isNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==L.NONE)return!1;return!0},setAllLocationsIfNull:function(t){for(var e=0;e<this.location.length;e++)this.location[e]===L.NONE&&(this.location[e]=t)},isLine:function(){return 1===this.location.length},merge:function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[cn.ON]=this.location[cn.ON],e[cn.LEFT]=L.NONE,e[cn.RIGHT]=L.NONE,this.location=e}for(var n=0;n<this.location.length;n++)this.location[n]===L.NONE&&n<t.location.length&&(this.location[n]=t.location[n])},getLocations:function(){return this.location},flip:function(){if(this.location.length<=1)return null;var t=this.location[cn.LEFT];this.location[cn.LEFT]=this.location[cn.RIGHT],this.location[cn.RIGHT]=t},toString:function(){var t=new P;return this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.LEFT])),t.append(L.toLocationSymbol(this.location[cn.ON])),this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.RIGHT])),t.toString()},setLocations:function(t,e,n){this.location[cn.ON]=t,this.location[cn.LEFT]=e,this.location[cn.RIGHT]=n},get:function(t){return t<this.location.length?this.location[t]:L.NONE},isArea:function(){return this.location.length>1},isAnyNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===L.NONE)return!0;return!1},setLocation:function(){if(1===arguments.length){var t=arguments[0];this.setLocation(cn.ON,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n}},init:function(t){this.location=new Array(t).fill(null),this.setAllLocations(L.NONE)},isEqualOnSide:function(t,e){return this.location[e]===t.location[e]},allPositionsEqual:function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0},interfaces_:function(){return[]},getClass:function(){return fn}}),e(gn.prototype,{getGeometryCount:function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t},setAllLocations:function(t,e){this.elt[t].setAllLocations(e)},isNull:function(t){return this.elt[t].isNull()},setAllLocationsIfNull:function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n)}},isLine:function(t){return this.elt[t].isLine()},merge:function(t){for(var e=0;2>e;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new fn(t.elt[e]):this.elt[e].merge(t.elt[e])},flip:function(){this.elt[0].flip(),this.elt[1].flip()},getLocation:function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(cn.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}},toString:function(){var t=new P;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()},isArea:function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}},isAnyNull:function(t){return this.elt[t].isAnyNull()},setLocation:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(cn.ON,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.elt[n].setLocation(i,r)}},isEqualOnSide:function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)},allPositionsEqual:function(t,e){return this.elt[t].allPositionsEqual(e)},toLine:function(t){this.elt[t].isArea()&&(this.elt[t]=new fn(this.elt[t].location[0]))},interfaces_:function(){return[]},getClass:function(){return gn}}),gn.toLineLabel=function(t){for(var e=new gn(L.NONE),n=0;2>n;n++)e.setLocation(n,t.getLocation(n));return e},e(dn.prototype,{computeRing:function(){if(null!==this.ring)return null;for(var t=new Array(this.pts.size()).fill(null),e=0;e<this.pts.size();e++)t[e]=this.pts.get(e);this.ring=this.geometryFactory.createLinearRing(t),this._isHole=he.isCCW(this.ring.getCoordinates())},isIsolated:function(){return 1===this.label.getGeometryCount()},computePoints:function(t){this.startDe=t;var e=t,n=!0;do{if(null===e)throw new sn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new sn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this.edges.add(e);var i=e.getLabel();f.isTrue(i.isArea()),this.mergeLabel(i),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this.startDe)},getLinearRing:function(){return this.ring},getCoordinate:function(t){return this.pts.get(t)},computeMaxNodeDegree:function(){this.maxNodeDegree=0;var t=this.startDe;do{var e=t.getNode(),n=e.getEdges().getOutgoingDegree(this);n>this.maxNodeDegree&&(this.maxNodeDegree=n),t=this.getNext(t)}while(t!==this.startDe);this.maxNodeDegree*=2},addPoints:function(t,e,n){var i=t.getCoordinates();if(e){var r=1;n&&(r=0);for(var s=r;s<i.length;s++)this.pts.add(i[s])}else{var r=i.length-2;n&&(r=i.length-1);for(var s=r;s>=0;s--)this.pts.add(i[s])}},isHole:function(){return this._isHole},setInResult:function(){var t=this.startDe;do t.getEdge().setInResult(!0),t=t.getNext();while(t!==this.startDe)},containsPoint:function(t){var e=this.getLinearRing(),n=e.getEnvelopeInternal();if(!n.contains(t))return!1;if(!he.isPointInRing(t,e.getCoordinates()))return!1;for(var i=this.holes.iterator();i.hasNext();){var r=i.next();if(r.containsPoint(t))return!1}return!0},addHole:function(t){this.holes.add(t)},isShell:function(){return null===this.shell},getLabel:function(){return this.label},getEdges:function(){return this.edges},getMaxNodeDegree:function(){return this.maxNodeDegree<0&&this.computeMaxNodeDegree(),this.maxNodeDegree},getShell:function(){return this.shell},mergeLabel:function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=e.getLocation(n,cn.RIGHT);if(i===L.NONE)return null;if(this.label.getLocation(n)===L.NONE)return this.label.setLocation(n,i),null}},setShell:function(t){this.shell=t,null!==t&&t.addHole(this)},toPolygon:function(t){for(var e=new Array(this.holes.size()).fill(null),n=0;n<this.holes.size();n++)e[n]=this.holes.get(n).getLinearRing();var i=t.createPolygon(this.getLinearRing(),e);return i},interfaces_:function(){return[]},getClass:function(){return dn}}),h(pn,dn),e(pn.prototype,{setEdgeRing:function(t,e){t.setMinEdgeRing(e)},getNext:function(t){return t.getNextMin()},interfaces_:function(){return[]},getClass:function(){return pn}}),h(vn,dn),e(vn.prototype,{buildMinimalRings:function(){var t=new I,e=this.startDe;do{if(null===e.getMinEdgeRing()){var n=new pn(e,this.geometryFactory);t.add(n)}e=e.getNext()}while(e!==this.startDe);return t},setEdgeRing:function(t,e){t.setEdgeRing(e)},linkDirectedEdgesForMinimalEdgeRings:function(){var t=this.startDe;do{var e=t.getNode();e.getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this.startDe)},getNext:function(t){return t.getNext()},interfaces_:function(){return[]},getClass:function(){return vn}}),e(mn.prototype,{setVisited:function(t){this._isVisited=t},setInResult:function(t){this._isInResult=t},isCovered:function(){return this._isCovered},isCoveredSet:function(){return this._isCoveredSet},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setCovered:function(t){this._isCovered=t,this._isCoveredSet=!0},updateIM:function(t){f.isTrue(this.label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)},isInResult:function(){return this._isInResult},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return mn}}),h(yn,mn),e(yn.prototype,{isIncidentEdgeInResult:function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();){var e=t.next();if(e.getEdge().isInResult())return!0}return!1},isIsolated:function(){return 1===this.label.getGeometryCount()},getCoordinate:function(){return this.coord},print:function(t){t.println("node "+this.coord+" lbl: "+this.label)},computeIM:function(t){},computeMergedLocation:function(t,e){var n=L.NONE;if(n=this.label.getLocation(e),!t.isNull(e)){var i=t.getLocation(e);n!==L.BOUNDARY&&(n=i)}return n},setLabel:function(){if(2!==arguments.length)return mn.prototype.setLabel.apply(this,arguments);var t=arguments[0],e=arguments[1];null===this.label?this.label=new gn(t,e):this.label.setLocation(t,e)},getEdges:function(){return this.edges},mergeLabel:function(){if(arguments[0]instanceof yn){var t=arguments[0];this.mergeLabel(t.label)}else if(arguments[0]instanceof gn)for(var e=arguments[0],n=0;2>n;n++){var i=this.computeMergedLocation(e,n),r=this.label.getLocation(n);r===L.NONE&&this.label.setLocation(n,i)}},add:function(t){this.edges.insert(t),t.setNode(this)},setLabelBoundary:function(t){if(null===this.label)return null;var e=L.NONE;null!==this.label&&(e=this.label.getLocation(t));var n=null;switch(e){case L.BOUNDARY:n=L.INTERIOR;break;case L.INTERIOR:n=L.BOUNDARY;break;default:n=L.BOUNDARY}this.label.setLocation(t,n)},interfaces_:function(){return[]},getClass:function(){return yn}}),e(xn.prototype,{find:function(t){return this.nodeMap.get(t)},addNode:function(){if(arguments[0]instanceof g){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof yn){var n=arguments[0],e=this.nodeMap.get(n.getCoordinate());return null===e?(this.nodeMap.put(n.getCoordinate(),n),n):(e.mergeLabel(n),e)}},print:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},values:function(){return this.nodeMap.values()},getBoundaryNodes:function(t){for(var e=new I,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().getLocation(t)===L.BOUNDARY&&e.add(i)}return e},add:function(t){var e=t.getCoordinate(),n=this.addNode(e);n.add(t)},interfaces_:function(){return[]},getClass:function(){return xn}}),e(En.prototype,{compareDirection:function(t){return this.dx===t.dx&&this.dy===t.dy?0:this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getDy:function(){return this.dy},getCoordinate:function(){return this.p0},setNode:function(t){this.node=t},print:function(t){var e=Math.atan2(this.dy,this.dx),n=this.getClass().getName(),i=n.lastIndexOf("."),r=n.substring(i+1);t.print("  "+r+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+e+"   "+this.label)},compareTo:function(t){var e=t;return this.compareDirection(e)},getDirectedCoordinate:function(){return this.p1},getDx:function(){return this.dx},getLabel:function(){return this.label},getEdge:function(){return this.edge},getQuadrant:function(){return this.quadrant},getNode:function(){return this.node},toString:function(){var t=Math.atan2(this.dy,this.dx),e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);return"  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+t+"   "+this.label},computeLabel:function(t){},init:function(t,e){this.p0=t,this.p1=e,this.dx=e.x-t.x,this.dy=e.y-t.y,this.quadrant=Je.quadrant(this.dx,this.dy),f.isTrue(!(0===this.dx&&0===this.dy),"EdgeEnd with identical endpoints found")},interfaces_:function(){return[s]},getClass:function(){return En}}),h(In,En),e(In.prototype,{getNextMin:function(){return this.nextMin},getDepth:function(t){return this.depth[t]},setVisited:function(t){this._isVisited=t},computeDirectedLabel:function(){this.label=new gn(this.edge.getLabel()),this._isForward||this.label.flip()},getNext:function(){return this.next},setDepth:function(t,e){if(-999!==this.depth[t]&&this.depth[t]!==e)throw new sn("assigned depths do not match",this.getCoordinate());this.depth[t]=e},isInteriorAreaEdge:function Bo(){for(var Bo=!0,t=0;2>t;t++)this.label.isArea(t)&&this.label.getLocation(t,cn.LEFT)===L.INTERIOR&&this.label.getLocation(t,cn.RIGHT)===L.INTERIOR||(Bo=!1);return Bo},setNextMin:function(t){this.nextMin=t},print:function(t){En.prototype.print.call(this,t),t.print(" "+this.depth[cn.LEFT]+"/"+this.depth[cn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")},setMinEdgeRing:function(t){this.minEdgeRing=t},isLineEdge:function(){var t=this.label.isLine(0)||this.label.isLine(1),e=!this.label.isArea(0)||this.label.allPositionsEqual(0,L.EXTERIOR),n=!this.label.isArea(1)||this.label.allPositionsEqual(1,L.EXTERIOR);return t&&e&&n},setEdgeRing:function(t){this.edgeRing=t},getMinEdgeRing:function(){return this.minEdgeRing},getDepthDelta:function(){var t=this.edge.getDepthDelta();return this._isForward||(t=-t),t},setInResult:function(t){this._isInResult=t},getSym:function(){return this.sym},isForward:function(){return this._isForward},getEdge:function(){return this.edge},printEdge:function(t){this.print(t),t.print(" "),this._isForward?this.edge.print(t):this.edge.printReverse(t)},setSym:function(t){this.sym=t},setVisitedEdge:function(t){this.setVisited(t),this.sym.setVisited(t)},setEdgeDepths:function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var i=1;t===cn.LEFT&&(i=-1);var r=cn.opposite(t),s=n*i,o=e+s;this.setDepth(t,e),this.setDepth(r,o)},getEdgeRing:function(){return this.edgeRing},isInResult:function(){return this._isInResult},setNext:function(t){this.next=t},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return In}}),In.depthFactor=function(t,e){return t===L.EXTERIOR&&e===L.INTERIOR?1:t===L.INTERIOR&&e===L.EXTERIOR?-1:0},e(Nn.prototype,{createNode:function(t){return new yn(t,null)},interfaces_:function(){return[]},getClass:function(){return Nn}}),e(Cn.prototype,{printEdges:function(t){t.println("Edges:");for(var e=0;e<this.edges.size();e++){t.println("edge "+e+":");var n=this.edges.get(e);n.print(t),n.eiList.print(t)}},find:function(t){return this.nodes.find(t)},addNode:function(){if(arguments[0]instanceof yn){var t=arguments[0];return this.nodes.addNode(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.nodes.addNode(e)}},getNodeIterator:function(){return this.nodes.iterator()},linkResultDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkResultDirectedEdges()}},debugPrintln:function(t){A.out.println(t)},isBoundaryNode:function(t,e){var n=this.nodes.find(e);if(null===n)return!1;var i=n.getLabel();return null!==i&&i.getLocation(t)===L.BOUNDARY},linkAllDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkAllDirectedEdges()}},matchInSameDirection:function(t,e,n,i){return t.equals(n)?he.computeOrientation(t,e,i)===he.COLLINEAR&&Je.quadrant(t,e)===Je.quadrant(n,i):!1},getEdgeEnds:function(){return this.edgeEndList},debugPrint:function(t){A.out.print(t)},getEdgeIterator:function(){return this.edges.iterator()},findEdgeInSameDirection:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(this.matchInSameDirection(t,e,r[0],r[1]))return i;if(this.matchInSameDirection(t,e,r[r.length-1],r[r.length-2]))return i}return null},insertEdge:function(t){this.edges.add(t)},findEdgeEnd:function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null},addEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.edges.add(n);var i=new In(n,!0),r=new In(n,!1);i.setSym(r),r.setSym(i),this.add(i),this.add(r)}},add:function(t){this.nodes.add(t),this.edgeEndList.add(t)},getNodes:function(){return this.nodes.values()},findEdge:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(t.equals(r[0])&&e.equals(r[1]))return i}return null},interfaces_:function(){return[]},getClass:function(){return Cn}}),Cn.linkResultDirectedEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.getEdges().linkResultDirectedEdges()}},e(Sn.prototype,{sortShellsAndHoles:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isHole()?n.add(r):e.add(r)}},computePolygons:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=i.toPolygon(this.geometryFactory);e.add(r)}return e},placeFreeHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(null===i.getShell()){var r=this.findEdgeRingContaining(i,t);if(null===r)throw new sn("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(r)}}},buildMinimalEdgeRings:function(t,e,n){for(var i=new I,r=t.iterator();r.hasNext();){var s=r.next();if(s.getMaxNodeDegree()>2){s.linkDirectedEdgesForMinimalEdgeRings();var o=s.buildMinimalRings(),a=this.findShell(o);null!==a?(this.placePolygonHoles(a,o),e.add(a)):n.addAll(o)}else i.add(s)}return i},containsPoint:function(t){for(var e=this.shellList.iterator();e.hasNext();){var n=e.next();if(n.containsPoint(t))return!0}return!1},buildMaximalEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&i.getLabel().isArea()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);e.add(r),r.setInResult()}}return e},placePolygonHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();i.isHole()&&i.setShell(t)}},getPolygons:function(){var t=this.computePolygons(this.shellList);return t},findEdgeRingContaining:function(t,e){for(var n=t.getLinearRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),h=l.getEnvelopeInternal();null!==s&&(o=s.getLinearRing().getEnvelopeInternal());var c=!1;h.contains(i)&&he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u)}return s},findShell:function(t){for(var e=0,n=null,i=t.iterator();i.hasNext();){var r=i.next();r.isHole()||(n=r,e++)}return f.isTrue(1>=e,"found two shells in MinimalEdgeRing list"),n},add:function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];Cn.linkResultDirectedEdges(n);var i=this.buildMaximalEdgeRings(e),r=new I,s=this.buildMinimalEdgeRings(i,this.shellList,r);this.sortShellsAndHoles(s,this.shellList,r),this.placeFreeHoles(this.shellList,r)}},interfaces_:function(){return[]},getClass:function(){return Sn}}),e(wn.prototype,{collectLines:function(t){for(var e=this.op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next();this.collectLineEdge(n,t,this.lineEdgesList),this.collectBoundaryTouchEdge(n,t,this.lineEdgesList)}},labelIsolatedLine:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.op.getArgGeometry(e));t.getLabel().setLocation(e,n)},build:function(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this.resultLineList},collectLineEdge:function(t,e,n){var i=t.getLabel(),r=t.getEdge();t.isLineEdge()&&(t.isVisited()||!ii.isResultOfOp(i,e)||r.isCovered()||(n.add(r),t.setVisitedEdge(!0)))},findCoveredLineEdges:function(){for(var t=this.op.getGraph().getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().findCoveredLineEdges()}for(var n=this.op.getGraph().getEdgeEnds().iterator();n.hasNext();){var i=n.next(),r=i.getEdge();if(i.isLineEdge()&&!r.isCoveredSet()){var s=this.op.isCoveredByA(i.getCoordinate());r.setCovered(s)}}},labelIsolatedLines:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(i.isNull(0)?this.labelIsolatedLine(n,0):this.labelIsolatedLine(n,1))}},buildLines:function(t){for(var e=this.lineEdgesList.iterator();e.hasNext();){var n=e.next(),i=(n.getLabel(),this.geometryFactory.createLineString(n.getCoordinates()));this.resultLineList.add(i),n.setInResult(!0)}},collectBoundaryTouchEdge:function(t,e,n){var i=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(f.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(ii.isResultOfOp(i,e)&&e===ii.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))},interfaces_:function(){return[]},getClass:function(){return wn}}),e(Ln.prototype,{filterCoveredNodeToPoint:function(t){var e=t.getCoordinate();if(!this.op.isCoveredByLA(e)){var n=this.geometryFactory.createPoint(e);this.resultPointList.add(n)}},extractNonCoveredResultNodes:function(t){for(var e=this.op.getGraph().getNodes().iterator();e.hasNext();){var n=e.next();if(!(n.isInResult()||n.isIncidentEdgeInResult()||0!==n.getEdges().getDegree()&&t!==ii.INTERSECTION)){var i=n.getLabel();ii.isResultOfOp(i,t)&&this.filterCoveredNodeToPoint(n)}}},build:function(t){return this.extractNonCoveredResultNodes(t),this.resultPointList},interfaces_:function(){return[]},getClass:function(){return Ln}}),e(Rn.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return Rn}}),e(Tn.prototype,{locate:function(t){return Tn.locate(t,this.geom)},interfaces_:function(){return[Rn]},getClass:function(){return Tn}}),Tn.isPointInRing=function(t,e){return e.getEnvelopeInternal().intersects(t)?he.isPointInRing(t,e.getCoordinates()):!1},Tn.containsPointInPolygon=function(t,e){if(e.isEmpty())return!1;var n=e.getExteriorRing();if(!Tn.isPointInRing(t,n))return!1;for(var i=0;i<e.getNumInteriorRing();i++){var r=e.getInteriorRingN(i);if(Tn.isPointInRing(t,r))return!1}return!0},Tn.containsPoint=function(t,e){if(e instanceof Tt)return Tn.containsPointInPolygon(t,e);if(e instanceof ft)for(var n=new Re(e);n.hasNext();){var i=n.next();if(i!==e&&Tn.containsPoint(t,i))return!0}return!1},Tn.locate=function(t,e){return e.isEmpty()?L.EXTERIOR:Tn.containsPoint(t,e)?L.INTERIOR:L.EXTERIOR},e(Pn.prototype,{getNextCW:function(t){this.getEdges();var e=this.edgeList.indexOf(t),n=e-1;return 0===e&&(n=this.edgeList.size()-1),this.edgeList.get(n)},propagateSideLabels:function(t){for(var e=L.NONE,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();r.isArea(t)&&r.getLocation(t,cn.LEFT)!==L.NONE&&(e=r.getLocation(t,cn.LEFT))}if(e===L.NONE)return null;for(var s=e,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();if(r.getLocation(t,cn.ON)===L.NONE&&r.setLocation(t,cn.ON,s),r.isArea(t)){var o=r.getLocation(t,cn.LEFT),a=r.getLocation(t,cn.RIGHT);if(a!==L.NONE){if(a!==s)throw new sn("side location conflict",i.getCoordinate());o===L.NONE&&f.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),s=o}else f.isTrue(r.getLocation(t,cn.LEFT)===L.NONE,"found single null side"),r.setLocation(t,cn.RIGHT,s),r.setLocation(t,cn.LEFT,s)}}},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},print:function(t){A.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},isAreaLabelsConsistent:function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0);
},checkAreaLabelsConsistent:function(t){var e=this.getEdges();if(e.size()<=0)return!0;var n=e.size()-1,i=e.get(n).getLabel(),r=i.getLocation(t,cn.LEFT);f.isTrue(r!==L.NONE,"Found unlabelled area edge");for(var s=r,o=this.iterator();o.hasNext();){var a=o.next(),u=a.getLabel();f.isTrue(u.isArea(t),"Found non-area edge");var l=u.getLocation(t,cn.LEFT),h=u.getLocation(t,cn.RIGHT);if(l===h)return!1;if(h!==s)return!1;s=l}return!0},findIndex:function(t){this.iterator();for(var e=0;e<this.edgeList.size();e++){var n=this.edgeList.get(e);if(n===t)return e}return-1},iterator:function(){return this.getEdges().iterator()},getEdges:function(){return null===this.edgeList&&(this.edgeList=new I(this.edgeMap.values())),this.edgeList},getLocation:function(t,e,n){return this.ptInAreaLocation[t]===L.NONE&&(this.ptInAreaLocation[t]=Tn.locate(e,n[t].getGeometry())),this.ptInAreaLocation[t]},toString:function(){var t=new P;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n")}return t.toString()},computeEdgeEndLabels:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.computeLabel(t)}},computeLabelling:function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)r.isLine(s)&&r.getLocation(s)===L.BOUNDARY&&(e[s]=!0);for(var n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)if(r.isAnyNull(s)){var o=L.NONE;if(e[s])o=L.EXTERIOR;else{var a=i.getCoordinate();o=this.getLocation(s,a,t)}r.setAllLocationsIfNull(s,o)}},getDegree:function(){return this.edgeMap.size()},insertEdgeEnd:function(t,e){this.edgeMap.put(t,e),this.edgeList=null},interfaces_:function(){return[]},getClass:function(){return Pn}}),h(bn,Pn),e(bn.prototype,{linkResultDirectedEdges:function(){this.getResultAreaEdges();for(var t=null,e=null,n=this.SCANNING_FOR_INCOMING,i=0;i<this.resultAreaEdgeList.size();i++){var r=this.resultAreaEdgeList.get(i),s=r.getSym();if(r.getLabel().isArea())switch(null===t&&r.isInResult()&&(t=r),n){case this.SCANNING_FOR_INCOMING:if(!s.isInResult())continue;e=s,n=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(!r.isInResult())continue;e.setNext(r),n=this.SCANNING_FOR_INCOMING}}if(n===this.LINKING_TO_OUTGOING){if(null===t)throw new sn("no outgoing dirEdge found",this.getCoordinate());f.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}},insert:function(t){var e=t;this.insertEdgeEnd(e,e)},getRightmostEdge:function(){var t=this.getEdges(),e=t.size();if(1>e)return null;var n=t.get(0);if(1===e)return n;var i=t.get(e-1),r=n.getQuadrant(),s=i.getQuadrant();if(Je.isNorthern(r)&&Je.isNorthern(s))return n;if(!Je.isNorthern(r)&&!Je.isNorthern(s))return i;return 0!==n.getDy()?n:0!==i.getDy()?i:(f.shouldNeverReachHere("found two horizontal edges incident on node"),null)},print:function(t){A.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}},getResultAreaEdges:function(){if(null!==this.resultAreaEdgeList)return this.resultAreaEdgeList;this.resultAreaEdgeList=new I;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this.resultAreaEdgeList.add(e)}return this.resultAreaEdgeList},updateLabelling:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.setAllLocationsIfNull(0,t.getLocation(0)),i.setAllLocationsIfNull(1,t.getLocation(1))}},linkAllDirectedEdges:function(){this.getEdges();for(var t=null,e=null,n=this.edgeList.size()-1;n>=0;n--){var i=this.edgeList.get(n),r=i.getSym();null===e&&(e=r),null!==t&&r.setNext(t),t=i}e.setNext(t)},computeDepths:function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=(t.getLabel(),t.getDepth(cn.LEFT)),i=t.getDepth(cn.RIGHT),r=this.computeDepths(e+1,this.edgeList.size(),n),s=this.computeDepths(0,e,r);if(s!==i)throw new sn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=u,h=o;a>h;h++){var c=this.edgeList.get(h);c.getLabel();c.setEdgeDepths(cn.RIGHT,l),l=c.getDepth(cn.LEFT)}return l}},mergeSymLabels:function(){for(var t=this.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();n.merge(e.getSym().getLabel())}},linkMinimalDirectedEdges:function(t){for(var e=null,n=null,i=this.SCANNING_FOR_INCOMING,r=this.resultAreaEdgeList.size()-1;r>=0;r--){var s=this.resultAreaEdgeList.get(r),o=s.getSym();switch(null===e&&s.getEdgeRing()===t&&(e=s),i){case this.SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,i=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(s.getEdgeRing()!==t)continue;n.setNextMin(s),i=this.SCANNING_FOR_INCOMING}}i===this.LINKING_TO_OUTGOING&&(f.isTrue(null!==e,"found null for first outgoing dirEdge"),f.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))},getOutgoingDegree:function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();){var n=e.next();n.isInResult()&&t++}return t}if(1===arguments.length){for(var i=arguments[0],t=0,e=this.iterator();e.hasNext();){var n=e.next();n.getEdgeRing()===i&&t++}return t}},getLabel:function(){return this.label},findCoveredLineEdges:function(){for(var t=L.NONE,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=L.INTERIOR;break}if(i.isInResult()){t=L.EXTERIOR;break}}}if(t===L.NONE)return null;for(var r=t,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();n.isLineEdge()?n.getEdge().setCovered(r===L.INTERIOR):(n.isInResult()&&(r=L.EXTERIOR),i.isInResult()&&(r=L.INTERIOR))}},computeLabelling:function(t){Pn.prototype.computeLabelling.call(this,t),this.label=new gn(L.NONE);for(var e=this.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge(),r=i.getLabel(),s=0;2>s;s++){var o=r.getLocation(s);o!==L.INTERIOR&&o!==L.BOUNDARY||this.label.setLocation(s,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return bn}}),h(On,Nn),e(On.prototype,{createNode:function(t){return new yn(t,new bn)},interfaces_:function(){return[]},getClass:function(){return On}}),e(_n.prototype,{computeIntersections:function(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)},interfaces_:function(){return[]},getClass:function(){return _n}}),e(Mn.prototype,{isDelete:function(){return this.eventType===Mn.DELETE},setDeleteEventIndex:function(t){this.deleteEventIndex=t},getObject:function(){return this.obj},compareTo:function(t){var e=t;return this.xValue<e.xValue?-1:this.xValue>e.xValue?1:this.eventType<e.eventType?-1:this.eventType>e.eventType?1:0},getInsertEvent:function(){return this.insertEvent},isInsert:function(){return this.eventType===Mn.INSERT},isSameLabel:function(t){return null===this.label?!1:this.label===t.label},getDeleteEventIndex:function(){return this.deleteEventIndex},interfaces_:function(){return[s]},getClass:function(){return Mn}}),Mn.INSERT=1,Mn.DELETE=2,e(Dn.prototype,{interfaces_:function(){return[]},getClass:function(){return Dn}}),e(An.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(An.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.getNumPoints()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},setIsDoneIfProperInt:function(t){this.isDoneWhenProperInt=t},hasProperInteriorIntersection:function(){return this.hasProperInterior},isBoundaryPointInternal:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinate();if(t.isIntersection(r))return!0}return!1},hasProperIntersection:function(){return this.hasProper},hasIntersection:function(){return this._hasIntersection},isDone:function(){return this._isDone},isBoundaryPoint:function(t,e){return null===e?!1:this.isBoundaryPointInternal(t,e[0])?!0:!!this.isBoundaryPointInternal(t,e[1])},setBoundaryNodes:function(t,e){this.bdyNodes=new Array(2).fill(null),this.bdyNodes[0]=t,this.bdyNodes[1]=e},addIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this.numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this.includeProper&&this.li.isProper()||(t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)),this.li.isProper()&&(this.properIntersectionPoint=this.li.getIntersection(0).copy(),this.hasProper=!0,this.isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this.li,this.bdyNodes)||(this.hasProperInterior=!0))))},interfaces_:function(){return[]},getClass:function(){return An}}),An.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},h(Fn,Dn),e(Fn.prototype,{prepareEvents:function(){ho.sort(this.events);for(var t=0;t<this.events.size();t++){var e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}},computeIntersections:function(){if(1===arguments.length){var t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var e=0;e<this.events.size();e++){var n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof An&&R(arguments[0],y)&&R(arguments[1],y)){var i=arguments[0],r=arguments[1],s=arguments[2];this.addEdges(i,i),this.addEdges(r,r),this.computeIntersections(s)}else if("boolean"==typeof arguments[2]&&R(arguments[0],y)&&arguments[1]instanceof An){var o=arguments[0],a=arguments[1],u=arguments[2];u?this.addEdges(o,null):this.addEdges(o),this.computeIntersections(a)}},addEdge:function(t,e){for(var n=t.getMonotoneChainEdge(),i=n.getStartIndexes(),r=0;r<i.length-1;r++){var s=new _n(n,r),o=new Mn(e,n.getMinX(r),s);this.events.add(o),this.events.add(new Mn(n.getMaxX(r),o))}},processOverlaps:function(t,e,n,i){for(var r=n.getObject(),s=t;e>s;s++){var o=this.events.get(s);if(o.isInsert()){var a=o.getObject();n.isSameLabel(o)||(r.computeIntersections(a,i),this.nOverlaps++)}}},addEdges:function(){if(1===arguments.length)for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.addEdge(n,n)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],e=i.iterator();e.hasNext();){var n=e.next();this.addEdge(n,r)}},interfaces_:function(){return[]},getClass:function(){return Fn}}),e(Gn.prototype,{getMin:function(){return this.min},intersects:function(t,e){return!(this.min>e||this.max<t)},getMax:function(){return this.max},toString:function(){return se.toLineString(new g(this.min,0),new g(this.max,0))},interfaces_:function(){return[]},getClass:function(){return Gn}}),e(qn.prototype,{compare:function(t,e){var n=t,i=e,r=(n.min+n.max)/2,s=(i.min+i.max)/2;return s>r?-1:r>s?1:0},interfaces_:function(){return[a]},getClass:function(){return qn}}),Gn.NodeComparator=qn,h(Bn,Gn),e(Bn.prototype,{query:function(t,e,n){return this.intersects(t,e)?void n.visitItem(this.item):null},interfaces_:function(){return[]},getClass:function(){return Bn}}),h(zn,Gn),e(zn.prototype,{buildExtent:function(t,e){this.min=Math.min(t.min,e.min),this.max=Math.max(t.max,e.max)},query:function(t,e,n){return this.intersects(t,e)?(null!==this.node1&&this.node1.query(t,e,n),void(null!==this.node2&&this.node2.query(t,e,n))):null},interfaces_:function(){return[]},getClass:function(){return zn}}),e(Vn.prototype,{buildTree:function(){ho.sort(this.leaves,new IntervalRTreeNode.NodeComparator);for(var t=this.leaves,e=null,n=new I;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}},insert:function(t,e,n){if(null!==this.root)throw new IllegalStateException("Index cannot be added to once it has been queried");this.leaves.add(new Bn(t,e,n))},query:function(t,e,n){this.init(),this.root.query(t,e,n)},buildRoot:function(){return null!==this.root?null:void(this.root=this.buildTree())},printNode:function(t){A.out.println(se.toLineString(new g(t.min,this.level),new g(t.max,this.level)))},init:function(){return null!==this.root?null:void this.buildRoot()},buildLevel:function(t,e){this.level++,e.clear();for(var n=0;n<t.size();n+=2){var i=t.get(n),r=n+1<t.size()?t.get(n):null;if(null===r)e.add(i);else{var s=new zn(t.get(n),t.get(n+1));e.add(s)}}},interfaces_:function(){return[]},getClass:function(){return Vn}}),e(kn.prototype,{filter:function(t){if(this.isForcedToLineString&&t instanceof bt){var e=t.getFactory().createLineString(t.getCoordinateSequence());return this.lines.add(e),null}t instanceof St&&this.lines.add(t)},setForceToLineString:function(t){this.isForcedToLineString=t},interfaces_:function(){return[q]},getClass:function(){return kn}}),kn.getGeometry=function(){if(1===arguments.length){var t=arguments[0];return t.getFactory().buildGeometry(kn.getLines(t))}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().buildGeometry(kn.getLines(e,n))}},kn.getLines=function(){if(1===arguments.length){var t=arguments[0];return kn.getLines(t,!1)}if(2===arguments.length){if(R(arguments[0],v)&&R(arguments[1],v)){for(var e=arguments[0],n=arguments[1],i=e.iterator();i.hasNext();){var r=i.next();kn.getLines(r,n)}return n}if(arguments[0]instanceof B&&"boolean"==typeof arguments[1]){var s=arguments[0],o=arguments[1],a=new I;return s.apply(new kn(a,o)),a}if(arguments[0]instanceof B&&R(arguments[1],v)){var u=arguments[0],l=arguments[1];return u instanceof St?l.add(u):u.apply(new kn(l)),l}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&R(arguments[0],v)&&R(arguments[1],v)){for(var h=arguments[0],c=arguments[1],f=arguments[2],i=h.iterator();i.hasNext();){var r=i.next();kn.getLines(r,c,f)}return c}if("boolean"==typeof arguments[2]&&arguments[0]instanceof B&&R(arguments[1],v)){var g=arguments[0],d=arguments[1],p=arguments[2];return g.apply(new kn(d,p)),d}}},e(Yn.prototype,{visitItem:function(t){this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return Yn}}),e(Un.prototype,{locate:function(t){var e=new le(t),n=new Xn(e);return this.index.query(t.y,t.y,n),e.getLocation()},interfaces_:function(){return[Rn]},getClass:function(){return Un}}),e(Xn.prototype,{visitItem:function(t){var e=t;this.counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))},interfaces_:function(){return[Ae]},getClass:function(){return Xn}}),e(Hn.prototype,{init:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinates();this.addLine(r)}},addLine:function(t){for(var e=1;e<t.length;e++){var n=new ce(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),r=Math.max(n.p0.y,n.p1.y);this.index.insert(i,r,n)}},query:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yn;return this.index.query(t,e,n),n.getItems()}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.index.query(i,r,s)}},interfaces_:function(){return[]},getClass:function(){return Hn}}),Un.SegmentVisitor=Xn,Un.IntervalIndexedGeometry=Hn,e(Wn.prototype,{getSegmentIndex:function(){return this.segmentIndex},getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)},compareTo:function(t){var e=t;return this.compare(e.segmentIndex,e.dist)},isEndPoint:function(t){return 0===this.segmentIndex&&0===this.dist?!0:this.segmentIndex===t},toString:function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},getDistance:function(){return this.dist},compare:function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0},interfaces_:function(){return[s]},getClass:function(){return Wn}}),e(jn.prototype,{print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},addEndpoints:function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.pts[e.segmentIndex],r=e.dist>0||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.pts[a];return r&&(s[o]=e.coord),new Jn(s,new gn(this.edge.label))},add:function(t,e,n){var i=new Wn(t,e,n),r=this.nodeMap.get(i);return null!==r?r:(this.nodeMap.put(i,i),i)},isIntersection:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();if(n.coord.equals(t))return!0}return!1},interfaces_:function(){return[]},getClass:function(){return jn}}),e(Kn.prototype,{getChainStartIndices:function(t){var e=0,n=new I;n.add(new b(e));do{var i=this.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=Kn.toIntArray(n);return r},findChainEnd:function(t,e){for(var n=Je.quadrant(t[e],t[e+1]),i=e+1;i<t.length;){var r=Je.quadrant(t[i-1],t[i]);if(r!==n)break;i++}return i-1},interfaces_:function(){return[]},getClass:function(){return Kn}}),Kn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(Zn.prototype,{getCoordinates:function(){return this.pts},getMaxX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n},getMinX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return n>e?e:n},computeIntersectsForChain:function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5],h=this.pts[r],c=this.pts[s],f=o.pts[a],g=o.pts[u];if(s-r===1&&u-a===1)return l.addIntersections(this.e,r,o.e,a),null;if(this.env1.init(h,c),this.env2.init(f,g),!this.env1.intersects(this.env2))return null;var d=Math.trunc((r+s)/2),p=Math.trunc((a+u)/2);d>r&&(p>a&&this.computeIntersectsForChain(r,d,o,a,p,l),u>p&&this.computeIntersectsForChain(r,d,o,p,u,l)),s>d&&(p>a&&this.computeIntersectsForChain(d,s,o,a,p,l),u>p&&this.computeIntersectsForChain(d,s,o,p,u,l))}},getStartIndexes:function(){return this.startIndex},computeIntersects:function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)},interfaces_:function(){return[]},getClass:function(){return Zn}}),e(Qn.prototype,{getDepth:function(t,e){return this.depth[t][e]},setDepth:function(t,e,n){this.depth[t][e]=n},isNull:function(){if(0===arguments.length){for(var t=0;2>t;t++)for(var e=0;3>e;e++)if(this.depth[t][e]!==Qn.NULL_VALUE)return!1;return!0}if(1===arguments.length){var n=arguments[0];return this.depth[n][1]===Qn.NULL_VALUE}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this.depth[i][r]===Qn.NULL_VALUE}},normalize:function(){for(var t=0;2>t;t++)if(!this.isNull(t)){var e=this.depth[t][1];this.depth[t][2]<e&&(e=this.depth[t][2]),0>e&&(e=0);for(var n=1;3>n;n++){var i=0;this.depth[t][n]>e&&(i=1),this.depth[t][n]=i}}},getDelta:function(t){return this.depth[t][cn.RIGHT]-this.depth[t][cn.LEFT]},getLocation:function(t,e){return this.depth[t][e]<=0?L.EXTERIOR:L.INTERIOR},toString:function(){return"A: "+this.depth[0][1]+","+this.depth[0][2]+" B: "+this.depth[1][1]+","+this.depth[1][2]},add:function(){if(1===arguments.length)for(var t=arguments[0],e=0;2>e;e++)for(var n=1;3>n;n++){var i=t.getLocation(e,n);i!==L.EXTERIOR&&i!==L.INTERIOR||(this.isNull(e,n)?this.depth[e][n]=Qn.depthAtLocation(i):this.depth[e][n]+=Qn.depthAtLocation(i))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];o===L.INTERIOR&&this.depth[r][s]++}},interfaces_:function(){return[]},getClass:function(){return Qn}}),Qn.depthAtLocation=function(t){return t===L.EXTERIOR?0:t===L.INTERIOR?1:Qn.NULL_VALUE},Qn.NULL_VALUE=-1,h(Jn,mn),e(Jn.prototype,{getDepth:function(){return this.depth},getCollapsedEdge:function(){var t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];var e=new Jn(t,gn.toLineLabel(this.label));return e},isIsolated:function(){return this._isIsolated},getCoordinates:function(){return this.pts},setIsolated:function(t){this._isIsolated=t},setName:function(t){this.name=t},equals:function(t){if(!(t instanceof Jn))return!1;var e=t;if(this.pts.length!==e.pts.length)return!1;for(var n=!0,i=!0,r=this.pts.length,s=0;s<this.pts.length;s++)if(this.pts[s].equals2D(e.pts[s])||(n=!1),this.pts[s].equals2D(e.pts[--r])||(i=!1),!n&&!i)return!1;return!0},getCoordinate:function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}},print:function(t){t.print("edge "+this.name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this.label+" "+this.depthDelta)},computeIM:function(t){Jn.updateIM(this.label,t)},isCollapsed:function(){return this.label.isArea()?3!==this.pts.length?!1:!!this.pts[0].equals(this.pts[2]):!1},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getMaximumSegmentIndex:function(){return this.pts.length-1},getDepthDelta:function(){return this.depthDelta},getNumPoints:function(){return this.pts.length},printReverse:function(t){t.print("edge "+this.name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")},getMonotoneChainEdge:function(){return null===this.mce&&(this.mce=new Zn(this)),this.mce},getEnvelope:function(){if(null===this.env){this.env=new C;for(var t=0;t<this.pts.length;t++)this.env.expandToInclude(this.pts[t])}return this.env},addIntersection:function(t,e,n,i){var r=new g(t.getIntersection(i)),s=e,o=t.getEdgeDistance(n,i),a=s+1;if(a<this.pts.length){var u=this.pts[a];r.equals2D(u)&&(s=a,o=0)}this.eiList.add(r,s,o)},toString:function(){var t=new P;t.append("edge "+this.name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this.label+" "+this.depthDelta),t.toString()},isPointwiseEqual:function(t){if(this.pts.length!==t.pts.length)return!1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0},setDepthDelta:function(t){this.depthDelta=t},getEdgeIntersectionList:function(){return this.eiList},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[]},getClass:function(){return Jn}}),Jn.updateIM=function(){if(2!==arguments.length)return mn.prototype.updateIM.apply(this,arguments);var t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,cn.ON),t.getLocation(1,cn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,cn.LEFT),t.getLocation(1,cn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,cn.RIGHT),t.getLocation(1,cn.RIGHT),2))},h($n,Cn),e($n.prototype,{insertBoundaryPoint:function(t,e){var n=this.nodes.addNode(e),i=n.getLabel(),r=1,s=L.NONE;s=i.getLocation(t,cn.ON),s===L.BOUNDARY&&r++;var o=$n.determineBoundary(this.boundaryNodeRule,r);i.setLocation(t,o)},computeSelfNodes:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=new An(n,!0,!1);s.setIsDoneIfProperInt(r);var o=this.createEdgeSetIntersector(),a=this.parentGeom instanceof bt||this.parentGeom instanceof Tt||this.parentGeom instanceof Ot,u=i||!a;return o.computeIntersections(this.edges,s,u),this.addSelfIntersectionNodes(this.argIndex),s}},computeSplitEdges:function(t){for(var e=this.edges.iterator();e.hasNext();){var n=e.next();n.eiList.addSplitEdges(t)}},computeEdgeIntersections:function(t,e,n){var i=new An(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());var r=this.createEdgeSetIntersector();return r.computeIntersections(this.edges,t.edges,i),i},getGeometry:function(){return this.parentGeom},getBoundaryNodeRule:function(){return this.boundaryNodeRule},hasTooFewPoints:function(){return this._hasTooFewPoints},addPoint:function(){if(arguments[0]instanceof Lt){var t=arguments[0],e=t.getCoordinate();this.insertPoint(this.argIndex,e,L.INTERIOR)}else if(arguments[0]instanceof g){var n=arguments[0];this.insertPoint(this.argIndex,n,L.INTERIOR)}},addPolygon:function(t){this.addPolygonRing(t.getExteriorRing(),L.EXTERIOR,L.INTERIOR);for(var e=0;e<t.getNumInteriorRing();e++){var n=t.getInteriorRingN(e);this.addPolygonRing(n,L.INTERIOR,L.EXTERIOR)}},addEdge:function(t){this.insertEdge(t);var e=t.getCoordinates();this.insertPoint(this.argIndex,e[0],L.BOUNDARY),this.insertPoint(this.argIndex,e[e.length-1],L.BOUNDARY)},addLineString:function(t){var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this.invalidPoint=e[0],null;var n=new Jn(e,new gn(this.argIndex,L.INTERIOR));this.lineEdgeMap.put(t,n),this.insertEdge(n),f.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this.argIndex,e[0]),this.insertBoundaryPoint(this.argIndex,e[e.length-1])},getInvalidPoint:function(){return this.invalidPoint},getBoundaryPoints:function(){for(var t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null),n=0,i=t.iterator();i.hasNext();){var r=i.next();e[n++]=r.getCoordinate().copy()}return e},getBoundaryNodes:function(){return null===this.boundaryNodes&&(this.boundaryNodes=this.nodes.getBoundaryNodes(this.argIndex)),this.boundaryNodes},addSelfIntersectionNode:function(t,e,n){return this.isBoundaryNode(t,e)?null:void(n===L.BOUNDARY&&this.useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n))},addPolygonRing:function(t,e,n){if(t.isEmpty())return null;var i=H.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this.invalidPoint=i[0],null;var r=e,s=n;he.isCCW(i)&&(r=n,s=e);var o=new Jn(i,new gn(this.argIndex,L.BOUNDARY,r,s));this.lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this.argIndex,i[0],L.BOUNDARY)},insertPoint:function(t,e,n){var i=this.nodes.addNode(e),r=i.getLabel();null===r?i.label=new gn(t,n):r.setLocation(t,n)},createEdgeSetIntersector:function(){return new Fn},addSelfIntersectionNodes:function(t){for(var e=this.edges.iterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.eiList.iterator();r.hasNext();){var s=r.next();this.addSelfIntersectionNode(t,s.coord,i)}},add:function(){if(1!==arguments.length)return Cn.prototype.add.apply(this,arguments);var t=arguments[0];if(t.isEmpty())return null;if(t instanceof Ot&&(this.useBoundaryDeterminationRule=!1),t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},locate:function(t){return R(this.parentGeom,Rt)&&this.parentGeom.getNumGeometries()>50?(null===this.areaPtLocator&&(this.areaPtLocator=new Un(this.parentGeom)),this.areaPtLocator.locate(t)):this.ptLocator.locate(t,this.parentGeom)},findEdge:function(){if(1===arguments.length){var t=arguments[0];return this.lineEdgeMap.get(t)}return Cn.prototype.findEdge.apply(this,arguments)},interfaces_:function(){return[]},getClass:function(){return $n}}),$n.determineBoundary=function(t,e){return t.isInBoundary(e)?L.BOUNDARY:L.INTERIOR},e(ti.prototype,{getArgGeometry:function(t){return this.arg[t].getGeometry()},setComputationPrecision:function(t){this.resultPrecisionModel=t,this.li.setPrecisionModel(this.resultPrecisionModel)},interfaces_:function(){return[]},getClass:function(){return ti}}),e(ei.prototype,{compareTo:function(t){var e=t,n=ei.compareOriented(this.pts,this._orientation,e.pts,e._orientation);return n},interfaces_:function(){return[s]},getClass:function(){return ei}}),ei.orientation=function(t){return 1===H.increasingDirection(t)},ei.compareOriented=function(t,e,n,i){for(var r=e?1:-1,s=i?1:-1,o=e?t.length:-1,a=i?n.length:-1,u=e?0:t.length-1,l=i?0:n.length-1;;){var h=t[u].compareTo(n[l]);if(0!==h)return h;u+=r,l+=s;var c=u===o,f=l===a;if(c&&!f)return-1;if(!c&&f)return 1;if(c&&f)return 0}},e(ni.prototype,{print:function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this.edges.size();e++){var n=this.edges.get(e);e>0&&t.print(","),t.print("(");for(var i=n.getCoordinates(),r=0;r<i.length;r++)r>0&&t.print(","),t.print(i[r].x+" "+i[r].y);t.println(")")}t.print(")  ")},addAll:function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next())},findEdgeIndex:function(t){for(var e=0;e<this.edges.size();e++)if(this.edges.get(e).equals(t))return e;return-1},iterator:function(){return this.edges.iterator()},getEdges:function(){return this.edges},get:function(t){return this.edges.get(t)},findEqualEdge:function(t){var e=new ei(t.getCoordinates()),n=this.ocaMap.get(e);return n},add:function(t){this.edges.add(t);var e=new ei(t.getCoordinates());this.ocaMap.put(e,t)},interfaces_:function(){return[]},getClass:function(){return ni}}),h(ii,ti),e(ii.prototype,{insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip());var r=e.getDepth();r.isNull()&&r.add(n),r.add(i),n.merge(i)}else this.edgeList.add(t)},getGraph:function(){return this.graph},cancelDuplicateResultEdges:function(){for(var t=this.graph.getEdgeEnds().iterator();t.hasNext();){var e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}},isCoveredByLA:function(t){return this.isCovered(t,this.resultLineList)?!0:!!this.isCovered(t,this.resultPolyList)},computeGeometry:function(t,e,n,i){var r=new I;return r.addAll(t),r.addAll(e),r.addAll(n),r.isEmpty()?ii.createEmptyResult(i,this.arg[0].getGeometry(),this.arg[1].getGeometry(),this.geomFact):this.geomFact.buildGeometry(r)},mergeSymLabels:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().mergeSymLabels()}},isCovered:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=this.ptLocator.locate(t,i);if(r!==L.EXTERIOR)return!0}return!1},replaceCollapsedEdges:function(){for(var t=new I,e=this.edgeList.iterator();e.hasNext();){var n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this.edgeList.addAll(t)},updateNodeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}},getResultGeometry:function(t){return this.computeOverlay(t),this.resultGeom},insertUniqueEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertUniqueEdge(n)}},computeOverlay:function(t){this.copyPoints(0),this.copyPoints(1),this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1),this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!0);var e=new I;this.arg[0].computeSplitEdges(e),this.arg[1].computeSplitEdges(e);this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),ln.checkValid(this.edgeList.getEdges()),this.graph.addEdges(this.edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),
this.cancelDuplicateResultEdges();var n=new Sn(this.geomFact);n.add(this.graph),this.resultPolyList=n.getPolygons();var i=new wn(this,this.geomFact,this.ptLocator);this.resultLineList=i.build(t);var r=new Ln(this,this.geomFact,this.ptLocator);this.resultPointList=r.build(t),this.resultGeom=this.computeGeometry(this.resultPointList,this.resultLineList,this.resultPolyList,t)},labelIncompleteNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setLocation(e,n)},copyPoints:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.graph.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},findResultAreaEdges:function(t){for(var e=this.graph.getEdgeEnds().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.isArea()&&!n.isInteriorAreaEdge()&&ii.isResultOfOp(i.getLocation(0,cn.RIGHT),i.getLocation(1,cn.RIGHT),t)&&n.setInResult(!0)}},computeLabelsFromDepths:function(){for(var t=this.edgeList.iterator();t.hasNext();){var e=t.next(),n=e.getLabel(),i=e.getDepth();if(!i.isNull()){i.normalize();for(var r=0;2>r;r++)n.isNull(r)||!n.isArea()||i.isNull(r)||(0===i.getDelta(r)?n.toLine(r):(f.isTrue(!i.isNull(r,cn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(r,cn.LEFT,i.getLocation(r,cn.LEFT)),f.isTrue(!i.isNull(r,cn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(r,cn.RIGHT,i.getLocation(r,cn.RIGHT))))}}},computeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}this.mergeSymLabels(),this.updateNodeLabelling()},labelIncompleteNodes:function(){for(var t=0,e=this.graph.getNodes().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(t++,i.isNull(0)?this.labelIncompleteNode(n,0):this.labelIncompleteNode(n,1)),n.getEdges().updateLabelling(i)}},isCoveredByA:function(t){return!!this.isCovered(t,this.resultPolyList)},interfaces_:function(){return[]},getClass:function(){return ii}}),ii.overlayOp=function(t,e,n){var i=new ii(t,e),r=i.getResultGeometry(n);return r},ii.intersection=function(t,e){if(t.isEmpty()||e.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){var n=e;return hn.map(t,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(n)}})}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.INTERSECTION)},ii.symDifference=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.SYMDIFFERENCE)},ii.resultDimension=function(t,e,n){var i=e.getDimension(),r=n.getDimension(),s=-1;switch(t){case ii.INTERSECTION:s=Math.min(i,r);break;case ii.UNION:s=Math.max(i,r);break;case ii.DIFFERENCE:s=i;break;case ii.SYMDIFFERENCE:s=Math.max(i,r)}return s},ii.createEmptyResult=function(t,e,n,i){var r=null;switch(ii.resultDimension(t,e,n)){case-1:r=i.createGeometryCollection(new Array(0).fill(null));break;case 0:r=i.createPoint();break;case 1:r=i.createLineString();break;case 2:r=i.createPolygon()}return r},ii.difference=function(t,e){return t.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,t,e,t.getFactory()):e.isEmpty()?t.copy():(t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.DIFFERENCE))},ii.isResultOfOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=t.getLocation(0),i=t.getLocation(1);return ii.isResultOfOp(n,i,e)}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];switch(r===L.BOUNDARY&&(r=L.INTERIOR),s===L.BOUNDARY&&(s=L.INTERIOR),o){case ii.INTERSECTION:return r===L.INTERIOR&&s===L.INTERIOR;case ii.UNION:return r===L.INTERIOR||s===L.INTERIOR;case ii.DIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR;case ii.SYMDIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR||r!==L.INTERIOR&&s===L.INTERIOR}return!1}},ii.INTERSECTION=1,ii.UNION=2,ii.DIFFERENCE=3,ii.SYMDIFFERENCE=4,e(ri.prototype,{selfSnap:function(t){var e=new Ie(t),n=e.snapTo(t,this.snapTolerance);return n},removeCommonBits:function(t){this.cbr=new Se,this.cbr.add(t[0]),this.cbr.add(t[1]);var e=new Array(2).fill(null);return e[0]=this.cbr.removeCommonBits(t[0].copy()),e[1]=this.cbr.removeCommonBits(t[1].copy()),e},prepareResult:function(t){return this.cbr.addCommonBits(t),t},getResultGeometry:function(t){var e=this.snap(this.geom),n=ii.overlayOp(e[0],e[1],t);return this.prepareResult(n)},checkValid:function(t){t.isValid()||A.out.println("Snapped geometry is invalid")},computeSnapTolerance:function(){this.snapTolerance=Ie.computeOverlaySnapTolerance(this.geom[0],this.geom[1])},snap:function(t){var e=this.removeCommonBits(t),n=Ie.snap(e[0],e[1],this.snapTolerance);return n},interfaces_:function(){return[]},getClass:function(){return ri}}),ri.overlayOp=function(t,e,n){var i=new ri(t,e);return i.getResultGeometry(n)},ri.union=function(t,e){return ri.overlayOp(t,e,ii.UNION)},ri.intersection=function(t,e){return ri.overlayOp(t,e,ii.INTERSECTION)},ri.symDifference=function(t,e){return ri.overlayOp(t,e,ii.SYMDIFFERENCE)},ri.difference=function(t,e){return ri.overlayOp(t,e,ii.DIFFERENCE)},e(si.prototype,{getResultGeometry:function(t){var e=null,n=!1,i=null;try{e=ii.overlayOp(this.geom[0],this.geom[1],t);var r=!0;r&&(n=!0)}catch(s){if(!(s instanceof l))throw s;i=s}finally{}if(!n)try{e=ri.overlayOp(this.geom[0],this.geom[1],t)}catch(s){throw s instanceof l?i:s}finally{}return e},interfaces_:function(){return[]},getClass:function(){return si}}),si.overlayOp=function(t,e,n){var i=new si(t,e);return i.getResultGeometry(n)},si.union=function(t,e){return si.overlayOp(t,e,ii.UNION)},si.intersection=function(t,e){return si.overlayOp(t,e,ii.INTERSECTION)},si.symDifference=function(t,e){return si.overlayOp(t,e,ii.SYMDIFFERENCE)},si.difference=function(t,e){return si.overlayOp(t,e,ii.DIFFERENCE)},e(oi.prototype,{addPolygon:function(t){if(t.isEmpty())return null;var e=null,n=0,i=this.horizontalBisector(t);if(0===i.getLength())n=0,e=i.getCoordinate();else{var r=si.overlayOp(i,t,ii.INTERSECTION),s=this.widestGeometry(r);n=s.getEnvelopeInternal().getWidth(),e=oi.centre(s.getEnvelopeInternal())}(null===this.interiorPoint||n>this.maxWidth)&&(this.interiorPoint=e,this.maxWidth=n)},getInteriorPoint:function(){return this.interiorPoint},widestGeometry:function zo(){if(arguments[0]instanceof ft){var t=arguments[0];if(t.isEmpty())return t;for(var zo=t.getGeometryN(0),e=1;e<t.getNumGeometries();e++)t.getGeometryN(e).getEnvelopeInternal().getWidth()>zo.getEnvelopeInternal().getWidth()&&(zo=t.getGeometryN(e));return zo}if(arguments[0]instanceof B){var n=arguments[0];return n instanceof ft?this.widestGeometry(n):n}},horizontalBisector:function(t){var e=t.getEnvelopeInternal(),n=ai.getBisectorY(t);return this.factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])},add:function(t){if(t instanceof Tt)this.addPolygon(t);else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))},interfaces_:function(){return[]},getClass:function(){return oi}}),oi.centre=function(t){return new g(oi.avg(t.getMinX(),t.getMaxX()),oi.avg(t.getMinY(),t.getMaxY()))},oi.avg=function(t,e){return(t+e)/2},e(ai.prototype,{updateInterval:function(t){t<=this.centreY?t>this.loY&&(this.loY=t):t>this.centreY&&t<this.hiY&&(this.hiY=t)},getBisectorY:function(){this.process(this.poly.getExteriorRing());for(var t=0;t<this.poly.getNumInteriorRing();t++)this.process(this.poly.getInteriorRingN(t));var e=oi.avg(this.hiY,this.loY);return e},process:function(t){for(var e=t.getCoordinateSequence(),n=0;n<e.size();n++){var i=e.getY(n);this.updateInterval(i)}},interfaces_:function(){return[]},getClass:function(){return ai}}),ai.getBisectorY=function(t){var e=new ai(t);return e.getBisectorY()},oi.SafeBisectorFinder=ai,e(ui.prototype,{addEndpoints:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addEndpoints(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addEndpoints(e.getGeometryN(n))}else if(arguments[0]instanceof Array){var i=arguments[0];this.add(i[0]),this.add(i[i.length-1])}},getInteriorPoint:function(){return this.interiorPoint},addInterior:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addInterior(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addInterior(e.getGeometryN(n))}else if(arguments[0]instanceof Array)for(var i=arguments[0],n=1;n<i.length-1;n++)this.add(i[n])},add:function(t){var e=t.distance(this.centroid);e<this.minDistance&&(this.interiorPoint=new g(t),this.minDistance=e)},interfaces_:function(){return[]},getClass:function(){return ui}}),e(li.prototype,{getInteriorPoint:function(){return this.interiorPoint},add:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof Lt)this.add(t.getCoordinate());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))}else if(arguments[0]instanceof g){var i=arguments[0],r=i.distance(this.centroid);r<this.minDistance&&(this.interiorPoint=new g(i),this.minDistance=r)}},interfaces_:function(){return[]},getClass:function(){return li}}),e(hi.prototype,{select:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){var t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}},interfaces_:function(){return[]},getClass:function(){return hi}}),e(ci.prototype,{hasChildren:function(){for(var t=0;2>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;2>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},size:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){return null===t||this.isSearchMatch(t)?(e.addAll(this.items),null!==this.subnode[0]&&this.subnode[0].addAllItemsFromOverlapping(t,e),void(null!==this.subnode[1]&&this.subnode[1].addAllItemsFromOverlapping(t,e))):null},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;2>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;2>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},nodeSize:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].nodeSize());return t+1},add:function(t){this.items.add(t)},interfaces_:function(){return[]},getClass:function(){return ci}}),ci.getSubnodeIndex=function(t,e){var n=-1;return t.min>=e&&(n=1),t.max<=e&&(n=0),n},e(fi.prototype,{expandToInclude:function(t){t.max>this.max&&(this.max=t.max),t.min<this.min&&(this.min=t.min)},getWidth:function(){return this.max-this.min},overlaps:function(){if(1===arguments.length){var t=arguments[0];return this.overlaps(t.min,t.max)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return!(this.min>n||this.max<e)}},getMin:function(){return this.min},toString:function(){return"["+this.min+", "+this.max+"]"},contains:function(){if(1===arguments.length){if(arguments[0]instanceof fi){var t=arguments[0];return this.contains(t.min,t.max)}if("number"==typeof arguments[0]){var e=arguments[0];return e>=this.min&&e<=this.max}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return n>=this.min&&i<=this.max}},init:function(t,e){this.min=t,this.max=e,t>e&&(this.min=e,this.max=t)},getMax:function(){return this.max},interfaces_:function(){return[]},getClass:function(){return fi}}),gi.exponent=function(t){return di(64,t)-1023},gi.powerOf2=function(t){return Math.pow(2,t)},e(pi.prototype,{getInterval:function(){return this.interval},getLevel:function(){return this.level},computeKey:function(t){for(this.level=pi.computeLevel(t),this.interval=new fi,this.computeInterval(this.level,t);!this.interval.contains(t);)this.level+=1,this.computeInterval(this.level,t)},computeInterval:function(t,e){var n=gi.powerOf2(t);this.pt=Math.floor(e.getMin()/n)*n,this.interval.init(this.pt,this.pt+n)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return pi}}),pi.computeLevel=function(t){var e=t.getWidth(),n=gi.exponent(e)+1;return n},h(vi,ci),e(vi.prototype,{getInterval:function(){return this.interval},find:function(t){var e=ci.getSubnodeIndex(t,this.centre);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},insert:function(t){f.isTrue(null===this.interval||this.interval.contains(t.interval));var e=ci.getSubnodeIndex(t.interval,this.centre);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insert(t),this.subnode[e]=n}},isSearchMatch:function(t){return t.overlaps(this.interval)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getNode:function(t){var e=ci.getSubnodeIndex(t,this.centre);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0;switch(t){case 0:e=this.interval.getMin(),n=this.centre;break;case 1:e=this.centre,n=this.interval.getMax()}var i=new fi(e,n),r=new vi(i,this.level-1);return r},interfaces_:function(){return[]},getClass:function(){return vi}}),vi.createNode=function(t){var e=new pi(t),n=new vi(e.getInterval(),e.getLevel());return n},vi.createExpanded=function(t,e){var n=new fi(e);null!==t&&n.expandToInclude(t.interval);var i=vi.createNode(n);return null!==t&&i.insert(t),i},e(mi.prototype,{interfaces_:function(){return[]},getClass:function(){return mi}}),mi.isZeroWidth=function(t,e){var n=e-t;if(0===n)return!0;var i=Math.max(Math.abs(t),Math.abs(e)),r=n/i,s=gi.exponent(r);return s<=mi.MIN_BINARY_EXPONENT},mi.MIN_BINARY_EXPONENT=-50,h(yi,ci),e(yi.prototype,{insert:function(t,e){var n=ci.getSubnodeIndex(t,yi.origin);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getInterval().contains(t)){var r=vi.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getInterval().contains(e));var i=mi.isZeroWidth(e.getMin(),e.getMax()),r=null;r=i?t.find(e):t.getNode(e),r.add(n)},interfaces_:function(){return[]},getClass:function(){return yi}}),yi.origin=0,e(xi.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=xi.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];return this.query(new fi(t,t))}if(arguments[0]instanceof fi){var e=arguments[0],n=new I;return this.query(e,n),n}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.root.addAllItemsFromOverlapping(i,r)}},iterator:function(){var t=new I;return this.root.addAllItems(t),t.iterator()},remove:function(t,e){var n=xi.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e)},depth:function(){return null!==this.root?this.root.depth():0},nodeSize:function(){return null!==this.root?this.root.nodeSize():0},interfaces_:function(){return[]},getClass:function(){return xi}}),xi.ensureExtent=function(t,e){var n=t.getMin(),i=t.getMax();return n!==i?t:(n===i&&(n-=e/2,i=n+e/2),new fi(n,i))},e(Ei.prototype,{isInside:function(t){},interfaces_:function(){return[]},getClass:function(){return Ei}}),e(Ii.prototype,{testLineSegment:function(t,e){var n=null,i=null,r=null,s=null,o=null,a=e.p0,u=e.p1;i=a.x-t.x,r=a.y-t.y,s=u.x-t.x,o=u.y-t.y,(r>0&&0>=o||o>0&&0>=r)&&(n=ue.signOfDet2x2(i,r,s,o)/(o-r),n>0&&this.crossings++)},buildIndex:function(){this.tree=new xi;for(var t=H.removeRepeatedPoints(this.ring.getCoordinates()),e=$e.getChains(t),n=0;n<e.size();n++){var i=e.get(n),r=i.getEnvelope();this.interval.min=r.getMinY(),this.interval.max=r.getMaxY(),this.tree.insert(this.interval,i)}},testMonotoneChain:function(t,e,n){n.select(t,e)},isInside:function(t){this.crossings=0;var e=new C(r.NEGATIVE_INFINITY,r.POSITIVE_INFINITY,t.y,t.y);this.interval.min=t.y,this.interval.max=t.y;for(var n=this.tree.query(this.interval),i=new Ni(this,t),s=n.iterator();s.hasNext();){var o=s.next();this.testMonotoneChain(e,i,o)}return this.crossings%2===1},interfaces_:function(){return[Ei]},getClass:function(){return Ii}}),h(Ni,hi),e(Ni.prototype,{select:function(){if(1!==arguments.length)return hi.prototype.select.apply(this,arguments);var t=arguments[0];this.mcp.testLineSegment(this.p,t)},interfaces_:function(){return[]},getClass:function(){return Ni}}),Ii.MCSelecter=Ni,e(Ci.prototype,{interfaces_:function(){return[]},getClass:function(){return Ci}}),Ci.toDegrees=function(t){return 180*t/Math.PI},Ci.normalize=function(t){for(;t>Math.PI;)t-=Ci.PI_TIMES_2;for(;t<=-Math.PI;)t+=Ci.PI_TIMES_2;return t},Ci.angle=function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],i=n.x-e.x,r=n.y-e.y;return Math.atan2(r,i)}},Ci.isAcute=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return a>0},Ci.isObtuse=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return 0>a},Ci.interiorAngle=function(t,e,n){var i=Ci.angle(e,t),r=Ci.angle(e,n);return Math.abs(r-i)},Ci.normalizePositive=function(t){if(0>t){for(;0>t;)t+=Ci.PI_TIMES_2;t>=Ci.PI_TIMES_2&&(t=0)}else{for(;t>=Ci.PI_TIMES_2;)t-=Ci.PI_TIMES_2;0>t&&(t=0)}return t},Ci.angleBetween=function(t,e,n){var i=Ci.angle(e,t),r=Ci.angle(e,n);return Ci.diff(i,r)},Ci.diff=function(t,e){var n=null;return n=e>t?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n},Ci.toRadians=function(t){return t*Math.PI/180},Ci.getTurn=function(t,e){var n=Math.sin(e-t);return n>0?Ci.COUNTERCLOCKWISE:0>n?Ci.CLOCKWISE:Ci.NONE},Ci.angleBetweenOriented=function(t,e,n){var i=Ci.angle(e,t),r=Ci.angle(e,n),s=r-i;return s<=-Math.PI?s+Ci.PI_TIMES_2:s>Math.PI?s-Ci.PI_TIMES_2:s},Ci.PI_TIMES_2=2*Math.PI,Ci.PI_OVER_2=Math.PI/2,Ci.PI_OVER_4=Math.PI/4,Ci.COUNTERCLOCKWISE=he.COUNTERCLOCKWISE,Ci.CLOCKWISE=he.CLOCKWISE,Ci.NONE=he.COLLINEAR,e(Si.prototype,{area:function(){return Si.area(this.p0,this.p1,this.p2)},signedArea:function(){return Si.signedArea(this.p0,this.p1,this.p2)},interpolateZ:function(t){if(null===t)throw new i("Supplied point is null.");return Si.interpolateZ(t,this.p0,this.p1,this.p2)},longestSideLength:function(){return Si.longestSideLength(this.p0,this.p1,this.p2)},isAcute:function(){return Si.isAcute(this.p0,this.p1,this.p2)},circumcentre:function(){return Si.circumcentre(this.p0,this.p1,this.p2)},area3D:function(){return Si.area3D(this.p0,this.p1,this.p2)},centroid:function(){return Si.centroid(this.p0,this.p1,this.p2)},inCentre:function(){return Si.inCentre(this.p0,this.p1,this.p2)},interfaces_:function(){return[]},getClass:function(){return Si}}),Si.area=function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)},Si.signedArea=function(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2},Si.det=function(t,e,n,i){return t*i-e*n},Si.interpolateZ=function(t,e,n,i){var r=e.x,s=e.y,o=n.x-r,a=i.x-r,u=n.y-s,l=i.y-s,h=o*l-a*u,c=t.x-r,f=t.y-s,g=(l*c-a*f)/h,d=(-u*c+o*f)/h,p=e.z+g*(n.z-e.z)+d*(i.z-e.z);return p},Si.longestSideLength=function(t,e,n){var i=t.distance(e),r=e.distance(n),s=n.distance(t),o=i;return r>o&&(o=r),s>o&&(o=s),o},Si.isAcute=function(t,e,n){return Ci.isAcute(t,e,n)&&Ci.isAcute(e,n,t)?!!Ci.isAcute(n,t,e):!1},Si.circumcentre=function(t,e,n){var i=n.x,r=n.y,s=t.x-i,o=t.y-r,a=e.x-i,u=e.y-r,l=2*Si.det(s,o,a,u),h=Si.det(o,s*s+o*o,u,a*a+u*u),c=Si.det(s,s*s+o*o,a,a*a+u*u),f=i-h/l,d=r+c/l;return new g(f,d)},Si.perpendicularBisector=function(t,e){var n=e.x-t.x,i=e.y-t.y,r=new F(t.x+n/2,t.y+i/2,1),s=new F(t.x-i+n/2,t.y+n+i/2,1);return new F(r,s)},Si.angleBisector=function(t,e,n){var i=e.distance(t),r=e.distance(n),s=i/(i+r),o=n.x-t.x,a=n.y-t.y,u=new g(t.x+s*o,t.y+s*a);return u},Si.area3D=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=e.z-t.z,o=n.x-t.x,a=n.y-t.y,u=n.z-t.z,l=r*u-s*a,h=s*o-i*u,c=i*a-r*o,f=l*l+h*h+c*c,g=Math.sqrt(f)/2;return g},Si.centroid=function(t,e,n){var i=(t.x+e.x+n.x)/3,r=(t.y+e.y+n.y)/3;return new g(i,r)},Si.inCentre=function(t,e,n){var i=e.distance(n),r=t.distance(n),s=t.distance(e),o=i+r+s,a=(i*t.x+r*e.x+s*n.x)/o,u=(i*t.y+r*e.y+s*n.y)/o;return new g(a,u)},e(wi.prototype,{getRadius:function(){return this.compute(),this.radius},getDiameter:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[1];return this.input.getFactory().createLineString([t,e])},getExtremalPoints:function(){return this.compute(),this.extremalPts},computeCirclePoints:function(){if(this.input.isEmpty())return this.extremalPts=new Array(0).fill(null),null;if(1===this.input.getNumPoints()){var t=this.input.getCoordinates();return this.extremalPts=[new g(t[0])],null}var e=this.input.convexHull(),n=e.getCoordinates(),t=n;if(n[0].equals2D(n[n.length-1])&&(t=new Array(n.length-1).fill(null),H.copyDeep(n,0,t,0,n.length-1)),t.length<=2)return this.extremalPts=H.copyDeep(t),null;for(var i=wi.lowestPoint(t),r=wi.pointWitMinAngleWithX(t,i),s=0;s<t.length;s++){var o=wi.pointWithMinAngleWithSegment(t,i,r);if(Ci.isObtuse(i,o,r))return this.extremalPts=[new g(i),new g(r)],null;if(Ci.isObtuse(o,i,r))i=o;else{if(!Ci.isObtuse(o,r,i))return this.extremalPts=[new g(i),new g(r),new g(o)],null;r=o}}f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")},compute:function(){return null!==this.extremalPts?null:(this.computeCirclePoints(),this.computeCentre(),void(null!==this.centre&&(this.radius=this.centre.distance(this.extremalPts[0]))))},getFarthestPoints:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[this.extremalPts.length-1];return this.input.getFactory().createLineString([t,e])},getCircle:function(){if(this.compute(),null===this.centre)return this.input.getFactory().createPolygon();var t=this.input.getFactory().createPoint(this.centre);return 0===this.radius?t:t.buffer(this.radius)},getCentre:function(){return this.compute(),this.centre},computeCentre:function(){switch(this.extremalPts.length){case 0:this.centre=null;break;case 1:this.centre=this.extremalPts[0];break;case 2:this.centre=new g((this.extremalPts[0].x+this.extremalPts[1].x)/2,(this.extremalPts[0].y+this.extremalPts[1].y)/2);break;case 3:this.centre=Si.circumcentre(this.extremalPts[0],this.extremalPts[1],this.extremalPts[2])}},interfaces_:function(){return[]},getClass:function(){return wi}}),wi.pointWitMinAngleWithX=function(t,e){for(var n=r.MAX_VALUE,i=null,s=0;s<t.length;s++){var o=t[s];if(o!==e){var a=o.x-e.x,u=o.y-e.y;0>u&&(u=-u);var l=Math.sqrt(a*a+u*u),h=u/l;n>h&&(n=h,i=o)}}return i},wi.lowestPoint=function(t){for(var e=t[0],n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e},wi.pointWithMinAngleWithSegment=function(t,e,n){for(var i=r.MAX_VALUE,s=null,o=0;o<t.length;o++){var a=t[o];if(a!==e&&a!==n){var u=Ci.angleBetween(e,a,n);i>u&&(i=u,s=a)}}return s},e(Li.prototype,{getWidthCoordinate:function(){return this.computeMinimumDiameter(),this.minWidthPt},getSupportingSegment:function(){return this.computeMinimumDiameter(),this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0,this.minBaseSeg.p1])},getDiameter:function(){if(this.computeMinimumDiameter(),null===this.minWidthPt)return this.inputGeom.getFactory().createLineString(null);var t=this.minBaseSeg.project(this.minWidthPt);return this.inputGeom.getFactory().createLineString([t,this.minWidthPt])},computeWidthConvex:function(t){t instanceof Tt?this.convexHullPts=t.getExteriorRing().getCoordinates():this.convexHullPts=t.getCoordinates(),0===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=null,this.minBaseSeg=null):1===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[0]):2===this.convexHullPts.length||3===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[1]):this.computeConvexRingMinDiameter(this.convexHullPts)},computeConvexRingMinDiameter:function(t){this.minWidth=r.MAX_VALUE;for(var e=1,n=new ce,i=0;i<t.length-1;i++)n.p0=t[i],n.p1=t[i+1],e=this.findMaxPerpDistance(t,n,e)},computeMinimumDiameter:function(){if(null!==this.minWidthPt)return null;if(this.isConvex)this.computeWidthConvex(this.inputGeom);else{var t=new me(this.inputGeom).getConvexHull();this.computeWidthConvex(t)}},getLength:function(){return this.computeMinimumDiameter(),this.minWidth},findMaxPerpDistance:function(t,e,n){for(var i=e.distancePerpendicular(t[n]),r=i,s=n,o=s;r>=i;)i=r,s=o,o=Li.nextIndex(t,s),r=e.distancePerpendicular(t[o]);return i<this.minWidth&&(this.minPtIndex=s,this.minWidth=i,this.minWidthPt=t[this.minPtIndex],this.minBaseSeg=new ce(e)),s},getMinimumRectangle:function(){if(this.computeMinimumDiameter(),0===this.minWidth)return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)?this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0):this.minBaseSeg.toGeometry(this.inputGeom.getFactory());for(var t=this.minBaseSeg.p1.x-this.minBaseSeg.p0.x,e=this.minBaseSeg.p1.y-this.minBaseSeg.p0.y,n=r.MAX_VALUE,i=-r.MAX_VALUE,s=r.MAX_VALUE,o=-r.MAX_VALUE,a=0;a<this.convexHullPts.length;a++){var u=Li.computeC(t,e,this.convexHullPts[a]);u>i&&(i=u),n>u&&(n=u);var l=Li.computeC(-e,t,this.convexHullPts[a]);l>o&&(o=l),s>l&&(s=l)}var h=Li.computeSegmentForLine(-t,-e,o),c=Li.computeSegmentForLine(-t,-e,s),f=Li.computeSegmentForLine(-e,t,i),g=Li.computeSegmentForLine(-e,t,n),d=f.lineIntersection(h),p=g.lineIntersection(h),v=g.lineIntersection(c),m=f.lineIntersection(c),y=this.inputGeom.getFactory().createLinearRing([d,p,v,m,d]);return this.inputGeom.getFactory().createPolygon(y,null)},interfaces_:function(){return[]},getClass:function(){return Li}}),Li.nextIndex=function(t,e){return e++,e>=t.length&&(e=0),e},Li.computeC=function(t,e,n){return t*n.y-e*n.x},Li.getMinimumDiameter=function(t){return new Li(t).getDiameter()},Li.getMinimumRectangle=function(t){return new Li(t).getMinimumRectangle()},Li.computeSegmentForLine=function(t,e,n){var i=null,r=null;return Math.abs(e)>Math.abs(t)?(i=new g(0,n/e),r=new g(1,n/e-t/e)):(i=new g(n/t,0),r=new g(n/t-e/t,1)),new ce(i,r)};var co=Object.freeze({Centroid:ge,CGAlgorithms:he,ConvexHull:me,InteriorPointArea:oi,InteriorPointLine:ui,InteriorPointPoint:li,RobustLineIntersector:ae,MCPointInRing:Ii,MinimumBoundingCircle:wi,MinimumDiameter:Li});e(Ri.prototype,{getResultGeometry:function(){return new Ti(this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>=t)throw new i("Tolerance must be positive");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return Ri}}),Ri.densifyPoints=function(t,e,n){for(var i=new ce,r=new N,s=0;s<t.length-1;s++){i.p0=t[s],i.p1=t[s+1],r.add(i.p0,!1);var o=i.getLength(),a=Math.trunc(o/e)+1;if(a>1)for(var u=o/a,l=1;a>l;l++){var h=l*u/o,c=i.pointAlong(h);n.makePrecise(c),r.add(c,!1)}}return r.add(t[t.length-1],!1),r.toCoordinateArray()},Ri.densify=function(t,e){var n=new Ri(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(Ti,xe),e(Ti.prototype,{transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformPolygon:function(t,e){var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=Ri.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof St&&1===i.length&&(i=new Array(0).fill(null)),this.factory.getCoordinateSequenceFactory().create(i)},createValidArea:function(t){return t.buffer(0)},interfaces_:function(){return[]},getClass:function(){return Ti}}),Ri.DensifyTransformer=Ti;var fo=Object.freeze({Densifier:Ri});e(Pi.prototype,{find:function(t){var e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null},dest:function(){return this._sym._orig},oNext:function(){return this._sym._next},insert:function(t){if(this.oNext()===this)return this.insertAfter(t),null;var e=this.compareTo(t),n=this;do{var i=n.oNext(),r=i.compareTo(t);if(r!==e||i===this)return n.insertAfter(t),null;n=i}while(n!==this);f.shouldNeverReachHere()},insertAfter:function(t){f.equals(this._orig,t.orig());var e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)},degree:function Vo(){var Vo=0,t=this;do Vo++,t=t.oNext();while(t!==this);return Vo},equals:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}},deltaY:function(){return this._sym._orig.y-this._orig.y},sym:function(){return this._sym},prev:function(){return this._sym.next()._sym},compareAngularDirection:function(t){var e=this.deltaX(),n=this.deltaY(),i=t.deltaX(),r=t.deltaY();if(e===i&&n===r)return 0;var s=Je.quadrant(e,n),o=Je.quadrant(i,r);return s>o?1:o>s?-1:he.computeOrientation(t._orig,t.dest(),this.dest())},prevNode:function(){for(var t=this;2===t.degree();)if(t=t.prev(),t===this)return null;return t},compareTo:function(t){var e=t,n=this.compareAngularDirection(e);return n},next:function(){return this._next},setSym:function(t){this._sym=t},orig:function(){return this._orig},toString:function(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"},setNext:function(t){this._next=t},init:function(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)},deltaX:function(){return this._sym._orig.x-this._orig.x},interfaces_:function(){return[]},getClass:function(){return Pi}}),Pi.init=function(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t},Pi.create=function(t,e){var n=new Pi(t),i=new Pi(e);return n.init(i),n},h(bi,Pi),e(bi.prototype,{mark:function(){this._isMarked=!0},setMark:function(t){this._isMarked=t},isMarked:function(){return this._isMarked},interfaces_:function(){return[]},getClass:function(){return bi}}),bi.setMarkBoth=function(t,e){t.setMark(e),t.sym().setMark(e)},bi.isMarked=function(t){return t.isMarked()},bi.setMark=function(t,e){t.setMark(e)},bi.markBoth=function(t){t.mark(),t.sym().mark()},bi.mark=function(t){t.mark()},e(Oi.prototype,{insert:function(t,e,n){var i=this.create(t,e);null!==n?n.insert(i):this.vertexMap.put(t,i);var r=this.vertexMap.get(e);return null!==r?r.insert(i.sym()):this.vertexMap.put(e,i.sym()),i},create:function(t,e){var n=this.createEdge(t),i=this.createEdge(e);return Pi.init(n,i),n},createEdge:function(t){return new Pi(t)},addEdge:function(t,e){if(!Oi.isValidEdge(t,e))return null;var n=this.vertexMap.get(t),i=null;if(null!==n&&(i=n.find(e)),null!==i)return i;var r=this.insert(t,e,n);return r},getVertexEdges:function(){return this.vertexMap.values()},findEdge:function(t,e){var n=this.vertexMap.get(t);return null===n?null:n.find(e)},interfaces_:function(){return[]},getClass:function(){return Oi}}),Oi.isValidEdge=function(t,e){var n=e.compareTo(t);return 0!==n},h(_i,bi),e(_i.prototype,{setStart:function(){this._isStart=!0;
},isStart:function(){return this._isStart},interfaces_:function(){return[]},getClass:function(){return _i}}),h(Mi,Oi),e(Mi.prototype,{createEdge:function(t){return new _i(t)},interfaces_:function(){return[]},getClass:function(){return Mi}}),e(Di.prototype,{addLine:function(t){this.lines.add(this.factory.createLineString(t.toCoordinateArray()))},updateRingStartEdge:function(t){return t.isStart()||(t=t.sym(),t.isStart())?null===this.ringStartEdge?(this.ringStartEdge=t,null):void(t.orig().compareTo(this.ringStartEdge.orig())<0&&(this.ringStartEdge=t)):null},getResult:function(){return null===this.result&&this.computeResult(),this.result},process:function(t){var e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()},buildRing:function(t){var e=new N,n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){var i=n.next();if(i===t)break;e.add(i.orig().copy(),!1),n=i}e.add(n.dest().copy(),!1),this.addLine(e)},buildLine:function(t){var e=new N,n=t;for(this.ringStartEdge=null,bi.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);var i=n.next();if(i===t)return this.buildRing(this.ringStartEdge),null;e.add(i.orig().copy(),!1),n=i,bi.markBoth(n)}e.add(n.dest().copy(),!1),this.stackEdges(n.sym()),this.addLine(e)},stackEdges:function(t){var e=t;do bi.isMarked(e)||this.nodeEdgeStack.add(e),e=e.oNext();while(e!==t)},computeResult:function(){for(var t=this.graph.getVertexEdges(),e=t.iterator();e.hasNext();){var n=e.next();bi.isMarked(n)||this.process(n)}this.result=this.factory.buildGeometry(this.lines)},buildLines:function(){for(;!this.nodeEdgeStack.empty();){var t=this.nodeEdgeStack.pop();bi.isMarked(t)||this.buildLine(t)}},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v))for(var e=arguments[0],n=e.iterator();n.hasNext();){var i=n.next();this.add(i)}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory());for(var s=r.getCoordinateSequence(),o=!1,n=1;n<s.size();n++){var a=this.graph.addEdge(s.getCoordinate(n-1),s.getCoordinate(n));null!==a&&(o||(a.setStart(),o=!0))}}},interfaces_:function(){return[]},getClass:function(){return Di}}),Di.dissolve=function(t){var e=new Di;return e.add(t),e.getResult()};var go=Object.freeze({LineDissolver:Di}),po=Object.freeze({GeometryGraph:$n});e(Ai.prototype,{hasChildren:function(){for(var t=0;4>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;4>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},getNodeCount:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+1},size:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this.items);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].addAllItemsFromOverlapping(t,e)},visitItems:function(t,e){for(var n=this.items.iterator();n.hasNext();)e.visitItem(n.next())},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;4>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},visit:function(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].visit(t,e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;4>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},isEmpty:function ko(){var ko=!0;this.items.isEmpty()||(ko=!1);for(var t=0;4>t;t++)null!==this.subnode[t]&&(this.subnode[t].isEmpty()||(ko=!1));return ko},add:function(t){this.items.add(t)},interfaces_:function(){return[u]},getClass:function(){return Ai}}),Ai.getSubnodeIndex=function(t,e,n){var i=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(i=3),t.getMaxY()<=n&&(i=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(i=2),t.getMaxY()<=n&&(i=0)),i},e(Fi.prototype,{getLevel:function(){return this.level},computeKey:function(){if(1===arguments.length){var t=arguments[0];for(this.level=Fi.computeQuadLevel(t),this.env=new C,this.computeKey(this.level,t);!this.env.contains(t);)this.level+=1,this.computeKey(this.level,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=gi.powerOf2(e);this.pt.x=Math.floor(n.getMinX()/i)*i,this.pt.y=Math.floor(n.getMinY()/i)*i,this.env.init(this.pt.x,this.pt.x+i,this.pt.y,this.pt.y+i)}},getEnvelope:function(){return this.env},getCentre:function(){return new g((this.env.getMinX()+this.env.getMaxX())/2,(this.env.getMinY()+this.env.getMaxY())/2)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return Fi}}),Fi.computeQuadLevel=function(t){var e=t.getWidth(),n=t.getHeight(),i=e>n?e:n,r=gi.exponent(i)+1;return r},h(Gi,Ai),e(Gi.prototype,{find:function(t){var e=Ai.getSubnodeIndex(t,this.centrex,this.centrey);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},isSearchMatch:function(t){return this.env.intersects(t)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getEnvelope:function(){return this.env},getNode:function(t){var e=Ai.getSubnodeIndex(t,this.centrex,this.centrey);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0,i=0,r=0;switch(t){case 0:e=this.env.getMinX(),n=this.centrex,i=this.env.getMinY(),r=this.centrey;break;case 1:e=this.centrex,n=this.env.getMaxX(),i=this.env.getMinY(),r=this.centrey;break;case 2:e=this.env.getMinX(),n=this.centrex,i=this.centrey,r=this.env.getMaxY();break;case 3:e=this.centrex,n=this.env.getMaxX(),i=this.centrey,r=this.env.getMaxY()}var s=new C(e,n,i,r),o=new Gi(s,this.level-1);return o},insertNode:function(t){f.isTrue(null===this.env||this.env.contains(t.env));var e=Ai.getSubnodeIndex(t.env,this.centrex,this.centrey);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insertNode(t),this.subnode[e]=n}},interfaces_:function(){return[]},getClass:function(){return Gi}}),Gi.createNode=function(t){var e=new Fi(t),n=new Gi(e.getEnvelope(),e.getLevel());return n},Gi.createExpanded=function(t,e){var n=new C(e);null!==t&&n.expandToInclude(t.env);var i=Gi.createNode(n);return null!==t&&i.insertNode(t),i},h(qi,Ai),e(qi.prototype,{insert:function(t,e){var n=Ai.getSubnodeIndex(t,qi.origin.x,qi.origin.y);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getEnvelope().contains(t)){var r=Gi.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getEnvelope().contains(e));var i=mi.isZeroWidth(e.getMinX(),e.getMaxX()),r=mi.isZeroWidth(e.getMinY(),e.getMaxY()),s=null;s=i||r?t.find(e):t.getNode(e),s.add(n)},interfaces_:function(){return[]},getClass:function(){return qi}}),qi.origin=new g(0,0),e(Bi.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=Bi.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){var t=arguments[0],e=new Yn;return this.query(t,e),e.getItems()}if(2===arguments.length){var n=arguments[0],i=arguments[1];this.root.visit(n,i)}},queryAll:function(){var t=new I;return this.root.addAllItems(t),t},remove:function(t,e){var n=Bi.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e);var n=t.getHeight();n<this.minExtent&&n>0&&(this.minExtent=n)},depth:function(){return null!==this.root?this.root.depth():0},isEmpty:function(){return null===this.root},interfaces_:function(){return[Fe,u]},getClass:function(){return Bi}}),Bi.ensureExtent=function(t,e){var n=t.getMinX(),i=t.getMaxX(),r=t.getMinY(),s=t.getMaxY();return n!==i&&r!==s?t:(n===i&&(n-=e/2,i=n+e/2),r===s&&(r-=e/2,s=r+e/2),new C(n,i,r,s))},Bi.serialVersionUID=-0x678b60c967a25400;var vo=Object.freeze({Quadtree:Bi}),mo=Object.freeze({STRtree:ke}),yo=Object.freeze({quadtree:vo,strtree:mo}),xo=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];e(zi.prototype,{read:function(t){var e=void 0;e="string"==typeof t?JSON.parse(t):t;var n=e.type;if(!Eo[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==xo.indexOf(n)?Eo[n].apply(this,[e.coordinates]):"GeometryCollection"===n?Eo[n].apply(this,[e.geometries]):Eo[n].apply(this,[e])},write:function(t){var e=t.getGeometryType();if(!Io[e])throw new Error("Geometry is not supported");return Io[e].apply(this,[t])}});var Eo={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var i=t.geometry.type;if(!Eo[i])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Eo.bbox.apply(this,[t.bbox])),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.apply(this,[t.bbox])),e},coordinates:function Yo(t){for(var Yo=[],e=0;e<t.length;++e){var n=t[e];Yo.push(new g(n[0],n[1]))}return Yo},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){var e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(Eo.Point.apply(this,[t[n]]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=Eo.coordinates.apply(this,[t]);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(Eo.LineString.apply(this,[t[n]]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=Eo.coordinates.apply(this,[t[0]]),n=this.geometryFactory.createLinearRing(e),i=[],r=1;r<t.length;++r){var s=t[r],o=Eo.coordinates.apply(this,[s]),a=this.geometryFactory.createLinearRing(o);i.push(a)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(Eo.Polygon.apply(this,[i]))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},Io={coordinate:function(t){return[t.x,t.y]},Point:function(t){var e=Io.coordinate.apply(this,[t.getCoordinate()]);return{type:"Point",coordinates:e}},MultiPoint:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Io.Point.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),i=0;i<n.length;++i){var r=n[i];e.push(Io.coordinate.apply(this,[r]))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Io.LineString.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=Io.LineString.apply(this,[t.shell]);e.push(n.coordinates);for(var i=0;i<t.holes.length;++i){var r=t.holes[i],s=Io.LineString.apply(this,[r]);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Io.Polygon.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=i.getGeometryType();e.push(Io[r].apply(this,[i]))}return{type:"GeometryCollection",geometries:e}}};e(Vi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){var e,n;if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(e=0,n=t.points.length;n>e;e++)this.precisionModel.makePrecise(t.points[e]);else if(t.geometries)for(e=0,n=t.geometries.length;n>e;e++)this.reducePrecision(t.geometries[e])}}),e(ki.prototype,{write:function(t){return this.parser.write(t)}}),e(Yi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(var e=0,n=t.points.coordinates.length;n>e;e++)this.precisionModel.makePrecise(t.points.coordinates[e]);else if(t.geometries)for(var i=0,r=t.geometries.length;r>i;i++)this.reducePrecision(t.geometries[i])}}),e(Xi.prototype,{read:function(t){return t instanceof ol.geom.Point?this.convertFromPoint(t):t instanceof ol.geom.LineString?this.convertFromLineString(t):t instanceof ol.geom.LinearRing?this.convertFromLinearRing(t):t instanceof ol.geom.Polygon?this.convertFromPolygon(t):t instanceof ol.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof ol.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof ol.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof ol.geom.GeometryCollection?this.convertFromCollection(t):void 0},convertFromPoint:function(t){var e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))},convertFromLineString:function(t){return this.geometryFactory.createLineString(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromLinearRing:function(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromPolygon:function(t){for(var e=t.getLinearRings(),n=null,i=[],r=0;r<e.length;r++){var s=this.convertFromLinearRing(e[r]);0===r?n=s:i.push(s)}return this.geometryFactory.createPolygon(n,i)},convertFromMultiPoint:function(t){var e=t.getPoints().map(function(t){return this.convertFromPoint(t)},this);return this.geometryFactory.createMultiPoint(e)},convertFromMultiLineString:function(t){var e=t.getLineStrings().map(function(t){return this.convertFromLineString(t)},this);return this.geometryFactory.createMultiLineString(e)},convertFromMultiPolygon:function(t){var e=t.getPolygons().map(function(t){return this.convertFromPolygon(t)},this);return this.geometryFactory.createMultiPolygon(e)},convertFromCollection:function(t){var e=t.getGeometries().map(function(t){return this.read(t)},this);return this.geometryFactory.createGeometryCollection(e)},write:function(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0},convertToPoint:function(t){return new ol.geom.Point([t.x,t.y])},convertToLineString:function(t){var e=t.points.coordinates.map(Ui);return new ol.geom.LineString(e)},convertToLinearRing:function(t){var e=t.points.coordinates.map(Ui);return new ol.geom.LinearRing(e)},convertToPolygon:function(t){for(var e=[t.shell.points.coordinates.map(Ui)],n=0;n<t.holes.length;n++)e.push(t.holes[n].points.coordinates.map(Ui));return new ol.geom.Polygon(e)},convertToMultiPoint:function(t){return new ol.geom.MultiPoint(t.getCoordinates().map(Ui))},convertToMultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToLineString(t.geometries[n]).getCoordinates());return new ol.geom.MultiLineString(e)},convertToMultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());return new ol.geom.MultiPolygon(e)},convertToCollection:function(t){for(var e=[],n=0;n<t.geometries.length;n++){var i=t.geometries[n];e.push(this.write(i))}return new ol.geom.GeometryCollection(e)}});var No=Object.freeze({GeoJSONReader:Vi,GeoJSONWriter:ki,OL3Parser:Xi,WKTReader:Yi,WKTWriter:se});e(Hi.prototype,{rescale:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.rescale(n.getCoordinates())}else if(arguments[0]instanceof Array){var i=arguments[0],r=null,s=null;2===i.length&&(r=new g(i[0]),s=new g(i[1]));for(var e=0;e<i.length;e++)i[e].x=i[e].x/this.scaleFactor+this.offsetX,i[e].y=i[e].y/this.scaleFactor+this.offsetY;2===i.length&&i[0].equals2D(i[1])&&A.out.println(i)}},scale:function(){if(R(arguments[0],v)){for(var t=arguments[0],e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ke(this.scale(i.getCoordinates()),i.getData()))}return e}if(arguments[0]instanceof Array){for(var r=arguments[0],s=new Array(r.length).fill(null),n=0;n<r.length;n++)s[n]=new g(Math.round((r[n].x-this.offsetX)*this.scaleFactor),Math.round((r[n].y-this.offsetY)*this.scaleFactor),r[n].z);var o=H.removeRepeatedPoints(s);return o}},isIntegerPrecision:function(){return 1===this.scaleFactor},getNodedSubstrings:function(){var t=this.noder.getNodedSubstrings();return this.isScaled&&this.rescale(t),t},computeNodes:function(t){var e=t;this.isScaled&&(e=this.scale(t)),this.noder.computeNodes(e)},interfaces_:function(){return[tn]},getClass:function(){return Hi}});var Co=Object.freeze({MCIndexNoder:nn,ScaledNoder:Hi,SegmentString:be});e(Wi.prototype,{isSimpleMultiPoint:function(t){if(t.isEmpty())return!0;for(var e=new at,n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n),r=i.getCoordinate();if(e.contains(r))return this.nonSimpleLocation=r,!1;e.add(r)}return!0},isSimplePolygonal:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next();if(!this.isSimpleLinearGeometry(i))return!1}return!0},hasClosedEndpointIntersection:function(t){for(var e=new rt,n=t.getEdgeIterator();n.hasNext();){var i=n.next(),r=(i.getMaximumSegmentIndex(),i.isClosed()),s=i.getCoordinate(0);this.addEndpoint(e,s,r);var o=i.getCoordinate(i.getNumPoints()-1);this.addEndpoint(e,o,r)}for(var n=e.values().iterator();n.hasNext();){var a=n.next();if(a.isClosed&&2!==a.degree)return this.nonSimpleLocation=a.getCoordinate(),!0}return!1},getNonSimpleLocation:function(){return this.nonSimpleLocation},isSimpleLinearGeometry:function(t){if(t.isEmpty())return!0;var e=new $n(0,t),n=new ae,i=e.computeSelfNodes(n,!0);return i.hasIntersection()?i.hasProperIntersection()?(this.nonSimpleLocation=i.getProperIntersectionPoint(),!1):this.hasNonEndpointIntersection(e)?!1:!this.isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e):!0},hasNonEndpointIntersection:function(t){for(var e=t.getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getMaximumSegmentIndex(),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next();if(!s.isEndPoint(i))return this.nonSimpleLocation=s.getCoordinate(),!0}return!1},addEndpoint:function(t,e,n){var i=t.get(e);null===i&&(i=new ji(e),t.put(e,i)),i.addEndpoint(n)},computeSimple:function(t){return this.nonSimpleLocation=null,t.isEmpty()?!0:t instanceof St?this.isSimpleLinearGeometry(t):t instanceof gt?this.isSimpleLinearGeometry(t):t instanceof Pt?this.isSimpleMultiPoint(t):R(t,Rt)?this.isSimplePolygonal(t):t instanceof ft?this.isSimpleGeometryCollection(t):!0},isSimple:function(){return this.nonSimpleLocation=null,this.computeSimple(this.inputGeom)},isSimpleGeometryCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0},interfaces_:function(){return[]},getClass:function(){return Wi}}),e(ji.prototype,{addEndpoint:function(t){this.degree++,this.isClosed|=t},getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return ji}}),Wi.EndpointInfo=ji,e(Ki.prototype,{getEndCapStyle:function(){return this.endCapStyle},isSingleSided:function(){return this._isSingleSided},setQuadrantSegments:function(t){this.quadrantSegments=t,0===this.quadrantSegments&&(this.joinStyle=Ki.JOIN_BEVEL),this.quadrantSegments<0&&(this.joinStyle=Ki.JOIN_MITRE,this.mitreLimit=Math.abs(this.quadrantSegments)),0>=t&&(this.quadrantSegments=1),this.joinStyle!==Ki.JOIN_ROUND&&(this.quadrantSegments=Ki.DEFAULT_QUADRANT_SEGMENTS)},getJoinStyle:function(){return this.joinStyle},setJoinStyle:function(t){this.joinStyle=t},setSimplifyFactor:function(t){this.simplifyFactor=0>t?0:t},getSimplifyFactor:function(){return this.simplifyFactor},getQuadrantSegments:function(){return this.quadrantSegments},setEndCapStyle:function(t){this.endCapStyle=t},getMitreLimit:function(){return this.mitreLimit},setMitreLimit:function(t){this.mitreLimit=t},setSingleSided:function(t){this._isSingleSided=t},interfaces_:function(){return[]},getClass:function(){return Ki}}),Ki.bufferDistanceError=function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)},Ki.CAP_ROUND=1,Ki.CAP_FLAT=2,Ki.CAP_SQUARE=3,Ki.JOIN_ROUND=1,Ki.JOIN_MITRE=2,Ki.JOIN_BEVEL=3,Ki.DEFAULT_QUADRANT_SEGMENTS=8,Ki.DEFAULT_MITRE_LIMIT=5,Ki.DEFAULT_SIMPLIFY_FACTOR=.01,e(Zi.prototype,{getCoordinate:function(){return this.minCoord},getRightmostSide:function(t,e){var n=this.getRightmostSideOfSegment(t,e);return 0>n&&(n=this.getRightmostSideOfSegment(t,e-1)),0>n&&(this.minCoord=null,this.checkForRightmostCoordinate(t)),n},findRightmostEdgeAtVertex:function(){var t=this.minDe.getEdge().getCoordinates();f.isTrue(this.minIndex>0&&this.minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this.minIndex-1],n=t[this.minIndex+1],i=he.computeOrientation(this.minCoord,n,e),r=!1;e.y<this.minCoord.y&&n.y<this.minCoord.y&&i===he.COUNTERCLOCKWISE?r=!0:e.y>this.minCoord.y&&n.y>this.minCoord.y&&i===he.CLOCKWISE&&(r=!0),r&&(this.minIndex=this.minIndex-1)},getRightmostSideOfSegment:function(t,e){var n=t.getEdge(),i=n.getCoordinates();if(0>e||e+1>=i.length)return-1;if(i[e].y===i[e+1].y)return-1;var r=cn.LEFT;return i[e].y<i[e+1].y&&(r=cn.RIGHT),r},getEdge:function(){return this.orientedDe},checkForRightmostCoordinate:function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this.minCoord||e[n].x>this.minCoord.x)&&(this.minDe=t,this.minIndex=n,this.minCoord=e[n])},findRightmostEdgeAtNode:function(){var t=this.minDe.getNode(),e=t.getEdges();this.minDe=e.getRightmostEdge(),this.minDe.isForward()||(this.minDe=this.minDe.getSym(),this.minIndex=this.minDe.getEdge().getCoordinates().length-1)},findEdge:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n)}f.isTrue(0!==this.minIndex||this.minCoord.equals(this.minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this.minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this.orientedDe=this.minDe;var i=this.getRightmostSide(this.minDe,this.minIndex);i===cn.LEFT&&(this.orientedDe=this.minDe.getSym())},interfaces_:function(){return[]},getClass:function(){return Zi}}),Qi.prototype.addLast=function(t){this.array_.push(t)},Qi.prototype.removeFirst=function(){return this.array_.shift()},Qi.prototype.isEmpty=function(){return 0===this.array_.length},e(Ji.prototype,{clearVisitedEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.setVisited(!1)}},getRightmostCoordinate:function(){return this.rightMostCoord},computeNodeDepth:function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var i=n.next();if(i.isVisited()||i.getSym().isVisited()){e=i;break}}if(null===e)throw new sn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();i.setVisited(!0),this.copySymDepths(i)}},computeDepth:function(t){this.clearVisitedEdges();var e=this.finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(cn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)},create:function(t){this.addReachable(t),this.finder.findEdge(this.dirEdgeList),this.rightMostCoord=this.finder.getCoordinate()},findResultEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(cn.RIGHT)>=1&&e.getDepth(cn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}},computeDepths:function(t){var e=new J,n=new Qi,i=t.getNode();for(n.addLast(i),e.add(i),t.setVisited(!0);!n.isEmpty();){var r=n.removeFirst();e.add(r),this.computeNodeDepth(r);for(var s=r.getEdges().iterator();s.hasNext();){var o=s.next(),a=o.getSym();if(!a.isVisited()){var u=a.getNode();e.contains(u)||(n.addLast(u),e.add(u))}}}},compareTo:function(t){var e=t;return this.rightMostCoord.x<e.rightMostCoord.x?-1:this.rightMostCoord.x>e.rightMostCoord.x?1:0},getEnvelope:function(){if(null===this.env){for(var t=new C,e=this.dirEdgeList.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge().getCoordinates(),r=0;r<i.length-1;r++)t.expandToInclude(i[r]);this.env=t}return this.env},addReachable:function(t){var e=new pe;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e)}},copySymDepths:function(t){var e=t.getSym();e.setDepth(cn.LEFT,t.getDepth(cn.RIGHT)),e.setDepth(cn.RIGHT,t.getDepth(cn.LEFT))},add:function(t,e){t.setVisited(!0),this.nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();this.dirEdgeList.add(i);var r=i.getSym(),s=r.getNode();s.isVisited()||e.push(s)}},getNodes:function(){return this.nodes},getDirectedEdges:function(){return this.dirEdgeList},interfaces_:function(){return[s]},getClass:function(){return Ji}}),e($i.prototype,{isDeletable:function(t,e,n,i){var r=this.inputLine[t],s=this.inputLine[e],o=this.inputLine[n];return this.isConcave(r,s,o)&&this.isShallow(r,s,o,i)?this.isShallowSampled(r,s,t,n,i):!1},deleteShallowConcavities:function(){for(var t=1,e=(this.inputLine.length-1,this.findNextNonDeletedIndex(t)),n=this.findNextNonDeletedIndex(e),i=!1;n<this.inputLine.length;){var r=!1;this.isDeletable(t,e,n,this.distanceTol)&&(this.isDeleted[e]=$i.DELETE,r=!0,i=!0),t=r?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return i},isShallowConcavity:function(t,e,n,i){var r=he.computeOrientation(t,e,n),s=r===this.angleOrientation;if(!s)return!1;var o=he.distancePointLine(e,t,n);return i>o},isShallowSampled:function(t,e,n,i,r){var s=Math.trunc((i-n)/$i.NUM_PTS_TO_CHECK);0>=s&&(s=1);for(var o=n;i>o;o+=s)if(!this.isShallow(t,e,this.inputLine[o],r))return!1;return!0},isConcave:function Uo(t,e,n){var i=he.computeOrientation(t,e,n),Uo=i===this.angleOrientation;return Uo},simplify:function(t){this.distanceTol=Math.abs(t),0>t&&(this.angleOrientation=he.CLOCKWISE),this.isDeleted=new Array(this.inputLine.length).fill(null);var e=!1;do e=this.deleteShallowConcavities();while(e);return this.collapseLine()},findNextNonDeletedIndex:function(t){for(var e=t+1;e<this.inputLine.length&&this.isDeleted[e]===$i.DELETE;)e++;return e},isShallow:function(t,e,n,i){var r=he.distancePointLine(e,t,n);return i>r},collapseLine:function(){for(var t=new N,e=0;e<this.inputLine.length;e++)this.isDeleted[e]!==$i.DELETE&&t.add(this.inputLine[e]);return t.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return $i}}),$i.simplify=function(t,e){var n=new $i(t);return n.simplify(e)},$i.INIT=0,$i.DELETE=1,$i.KEEP=1,$i.NUM_PTS_TO_CHECK=10,e(tr.prototype,{getCoordinates:function(){var t=this.ptList.toArray(tr.COORDINATE_ARRAY_TYPE);return t},setPrecisionModel:function(t){this.precisionModel=t},addPt:function(t){var e=new g(t);return this.precisionModel.makePrecise(e),this.isRedundant(e)?null:void this.ptList.add(e)},reverse:function(){},addPts:function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var n=t.length-1;n>=0;n--)this.addPt(t[n])},isRedundant:function(t){if(this.ptList.size()<1)return!1;var e=this.ptList.get(this.ptList.size()-1),n=t.distance(e);return n<this.minimimVertexDistance},toString:function(){var t=new ie,e=t.createLineString(this.getCoordinates());return e.toString()},closeRing:function(){if(this.ptList.size()<1)return null;var t=new g(this.ptList.get(0)),e=this.ptList.get(this.ptList.size()-1),n=null;return this.ptList.size()>=2&&(n=this.ptList.get(this.ptList.size()-2)),t.equals(e)?null:void this.ptList.add(t)},setMinimumVertexDistance:function(t){this.minimimVertexDistance=t},interfaces_:function(){return[]},getClass:function(){return tr}}),tr.COORDINATE_ARRAY_TYPE=new Array(0).fill(null),e(er.prototype,{addNextSegment:function(t,e){if(this.s0=this.s1,this.s1=this.s2,this.s2=t,this.seg0.setCoordinates(this.s0,this.s1),this.computeOffsetSegment(this.seg0,this.side,this.distance,this.offset0),this.seg1.setCoordinates(this.s1,this.s2),this.computeOffsetSegment(this.seg1,this.side,this.distance,this.offset1),this.s1.equals(this.s2))return null;var n=he.computeOrientation(this.s0,this.s1,this.s2),i=n===he.CLOCKWISE&&this.side===cn.LEFT||n===he.COUNTERCLOCKWISE&&this.side===cn.RIGHT;0===n?this.addCollinear(e):i?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)},addLineEndCap:function(t,e){var n=new ce(t,e),i=new ce;this.computeOffsetSegment(n,cn.LEFT,this.distance,i);var r=new ce;this.computeOffsetSegment(n,cn.RIGHT,this.distance,r);var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s);switch(this.bufParams.getEndCapStyle()){case Ki.CAP_ROUND:this.segList.addPt(i.p1),this.addFilletArc(e,a+Math.PI/2,a-Math.PI/2,he.CLOCKWISE,this.distance),this.segList.addPt(r.p1);break;case Ki.CAP_FLAT:this.segList.addPt(i.p1),this.segList.addPt(r.p1);break;case Ki.CAP_SQUARE:var u=new g;u.x=Math.abs(this.distance)*Math.cos(a),u.y=Math.abs(this.distance)*Math.sin(a);var l=new g(i.p1.x+u.x,i.p1.y+u.y),h=new g(r.p1.x+u.x,r.p1.y+u.y);this.segList.addPt(l),this.segList.addPt(h)}},getCoordinates:function(){var t=this.segList.getCoordinates();return t},addMitreJoin:function(t,e,n,i){var r=!0,s=null;try{s=F.intersection(e.p0,e.p1,n.p0,n.p1);var o=0>=i?1:s.distance(t)/Math.abs(i);o>this.bufParams.getMitreLimit()&&(r=!1)}catch(a){if(!(a instanceof w))throw a;s=new g(0,0),r=!1}finally{}r?this.segList.addPt(s):this.addLimitedMitreJoin(e,n,i,this.bufParams.getMitreLimit())},addFilletCorner:function(t,e,n,i,r){var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s),u=n.x-t.x,l=n.y-t.y,h=Math.atan2(l,u);i===he.CLOCKWISE?h>=a&&(a+=2*Math.PI):a>=h&&(a-=2*Math.PI),this.segList.addPt(e),this.addFilletArc(t,a,h,i,r),this.segList.addPt(n)},addOutsideTurn:function(t,e){return this.offset0.p1.distance(this.offset1.p0)<this.distance*er.OFFSET_SEGMENT_SEPARATION_FACTOR?(this.segList.addPt(this.offset0.p1),null):void(this.bufParams.getJoinStyle()===Ki.JOIN_MITRE?this.addMitreJoin(this.s1,this.offset0,this.offset1,this.distance):this.bufParams.getJoinStyle()===Ki.JOIN_BEVEL?this.addBevelJoin(this.offset0,this.offset1):(e&&this.segList.addPt(this.offset0.p1),this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,t,this.distance),this.segList.addPt(this.offset1.p0)))},createSquare:function(t){this.segList.addPt(new g(t.x+this.distance,t.y+this.distance)),this.segList.addPt(new g(t.x+this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y+this.distance)),this.segList.closeRing()},addSegments:function(t,e){this.segList.addPts(t,e)},addFirstSegment:function(){this.segList.addPt(this.offset1.p0)},addLastSegment:function(){this.segList.addPt(this.offset1.p1)},initSideSegments:function(t,e,n){this.s1=t,this.s2=e,this.side=n,this.seg1.setCoordinates(t,e),this.computeOffsetSegment(this.seg1,n,this.distance,this.offset1)},addLimitedMitreJoin:function(t,e,n,i){var r=this.seg0.p1,s=Ci.angle(r,this.seg0.p0),o=(Ci.angle(r,this.seg1.p1),Ci.angleBetweenOriented(this.seg0.p0,r,this.seg1.p1)),a=o/2,u=Ci.normalize(s+a),l=Ci.normalize(u+Math.PI),h=i*n,c=h*Math.abs(Math.sin(a)),f=n-c,d=r.x+h*Math.cos(l),p=r.y+h*Math.sin(l),v=new g(d,p),m=new ce(r,v),y=m.pointAlongOffset(1,f),x=m.pointAlongOffset(1,-f);
this.side===cn.LEFT?(this.segList.addPt(y),this.segList.addPt(x)):(this.segList.addPt(x),this.segList.addPt(y))},computeOffsetSegment:function(t,e,n,i){var r=e===cn.LEFT?1:-1,s=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,a=Math.sqrt(s*s+o*o),u=r*n*s/a,l=r*n*o/a;i.p0.x=t.p0.x-l,i.p0.y=t.p0.y+u,i.p1.x=t.p1.x-l,i.p1.y=t.p1.y+u},addFilletArc:function(t,e,n,i,r){var s=i===he.CLOCKWISE?-1:1,o=Math.abs(e-n),a=Math.trunc(o/this.filletAngleQuantum+.5);if(1>a)return null;var u=null,l=null;u=0,l=o/a;for(var h=u,c=new g;o>h;){var f=e+s*h;c.x=t.x+r*Math.cos(f),c.y=t.y+r*Math.sin(f),this.segList.addPt(c),h+=l}},addInsideTurn:function(t,e){if(this.li.computeIntersection(this.offset0.p0,this.offset0.p1,this.offset1.p0,this.offset1.p1),this.li.hasIntersection())this.segList.addPt(this.li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this.offset0.p1.distance(this.offset1.p0)<this.distance*er.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this.segList.addPt(this.offset0.p1);else{if(this.segList.addPt(this.offset0.p1),this.closingSegLengthFactor>0){var n=new g((this.closingSegLengthFactor*this.offset0.p1.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset0.p1.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(n);var i=new g((this.closingSegLengthFactor*this.offset1.p0.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset1.p0.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(i)}else this.segList.addPt(this.s1);this.segList.addPt(this.offset1.p0)}},createCircle:function(t){var e=new g(t.x+this.distance,t.y);this.segList.addPt(e),this.addFilletArc(t,0,2*Math.PI,-1,this.distance),this.segList.closeRing()},addBevelJoin:function(t,e){this.segList.addPt(t.p1),this.segList.addPt(e.p0)},init:function(t){this.distance=t,this.maxCurveSegmentError=t*(1-Math.cos(this.filletAngleQuantum/2)),this.segList=new tr,this.segList.setPrecisionModel(this.precisionModel),this.segList.setMinimumVertexDistance(t*er.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},addCollinear:function(t){this.li.computeIntersection(this.s0,this.s1,this.s1,this.s2);var e=this.li.getIntersectionNum();e>=2&&(this.bufParams.getJoinStyle()===Ki.JOIN_BEVEL||this.bufParams.getJoinStyle()===Ki.JOIN_MITRE?(t&&this.segList.addPt(this.offset0.p1),this.segList.addPt(this.offset1.p0)):this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,he.CLOCKWISE,this.distance))},closeRing:function(){this.segList.closeRing()},hasNarrowConcaveAngle:function(){return this._hasNarrowConcaveAngle},interfaces_:function(){return[]},getClass:function(){return er}}),er.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,er.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,er.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,er.MAX_CLOSING_SEG_LEN_FACTOR=80,e(nr.prototype,{getOffsetCurve:function(t,e){if(this.distance=e,0===e)return null;var n=0>e,i=Math.abs(e),r=this.getSegGen(i);t.length<=1?this.computePointCurve(t[0],r):this.computeOffsetCurve(t,n,r);var s=r.getCoordinates();return n&&H.reverse(s),s},computeSingleSidedBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){n.addSegments(t,!0);var r=$i.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{n.addSegments(t,!1);var a=$i.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment(),n.closeRing()},computeRingBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);e===cn.RIGHT&&(i=-i);var r=$i.simplify(t,i),s=r.length-1;n.initSideSegments(r[s-1],r[0],e);for(var o=1;s>=o;o++){var a=1!==o;n.addNextSegment(r[o],a)}n.closeRing()},computeLineBufferCurve:function(t,e){var n=this.simplifyTolerance(this.distance),i=$i.simplify(t,n),r=i.length-1;e.initSideSegments(i[0],i[1],cn.LEFT);for(var s=2;r>=s;s++)e.addNextSegment(i[s],!0);e.addLastSegment(),e.addLineEndCap(i[r-1],i[r]);var o=$i.simplify(t,-n),a=o.length-1;e.initSideSegments(o[a],o[a-1],cn.LEFT);for(var s=a-2;s>=0;s--)e.addNextSegment(o[s],!0);e.addLastSegment(),e.addLineEndCap(o[1],o[0]),e.closeRing()},computePointCurve:function(t,e){switch(this.bufParams.getEndCapStyle()){case Ki.CAP_ROUND:e.createCircle(t);break;case Ki.CAP_SQUARE:e.createSquare(t)}},getLineCurve:function(t,e){if(this.distance=e,0>e&&!this.bufParams.isSingleSided())return null;if(0===e)return null;var n=Math.abs(e),i=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],i);else if(this.bufParams.isSingleSided()){var r=0>e;this.computeSingleSidedBufferCurve(t,r,i)}else this.computeLineBufferCurve(t,i);var s=i.getCoordinates();return s},getBufferParameters:function(){return this.bufParams},simplifyTolerance:function(t){return t*this.bufParams.getSimplifyFactor()},getRingCurve:function(t,e,n){if(this.distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return nr.copyCoordinates(t);var i=this.getSegGen(n);return this.computeRingBufferCurve(t,e,i),i.getCoordinates()},computeOffsetCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){var r=$i.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{var a=$i.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment()},getSegGen:function(t){return new er(this.precisionModel,this.bufParams,t)},interfaces_:function(){return[]},getClass:function(){return nr}}),nr.copyCoordinates=function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new g(t[n]);return e},e(ir.prototype,{findStabbedSegments:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=this.subgraphs.iterator();n.hasNext();){var i=n.next(),r=i.getEnvelope();t.y<r.getMinY()||t.y>r.getMaxY()||this.findStabbedSegments(t,i.getDirectedEdges(),e)}return e}if(3===arguments.length)if(R(arguments[2],y)&&arguments[0]instanceof g&&arguments[1]instanceof In)for(var s=arguments[0],o=arguments[1],a=arguments[2],u=o.getEdge().getCoordinates(),n=0;n<u.length-1;n++){this.seg.p0=u[n],this.seg.p1=u[n+1],this.seg.p0.y>this.seg.p1.y&&this.seg.reverse();var l=Math.max(this.seg.p0.x,this.seg.p1.x);if(!(l<s.x||this.seg.isHorizontal()||s.y<this.seg.p0.y||s.y>this.seg.p1.y||he.computeOrientation(this.seg.p0,this.seg.p1,s)===he.RIGHT)){var h=o.getDepth(cn.LEFT);this.seg.p0.equals(u[n])||(h=o.getDepth(cn.RIGHT));var c=new rr(this.seg,h);a.add(c)}}else if(R(arguments[2],y)&&arguments[0]instanceof g&&R(arguments[1],y))for(var f=arguments[0],d=arguments[1],p=arguments[2],n=d.iterator();n.hasNext();){var v=n.next();v.isForward()&&this.findStabbedSegments(f,v,p)}},getDepth:function(t){var e=this.findStabbedSegments(t);if(0===e.size())return 0;var n=ho.min(e);return n.leftDepth},interfaces_:function(){return[]},getClass:function(){return ir}}),e(rr.prototype,{compareTo:function(t){var e=t;if(this.upwardSeg.minX()>=e.upwardSeg.maxX())return 1;if(this.upwardSeg.maxX()<=e.upwardSeg.minX())return-1;var n=this.upwardSeg.orientationIndex(e.upwardSeg);return 0!==n?n:(n=-1*e.upwardSeg.orientationIndex(this.upwardSeg),0!==n?n:this.upwardSeg.compareTo(e.upwardSeg))},compareX:function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)},toString:function(){return this.upwardSeg.toString()},interfaces_:function(){return[s]},getClass:function(){return rr}}),ir.DepthSegment=rr,e(sr.prototype,{addPoint:function(t){if(this.distance<=0)return null;var e=t.getCoordinates(),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addPolygon:function(t){var e=this.distance,n=cn.LEFT;this.distance<0&&(e=-this.distance,n=cn.RIGHT);var i=t.getExteriorRing(),r=H.removeRepeatedPoints(i.getCoordinates());if(this.distance<0&&this.isErodedCompletely(i,this.distance))return null;if(this.distance<=0&&r.length<3)return null;this.addPolygonRing(r,e,n,L.EXTERIOR,L.INTERIOR);for(var s=0;s<t.getNumInteriorRing();s++){var o=t.getInteriorRingN(s),a=H.removeRepeatedPoints(o.getCoordinates());this.distance>0&&this.isErodedCompletely(o,-this.distance)||this.addPolygonRing(a,e,cn.opposite(n),L.INTERIOR,L.EXTERIOR)}},isTriangleErodedCompletely:function(t,e){var n=new Si(t[0],t[1],t[2]),i=n.inCentre(),r=he.distancePointLine(i,n.p0,n.p1);return r<Math.abs(e)},addLineString:function(t){if(this.distance<=0&&!this.curveBuilder.getBufferParameters().isSingleSided())return null;var e=H.removeRepeatedPoints(t.getCoordinates()),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addCurve:function(t,e,n){if(null===t||t.length<2)return null;var i=new Ke(t,new gn(0,L.BOUNDARY,e,n));this.curveList.add(i)},getCurves:function(){return this.add(this.inputGeom),this.curveList},addPolygonRing:function(t,e,n,i,r){if(0===e&&t.length<bt.MINIMUM_VALID_SIZE)return null;var s=i,o=r;t.length>=bt.MINIMUM_VALID_SIZE&&he.isCCW(t)&&(s=r,o=i,n=cn.opposite(n));var a=this.curveBuilder.getRingCurve(t,n,e);this.addCurve(a,s,o)},add:function(t){if(t.isEmpty())return null;if(t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},isErodedCompletely:function(t,e){var n=t.getCoordinates();if(n.length<4)return 0>e;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var i=t.getEnvelopeInternal(),r=Math.min(i.getHeight(),i.getWidth());return 0>e&&2*Math.abs(e)>r},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},interfaces_:function(){return[]},getClass:function(){return sr}}),e(or.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(or.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.size()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},hasProperInteriorIntersection:function(){return this.hasProperInterior},getLineIntersector:function(){return this.li},hasProperIntersection:function(){return this.hasProper},processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.numIntersections++,this.li.isInteriorIntersection()&&(this.numInteriorIntersections++,this.hasInterior=!0),this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1),this.li.isProper()&&(this.numProperIntersections++,this.hasProper=!0,this.hasProperInterior=!0)))},hasIntersection:function(){return this._hasIntersection},isDone:function(){return!1},hasInteriorIntersection:function(){return this.hasInterior},interfaces_:function(){return[on]},getClass:function(){return or}}),or.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},e(ar.prototype,{setWorkingPrecisionModel:function(t){this.workingPrecisionModel=t},insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip()),n.merge(i);var r=ar.depthDelta(i),s=e.getDepthDelta(),o=s+r;e.setDepthDelta(o)}else this.edgeList.add(t),t.setDepthDelta(ar.depthDelta(t.getLabel()))},buildSubgraphs:function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next(),s=r.getRightmostCoordinate(),o=new ir(n),a=o.getDepth(s);r.computeDepth(a),r.findResultEdges(),n.add(r),e.add(r.getDirectedEdges(),r.getNodes())}},createSubgraphs:function(t){for(var e=new I,n=t.getNodes().iterator();n.hasNext();){var i=n.next();if(!i.isVisited()){var r=new Ji;r.create(i),e.add(r)}}return ho.sort(e,ho.reverseOrder()),e},createEmptyResultGeometry:function(){var t=this.geomFact.createPolygon();return t},getNoder:function(t){if(null!==this.workingNoder)return this.workingNoder;var e=new nn,n=new ae;return n.setPrecisionModel(t),e.setSegmentIntersector(new or(n)),e},buffer:function(t,e){var n=this.workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this.geomFact=t.getFactory();var i=new nr(n,this.bufParams),r=new sr(t,e,i),s=r.getCurves();if(s.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(s,n),this.graph=new Cn(new On),this.graph.addEdges(this.edgeList.getEdges());var o=this.createSubgraphs(this.graph),a=new Sn(this.geomFact);this.buildSubgraphs(o,a);var u=a.getPolygons();if(u.size()<=0)return this.createEmptyResultGeometry();var l=this.geomFact.buildGeometry(u);return l},computeNodedEdges:function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var i=n.getNodedSubstrings(),r=i.iterator();r.hasNext();){var s=r.next(),o=s.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var a=s.getData(),u=new Jn(s.getCoordinates(),new gn(a));this.insertUniqueEdge(u)}}},setNoder:function(t){this.workingNoder=t},interfaces_:function(){return[]},getClass:function(){return ar}}),ar.depthDelta=function(t){var e=t.getLocation(0,cn.LEFT),n=t.getLocation(0,cn.RIGHT);return e===L.INTERIOR&&n===L.EXTERIOR?1:e===L.EXTERIOR&&n===L.INTERIOR?-1:0},ar.convertSegStrings=function(t){for(var e=new ie,n=new I;t.hasNext();){var i=t.next(),r=e.createLineString(i.getCoordinates());n.add(r)}return e.buildGeometry(n)},e(ur.prototype,{checkEndPtVertexIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next(),n=e.getCoordinates();this.checkEndPtVertexIntersections(n[0],this.segStrings),this.checkEndPtVertexIntersections(n[n.length-1],this.segStrings)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],t=r.iterator();t.hasNext();)for(var e=t.next(),n=e.getCoordinates(),s=1;s<n.length-1;s++)if(n[s].equals(i))throw new l("found endpt/interior pt intersection at index "+s+" :pt "+i)},checkInteriorIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this.segStrings.iterator();n.hasNext();){var i=n.next();this.checkInteriorIntersections(e,i)}else if(2===arguments.length)for(var r=arguments[0],s=arguments[1],o=r.getCoordinates(),a=s.getCoordinates(),u=0;u<o.length-1;u++)for(var h=0;h<a.length-1;h++)this.checkInteriorIntersections(r,u,s,h);else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3];if(c===g&&f===d)return null;var p=c.getCoordinates()[f],v=c.getCoordinates()[f+1],m=g.getCoordinates()[d],y=g.getCoordinates()[d+1];if(this.li.computeIntersection(p,v,m,y),this.li.hasIntersection()&&(this.li.isProper()||this.hasInteriorIntersection(this.li,p,v)||this.hasInteriorIntersection(this.li,m,y)))throw new l("found non-noded intersection at "+p+"-"+v+" and "+m+"-"+y)}},checkValid:function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},checkCollapses:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e)}else if(1===arguments.length)for(var n=arguments[0],i=n.getCoordinates(),t=0;t<i.length-2;t++)this.checkCollapse(i[t],i[t+1],i[t+2])},hasInteriorIntersection:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++){var r=t.getIntersection(i);if(!r.equals(e)&&!r.equals(n))return!0}return!1},checkCollapse:function(t,e,n){if(t.equals(n))throw new l("found non-noded collapse at "+ur.fact.createLineString([t,e,n]))},interfaces_:function(){return[]},getClass:function(){return ur}}),ur.fact=new ie,e(lr.prototype,{intersectsScaled:function(t,e){var n=Math.min(t.x,e.x),i=Math.max(t.x,e.x),r=Math.min(t.y,e.y),s=Math.max(t.y,e.y),o=this.maxx<n||this.minx>i||this.maxy<r||this.miny>s;if(o)return!1;var a=this.intersectsToleranceSquare(t,e);return f.isTrue(!(o&&a),"Found bad envelope test"),a},initCorners:function(t){var e=.5;this.minx=t.x-e,this.maxx=t.x+e,this.miny=t.y-e,this.maxy=t.y+e,this.corner[0]=new g(this.maxx,this.maxy),this.corner[1]=new g(this.minx,this.maxy),this.corner[2]=new g(this.minx,this.miny),this.corner[3]=new g(this.maxx,this.miny)},intersects:function(t,e){return 1===this.scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this.p0Scaled),this.copyScaled(e,this.p1Scaled),this.intersectsScaled(this.p0Scaled,this.p1Scaled))},scale:function(t){return Math.round(t*this.scaleFactor)},getCoordinate:function(){return this.originalPt},copyScaled:function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)},getSafeEnvelope:function(){if(null===this.safeEnv){var t=lr.SAFE_ENV_EXPANSION_FACTOR/this.scaleFactor;this.safeEnv=new C(this.originalPt.x-t,this.originalPt.x+t,this.originalPt.y-t,this.originalPt.y+t)}return this.safeEnv},intersectsPixelClosure:function(t,e){return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),!!this.li.hasIntersection())))},intersectsToleranceSquare:function(t,e){var n=!1,i=!1;return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.isProper()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.isProper()?!0:(this.li.hasIntersection()&&(n=!0),this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.isProper()?!0:(this.li.hasIntersection()&&(i=!0),this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),this.li.isProper()?!0:n&&i?!0:t.equals(this.pt)?!0:!!e.equals(this.pt))))},addSnappedNode:function(t,e){var n=t.getCoordinate(e),i=t.getCoordinate(e+1);return this.intersects(n,i)?(t.addIntersection(this.getCoordinate(),e),!0):!1},interfaces_:function(){return[]},getClass:function(){return lr}}),lr.SAFE_ENV_EXPANSION_FACTOR=.75,e(hr.prototype,{snap:function(){if(1===arguments.length){var t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=e.getSafeEnvelope(),s=new cr(e,n,i);return this.index.query(r,{interfaces_:function(){return[Ae]},visitItem:function(t){var e=t;e.select(r,s)}}),s.isNodeAdded()}},interfaces_:function(){return[]},getClass:function(){return hr}}),h(cr,hi),e(cr.prototype,{isNodeAdded:function(){return this._isNodeAdded},select:function(){if(2!==arguments.length)return hi.prototype.select.apply(this,arguments);var t=arguments[0],e=arguments[1],n=t.getContext();return null!==this.parentEdge&&n===this.parentEdge&&e===this.hotPixelVertexIndex?null:void(this._isNodeAdded=this.hotPixel.addSnappedNode(n,e))},interfaces_:function(){return[]},getClass:function(){return cr}}),hr.HotPixelSnapAction=cr,e(fr.prototype,{processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];if(this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&this.li.isInteriorIntersection()){for(var u=0;u<this.li.getIntersectionNum();u++)this.interiorIntersections.add(this.li.getIntersection(u));t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)}},isDone:function(){return!1},getInteriorIntersections:function(){return this.interiorIntersections},interfaces_:function(){return[on]},getClass:function(){return fr}}),e(gr.prototype,{checkCorrectness:function(t){var e=Ke.getNodedSubstrings(t),n=new ur(e);try{n.checkValid()}catch(i){if(!(i instanceof S))throw i;i.printStackTrace()}finally{}},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},snapRound:function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)},findInteriorIntersections:function(t,e){var n=new fr(e);return this.noder.setSegmentIntersector(n),this.noder.computeNodes(t),n.getInteriorIntersections()},computeVertexSnaps:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.computeVertexSnaps(n)}else if(arguments[0]instanceof Ke)for(var i=arguments[0],r=i.getCoordinates(),s=0;s<r.length;s++){var o=new lr(r[s],this.scaleFactor,this.li),a=this.pointSnapper.snap(o,i,s);a&&i.addIntersection(r[s],s)}},computeNodes:function(t){this.nodedSegStrings=t,this.noder=new nn,this.pointSnapper=new hr(this.noder.getIndex()),this.snapRound(t,this.li)},computeIntersectionSnaps:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=new lr(n,this.scaleFactor,this.li);this.pointSnapper.snap(i)}},interfaces_:function(){return[tn]},getClass:function(){return gr}}),e(dr.prototype,{bufferFixedPrecision:function(t){var e=new Hi(new gr(new ee(1)),t.getScale()),n=new ar(this.bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this.resultGeometry=n.buffer(this.argGeom,this.distance)},bufferReducedPrecision:function(){if(0===arguments.length){for(var t=dr.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(e){if(!(e instanceof sn))throw e;this.saveException=e}finally{}if(null!==this.resultGeometry)return null}throw this.saveException}if(1===arguments.length){var n=arguments[0],i=dr.precisionScaleFactor(this.argGeom,this.distance,n),r=new ee(i);this.bufferFixedPrecision(r)}},computeGeometry:function(){if(this.bufferOriginalPrecision(),null!==this.resultGeometry)return null;var t=this.argGeom.getFactory().getPrecisionModel();t.getType()===ee.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()},setQuadrantSegments:function(t){this.bufParams.setQuadrantSegments(t)},bufferOriginalPrecision:function(){try{var t=new ar(this.bufParams);this.resultGeometry=t.buffer(this.argGeom,this.distance)}catch(e){if(!(e instanceof l))throw e;this.saveException=e}finally{}},getResultGeometry:function(t){return this.distance=t,this.computeGeometry(),this.resultGeometry},setEndCapStyle:function(t){this.bufParams.setEndCapStyle(t)},interfaces_:function(){return[]},getClass:function(){return dr}}),dr.bufferOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new dr(t),i=n.getResultGeometry(e);return i}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var r=arguments[0],s=arguments[1],o=arguments[2],a=new dr(r);a.setQuadrantSegments(o);var i=a.getResultGeometry(s);return i}if(arguments[2]instanceof Ki&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2],a=new dr(u,h),i=a.getResultGeometry(l);return i}}else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3],a=new dr(c);a.setQuadrantSegments(g),a.setEndCapStyle(d);var i=a.getResultGeometry(f);return i}},dr.precisionScaleFactor=function(t,e,n){var i=t.getEnvelopeInternal(),r=T.max(Math.abs(i.getMaxX()),Math.abs(i.getMaxY()),Math.abs(i.getMinX()),Math.abs(i.getMinY())),s=e>0?e:0,o=r+2*s,a=Math.trunc(Math.log(o)/Math.log(10)+1),u=n-a,l=Math.pow(10,u);return l},dr.CAP_ROUND=Ki.CAP_ROUND,dr.CAP_BUTT=Ki.CAP_FLAT,dr.CAP_FLAT=Ki.CAP_FLAT,dr.CAP_SQUARE=Ki.CAP_SQUARE,dr.MAX_PRECISION_DIGITS=12;var So=Object.freeze({BufferOp:dr,BufferParameters:Ki});e(pr.prototype,{filter:function(t){t instanceof Tt&&this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return pr}}),pr.getPolygons=function(){if(1===arguments.length){var t=arguments[0];return pr.getPolygons(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Tt?n.add(e):e instanceof ft&&e.apply(new pr(n)),n}},e(vr.prototype,{isInsideArea:function(){return this.segIndex===vr.INSIDE_AREA},getCoordinate:function(){return this.pt},getGeometryComponent:function(){return this.component},getSegmentIndex:function(){return this.segIndex},interfaces_:function(){return[]},getClass:function(){return vr}}),vr.INSIDE_AREA=-1,e(mr.prototype,{filter:function(t){t instanceof Lt&&this.pts.add(t)},interfaces_:function(){return[ht]},getClass:function(){return mr}}),mr.getPoints=function(){if(1===arguments.length){var t=arguments[0];return t instanceof Lt?ho.singletonList(t):mr.getPoints(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Lt?n.add(e):e instanceof ft&&e.apply(new mr(n)),n}},e(yr.prototype,{filter:function(t){(t instanceof Lt||t instanceof St||t instanceof Tt)&&this.locations.add(new vr(t,0,t.getCoordinate()))},interfaces_:function(){return[ht]},getClass:function(){return yr}}),yr.getLocations=function(t){var e=new I;return t.apply(new yr(e)),e},e(xr.prototype,{computeContainmentDistance:function(){if(0===arguments.length){var t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this.minDistance<=this.terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=1-e,r=pr.getPolygons(this.geom[e]);if(r.size()>0){var s=yr.getLocations(this.geom[i]);if(this.computeContainmentDistance(s,r,n),this.minDistance<=this.terminateDistance)return this.minDistanceLocation[i]=n[0],this.minDistanceLocation[e]=n[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&R(arguments[0],y)&&R(arguments[1],y)){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=0;l<o.size();l++)for(var h=o.get(l),c=0;c<a.size();c++)if(this.computeContainmentDistance(h,a.get(c),u),this.minDistance<=this.terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof vr&&arguments[1]instanceof Tt){var f=arguments[0],g=arguments[1],d=arguments[2],p=f.getCoordinate();if(L.EXTERIOR!==this.ptLocator.locate(p,g))return this.minDistance=0,d[0]=f,d[1]=new vr(g,p),null}},computeMinDistanceLinesPoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},computeFacetDistance:function(){var t=new Array(2).fill(null),e=kn.getLines(this.geom[0]),n=kn.getLines(this.geom[1]),i=mr.getPoints(this.geom[0]),r=mr.getPoints(this.geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,r,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,i,t),this.updateMinDistance(t,!0),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(i,r,t),void this.updateMinDistance(t,!1))))},nearestLocations:function(){return this.computeMinDistance(),this.minDistanceLocation},updateMinDistance:function(t,e){return null===t[0]?null:void(e?(this.minDistanceLocation[0]=t[1],this.minDistanceLocation[1]=t[0]):(this.minDistanceLocation[0]=t[0],this.minDistanceLocation[1]=t[1]))},nearestPoints:function(){this.computeMinDistance();var t=[this.minDistanceLocation[0].getCoordinate(),this.minDistanceLocation[1].getCoordinate()];return t},computeMinDistance:function(){if(0===arguments.length){if(null!==this.minDistanceLocation)return null;if(this.minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this.minDistance<=this.terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof Lt){var t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this.minDistance)return null;for(var i=t.getCoordinates(),r=e.getCoordinate(),s=0;s<i.length-1;s++){var o=he.distancePointLine(r,i[s],i[s+1]);if(o<this.minDistance){this.minDistance=o;var a=new ce(i[s],i[s+1]),u=a.closestPoint(r);n[0]=new vr(t,s,u),n[1]=new vr(e,0,r)}if(this.minDistance<=this.terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof St){var l=arguments[0],h=arguments[1],c=arguments[2];if(l.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this.minDistance)return null;for(var i=l.getCoordinates(),f=h.getCoordinates(),s=0;s<i.length-1;s++)for(var g=0;g<f.length-1;g++){var o=he.distanceLineLine(i[s],i[s+1],f[g],f[g+1]);if(o<this.minDistance){this.minDistance=o;var d=new ce(i[s],i[s+1]),p=new ce(f[g],f[g+1]),v=d.closestPoints(p);c[0]=new vr(l,s,v[0]),c[1]=new vr(h,g,v[1])}if(this.minDistance<=this.terminateDistance)return null}}},computeMinDistancePoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s),a=r.getCoordinate().distance(o.getCoordinate());if(a<this.minDistance&&(this.minDistance=a,n[0]=new vr(r,0,r.getCoordinate()),n[1]=new vr(o,0,o.getCoordinate())),this.minDistance<=this.terminateDistance)return null}},distance:function(){if(null===this.geom[0]||null===this.geom[1])throw new i("null geometries are not supported");return this.geom[0].isEmpty()||this.geom[1].isEmpty()?0:(this.computeMinDistance(),this.minDistance)},computeMinDistanceLines:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},interfaces_:function(){return[]},getClass:function(){return xr}}),xr.distance=function(t,e){var n=new xr(t,e);return n.distance()},xr.isWithinDistance=function(t,e,n){var i=new xr(t,e,n);return i.distance()<=n},xr.nearestPoints=function(t,e){var n=new xr(t,e);return n.nearestPoints()};var wo=Object.freeze({DistanceOp:xr});e(Er.prototype,{getCoordinates:function(){if(null===this.coordinates){for(var t=0,e=0,n=new N,i=this.directedEdges.iterator();i.hasNext();){var r=i.next();r.getEdgeDirection()?t++:e++,n.add(r.getEdge().getLine().getCoordinates(),!1,r.getEdgeDirection())}this.coordinates=n.toCoordinateArray(),e>t&&H.reverse(this.coordinates)}return this.coordinates},toLineString:function(){return this.factory.createLineString(this.getCoordinates())},add:function(t){this.directedEdges.add(t)},interfaces_:function(){return[]},getClass:function(){return Er}}),e(Ir.prototype,{setVisited:function(t){this._isVisited=t},isMarked:function(){return this._isMarked},setData:function(t){this.data=t},getData:function(){return this.data},setMarked:function(t){this._isMarked=t},getContext:function(){return this.data},isVisited:function(){return this._isVisited},setContext:function(t){this.data=t},interfaces_:function(){return[]},getClass:function(){return Ir}}),Ir.getComponentWithVisitedState=function(t,e){for(;t.hasNext();){var n=t.next();if(n.isVisited()===e)return n}return null},Ir.setVisited=function(t,e){for(;t.hasNext();){var n=t.next();n.setVisited(e)}},Ir.setMarked=function(t,e){for(;t.hasNext();){var n=t.next();n.setMarked(e)}},h(Nr,Ir),e(Nr.prototype,{isRemoved:function(){return null===this.parentEdge},compareDirection:function(t){return this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getCoordinate:function(){return this.from.getCoordinate()},print:function(t){var e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);t.print("  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+this.angle)},getDirectionPt:function(){return this.p1},getAngle:function(){return this.angle},compareTo:function(t){var e=t;return this.compareDirection(e)},getFromNode:function(){return this.from},getSym:function(){return this.sym},setEdge:function(t){this.parentEdge=t},remove:function(){this.sym=null,this.parentEdge=null},getEdge:function(){return this.parentEdge},getQuadrant:function(){return this.quadrant},setSym:function(t){this.sym=t},getToNode:function(){return this.to},getEdgeDirection:function(){return this.edgeDirection},interfaces_:function(){return[s]},getClass:function(){return Nr}}),Nr.toEdges=function(t){
for(var e=new I,n=t.iterator();n.hasNext();)e.add(n.next().parentEdge);return e},h(Cr,Nr),e(Cr.prototype,{getNext:function(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(f.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))},interfaces_:function(){return[]},getClass:function(){return Cr}}),h(Sr,Ir),e(Sr.prototype,{isRemoved:function(){return null===this.dirEdge},setDirectedEdges:function(t,e){this.dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)},getDirEdge:function(){if(Number.isInteger(arguments[0])){var t=arguments[0];return this.dirEdge[t]}if(arguments[0]instanceof Lr){var e=arguments[0];return this.dirEdge[0].getFromNode()===e?this.dirEdge[0]:this.dirEdge[1].getFromNode()===e?this.dirEdge[1]:null}},remove:function(){this.dirEdge=null},getOppositeNode:function(t){return this.dirEdge[0].getFromNode()===t?this.dirEdge[0].getToNode():this.dirEdge[1].getFromNode()===t?this.dirEdge[1].getToNode():null},interfaces_:function(){return[]},getClass:function(){return Sr}}),e(wr.prototype,{getNextEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e+1))},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},iterator:function(){return this.sortEdges(),this.outEdges.iterator()},sortEdges:function(){this.sorted||(ho.sort(this.outEdges),this.sorted=!0)},remove:function(t){this.outEdges.remove(t)},getEdges:function(){return this.sortEdges(),this.outEdges},getNextCWEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e-1))},getIndex:function(){if(arguments[0]instanceof Sr){var t=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n.getEdge()===t)return e}return-1}if(arguments[0]instanceof Nr){var i=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n===i)return e}return-1}if(Number.isInteger(arguments[0])){var r=arguments[0],s=r%this.outEdges.size();return 0>s&&(s+=this.outEdges.size()),s}},add:function(t){this.outEdges.add(t),this.sorted=!1},getDegree:function(){return this.outEdges.size()},interfaces_:function(){return[]},getClass:function(){return wr}}),h(Lr,Ir),e(Lr.prototype,{isRemoved:function(){return null===this.pt},addOutEdge:function(t){this.deStar.add(t)},getCoordinate:function(){return this.pt},getOutEdges:function(){return this.deStar},remove:function(){if(0===arguments.length)this.pt=null;else if(1===arguments.length){var t=arguments[0];this.deStar.remove(t)}},getIndex:function(t){return this.deStar.getIndex(t)},getDegree:function(){return this.deStar.getDegree()},interfaces_:function(){return[]},getClass:function(){return Lr}}),Lr.getEdgesBetween=function(t,e){var n=Nr.toEdges(t.getOutEdges().getEdges()),i=new J(n),r=Nr.toEdges(e.getOutEdges().getEdges());return i.retainAll(r),i},h(Rr,Sr),e(Rr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return Rr}}),e(Tr.prototype,{find:function(t){return this.nodeMap.get(t)},iterator:function(){return this.nodeMap.values().iterator()},remove:function(t){return this.nodeMap.remove(t)},values:function(){return this.nodeMap.values()},add:function(t){return this.nodeMap.put(t.getCoordinate(),t),t},interfaces_:function(){return[]},getClass:function(){return Tr}}),e(Pr.prototype,{findNodesOfDegree:function(t){for(var e=new I,n=this.nodeIterator();n.hasNext();){var i=n.next();i.getDegree()===t&&e.add(i)}return e},dirEdgeIterator:function(){return this.dirEdges.iterator()},edgeIterator:function(){return this.edges.iterator()},remove:function(){if(arguments[0]instanceof Sr){var t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this.edges.remove(t),t.remove()}else if(arguments[0]instanceof Nr){var e=arguments[0],n=e.getSym();null!==n&&n.setSym(null),e.getFromNode().remove(e),e.remove(),this.dirEdges.remove(e)}else if(arguments[0]instanceof Lr){for(var i=arguments[0],r=i.getOutEdges().getEdges(),s=r.iterator();s.hasNext();){var o=s.next(),n=o.getSym();null!==n&&this.remove(n),this.dirEdges.remove(o);var a=o.getEdge();null!==a&&this.edges.remove(a)}this.nodeMap.remove(i.getCoordinate()),i.remove()}},findNode:function(t){return this.nodeMap.find(t)},getEdges:function(){return this.edges},nodeIterator:function(){return this.nodeMap.iterator()},contains:function(){if(arguments[0]instanceof Sr){var t=arguments[0];return this.edges.contains(t)}if(arguments[0]instanceof Nr){var e=arguments[0];return this.dirEdges.contains(e)}},add:function(){if(arguments[0]instanceof Lr){var t=arguments[0];this.nodeMap.add(t)}else if(arguments[0]instanceof Sr){var e=arguments[0];this.edges.add(e),this.add(e.getDirEdge(0)),this.add(e.getDirEdge(1))}else if(arguments[0]instanceof Nr){var n=arguments[0];this.dirEdges.add(n)}},getNodes:function(){return this.nodeMap.values()},interfaces_:function(){return[]},getClass:function(){return Pr}}),h(br,Pr),e(br.prototype,{addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new Cr(r,s,e[1],!0),a=new Cr(s,r,e[e.length-2],!1),u=new Rr(t);u.setDirectedEdges(o,a),this.add(u)},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new Lr(t),this.add(e)),e},interfaces_:function(){return[]},getClass:function(){return br}}),e(Or.prototype,{buildEdgeStringsForUnprocessedNodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.isMarked()||(f.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForNonDegree2Nodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForObviousStartNodes:function(){this.buildEdgeStringsForNonDegree2Nodes()},getMergedLineStrings:function(){return this.merge(),this.mergedLineStrings},buildEdgeStringsStartingAt:function(t){for(var e=t.getOutEdges().iterator();e.hasNext();){var n=e.next();n.getEdge().isMarked()||this.edgeStrings.add(this.buildEdgeStringStartingWith(n))}},merge:function(){if(null!==this.mergedLineStrings)return null;Ir.setMarked(this.graph.nodeIterator(),!1),Ir.setMarked(this.graph.edgeIterator(),!1),this.edgeStrings=new I,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this.mergedLineStrings=new I;for(var t=this.edgeStrings.iterator();t.hasNext();){var e=t.next();this.mergedLineStrings.add(e.toLineString())}},buildEdgeStringStartingWith:function(t){var e=new Er(this.factory),n=t;do e.add(n),n.getEdge().setMarked(!0),n=n.getNext();while(null!==n&&n!==t);return e},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v)){var e=arguments[0];this.mergedLineStrings=null;for(var n=e.iterator();n.hasNext();){var i=n.next();this.add(i)}}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory()),this.graph.addEdge(r)}},buildEdgeStringsForIsolatedLoops:function(){this.buildEdgeStringsForUnprocessedNodes()},interfaces_:function(){return[]},getClass:function(){return Or}});var Lo=Object.freeze({LineMerger:Or}),Ro=Object.freeze({OverlayOp:ii});h(_r,Nr),e(_r.prototype,{getNext:function(){return this.next},isInRing:function(){return null!==this.edgeRing},setRing:function(t){this.edgeRing=t},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setNext:function(t){this.next=t},getRing:function(){return this.edgeRing},interfaces_:function(){return[]},getClass:function(){return _r}}),h(Mr,Sr),e(Mr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return Mr}}),e(Dr.prototype,{isIncluded:function(){return this._isIncluded},getCoordinates:function(){if(null===this.ringPts){for(var t=new N,e=this.deList.iterator();e.hasNext();){var n=e.next(),i=n.getEdge();Dr.addEdge(i.getLine().getCoordinates(),n.getEdgeDirection(),t)}this.ringPts=t.toCoordinateArray()}return this.ringPts},isIncludedSet:function(){return this._isIncludedSet},isValid:function(){return this.getCoordinates(),this.ringPts.length<=3?!1:(this.getRing(),this.ring.isValid())},build:function(t){var e=t;do this.add(e),e.setRing(this),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t)},isOuterHole:function(){return this._isHole?!this.hasShell():!1},getPolygon:function(){var t=null;if(null!==this.holes){t=new Array(this.holes.size()).fill(null);for(var e=0;e<this.holes.size();e++)t[e]=this.holes.get(e)}var n=this.factory.createPolygon(this.ring,t);return n},isHole:function(){return this._isHole},isProcessed:function(){return this._isProcessed},addHole:function(){if(arguments[0]instanceof bt){var t=arguments[0];null===this.holes&&(this.holes=new I),this.holes.add(t)}else if(arguments[0]instanceof Dr){var e=arguments[0];e.setShell(this);var n=e.getRing();null===this.holes&&(this.holes=new I),this.holes.add(n)}},setIncluded:function(t){this._isIncluded=t,this._isIncludedSet=!0},getOuterHole:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing();if(n.isOuterHole())return n}return null},computeHole:function(){var t=this.getRing();this._isHole=he.isCCW(t.getCoordinates())},hasShell:function(){return null!==this.shell},isOuterShell:function(){return null!==this.getOuterHole()},getLineString:function(){return this.getCoordinates(),this.factory.createLineString(this.ringPts)},toString:function(){return se.toLineString(new Gt(this.getCoordinates()))},getShell:function(){return this.isHole()?this.shell:this},add:function(t){this.deList.add(t)},getRing:function(){if(null!==this.ring)return this.ring;this.getCoordinates(),this.ringPts.length<3&&A.out.println(this.ringPts);try{this.ring=this.factory.createLinearRing(this.ringPts)}catch(t){if(!(t instanceof S))throw t;A.out.println(this.ringPts)}finally{}return this.ring},updateIncluded:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing().getShell();if(null!==n&&n.isIncludedSet())return this.setIncluded(!n.isIncluded()),null}},setShell:function(t){this.shell=t},setProcessed:function(t){this._isProcessed=t},interfaces_:function(){return[]},getClass:function(){return Dr}}),Dr.findDirEdgesInRing=function(t){var e=t,n=new I;do n.add(e),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t);return n},Dr.addEdge=function(t,e,n){if(e)for(var i=0;i<t.length;i++)n.add(t[i],!1);else for(var i=t.length-1;i>=0;i--)n.add(t[i],!1)},Dr.findEdgeRingContaining=function(t,e){for(var n=t.getRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getRing(),h=l.getEnvelopeInternal();if(!h.equals(i)&&h.contains(i)){r=H.ptNotInList(n.getCoordinates(),l.getCoordinates());var c=!1;he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u,o=s.getRing().getEnvelopeInternal())}}return s},e(Ar.prototype,{compare:function(t,e){var n=t,i=e;return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope())},interfaces_:function(){return[a]},getClass:function(){return Ar}}),Dr.EnvelopeComparator=Ar,h(Fr,Pr),e(Fr.prototype,{findEdgeRing:function(t){var e=new Dr(this.factory);return e.build(t),e},computeDepthParity:function(){if(0===arguments.length)for(;;){var t=null;if(null===t)return null;this.computeDepthParity(t)}else if(1===arguments.length){arguments[0]}},computeNextCWEdges:function(){for(var t=this.nodeIterator();t.hasNext();){var e=t.next();Fr.computeNextCWEdges(e)}},addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new _r(r,s,e[1],!0),a=new _r(s,r,e[e.length-2],!1),u=new Mr(t);u.setDirectedEdges(o,a),this.add(u)},deleteCutEdges:function(){this.computeNextCWEdges(),Fr.findLabeledEdgeRings(this.dirEdges);for(var t=new I,e=this.dirEdges.iterator();e.hasNext();){var n=e.next();if(!n.isMarked()){var i=n.getSym();if(n.getLabel()===i.getLabel()){n.setMarked(!0),i.setMarked(!0);var r=n.getEdge();t.add(r.getLine())}}}return t},getEdgeRings:function(){this.computeNextCWEdges(),Fr.label(this.dirEdges,-1);var t=Fr.findLabeledEdgeRings(this.dirEdges);this.convertMaximalToMinimalEdgeRings(t);for(var e=new I,n=this.dirEdges.iterator();n.hasNext();){var i=n.next();if(!i.isMarked()&&!i.isInRing()){var r=this.findEdgeRing(i);e.add(r)}}return e},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new Lr(t),this.add(e)),e},convertMaximalToMinimalEdgeRings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel(),r=Fr.findIntersectionNodes(n,i);if(null!==r)for(var s=r.iterator();s.hasNext();){var o=s.next();Fr.computeNextCCWEdges(o,i)}}},deleteDangles:function(){for(var t=this.findNodesOfDegree(1),e=new J,n=new pe,i=t.iterator();i.hasNext();)n.push(i.next());for(;!n.isEmpty();){var r=n.pop();Fr.deleteAllEdges(r);for(var s=r.getOutEdges().getEdges(),i=s.iterator();i.hasNext();){var o=i.next();o.setMarked(!0);var a=o.getSym();null!==a&&a.setMarked(!0);var u=o.getEdge();e.add(u.getLine());var l=o.getToNode();1===Fr.getDegreeNonDeleted(l)&&n.push(l)}}return e},interfaces_:function(){return[]},getClass:function(){return Fr}}),Fr.findLabeledEdgeRings=function(t){for(var e=new I,n=1,i=t.iterator();i.hasNext();){var r=i.next();if(!(r.isMarked()||r.getLabel()>=0)){e.add(r);var s=Dr.findDirEdgesInRing(r);Fr.label(s,n),n++}}return e},Fr.getDegreeNonDeleted=function(t){for(var e=t.getOutEdges().getEdges(),n=0,i=e.iterator();i.hasNext();){var r=i.next();r.isMarked()||n++}return n},Fr.deleteAllEdges=function(t){for(var e=t.getOutEdges().getEdges(),n=e.iterator();n.hasNext();){var i=n.next();i.setMarked(!0);var r=i.getSym();null!==r&&r.setMarked(!0)}},Fr.label=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();i.setLabel(e)}},Fr.computeNextCWEdges=function(t){for(var e=t.getOutEdges(),n=null,i=null,r=e.getEdges().iterator();r.hasNext();){var s=r.next();if(!s.isMarked()){if(null===n&&(n=s),null!==i){var o=i.getSym();o.setNext(s)}i=s}}if(null!==i){var o=i.getSym();o.setNext(n)}},Fr.computeNextCCWEdges=function(t,e){for(var n=t.getOutEdges(),i=null,r=null,s=n.getEdges(),o=s.size()-1;o>=0;o--){var a=s.get(o),u=a.getSym(),l=null;a.getLabel()===e&&(l=a);var h=null;u.getLabel()===e&&(h=u),null===l&&null===h||(null!==h&&(r=h),null!==l&&(null!==r&&(r.setNext(l),r=null),null===i&&(i=l)))}null!==r&&(f.isTrue(null!==i),r.setNext(i))},Fr.getDegree=function(t,e){for(var n=t.getOutEdges().getEdges(),i=0,r=n.iterator();r.hasNext();){var s=r.next();s.getLabel()===e&&i++}return i},Fr.findIntersectionNodes=function(t,e){var n=t,i=null;do{var r=n.getFromNode();Fr.getDegree(r,e)>1&&(null===i&&(i=new I),i.add(r)),n=n.getNext(),f.isTrue(null!==n,"found null DE in ring"),f.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return i},e(Gr.prototype,{getGeometry:function(){return null===this.geomFactory&&(this.geomFactory=new ie),this.polygonize(),this.extractOnlyPolygonal?this.geomFactory.buildGeometry(this.polyList):this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList))},getInvalidRingLines:function(){return this.polygonize(),this.invalidRingLines},findValidRings:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isValid()?e.add(r):n.add(r.getLineString())}},polygonize:function(){if(null!==this.polyList)return null;if(this.polyList=new I,null===this.graph)return null;this.dangles=this.graph.deleteDangles(),this.cutEdges=this.graph.deleteCutEdges();var t=this.graph.getEdgeRings(),e=new I;this.invalidRingLines=new I,this.isCheckingRingsValid?this.findValidRings(t,e,this.invalidRingLines):e=t,this.findShellsAndHoles(e),Gr.assignHolesToShells(this.holeList,this.shellList),ho.sort(this.shellList,new Dr.EnvelopeComparator);var n=!0;this.extractOnlyPolygonal&&(Gr.findDisjointShells(this.shellList),n=!1),this.polyList=Gr.extractPolygons(this.shellList,n)},getDangles:function(){return this.polygonize(),this.dangles},getCutEdges:function(){return this.polygonize(),this.cutEdges},getPolygons:function(){return this.polygonize(),this.polyList},add:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.add(n)}else if(arguments[0]instanceof St){var i=arguments[0];this.geomFactory=i.getFactory(),null===this.graph&&(this.graph=new Fr(this.geomFactory)),this.graph.addEdge(i)}else if(arguments[0]instanceof B){var r=arguments[0];r.apply(this.lineStringAdder)}},setCheckRingsValid:function(t){this.isCheckingRingsValid=t},findShellsAndHoles:function(t){this.holeList=new I,this.shellList=new I;for(var e=t.iterator();e.hasNext();){var n=e.next();n.computeHole(),n.isHole()?this.holeList.add(n):this.shellList.add(n)}},interfaces_:function(){return[]},getClass:function(){return Gr}}),Gr.findOuterShells=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getOuterHole();null===i||i.isProcessed()||(n.setIncluded(!0),i.setProcessed(!0))}},Gr.extractPolygons=function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next();(e||r.isIncluded())&&n.add(r.getPolygon())}return n},Gr.assignHolesToShells=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();Gr.assignHoleToShell(i,e)}},Gr.assignHoleToShell=function(t,e){var n=Dr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)},Gr.findDisjointShells=function(t){Gr.findOuterShells(t);var e=null;do{e=!1;for(var n=t.iterator();n.hasNext();){var i=n.next();i.isIncludedSet()||(i.updateIncluded(),i.isIncludedSet()||(e=!0))}}while(e)},e(qr.prototype,{filter:function(t){t instanceof St&&this.p.add(t)},interfaces_:function(){return[q]},getClass:function(){return qr}}),Gr.LineStringAdder=qr;var To=Object.freeze({Polygonizer:Gr});e(Br.prototype,{createEdgeEndForNext:function(t,e,n,i){var r=n.segmentIndex+1;if(r>=t.getNumPoints()&&null===i)return null;var s=t.getCoordinate(r);null!==i&&i.segmentIndex===n.segmentIndex&&(s=i.coord);var o=new En(t,n.coord,s,new gn(t.getLabel()));e.add(o)},createEdgeEndForPrev:function(t,e,n,i){var r=n.segmentIndex;if(0===n.dist){if(0===r)return null;r--}var s=t.getCoordinate(r);null!==i&&i.segmentIndex>=r&&(s=i.coord);var o=new gn(t.getLabel());o.flip();var a=new En(t,n.coord,s,o);e.add(a)},computeEdgeEnds:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=t;n.hasNext();){var i=n.next();this.computeEdgeEnds(i,e)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1],o=r.getEdgeIntersectionList();o.addEndpoints();var a=o.iterator(),u=null,l=null;if(!a.hasNext())return null;var h=a.next();do u=l,l=h,h=null,a.hasNext()&&(h=a.next()),null!==l&&(this.createEdgeEndForPrev(r,s,l,u),this.createEdgeEndForNext(r,s,l,h));while(null!==l)}},interfaces_:function(){return[]},getClass:function(){return Br}}),h(zr,En),e(zr.prototype,{insert:function(t){this.edgeEnds.add(t)},print:function(t){t.println("EdgeEndBundle--> Label: "+this.label);for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t),t.println()}},iterator:function(){return this.edgeEnds.iterator()},getEdgeEnds:function(){return this.edgeEnds},computeLabelOn:function(t,e){for(var n=0,i=!1,r=this.iterator();r.hasNext();){var s=r.next(),o=s.getLabel().getLocation(t);o===L.BOUNDARY&&n++,o===L.INTERIOR&&(i=!0)}var o=L.NONE;i&&(o=L.INTERIOR),n>0&&(o=$n.determineBoundary(e,n)),this.label.setLocation(t,o)},computeLabelSide:function(t,e){for(var n=this.iterator();n.hasNext();){var i=n.next();if(i.getLabel().isArea()){var r=i.getLabel().getLocation(t,e);if(r===L.INTERIOR)return this.label.setLocation(t,e,L.INTERIOR),null;r===L.EXTERIOR&&this.label.setLocation(t,e,L.EXTERIOR)}}},getLabel:function(){return this.label},computeLabelSides:function(t){this.computeLabelSide(t,cn.LEFT),this.computeLabelSide(t,cn.RIGHT)},updateIM:function(t){Jn.updateIM(this.label,t)},computeLabel:function(t){for(var e=!1,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().isArea()&&(e=!0)}e?this.label=new gn(L.NONE,L.NONE,L.NONE):this.label=new gn(L.NONE);for(var r=0;2>r;r++)this.computeLabelOn(r,t),e&&this.computeLabelSides(r)},interfaces_:function(){return[]},getClass:function(){return zr}}),h(Vr,Pn),e(Vr.prototype,{updateIM:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}},insert:function(t){var e=this.edgeMap.get(t);null===e?(e=new zr(t),this.insertEdgeEnd(t,e)):e.insert(t)},interfaces_:function(){return[]},getClass:function(){return Vr}}),h(kr,yn),e(kr.prototype,{updateIMFromEdges:function(t){this.edges.updateIM(t)},computeIM:function(t){t.setAtLeastIfValid(this.label.getLocation(0),this.label.getLocation(1),0)},interfaces_:function(){return[]},getClass:function(){return kr}}),h(Yr,Nn),e(Yr.prototype,{createNode:function(t){return new kr(t,new Vr)},interfaces_:function(){return[]},getClass:function(){return Yr}}),e(Ur.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},computeProperIntersectionIM:function(t,e){var n=this.arg[0].getGeometry().getDimension(),i=this.arg[1].getGeometry().getDimension(),r=t.hasProperIntersection(),s=t.hasProperInteriorIntersection();2===n&&2===i?r&&e.setAtLeast("212101212"):2===n&&1===i?(r&&e.setAtLeast("FFF0FFFF2"),s&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(r&&e.setAtLeast("F0FFFFFF2"),s&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&s&&e.setAtLeast("0FFFFFFFF")},labelIsolatedEdges:function(t,e){for(var n=this.arg[t].getEdgeIterator();n.hasNext();){var i=n.next();i.isIsolated()&&(this.labelIsolatedEdge(i,e,this.arg[e].getGeometry()),this.isolatedEdges.add(i))}},labelIsolatedEdge:function(t,e,n){if(n.getDimension()>0){var i=this.ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,L.EXTERIOR)},computeIM:function(){var t=new fe;if(t.set(L.EXTERIOR,L.EXTERIOR,2),!this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1);var e=this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);var n=new Br,i=n.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(i);var r=n.computeEdgeEnds(this.arg[1].getEdgeIterator());return this.insertEdgeEnds(r),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t},labelNodeEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}},copyNodesAndLabels:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.nodes.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},labelIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.find(s.coord);o.getLabel().isNull(t)&&(i===L.BOUNDARY?o.setLabelBoundary(t):o.setLabel(t,L.INTERIOR))}},labelIsolatedNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setAllLocations(e,n)},computeIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.addNode(s.coord);i===L.BOUNDARY?o.setLabelBoundary(t):o.getLabel().isNull(t)&&o.setLabel(t,L.INTERIOR)}},labelIsolatedNodes:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();f.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}},updateIM:function(t){for(var e=this.isolatedEdges.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}for(var i=this.nodes.iterator();i.hasNext();){var r=i.next();r.updateIM(t),r.updateIMFromEdges(t)}},computeDisjointIM:function(t){var e=this.arg[0].getGeometry();e.isEmpty()||(t.set(L.INTERIOR,L.EXTERIOR,e.getDimension()),t.set(L.BOUNDARY,L.EXTERIOR,e.getBoundaryDimension()));var n=this.arg[1].getGeometry();n.isEmpty()||(t.set(L.EXTERIOR,L.INTERIOR,n.getDimension()),t.set(L.EXTERIOR,L.BOUNDARY,n.getBoundaryDimension()))},interfaces_:function(){return[]},getClass:function(){return Ur}}),e(Xr.prototype,{isContainedInBoundary:function(t){if(t instanceof Tt)return!1;if(t instanceof Lt)return this.isPointContainedInBoundary(t);if(t instanceof St)return this.isLineStringContainedInBoundary(t);for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0},isLineSegmentContainedInBoundary:function(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this.rectEnv.getMinX()||t.x===this.rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this.rectEnv.getMinY()||t.y===this.rectEnv.getMaxY()))return!0;return!1},isLineStringContainedInBoundary:function(t){for(var e=t.getCoordinateSequence(),n=new g,i=new g,r=0;r<e.size()-1;r++)if(e.getCoordinate(r,n),e.getCoordinate(r+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0},isPointContainedInBoundary:function(){if(arguments[0]instanceof Lt){var t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){var e=arguments[0];return e.x===this.rectEnv.getMinX()||e.x===this.rectEnv.getMaxX()||e.y===this.rectEnv.getMinY()||e.y===this.rectEnv.getMaxY()}},contains:function(t){return this.rectEnv.contains(t.getEnvelopeInternal())?!this.isContainedInBoundary(t):!1},interfaces_:function(){return[]},getClass:function(){return Xr}}),Xr.contains=function(t,e){var n=new Xr(t);return n.contains(e)},e(Hr.prototype,{intersects:function(t,e){var n=new C(t,e);if(!this.rectEnv.intersects(n))return!1;if(this.rectEnv.intersects(t))return!0;if(this.rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){var i=t;t=e,e=i}var r=!1;return e.y>t.y&&(r=!0),r?this.li.computeIntersection(t,e,this.diagDown0,this.diagDown1):this.li.computeIntersection(t,e,this.diagUp0,this.diagUp1),!!this.li.hasIntersection()},interfaces_:function(){return[]},getClass:function(){return Hr}}),e(Wr.prototype,{applyTo:function(t){for(var e=0;e<t.getNumGeometries()&&!this._isDone;e++){var n=t.getGeometryN(e);if(n instanceof ft)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}},interfaces_:function(){return[]},getClass:function(){return Wr}}),e(jr.prototype,{intersects:function(t){if(!this.rectEnv.intersects(t.getEnvelopeInternal()))return!1;var e=new Kr(this.rectEnv);if(e.applyTo(t),e.intersects())return!0;var n=new Zr(this.rectangle);if(n.applyTo(t),n.containsPoint())return!0;var i=new Qr(this.rectangle);return i.applyTo(t),!!i.intersects()},interfaces_:function(){return[]},getClass:function(){return jr}}),jr.intersects=function(t,e){var n=new jr(t);return n.intersects(e)},h(Kr,Wr),e(Kr.prototype,{isDone:function(){return this._intersects===!0},visit:function(t){var e=t.getEnvelopeInternal();return this.rectEnv.intersects(e)?this.rectEnv.contains(e)?(this._intersects=!0,null):e.getMinX()>=this.rectEnv.getMinX()&&e.getMaxX()<=this.rectEnv.getMaxX()?(this._intersects=!0,null):e.getMinY()>=this.rectEnv.getMinY()&&e.getMaxY()<=this.rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null},intersects:function(){return this._intersects},interfaces_:function(){return[]},getClass:function(){return Kr}}),h(Zr,Wr),e(Zr.prototype,{isDone:function(){return this._containsPoint===!0},visit:function(t){if(!(t instanceof Tt))return null;var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;for(var n=new g,i=0;4>i;i++)if(this.rectSeq.getCoordinate(i,n),e.contains(n)&&Tn.containsPointInPolygon(n,t))return this._containsPoint=!0,null},containsPoint:function(){return this._containsPoint},interfaces_:function(){return[]},getClass:function(){return Zr}}),h(Qr,Wr),e(Qr.prototype,{intersects:function(){return this.hasIntersection},isDone:function(){return this.hasIntersection===!0},visit:function(t){var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;var n=kn.getLines(t);this.checkIntersectionWithLineStrings(n)},checkIntersectionWithLineStrings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();if(this.checkIntersectionWithSegments(n),this.hasIntersection)return null}},checkIntersectionWithSegments:function(t){for(var e=t.getCoordinateSequence(),n=1;n<e.size();n++)if(e.getCoordinate(n-1,this.p0),e.getCoordinate(n,this.p1),this.rectIntersector.intersects(this.p0,this.p1))return this.hasIntersection=!0,null},interfaces_:function(){return[]},getClass:function(){return Qr}}),h(Jr,ti),e(Jr.prototype,{getIntersectionMatrix:function(){return this._relate.computeIM()},interfaces_:function(){return[]},getClass:function(){return Jr}}),Jr.covers=function(t,e){return t.getEnvelopeInternal().covers(e.getEnvelopeInternal())?t.isRectangle()?!0:Jr.relate(t,e).isCovers():!1},Jr.intersects=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?t.isRectangle()?jr.intersects(t,e):e.isRectangle()?jr.intersects(e,t):Jr.relate(t,e).isIntersects():!1},Jr.touches=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Jr.relate(t,e).isTouches(t.getDimension(),e.getDimension()):!1},Jr.within=function(t,e){return e.contains(t)},Jr.coveredBy=function(t,e){return Jr.covers(e,t)},Jr.relate=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Jr(t,e),i=n.getIntersectionMatrix();return i}if(3===arguments.length){if("string"==typeof arguments[2]&&arguments[0]instanceof B&&arguments[1]instanceof B){var r=arguments[0],s=arguments[1],o=arguments[2];return Jr.relateWithCheck(r,s).matches(o)}if(R(arguments[2],V)&&arguments[0]instanceof B&&arguments[1]instanceof B){var a=arguments[0],u=arguments[1],l=arguments[2],n=new Jr(a,u,l),i=n.getIntersectionMatrix();return i}}},Jr.overlaps=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Jr.relate(t,e).isOverlaps(t.getDimension(),e.getDimension()):!1},Jr.disjoint=function(t,e){return!t.intersects(e)},Jr.relateWithCheck=function(t,e){return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),Jr.relate(t,e)},Jr.crosses=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Jr.relate(t,e).isCrosses(t.getDimension(),e.getDimension()):!1},Jr.contains=function(t,e){return t.getEnvelopeInternal().contains(e.getEnvelopeInternal())?t.isRectangle()?Xr.contains(t,e):Jr.relate(t,e).isContains():!1};var Po=Object.freeze({RelateOp:Jr});e($r.prototype,{extractElements:function(t,e){if(null===t)return null;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);this.skipEmpty&&i.isEmpty()||e.add(i)}},combine:function(){for(var t=new I,e=this.inputGeoms.iterator();e.hasNext();){var n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this.geomFactory?this.geomFactory.createGeometryCollection(null):null:this.geomFactory.buildGeometry(t)},interfaces_:function(){return[]},getClass:function(){return $r}}),$r.combine=function(){if(1===arguments.length){var t=arguments[0],e=new $r(t);
return e.combine()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new $r($r.createList(n,i));return e.combine()}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],e=new $r($r.createList(r,s,o));return e.combine()}},$r.extractFactory=function(t){return t.isEmpty()?null:t.iterator().next().getFactory()},$r.createList=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new I;return n.add(t),n.add(e),n}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],n=new I;return n.add(i),n.add(r),n.add(s),n}},e(ts.prototype,{union:function(){for(var t=new Te,e=new at,n=0;n<this.pointGeom.getNumGeometries();n++){var i=this.pointGeom.getGeometryN(n),r=i.getCoordinate(),s=t.locate(r,this.otherGeom);s===L.EXTERIOR&&e.add(r)}if(0===e.size())return this.otherGeom;var o=null,a=H.toCoordinateArray(e);return o=1===a.length?this.geomFact.createPoint(a[0]):this.geomFact.createMultiPointFromCoords(a),$r.combine(o,this.otherGeom)},interfaces_:function(){return[]},getClass:function(){return ts}}),ts.union=function(t,e){var n=new ts(t,e);return n.union()},e(es.prototype,{filter:function(t){-1!==this.sortIndex&&t.getSortIndex()!==this.sortIndex||this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return es}}),es.extract=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return es.extract(t,e,new I)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];return n.getSortIndex()===i?r.add(n):n instanceof ft&&n.apply(new es(i,r)),r}},e(ns.prototype,{reduceToGeometries:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=null;R(i,y)?r=this.unionTree(i):i instanceof B&&(r=i),e.add(r)}return e},extractByEnvelope:function(t,e,n){for(var i=new I,r=0;r<e.getNumGeometries();r++){var s=e.getGeometryN(r);s.getEnvelopeInternal().intersects(t)?i.add(s):n.add(s)}return this.geomFactory.buildGeometry(i)},unionOptimized:function(t,e){var n=t.getEnvelopeInternal(),i=e.getEnvelopeInternal();if(!n.intersects(i)){var r=$r.combine(t,e);return r}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);var s=n.intersection(i);return this.unionUsingEnvelopeIntersection(t,e,s)},union:function(){if(null===this.inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this.inputPolys.isEmpty())return null;this.geomFactory=this.inputPolys.iterator().next().getFactory();for(var t=new ke(ns.STRTREE_NODE_CAPACITY),e=this.inputPolys.iterator();e.hasNext();){var n=e.next();t.insert(n.getEnvelopeInternal(),n)}this.inputPolys=null;var i=t.itemsTree(),r=this.unionTree(i);return r},binaryUnion:function(){if(1===arguments.length){var t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];if(1>=i-n){var r=ns.getGeometry(e,n);return this.unionSafe(r,null)}if(i-n===2)return this.unionSafe(ns.getGeometry(e,n),ns.getGeometry(e,n+1));var s=Math.trunc((i+n)/2),r=this.binaryUnion(e,n,s),o=this.binaryUnion(e,s,i);return this.unionSafe(r,o)}},repeatedUnion:function(t){for(var e=null,n=t.iterator();n.hasNext();){var i=n.next();e=null===e?i.copy():e.union(i)}return e},unionSafe:function(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)},unionActual:function(t,e){return ns.restrictToPolygons(t.union(e))},unionTree:function(t){var e=this.reduceToGeometries(t),n=this.binaryUnion(e);return n},unionUsingEnvelopeIntersection:function(t,e,n){var i=new I,r=this.extractByEnvelope(n,t,i),s=this.extractByEnvelope(n,e,i),o=this.unionActual(r,s);i.add(o);var a=$r.combine(i);return a},bufferUnion:function(){if(1===arguments.length){var t=arguments[0],e=t.get(0).getFactory(),n=e.buildGeometry(t),i=n.buffer(0);return i}if(2===arguments.length){var r=arguments[0],s=arguments[1],e=r.getFactory(),n=e.createGeometryCollection([r,s]),i=n.buffer(0);return i}},interfaces_:function(){return[]},getClass:function(){return ns}}),ns.restrictToPolygons=function(t){if(R(t,Rt))return t;var e=pr.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(ie.toPolygonArray(e))},ns.getGeometry=function(t,e){return e>=t.size()?null:t.get(e)},ns.union=function(t){var e=new ns(t);return e.union()},ns.STRTREE_NODE_CAPACITY=4,e(is.prototype,{unionNoOpt:function(t){var e=this.geomFact.createPoint();return si.overlayOp(t,e,ii.UNION)},unionWithNull:function(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)},extract:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.extract(n)}else if(arguments[0]instanceof B){var i=arguments[0];null===this.geomFact&&(this.geomFact=i.getFactory()),es.extract(i,B.SORTINDEX_POLYGON,this.polygons),es.extract(i,B.SORTINDEX_LINESTRING,this.lines),es.extract(i,B.SORTINDEX_POINT,this.points)}},union:function Xo(){if(null===this.geomFact)return null;var t=null;if(this.points.size()>0){var e=this.geomFact.buildGeometry(this.points);t=this.unionNoOpt(e)}var n=null;if(this.lines.size()>0){var i=this.geomFact.buildGeometry(this.lines);n=this.unionNoOpt(i)}var r=null;this.polygons.size()>0&&(r=ns.union(this.polygons));var s=this.unionWithNull(n,r),Xo=null;return Xo=null===t?s:null===s?t:ts.union(t,s),null===Xo?this.geomFact.createGeometryCollection():Xo},interfaces_:function(){return[]},getClass:function(){return is}}),is.union=function(){if(1===arguments.length){if(R(arguments[0],v)){var t=arguments[0],e=new is(t);return e.union()}if(arguments[0]instanceof B){var n=arguments[0],e=new is(n);return e.union()}}else if(2===arguments.length){var i=arguments[0],r=arguments[1],e=new is(i,r);return e.union()}};var bo=Object.freeze({UnaryUnionOp:is});e(rs.prototype,{visitInteriorRing:function(t,e){var n=t.getCoordinates(),i=n[0],r=rs.findDifferentPoint(n,i),s=e.findEdgeInSameDirection(i,r),o=e.findEdgeEnd(s),a=null;o.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR?a=o:o.getSym().getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&(a=o.getSym()),f.isTrue(null!==a,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(a)},visitShellInteriors:function(t,e){if(t instanceof Tt){var n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof Ot)for(var i=t,r=0;r<i.getNumGeometries();r++){var n=i.getGeometryN(r);this.visitInteriorRing(n.getExteriorRing(),e)}},getCoordinate:function(){return this.disconnectedRingcoord},setInteriorEdgesInResult:function(t){for(var e=t.getEdgeEnds().iterator();e.hasNext();){var n=e.next();n.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&n.setInResult(!0)}},visitLinkedDirectedEdges:function(t){var e=t,n=t;do f.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext();while(n!==e)},buildEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);r.linkDirectedEdgesForMinimalEdgeRings();var s=r.buildMinimalRings();e.addAll(s)}}return e},hasUnvisitedShellEdge:function(t){for(var e=0;e<t.size();e++){var n=t.get(e);if(!n.isHole()){var i=n.getEdges(),r=i.get(0);if(r.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR)for(var s=0;s<i.size();s++)if(r=i.get(s),!r.isVisited())return this.disconnectedRingcoord=r.getCoordinate(),!0}}return!1},isInteriorsConnected:function(){var t=new I;this.geomGraph.computeSplitEdges(t);var e=new Cn(new On);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();var n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this.geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)},interfaces_:function(){return[]},getClass:function(){return rs}}),rs.findDifferentPoint=function(t,e){for(var n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null},e(ss.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},getNodeIterator:function(){return this.nodes.iterator()},copyNodesAndLabels:function(t,e){for(var n=t.getNodeIterator();n.hasNext();){var i=n.next(),r=this.nodes.addNode(i.getCoordinate());r.setLabel(e,i.getLabel().getLocation(e))}},build:function(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);var e=new Br,n=e.computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(n)},computeIntersectionNodes:function(t,e){for(var n=t.getEdgeIterator();n.hasNext();)for(var i=n.next(),r=i.getLabel().getLocation(e),s=i.getEdgeIntersectionList().iterator();s.hasNext();){var o=s.next(),a=this.nodes.addNode(o.coord);r===L.BOUNDARY?a.setLabelBoundary(e):a.getLabel().isNull(e)&&a.setLabel(e,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return ss}}),e(os.prototype,{isNodeEdgeAreaLabelsConsistent:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();){var e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this.geomGraph))return this.invalidPoint=e.getCoordinate().copy(),!1}return!0},getInvalidPoint:function(){return this.invalidPoint},hasDuplicateRings:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();)for(var e=t.next(),n=e.getEdges().iterator();n.hasNext();){var i=n.next();if(i.getEdgeEnds().size()>1)return this.invalidPoint=i.getEdge().getCoordinate(0),!0}return!1},isNodeConsistentArea:function(){var t=this.geomGraph.computeSelfNodes(this.li,!0,!0);return t.hasProperIntersection()?(this.invalidPoint=t.getProperIntersectionPoint(),!1):(this.nodeGraph.build(this.geomGraph),this.isNodeEdgeAreaLabelsConsistent())},interfaces_:function(){return[]},getClass:function(){return os}}),e(as.prototype,{buildIndex:function(){this.index=new ke;for(var t=0;t<this.rings.size();t++){var e=this.rings.get(t),n=e.getEnvelopeInternal();this.index.insert(n,e)}},getNestedPoint:function(){return this.nestedPt},isNonNested:function(){this.buildIndex();for(var t=0;t<this.rings.size();t++)for(var e=this.rings.get(t),n=e.getCoordinates(),i=this.index.query(e.getEnvelopeInternal()),r=0;r<i.size();r++){var s=i.get(r),o=s.getCoordinates();if(e!==s&&e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())){var a=ls.findPtNotNode(n,s,this.graph);if(null!==a){var u=he.isPointInRing(a,o);if(u)return this.nestedPt=a,!1}}}return!0},add:function(t){this.rings.add(t),this.totalEnv.expandToInclude(t.getEnvelopeInternal())},interfaces_:function(){return[]},getClass:function(){return as}}),e(us.prototype,{getErrorType:function(){return this.errorType},getMessage:function(){return us.errMsg[this.errorType]},getCoordinate:function(){return this.pt},toString:function(){var t="";return null!==this.pt&&(t=" at or near point "+this.pt),this.getMessage()+t},interfaces_:function(){return[]},getClass:function(){return us}}),us.ERROR=0,us.REPEATED_POINT=1,us.HOLE_OUTSIDE_SHELL=2,us.NESTED_HOLES=3,us.DISCONNECTED_INTERIOR=4,us.SELF_INTERSECTION=5,us.RING_SELF_INTERSECTION=6,us.NESTED_SHELLS=7,us.DUPLICATE_RINGS=8,us.TOO_FEW_POINTS=9,us.INVALID_COORDINATE=10,us.RING_NOT_CLOSED=11,us.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"],e(ls.prototype,{checkInvalidCoordinates:function(){if(arguments[0]instanceof Array){for(var t=arguments[0],e=0;e<t.length;e++)if(!ls.isValid(t[e]))return this.validErr=new us(us.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof Tt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()),null!==this.validErr)return null;for(var e=0;e<n.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()),null!==this.validErr)return null}},checkHolesNotNested:function(t,e){for(var n=new as(e),i=0;i<t.getNumInteriorRing();i++){var r=t.getInteriorRingN(i);n.add(r)}var s=n.isNonNested();s||(this.validErr=new us(us.NESTED_HOLES,n.getNestedPoint()))},checkConsistentArea:function(t){var e=new os(t),n=e.isNodeConsistentArea();return n?void(e.hasDuplicateRings()&&(this.validErr=new us(us.DUPLICATE_RINGS,e.getInvalidPoint()))):(this.validErr=new us(us.SELF_INTERSECTION,e.getInvalidPoint()),null)},isValid:function(){return this.checkValid(this.parentGeometry),null===this.validErr},checkShellInsideHole:function(t,e,n){var i=t.getCoordinates(),r=e.getCoordinates(),s=ls.findPtNotNode(i,e,n);if(null!==s){var o=he.isPointInRing(s,r);if(!o)return s}var a=ls.findPtNotNode(r,t,n);if(null!==a){var u=he.isPointInRing(a,i);return u?a:null}return f.shouldNeverReachHere("points in shell and hole appear to be equal"),null},checkNoSelfIntersectingRings:function(t){for(var e=t.getEdgeIterator();e.hasNext();){var n=e.next();if(this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()),null!==this.validErr)return null}},checkConnectedInteriors:function(t){var e=new rs(t);e.isInteriorsConnected()||(this.validErr=new us(us.DISCONNECTED_INTERIOR,e.getCoordinate()))},checkNoSelfIntersectingRing:function(t){for(var e=new at,n=!0,i=t.iterator();i.hasNext();){var r=i.next();if(n)n=!1;else{if(e.contains(r.coord))return this.validErr=new us(us.RING_SELF_INTERSECTION,r.coord),null;e.add(r.coord)}}},checkHolesInShell:function(t,e){for(var n=t.getExteriorRing(),i=new Ii(n),r=0;r<t.getNumInteriorRing();r++){var s=t.getInteriorRingN(r),o=ls.findPtNotNode(s.getCoordinates(),n,e);if(null===o)return null;var a=!i.isInside(o);if(a)return this.validErr=new us(us.HOLE_OUTSIDE_SHELL,o),null}},checkTooFewPoints:function(t){return t.hasTooFewPoints()?(this.validErr=new us(us.TOO_FEW_POINTS,t.getInvalidPoint()),null):void 0},getValidationError:function(){return this.checkValid(this.parentGeometry),this.validErr},checkValid:function(){if(arguments[0]instanceof Lt){var t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Pt){var e=arguments[0];this.checkInvalidCoordinates(e.getCoordinates())}else if(arguments[0]instanceof bt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getCoordinates()),null!==this.validErr)return null;if(this.checkClosedRing(n),null!==this.validErr)return null;var i=new $n(0,n);if(this.checkTooFewPoints(i),null!==this.validErr)return null;var r=new ae;i.computeSelfNodes(r,!0,!0),this.checkNoSelfIntersectingRings(i)}else if(arguments[0]instanceof St){var s=arguments[0];if(this.checkInvalidCoordinates(s.getCoordinates()),null!==this.validErr)return null;var i=new $n(0,s);this.checkTooFewPoints(i)}else if(arguments[0]instanceof Tt){var o=arguments[0];if(this.checkInvalidCoordinates(o),null!==this.validErr)return null;if(this.checkClosedRings(o),null!==this.validErr)return null;var i=new $n(0,o);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;if(this.checkHolesInShell(o,i),null!==this.validErr)return null;if(this.checkHolesNotNested(o,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof Ot){for(var a=arguments[0],u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkInvalidCoordinates(l),null!==this.validErr)return null;if(this.checkClosedRings(l),null!==this.validErr)return null}var i=new $n(0,a);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesInShell(l,i),null!==this.validErr)return null}for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesNotNested(l,i),null!==this.validErr)return null}if(this.checkShellsNotNested(a,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof ft)for(var h=arguments[0],u=0;u<h.getNumGeometries();u++){var c=h.getGeometryN(u);if(this.checkValid(c),null!==this.validErr)return null}else if(arguments[0]instanceof B){var f=arguments[0];if(this.validErr=null,f.isEmpty())return null;if(f instanceof Lt)this.checkValid(f);else if(f instanceof Pt)this.checkValid(f);else if(f instanceof bt)this.checkValid(f);else if(f instanceof St)this.checkValid(f);else if(f instanceof Tt)this.checkValid(f);else if(f instanceof Ot)this.checkValid(f);else{if(!(f instanceof ft))throw new UnsupportedOperationException(f.getClass().getName());this.checkValid(f)}}},setSelfTouchingRingFormingHoleValid:function(t){this.isSelfTouchingRingFormingHoleValid=t},checkShellNotNested:function(t,e,n){var i=t.getCoordinates(),r=e.getExteriorRing(),s=r.getCoordinates(),o=ls.findPtNotNode(i,r,n);if(null===o)return null;var a=he.isPointInRing(o,s);if(!a)return null;if(e.getNumInteriorRing()<=0)return this.validErr=new us(us.NESTED_SHELLS,o),null;for(var u=null,l=0;l<e.getNumInteriorRing();l++){var h=e.getInteriorRingN(l);if(u=this.checkShellInsideHole(t,h,n),null===u)return null}this.validErr=new us(us.NESTED_SHELLS,u)},checkClosedRings:function(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this.validErr)return null;for(var e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this.validErr)return null},checkClosedRing:function(t){if(!t.isClosed()){var e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this.validErr=new us(us.RING_NOT_CLOSED,e)}},checkShellsNotNested:function(t,e){for(var n=0;n<t.getNumGeometries();n++)for(var i=t.getGeometryN(n),r=i.getExteriorRing(),s=0;s<t.getNumGeometries();s++)if(n!==s){var o=t.getGeometryN(s);if(this.checkShellNotNested(r,o,e),null!==this.validErr)return null}},interfaces_:function(){return[]},getClass:function(){return ls}}),ls.findPtNotNode=function(t,e,n){for(var i=n.findEdge(e),r=i.getEdgeIntersectionList(),s=0;s<t.length;s++){var o=t[s];if(!r.isIntersection(o))return o}return null},ls.isValid=function(){if(arguments[0]instanceof B){var t=arguments[0],e=new ls(t);return e.isValid()}if(arguments[0]instanceof g){var n=arguments[0];return r.isNaN(n.x)?!1:r.isInfinite(n.x)?!1:r.isNaN(n.y)?!1:!r.isInfinite(n.y)}};var Oo=Object.freeze({IsValidOp:ls,ConsistentAreaTester:os}),_o=Object.freeze({BoundaryOp:dt,IsSimpleOp:Wi,buffer:So,distance:wo,linemerge:Lo,overlay:Ro,polygonize:To,relate:Po,union:bo,valid:Oo});h(hs,_t.CoordinateOperation),e(hs.prototype,{editCoordinates:function(t,e){if(0===t.length)return null;for(var n=new Array(t.length).fill(null),i=0;i<t.length;i++){var r=new g(t[i]);this.targetPM.makePrecise(r),n[i]=r}var s=new N(n,!1),o=s.toCoordinateArray(),a=0;e instanceof St&&(a=2),e instanceof bt&&(a=4);var u=n;return this.removeCollapsed&&(u=null),o.length<a?u:o},interfaces_:function(){return[]},getClass:function(){return hs}}),e(cs.prototype,{fixPolygonalTopology:function(t){var e=t;this.changePrecisionModel||(e=this.changePM(t,this.targetPM));var n=e.buffer(0),i=n;return this.changePrecisionModel||(i=t.getFactory().createGeometry(n)),i},reducePointwise:function(t){var e=null;if(this.changePrecisionModel){var n=this.createFactory(t.getFactory(),this.targetPM);e=new _t(n)}else e=new _t;var i=this.removeCollapsed;t.getDimension()>=2&&(i=!0);var r=e.edit(t,new hs(this.targetPM,i));return r},changePM:function(t,e){var n=this.createEditor(t.getFactory(),e);return n.edit(t,new _t.NoOpGeometryOperation)},setRemoveCollapsedComponents:function(t){this.removeCollapsed=t},createFactory:function(t,e){var n=new ie(e,t.getSRID(),t.getCoordinateSequenceFactory());return n},setChangePrecisionModel:function(t){this.changePrecisionModel=t},reduce:function(t){var e=this.reducePointwise(t);return this.isPointwise?e:R(e,Rt)?e.isValid()?e:this.fixPolygonalTopology(e):e},setPointwise:function(t){this.isPointwise=t},createEditor:function(t,e){if(t.getPrecisionModel()===e)return new _t;var n=this.createFactory(t,e),i=new _t(n);return i},interfaces_:function(){return[]},getClass:function(){return cs}}),cs.reduce=function(t,e){var n=new cs(e);return n.reduce(t)},cs.reducePointwise=function(t,e){var n=new cs(e);return n.setPointwise(!0),n.reduce(t)};var Mo=Object.freeze({GeometryPrecisionReducer:cs});e(fs.prototype,{simplifySection:function(t,e){if(t+1===e)return null;this.seg.p0=this.pts[t],this.seg.p1=this.pts[e];for(var n=-1,i=t,r=t+1;e>r;r++){var s=this.seg.distance(this.pts[r]);s>n&&(n=s,i=r)}if(n<=this.distanceTolerance)for(var r=t+1;e>r;r++)this.usePt[r]=!1;else this.simplifySection(t,i),this.simplifySection(i,e)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(){this.usePt=new Array(this.pts.length).fill(null);for(var t=0;t<this.pts.length;t++)this.usePt[t]=!0;this.simplifySection(0,this.pts.length-1);for(var e=new N,t=0;t<this.pts.length;t++)this.usePt[t]&&e.add(new g(this.pts[t]));return e.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return fs}}),fs.simplify=function(t,e){var n=new fs(t);return n.setDistanceTolerance(e),n.simplify()},e(gs.prototype,{setEnsureValid:function(t){this.isEnsureValidTopology=t},getResultGeometry:function(){return this.inputGeom.isEmpty()?this.inputGeom.copy():new ds(this.isEnsureValidTopology,this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return gs}}),gs.simplify=function(t,e){var n=new gs(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(ds,xe),e(ds.prototype,{transformPolygon:function(t,e){if(t.isEmpty())return null;var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},createValidArea:function(t){return this.isEnsureValidTopology?t.buffer(0):t},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=null;return i=0===n.length?new Array(0).fill(null):fs.simplify(n,this.distanceTolerance),this.factory.getCoordinateSequenceFactory().create(i)},transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformLinearRing:function(t,e){var n=e instanceof Tt,i=xe.prototype.transformLinearRing.call(this,t,e);return!n||i instanceof bt?i:null},interfaces_:function(){return[]},getClass:function(){return ds}}),gs.DPTransformer=ds,h(ps,ce),e(ps.prototype,{getIndex:function(){return this.index},getParent:function(){return this.parent},interfaces_:function(){return[]},getClass:function(){return ps}}),e(vs.prototype,{addToResult:function(t){this.resultSegs.add(t)},asLineString:function(){return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs))},getResultSize:function(){var t=this.resultSegs.size();return 0===t?0:t+1},getParent:function(){return this.parentLine},getSegment:function(t){return this.segs[t]},getParentCoordinates:function(){return this.parentLine.getCoordinates()},getMinimumSize:function(){return this.minimumSize},asLinearRing:function(){return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs))},getSegments:function(){return this.segs},init:function(){var t=this.parentLine.getCoordinates();this.segs=new Array(t.length-1).fill(null);for(var e=0;e<t.length-1;e++){var n=new ps(t[e],t[e+1],this.parentLine,e);this.segs[e]=n}},getResultCoordinates:function(){return vs.extractCoordinates(this.resultSegs)},interfaces_:function(){return[]},getClass:function(){return vs}}),vs.extractCoordinates=function(t){for(var e=new Array(t.size()+1).fill(null),n=null,i=0;i<t.size();i++)n=t.get(i),e[i]=n.p0;return e[e.length-1]=n.p1,e},e(ms.prototype,{remove:function(t){this.index.remove(new C(t.p0,t.p1),t)},add:function(){if(arguments[0]instanceof vs)for(var t=arguments[0],e=t.getSegments(),n=0;n<e.length;n++){var i=e[n];this.add(i)}else if(arguments[0]instanceof ce){var r=arguments[0];this.index.insert(new C(r.p0,r.p1),r)}},query:function(t){var e=new C(t.p0,t.p1),n=new ys(t);this.index.query(e,n);var i=n.getItems();return i},interfaces_:function(){return[]},getClass:function(){return ms}}),e(ys.prototype,{visitItem:function(t){var e=t;C.intersects(e.p0,e.p1,this.querySeg.p0,this.querySeg.p1)&&this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return ys}}),e(xs.prototype,{flatten:function(t,e){var n=this.linePts[t],i=this.linePts[e],r=new ce(n,i);return this.remove(this.line,t,e),this.outputIndex.add(r),r},hasBadIntersection:function(t,e,n){return this.hasBadOutputIntersection(n)?!0:!!this.hasBadInputIntersection(t,e,n)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplifySection:function(t,e,n){n+=1;var i=new Array(2).fill(null);if(t+1===e){var r=this.line.getSegment(t);return this.line.addToResult(r),null}var s=!0;if(this.line.getResultSize()<this.line.getMinimumSize()){var o=n+1;o<this.line.getMinimumSize()&&(s=!1)}var a=new Array(1).fill(null),u=this.findFurthestPoint(this.linePts,t,e,a);a[0]>this.distanceTolerance&&(s=!1);var l=new ce;if(l.p0=this.linePts[t],l.p1=this.linePts[e],i[0]=t,i[1]=e,this.hasBadIntersection(this.line,i,l)&&(s=!1),s){var r=this.flatten(t,e);return this.line.addToResult(r),null}this.simplifySection(t,u,n),this.simplifySection(u,e,n)},hasBadOutputIntersection:function(t){for(var e=this.outputIndex.query(t),n=e.iterator();n.hasNext();){var i=n.next();if(this.hasInteriorIntersection(i,t))return!0}return!1},findFurthestPoint:function(t,e,n,i){var r=new ce;r.p0=t[e],r.p1=t[n];for(var s=-1,o=e,a=e+1;n>a;a++){var u=t[a],l=r.distance(u);l>s&&(s=l,o=a)}return i[0]=s,o},simplify:function(t){this.line=t,this.linePts=t.getParentCoordinates(),this.simplifySection(0,this.linePts.length-1,0)},remove:function(t,e,n){for(var i=e;n>i;i++){var r=t.getSegment(i);this.inputIndex.remove(r)}},hasInteriorIntersection:function(t,e){return this.li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this.li.isInteriorIntersection()},hasBadInputIntersection:function(t,e,n){for(var i=this.inputIndex.query(n),r=i.iterator();r.hasNext();){var s=r.next();if(this.hasInteriorIntersection(s,n)){if(xs.isInLineSection(t,e,s))continue;return!0}}return!1},interfaces_:function(){return[]},getClass:function(){return xs}}),xs.isInLineSection=function(t,e,n){if(n.getParent()!==t.getParent())return!1;var i=n.getIndex();return i>=e[0]&&i<e[1]},e(Es.prototype,{setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(t){for(var e=t.iterator();e.hasNext();)this.inputIndex.add(e.next());for(var e=t.iterator();e.hasNext();){var n=new xs(this.inputIndex,this.outputIndex);n.setDistanceTolerance(this.distanceTolerance),n.simplify(e.next())}},interfaces_:function(){return[]},getClass:function(){return Es}}),e(Is.prototype,{getResultGeometry:function(){if(this.inputGeom.isEmpty())return this.inputGeom.copy();this.linestringMap=new te,this.inputGeom.apply(new Cs(this)),this.lineSimplifier.simplify(this.linestringMap.values());var t=new Ns(this.linestringMap).transform(this.inputGeom);return t},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.lineSimplifier.setDistanceTolerance(t)},interfaces_:function(){return[]},getClass:function(){return Is}}),Is.simplify=function(t,e){var n=new Is(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(Ns,xe),e(Ns.prototype,{transformCoordinates:function(t,e){if(0===t.size())return null;if(e instanceof St){var n=this.linestringMap.get(e);return this.createCoordinateSequence(n.getResultCoordinates())}return xe.prototype.transformCoordinates.call(this,t,e)},interfaces_:function(){return[]},getClass:function(){return Ns}}),e(Cs.prototype,{filter:function(t){if(t instanceof St){var e=t;if(e.isEmpty())return null;var n=e.isClosed()?4:2,i=new vs(e,n);this.tps.linestringMap.put(e,i)}},interfaces_:function(){return[q]},getClass:function(){return Cs}}),Is.LineStringTransformer=Ns,Is.LineStringMapBuilderFilter=Cs;var Do=Object.freeze({DouglasPeuckerSimplifier:gs,TopologyPreservingSimplifier:Is});e(Ss.prototype,{splitAt:function(){if(1===arguments.length){var t=arguments[0],e=this.minimumLen/this.segLen;if(t.distance(this.seg.p0)<this.minimumLen)return this.splitPt=this.seg.pointAlong(e),null;if(t.distance(this.seg.p1)<this.minimumLen)return this.splitPt=Ss.pointAlongReverse(this.seg,e),null;this.splitPt=t}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.getConstrainedLength(n),s=r/this.segLen;i.equals2D(this.seg.p0)?this.splitPt=this.seg.pointAlong(s):this.splitPt=Ss.pointAlongReverse(this.seg,s)}},setMinimumLength:function(t){this.minimumLen=t},getConstrainedLength:function(t){return t<this.minimumLen?this.minimumLen:t},getSplitPoint:function(){return this.splitPt},interfaces_:function(){return[]},getClass:function(){return Ss}}),Ss.pointAlongReverse=function(t,e){var n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n},e(ws.prototype,{findSplitPoint:function(t,e){},interfaces_:function(){return[]},getClass:function(){return ws}}),e(Ls.prototype,{findSplitPoint:function(t,e){var n=t.getLineSegment(),i=n.getLength(),r=i/2,s=new Ss(n),o=Ls.projectedSplitPoint(t,e),a=2*o.distance(e)*.8,u=a;return u>r&&(u=r),s.setMinimumLength(u),s.splitAt(o),s.getSplitPoint()},interfaces_:function(){return[ws]},getClass:function(){return Ls}}),Ls.projectedSplitPoint=function(t,e){var n=t.getLineSegment(),i=n.project(e);return i},e(Rs.prototype,{interfaces_:function(){return[]},getClass:function(){return Rs}}),Rs.triArea=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)},Rs.isInCircleDDNormalized=function(t,e,n,i){var r=_.valueOf(t.x).selfSubtract(i.x),s=_.valueOf(t.y).selfSubtract(i.y),o=_.valueOf(e.x).selfSubtract(i.x),a=_.valueOf(e.y).selfSubtract(i.y),u=_.valueOf(n.x).selfSubtract(i.x),l=_.valueOf(n.y).selfSubtract(i.y),h=r.multiply(a).selfSubtract(o.multiply(s)),c=o.multiply(l).selfSubtract(u.multiply(a)),f=u.multiply(s).selfSubtract(r.multiply(l)),g=r.multiply(r).selfAdd(s.multiply(s)),d=o.multiply(o).selfAdd(a.multiply(a)),p=u.multiply(u).selfAdd(l.multiply(l)),v=g.selfMultiply(c).selfAdd(d.selfMultiply(f)).selfAdd(p.selfMultiply(h)),m=v.doubleValue()>0;return m},Rs.checkRobustInCircle=function(t,e,n,i){var r=Rs.isInCircleNonRobust(t,e,n,i),s=Rs.isInCircleDDSlow(t,e,n,i),o=Rs.isInCircleCC(t,e,n,i),a=Si.circumcentre(t,e,n);A.out.println("p radius diff a = "+Math.abs(i.distance(a)-t.distance(a))/t.distance(a)),r===s&&r===o||(A.out.println("inCircle robustness failure (double result = "+r+", DD result = "+s+", CC result = "+o+")"),A.out.println(se.toLineString(new Gt([t,e,n,i]))),A.out.println("Circumcentre = "+se.toPoint(a)+" radius = "+t.distance(a)),A.out.println("p radius diff a = "+Math.abs(i.distance(a)/t.distance(a)-1)),A.out.println("p radius diff b = "+Math.abs(i.distance(a)/e.distance(a)-1)),A.out.println("p radius diff c = "+Math.abs(i.distance(a)/n.distance(a)-1)),A.out.println())},Rs.isInCircleDDFast=function(t,e,n,i){var r=_.sqr(t.x).selfAdd(_.sqr(t.y)).selfMultiply(Rs.triAreaDDFast(e,n,i)),s=_.sqr(e.x).selfAdd(_.sqr(e.y)).selfMultiply(Rs.triAreaDDFast(t,n,i)),o=_.sqr(n.x).selfAdd(_.sqr(n.y)).selfMultiply(Rs.triAreaDDFast(t,e,i)),a=_.sqr(i.x).selfAdd(_.sqr(i.y)).selfMultiply(Rs.triAreaDDFast(t,e,n)),u=r.selfSubtract(s).selfAdd(o).selfSubtract(a),l=u.doubleValue()>0;return l},Rs.isInCircleCC=function(t,e,n,i){var r=Si.circumcentre(t,e,n),s=t.distance(r),o=i.distance(r)-s;return 0>=o},Rs.isInCircleNormalized=function(t,e,n,i){var r=t.x-i.x,s=t.y-i.y,o=e.x-i.x,a=e.y-i.y,u=n.x-i.x,l=n.y-i.y,h=r*a-o*s,c=o*l-u*a,f=u*s-r*l,g=r*r+s*s,d=o*o+a*a,p=u*u+l*l,v=g*c+d*f+p*h;return v>0},Rs.isInCircleDDSlow=function(t,e,n,i){var r=_.valueOf(i.x),s=_.valueOf(i.y),o=_.valueOf(t.x),a=_.valueOf(t.y),u=_.valueOf(e.x),l=_.valueOf(e.y),h=_.valueOf(n.x),c=_.valueOf(n.y),f=o.multiply(o).add(a.multiply(a)).multiply(Rs.triAreaDDSlow(u,l,h,c,r,s)),g=u.multiply(u).add(l.multiply(l)).multiply(Rs.triAreaDDSlow(o,a,h,c,r,s)),d=h.multiply(h).add(c.multiply(c)).multiply(Rs.triAreaDDSlow(o,a,u,l,r,s)),p=r.multiply(r).add(s.multiply(s)).multiply(Rs.triAreaDDSlow(o,a,u,l,h,c)),v=f.subtract(g).add(d).subtract(p),m=v.doubleValue()>0;
return m},Rs.isInCircleNonRobust=function(t,e,n,i){var r=(t.x*t.x+t.y*t.y)*Rs.triArea(e,n,i)-(e.x*e.x+e.y*e.y)*Rs.triArea(t,n,i)+(n.x*n.x+n.y*n.y)*Rs.triArea(t,e,i)-(i.x*i.x+i.y*i.y)*Rs.triArea(t,e,n)>0;return r},Rs.isInCircleRobust=function(t,e,n,i){return Rs.isInCircleNormalized(t,e,n,i)},Rs.triAreaDDSlow=function(t,e,n,i,r,s){return n.subtract(t).multiply(s.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)))},Rs.triAreaDDFast=function(t,e,n){var i=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(n.y).selfSubtract(t.y)),r=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(n.x).selfSubtract(t.x));return i.selfSubtract(r)},e(Ts.prototype,{circleCenter:function(t,e){var n=new Ts(this.getX(),this.getY()),i=this.bisector(n,t),r=this.bisector(t,e),s=new F(i,r),o=null;try{o=new Ts(s.getX(),s.getY())}catch(a){if(!(a instanceof w))throw a;A.err.println("a: "+n+"  b: "+t+"  c: "+e),A.err.println(a)}finally{}return o},dot:function(t){return this.p.x*t.getX()+this.p.y*t.getY()},magn:function(){return Math.sqrt(this.p.x*this.p.x+this.p.y*this.p.y)},getZ:function(){return this.p.z},bisector:function(t,e){var n=e.getX()-t.getX(),i=e.getY()-t.getY(),r=new F(t.getX()+n/2,t.getY()+i/2,1),s=new F(t.getX()-i+n/2,t.getY()+n+i/2,1);return new F(r,s)},equals:function(){if(1===arguments.length){var t=arguments[0];return this.p.x===t.getX()&&this.p.y===t.getY()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.p.distance(e.getCoordinate())<n}},getCoordinate:function(){return this.p},isInCircle:function(t,e,n){return Rs.isInCircleRobust(t.p,e.p,n.p,this.p)},interpolateZValue:function(t,e,n){var i=t.getX(),r=t.getY(),s=e.getX()-i,o=n.getX()-i,a=e.getY()-r,u=n.getY()-r,l=s*u-o*a,h=this.getX()-i,c=this.getY()-r,f=(u*h-o*c)/l,g=(-a*h+s*c)/l,d=t.getZ()+f*(e.getZ()-t.getZ())+g*(n.getZ()-t.getZ());return d},midPoint:function(t){var e=(this.p.x+t.getX())/2,n=(this.p.y+t.getY())/2,i=(this.p.z+t.getZ())/2;return new Ts(e,n,i)},rightOf:function(t){return this.isCCW(t.dest(),t.orig())},isCCW:function(t,e){return(t.p.x-this.p.x)*(e.p.y-this.p.y)-(t.p.y-this.p.y)*(e.p.x-this.p.x)>0},getX:function(){return this.p.x},crossProduct:function(t){return this.p.x*t.getY()-this.p.y*t.getX()},setZ:function(t){this.p.z=t},times:function(t){return new Ts(t*this.p.x,t*this.p.y)},cross:function(){return new Ts(this.p.y,-this.p.x)},leftOf:function(t){return this.isCCW(t.orig(),t.dest())},toString:function(){return"POINT ("+this.p.x+" "+this.p.y+")"},sub:function(t){return new Ts(this.p.x-t.getX(),this.p.y-t.getY())},getY:function(){return this.p.y},classify:function(t,e){var n=this,i=e.sub(t),r=n.sub(t),s=i.crossProduct(r);return s>0?Ts.LEFT:0>s?Ts.RIGHT:i.getX()*r.getX()<0||i.getY()*r.getY()<0?Ts.BEHIND:i.magn()<r.magn()?Ts.BEYOND:t.equals(n)?Ts.ORIGIN:e.equals(n)?Ts.DESTINATION:Ts.BETWEEN},sum:function(t){return new Ts(this.p.x+t.getX(),this.p.y+t.getY())},distance:function(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))},circumRadiusRatio:function(t,e){var n=this.circleCenter(t,e),i=this.distance(n,t),r=this.distance(this,t),s=this.distance(t,e);return r>s&&(r=s),s=this.distance(e,this),r>s&&(r=s),i/r},interfaces_:function(){return[]},getClass:function(){return Ts}}),Ts.interpolateZ=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=e.distance(n),r=t.distance(e),s=n.z-e.z,o=e.z+s*(r/i);return o}if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3],c=u.x,f=u.y,g=l.x-c,d=h.x-c,p=l.y-f,v=h.y-f,m=g*v-d*p,y=a.x-c,x=a.y-f,E=(v*y-d*x)/m,I=(-p*y+g*x)/m,N=u.z+E*(l.z-u.z)+I*(h.z-u.z);return N}},Ts.LEFT=0,Ts.RIGHT=1,Ts.BEYOND=2,Ts.BEHIND=3,Ts.BETWEEN=4,Ts.ORIGIN=5,Ts.DESTINATION=6,h(Ps,Ts),e(Ps.prototype,{getConstraint:function(){return this.constraint},setOnConstraint:function(t){this._isOnConstraint=t},merge:function(t){t._isOnConstraint&&(this._isOnConstraint=!0,this.constraint=t.constraint)},isOnConstraint:function(){return this._isOnConstraint},setConstraint:function(t){this._isOnConstraint=!0,this.constraint=t},interfaces_:function(){return[]},getClass:function(){return Ps}}),e(bs.prototype,{equalsNonOriented:function(t){return this.equalsOriented(t)?!0:!!this.equalsOriented(t.sym())},toLineSegment:function(){return new ce(this.vertex.getCoordinate(),this.dest().getCoordinate())},dest:function(){return this.sym().orig()},oNext:function(){return this.next},equalsOriented:function(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))},dNext:function(){return this.sym().oNext().sym()},lPrev:function(){return this.next.sym()},rPrev:function(){return this.sym().oNext()},rot:function(){return this._rot},oPrev:function(){return this._rot.next._rot},sym:function(){return this._rot._rot},setOrig:function(t){this.vertex=t},lNext:function(){return this.invRot().oNext().rot()},getLength:function(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())},invRot:function(){return this._rot.sym()},setDest:function(t){this.sym().setOrig(t)},setData:function(t){this.data=t},getData:function(){return this.data},"delete":function(){this._rot=null},orig:function(){return this.vertex},rNext:function(){return this._rot.next.invRot()},toString:function(){var t=this.vertex.getCoordinate(),e=this.dest().getCoordinate();return se.toLineString(t,e)},isLive:function(){return null!==this._rot},getPrimary:function(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()},dPrev:function(){return this.invRot().oNext().invRot()},setNext:function(t){this.next=t},interfaces_:function(){return[]},getClass:function(){return bs}}),bs.makeEdge=function(t,e){var n=new bs,i=new bs,r=new bs,s=new bs;n._rot=i,i._rot=r,r._rot=s,s._rot=n,n.setNext(n),i.setNext(s),r.setNext(r),s.setNext(i);var o=n;return o.setOrig(t),o.setDest(e),o},bs.swap=function(t){var e=t.oPrev(),n=t.sym().oPrev();bs.splice(t,e),bs.splice(t.sym(),n),bs.splice(t,e.lNext()),bs.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())},bs.splice=function(t,e){var n=t.oNext().rot(),i=e.oNext().rot(),r=e.oNext(),s=t.oNext(),o=i.oNext(),a=n.oNext();t.setNext(r),e.setNext(s),n.setNext(o),i.setNext(a)},bs.connect=function(t,e){var n=bs.makeEdge(t.dest(),e.orig());return bs.splice(n,t.lNext()),bs.splice(n.sym(),e),n},e(Os.prototype,{insertSite:function(t){var e=this.subdiv.locate(t);if(this.subdiv.isVertexOfEdge(e,t))return e;this.subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this.subdiv["delete"](e.oNext()));var n=this.subdiv.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.subdiv.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);for(;;){var r=e.oPrev();if(r.dest().rightOf(e)&&t.isInCircle(e.orig(),r.dest(),e.dest()))bs.swap(e),e=e.oPrev();else{if(e.oNext()===i)return n;e=e.oNext().lPrev()}}},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},interfaces_:function(){return[]},getClass:function(){return Os}}),e(_s.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return _s}}),e(Ms.prototype,{init:function(){this.lastEdge=this.findEdge()},locate:function(t){this.lastEdge.isLive()||this.init();var e=this.subdiv.locateFromEdge(t,this.lastEdge);return this.lastEdge=e,e},findEdge:function(){var t=this.subdiv.getEdges();return t.iterator().next()},interfaces_:function(){return[_s]},getClass:function(){return Ms}}),h(Ds,l),e(Ds.prototype,{getSegment:function(){return this.seg},interfaces_:function(){return[]},getClass:function(){return Ds}}),Ds.msgWithSpatial=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(As.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return As}}),e(Fs.prototype,{getTriangleVertices:function(t){var e=new Bs;return this.visitTriangles(e,t),e.getTriangleVertices()},isFrameVertex:function(t){return t.equals(this.frameVertex[0])?!0:t.equals(this.frameVertex[1])?!0:!!t.equals(this.frameVertex[2])},isVertexOfEdge:function(t,e){return!(!e.equals(t.orig(),this.tolerance)&&!e.equals(t.dest(),this.tolerance))},connect:function(t,e){var n=bs.connect(t,e);return this.quadEdges.add(n),n},getVoronoiCellPolygon:function(t,e){var n=new I,i=t;do{var r=t.rot().orig().getCoordinate();n.add(r),t=t.oPrev()}while(t!==i);var s=new N;s.addAll(n,!1),s.closeRing(),s.size()<4&&(A.out.println(s),s.add(s.get(s.size()-1),!0));var o=s.toCoordinateArray(),a=e.createPolygon(e.createLinearRing(o),null),u=i.orig();return a.setUserData(u.getCoordinate()),a},setLocator:function(t){this.locator=t},initSubdiv:function(){var t=this.makeEdge(this.frameVertex[0],this.frameVertex[1]),e=this.makeEdge(this.frameVertex[1],this.frameVertex[2]);bs.splice(t.sym(),e);var n=this.makeEdge(this.frameVertex[2],this.frameVertex[0]);return bs.splice(e.sym(),n),bs.splice(n.sym(),t),t},isFrameBorderEdge:function(t){var e=new Array(3).fill(null);Fs.getTriangleEdges(t,e);var n=new Array(3).fill(null);Fs.getTriangleEdges(t.sym(),n);var i=t.lNext().dest();if(this.isFrameVertex(i))return!0;var r=t.sym().lNext().dest();return!!this.isFrameVertex(r)},makeEdge:function(t,e){var n=bs.makeEdge(t,e);return this.quadEdges.add(n),n},visitTriangles:function(t,e){this.visitedKey++;var n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=this.fetchTriangleToVisit(r,n,e,i);null!==s&&t.visit(s)}}},isFrameEdge:function(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))},isOnEdge:function(t,e){this.seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());var n=this.seg.distance(e);return n<this.edgeCoincidenceTolerance},getEnvelope:function(){return new C(this.frameEnv)},createFrame:function(t){var e=t.getWidth(),n=t.getHeight(),i=0;i=e>n?10*e:10*n,this.frameVertex[0]=new Ts((t.getMaxX()+t.getMinX())/2,t.getMaxY()+i),this.frameVertex[1]=new Ts(t.getMinX()-i,t.getMinY()-i),this.frameVertex[2]=new Ts(t.getMaxX()+i,t.getMinY()-i),this.frameEnv=new C(this.frameVertex[0].getCoordinate(),this.frameVertex[1].getCoordinate()),this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())},getTriangleCoordinates:function(t){var e=new zs;return this.visitTriangles(e,t),e.getTriangles()},getVertices:function(t){for(var e=new J,n=this.quadEdges.iterator();n.hasNext();){var i=n.next(),r=i.orig();!t&&this.isFrameVertex(r)||e.add(r);var s=i.dest();!t&&this.isFrameVertex(s)||e.add(s)}return e},fetchTriangleToVisit:function(t,e,n,i){var r=t,s=0,o=!1;do{this.triEdges[s]=r,this.isFrameEdge(r)&&(o=!0);var a=r.sym();i.contains(a)||e.push(a),i.add(r),s++,r=r.lNext()}while(r!==t);return o&&!n?null:this.triEdges},getEdges:function(){if(0===arguments.length)return this.quadEdges;if(1===arguments.length){for(var t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createLineString([s.orig().getCoordinate(),s.dest().getCoordinate()])}return t.createMultiLineString(n)}},getVertexUniqueEdges:function(t){for(var e=new I,n=new J,i=this.quadEdges.iterator();i.hasNext();){var r=i.next(),s=r.orig();n.contains(s)||(n.add(s),!t&&this.isFrameVertex(s)||e.add(r));var o=r.sym(),a=o.orig();n.contains(a)||(n.add(a),!t&&this.isFrameVertex(a)||e.add(o))}return e},getTriangleEdges:function(t){var e=new qs;return this.visitTriangles(e,t),e.getTriangleEdges()},getPrimaryEdges:function(t){this.visitedKey++;var e=new I,n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=r.getPrimary();!t&&this.isFrameEdge(s)||e.add(s),n.push(r.oNext()),n.push(r.sym().oNext()),i.add(r),i.add(r.sym())}}return e},"delete":function(t){bs.splice(t,t.oPrev()),bs.splice(t.sym(),t.sym().oPrev());var e=t.sym(),n=t.rot(),i=t.rot().sym();this.quadEdges.remove(t),this.quadEdges.remove(e),this.quadEdges.remove(n),this.quadEdges.remove(i),t["delete"](),e["delete"](),n["delete"](),i["delete"]()},locateFromEdge:function(t,e){for(var n=0,i=this.quadEdges.size(),r=e;;){if(n++,n>i)throw new Ds(r.toLineSegment());if(t.equals(r.orig())||t.equals(r.dest()))break;if(t.rightOf(r))r=r.sym();else if(t.rightOf(r.oNext())){if(t.rightOf(r.dPrev()))break;r=r.dPrev()}else r=r.oNext()}return r},getTolerance:function(){return this.tolerance},getVoronoiCellPolygons:function(t){this.visitTriangles(new Gs,!0);for(var e=new I,n=this.getVertexUniqueEdges(!1),i=n.iterator();i.hasNext();){var r=i.next();e.add(this.getVoronoiCellPolygon(r,t))}return e},getVoronoiDiagram:function(t){var e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(ie.toGeometryArray(e))},getTriangles:function(t){for(var e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createPolygon(t.createLinearRing(s),null)}return t.createGeometryCollection(n)},insertSite:function(t){var e=this.locate(t);if(t.equals(e.orig(),this.tolerance)||t.equals(e.dest(),this.tolerance))return e;var n=this.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);return i},locate:function(){if(1===arguments.length){if(arguments[0]instanceof Ts){var t=arguments[0];return this.locator.locate(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.locator.locate(new Ts(e))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.locator.locate(new Ts(n));if(null===r)return null;var s=r;r.dest().getCoordinate().equals2D(n)&&(s=r.sym());var o=s;do{if(o.dest().getCoordinate().equals2D(i))return o;o=o.oNext()}while(o!==s);return null}},interfaces_:function(){return[]},getClass:function(){return Fs}}),Fs.getTriangleEdges=function(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new i("Edges do not form a triangle")},e(Gs.prototype,{visit:function(t){for(var e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),i=t[2].orig().getCoordinate(),r=Si.circumcentre(e,n,i),s=new Ts(r),o=0;3>o;o++)t[o].rot().setOrig(s)},interfaces_:function(){return[As]},getClass:function(){return Gs}}),e(qs.prototype,{getTriangleEdges:function(){return this.triList},visit:function(t){this.triList.add(t.clone())},interfaces_:function(){return[As]},getClass:function(){return qs}}),e(Bs.prototype,{visit:function(t){this.triList.add([t[0].orig(),t[1].orig(),t[2].orig()])},getTriangleVertices:function(){return this.triList},interfaces_:function(){return[As]},getClass:function(){return Bs}}),e(zs.prototype,{checkTriangleSize:function(t){var e="";t.length>=2?e=se.toLineString(t[0],t[1]):t.length>=1&&(e=se.toPoint(t[0]))},visit:function(t){this.coordList.clear();for(var e=0;3>e;e++){var n=t[e].orig();this.coordList.add(n.getCoordinate())}if(this.coordList.size()>0){this.coordList.closeRing();var i=this.coordList.toCoordinateArray();if(4!==i.length)return null;this.triCoords.add(i)}},getTriangles:function(){return this.triCoords},interfaces_:function(){return[As]},getClass:function(){return zs}}),Fs.TriangleCircumcentreVisitor=Gs,Fs.TriangleEdgesListVisitor=qs,Fs.TriangleVertexListVisitor=Bs,Fs.TriangleCoordinatesVisitor=zs,Fs.EDGE_COINCIDENCE_TOL_FACTOR=1e3,e(Vs.prototype,{getLineSegment:function(){return this.ls},getEndZ:function(){var t=this.ls.getCoordinate(1);return t.z},getStartZ:function(){var t=this.ls.getCoordinate(0);return t.z},intersection:function(t){return this.ls.intersection(t.getLineSegment())},getStart:function(){return this.ls.getCoordinate(0)},getEnd:function(){return this.ls.getCoordinate(1)},getEndY:function(){var t=this.ls.getCoordinate(1);return t.y},getStartX:function(){var t=this.ls.getCoordinate(0);return t.x},equalsTopo:function(t){return this.ls.equalsTopo(t.getLineSegment())},getStartY:function(){var t=this.ls.getCoordinate(0);return t.y},setData:function(t){this.data=t},getData:function(){return this.data},getEndX:function(){var t=this.ls.getCoordinate(1);return t.x},toString:function(){return this.ls.toString()},interfaces_:function(){return[]},getClass:function(){return Vs}}),e(ks.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return ks}}),e(Ys.prototype,{isRepeated:function(){return this.count>1},getRight:function(){return this.right},getCoordinate:function(){return this.p},setLeft:function(t){this.left=t},getX:function(){return this.p.x},getData:function(){return this.data},getCount:function(){return this.count},getLeft:function(){return this.left},getY:function(){return this.p.y},increment:function(){this.count=this.count+1},setRight:function(t){this.right=t},interfaces_:function(){return[]},getClass:function(){return Ys}}),e(Us.prototype,{insert:function(){if(1===arguments.length){var t=arguments[0];return this.insert(t,null)}if(2===arguments.length){var e=arguments[0],n=arguments[1];if(null===this.root)return this.root=new Ys(e,n),this.root;if(this.tolerance>0){var i=this.findBestMatchNode(e);if(null!==i)return i.increment(),i}return this.insertExact(e,n)}},query:function(){var t=arguments,e=this;if(1===arguments.length){var n=arguments[0],i=new I;return this.query(n,i),i}if(2===arguments.length)if(arguments[0]instanceof C&&R(arguments[1],y))!function(){var n=t[0],i=t[1];e.queryNode(e.root,n,!0,{interfaces_:function(){return[ks]},visit:function(t){i.add(t)}})}();else if(arguments[0]instanceof C&&R(arguments[1],ks)){var r=arguments[0],s=arguments[1];this.queryNode(this.root,r,!0,s)}},queryNode:function(t,e,n,i){if(null===t)return null;var r=null,s=null,o=null;n?(r=e.getMinX(),s=e.getMaxX(),o=t.getX()):(r=e.getMinY(),s=e.getMaxY(),o=t.getY());var a=o>r,u=s>=o;a&&this.queryNode(t.getLeft(),e,!n,i),e.contains(t.getCoordinate())&&i.visit(t),u&&this.queryNode(t.getRight(),e,!n,i)},findBestMatchNode:function(t){var e=new Xs(t,this.tolerance);return this.query(e.queryEnvelope(),e),e.getNode()},isEmpty:function(){return null===this.root},insertExact:function(t,e){for(var n=this.root,i=this.root,r=!0,s=!0;null!==n;){if(null!==n){var o=t.distance(n.getCoordinate())<=this.tolerance;if(o)return n.increment(),n}s=r?t.x<n.getX():t.y<n.getY(),i=n,n=s?n.getLeft():n.getRight(),r=!r}this.numberOfNodes=this.numberOfNodes+1;var a=new Ys(t,e);return s?i.setLeft(a):i.setRight(a),a},interfaces_:function(){return[]},getClass:function(){return Us}}),Us.toCoordinates=function(){if(1===arguments.length){var t=arguments[0];return Us.toCoordinates(t,!1)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new N,r=e.iterator();r.hasNext();)for(var s=r.next(),o=n?s.getCount():1,a=0;o>a;a++)i.add(s.getCoordinate(),!0);return i.toCoordinateArray()}},e(Xs.prototype,{visit:function(t){var e=this.p.distance(t.getCoordinate()),n=e<=this.tolerance;if(!n)return null;var i=!1;(null===this.matchNode||e<this.matchDist||null!==this.matchNode&&e===this.matchDist&&t.getCoordinate().compareTo(this.matchNode.getCoordinate())<1)&&(i=!0),i&&(this.matchNode=t,this.matchDist=e)},queryEnvelope:function(){var t=new C(this.p);return t.expandBy(this.tolerance),t},getNode:function(){return this.matchNode},interfaces_:function(){return[ks]},getClass:function(){return Xs}}),Us.BestMatchVisitor=Xs,e(Hs.prototype,{getInitialVertices:function(){return this.initialVertices},getKDT:function(){return this.kdt},enforceConstraints:function(){this.addConstraintVertices();var t=0,e=0;do e=this.enforceGabriel(this.segments),t++;while(e>0&&t<Hs.MAX_SPLIT_ITER)},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},getVertexFactory:function(){return this.vertexFactory},getPointArray:function(){for(var t=new Array(this.initialVertices.size()+this.segVertices.size()).fill(null),e=0,n=this.initialVertices.iterator();n.hasNext();){var i=n.next();t[e++]=i.getCoordinate()}for(var r=this.segVertices.iterator();r.hasNext();){var i=r.next();t[e++]=i.getCoordinate()}return t},setConstraints:function(t,e){this.segments=t,this.segVertices=e},computeConvexHull:function(){var t=new ie,e=this.getPointArray(),n=new me(e,t);this.convexHull=n.getConvexHull()},addConstraintVertices:function(){this.computeConvexHull(),this.insertSites(this.segVertices)},findNonGabrielPoint:function(t){var e=t.getStart(),n=t.getEnd(),i=new g((e.x+n.x)/2,(e.y+n.y)/2),s=e.distance(i),o=new C(i);o.expandBy(s);for(var a=this.kdt.query(o),u=null,l=r.MAX_VALUE,h=a.iterator();h.hasNext();){var c=h.next(),f=c.getCoordinate();if(!f.equals2D(e)&&!f.equals2D(n)){var d=i.distance(f);if(s>d){var p=d;(null===u||l>p)&&(u=f,l=p)}}}return u},getConstraintSegments:function(){return this.segments},setSplitPointFinder:function(t){this.splitFinder=t},getConvexHull:function(){return this.convexHull},getTolerance:function(){return this.tolerance},enforceGabriel:function(t){for(var e=new I,n=0,i=new I,r=t.iterator();r.hasNext();){var s=r.next(),o=this.findNonGabrielPoint(s);if(null!==o){this.splitPt=this.splitFinder.findSplitPoint(s,o);var a=this.createVertex(this.splitPt,s),u=(this.insertSite(a),new Vs(s.getStartX(),s.getStartY(),s.getStartZ(),a.getX(),a.getY(),a.getZ(),s.getData())),l=new Vs(a.getX(),a.getY(),a.getZ(),s.getEndX(),s.getEndY(),s.getEndZ(),s.getData());e.add(u),e.add(l),i.add(s),n+=1}}return t.removeAll(i),t.addAll(e),n},createVertex:function(){if(1===arguments.length){var t=arguments[0],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(t,null):new Ps(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(n,i):new Ps(n),e.setOnConstraint(!0),e}},getSubdivision:function(){return this.subdiv},computeBoundingBox:function(){var t=Hs.computeVertexEnvelope(this.initialVertices),e=Hs.computeVertexEnvelope(this.segVertices),n=new C(t);n.expandToInclude(e);var i=.2*n.getWidth(),r=.2*n.getHeight(),s=Math.max(i,r);this.computeAreaEnv=new C(n),this.computeAreaEnv.expandBy(s)},setVertexFactory:function(t){this.vertexFactory=t},formInitialDelaunay:function(){this.computeBoundingBox(),this.subdiv=new Fs(this.computeAreaEnv,this.tolerance),this.subdiv.setLocator(new Ms(this.subdiv)),this.incDel=new Os(this.subdiv),this.insertSites(this.initialVertices)},insertSite:function(){if(arguments[0]instanceof Ps){var t=arguments[0],e=this.kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){var n=e.getData();return n.merge(t),n}return this.incDel.insertSite(t),t}if(arguments[0]instanceof g){var i=arguments[0];this.insertSite(this.createVertex(i))}},interfaces_:function(){return[]},getClass:function(){return Hs}}),Hs.computeVertexEnvelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i.getCoordinate())}return e},Hs.MAX_SPLIT_ITER=99,e(Ws.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var n=new Os(this.subdiv);n.insertSites(e)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},interfaces_:function(){return[]},getClass:function(){return Ws}}),Ws.extractUniqueCoordinates=function(t){if(null===t)return new N;var e=t.getCoordinates();return Ws.unique(e)},Ws.envelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i)}return e},Ws.unique=function(t){var e=H.copyDeep(t);ut.sort(e);var n=new N(e,!1);return n},Ws.toVertices=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ts(i))}return e},e(js.prototype,{createSiteVertices:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();this.constraintVertexMap.containsKey(i)||e.add(new Ps(i))}return e},create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=new I;null!==this.constraintLines&&(t.expandToInclude(this.constraintLines.getEnvelopeInternal()),this.createVertices(this.constraintLines),e=js.createConstraintSegments(this.constraintLines));var n=this.createSiteVertices(this.siteCoords),i=new Hs(n,this.tolerance);i.setConstraints(e,new I(this.constraintVertexMap.values())),i.formInitialDelaunay(),i.enforceConstraints(),this.subdiv=i.getSubdivision()},setTolerance:function(t){this.tolerance=t},setConstraints:function(t){this.constraintLines=t},setSites:function(t){this.siteCoords=Ws.extractUniqueCoordinates(t)},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},createVertices:function(t){for(var e=t.getCoordinates(),n=0;n<e.length;n++){var i=new Ps(e[n]);this.constraintVertexMap.put(e[n],i)}},interfaces_:function(){return[]},getClass:function(){return js}}),js.createConstraintSegments=function(){if(1===arguments.length){for(var t=arguments[0],e=kn.getLines(t),n=new I,i=e.iterator();i.hasNext();){var r=i.next();js.createConstraintSegments(r,n)}return n}if(2===arguments.length)for(var s=arguments[0],o=arguments[1],a=s.getCoordinates(),i=1;i<a.length;i++)o.add(new Vs(a[i-1],a[i]))},e(Ks.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords);this.diagramEnv=t;var e=Math.max(this.diagramEnv.getWidth(),this.diagramEnv.getHeight());this.diagramEnv.expandBy(e),null!==this.clipEnv&&this.diagramEnv.expandToInclude(this.clipEnv);var n=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var i=new Os(this.subdiv);i.insertSites(n)},getDiagram:function(t){this.create();var e=this.subdiv.getVoronoiDiagram(t);return Ks.clipGeometryCollection(e,this.diagramEnv)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},setClipEnvelope:function(t){this.clipEnv=t},getSubdivision:function(){return this.create(),this.subdiv},interfaces_:function(){return[]},getClass:function(){return Ks}}),Ks.clipGeometryCollection=function(t,e){for(var n=t.getFactory().toGeometry(e),i=new I,r=0;r<t.getNumGeometries();r++){var s=t.getGeometryN(r),o=null;e.contains(s.getEnvelopeInternal())?o=s:e.intersects(s.getEnvelopeInternal())&&(o=n.intersection(s),o.setUserData(s.getUserData())),null===o||o.isEmpty()||i.add(o)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(i))};var Ao=Object.freeze({ConformingDelaunayTriangulationBuilder:js,DelaunayTriangulationBuilder:Ws,VoronoiDiagramBuilder:Ks});e(Zs.prototype,{interfaces_:function(){return[]},getClass:function(){return Zs}}),Zs.union=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.UNION)},e(B.prototype,{equalsTopo:function(t){return this.getEnvelopeInternal().equals(t.getEnvelopeInternal())?Jr.relate(this,t).isEquals(this.getDimension(),t.getDimension()):!1},union:function(){if(0===arguments.length)return is.union(this);if(1===arguments.length){var t=arguments[0];return Zs.union(this,t)}},isValid:function(){return ls.isValid(this)},intersection:function(t){if(this.isEmpty()||t.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,this,t,this.factory);if(this.isGeometryCollection()){var e=t;return hn.map(this,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(e)}})}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.INTERSECTION)},covers:function(t){return Jr.covers(this,t)},coveredBy:function(t){return Jr.coveredBy(this,t)},touches:function(t){return Jr.touches(this,t)},intersects:function(t){return Jr.intersects(this,t)},within:function(t){return Jr.within(this,t)},overlaps:function(t){return Jr.overlaps(this,t)},disjoint:function(t){return Jr.disjoint(this,t)},crosses:function(t){return Jr.crosses(this,t)},buffer:function(){if(1===arguments.length){var t=arguments[0];return dr.bufferOp(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return dr.bufferOp(this,e,n)}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];return dr.bufferOp(this,i,r,s)}},convexHull:function(){return new me(this).getConvexHull()},relate:function(){for(var t=arguments.length,e=Array(t),n=0;t>n;n++)e[n]=arguments[n];return Jr.relate.apply(Jr,[this].concat(e))},getCentroid:function(){if(this.isEmpty())return this.factory.createPoint();var t=ge.getCentroid(this);return this.createPointFromInternalCoord(t,this)},getInteriorPoint:function(){if(this.isEmpty())return this.factory.createPoint();var t=null,e=this.getDimension();if(0===e){var n=new li(this);t=n.getInteriorPoint()}else if(1===e){var n=new ui(this);t=n.getInteriorPoint()}else{var n=new oi(this);t=n.getInteriorPoint()}return this.createPointFromInternalCoord(t,this)},symDifference:function(t){if(this.isEmpty()||t.isEmpty()){if(this.isEmpty()&&t.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,this,t,this.factory);if(this.isEmpty())return t.copy();if(t.isEmpty())return this.copy()}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.SYMDIFFERENCE)},createPointFromInternalCoord:function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},toText:function(){var t=new se;return t.write(this)},toString:function(){this.toText()},contains:function(t){return Jr.contains(this,t)},difference:function(t){return this.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,this,t,this.factory):t.isEmpty()?this.copy():(this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.DIFFERENCE))},isSimple:function(){var t=new Wi(this);return t.isSimple()},isWithinDistance:function(t,e){var n=this.getEnvelopeInternal().distance(t.getEnvelopeInternal());return n>e?!1:xr.isWithinDistance(this,t,e)},distance:function(t){return xr.distance(this,t)},isEquivalentClass:function(t){return this.getClass()===t.getClass()}});var Fo="1.2.0 (d405c89)";t.version=Fo,t.algorithm=co,t.densify=fo,t.dissolve=go,t.geom=lo,t.geomgraph=po,t.index=yo,t.io=No,t.noding=Co,t.operation=_o,t.precision=Mo,t.simplify=Do,t.triangulate=Ao});

},{}],9:[function(require,module,exports){
/*
 Leaflet 1.0.1, a JS library for interactive maps. http://leafletjs.com
 (c) 2010-2016 Vladimir Agafonkin, (c) 2010-2011 CloudMade
*/
(function (window, document, undefined) {
var L = {
	version: "1.0.1"
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed
if (typeof window !== 'undefined') {
	expose();
}



/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

L.Util = {

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	extend: function (dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// @function bind(fn: Function, ): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assiging it one if it doesn't have it.
	stamp: function (obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
		/*eslint-enable */
	},

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	lastId: 0,

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.bind` shortcut.
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	falseFn: function () { return false; },

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values  they will be evaluated passing `data` as an argument.
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_\-]+) *\}/g,

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	indexOf: function (array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	},

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	L.Util.requestAnimFrame = function (fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context));
		}
	};

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;




// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

L.Class = function () {};

L.Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
L.Class.include = function (props) {
	L.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};



/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */


L.Evented = L.Class.extend({

	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
		typeListeners.count++;
	},

	_off: function (type, fn, context) {
		var listeners,
		    i,
		    len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = L.Util.falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = L.Util.falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object  the first argument of the listener function will contain its
	// properties. The event might can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(): this
	// Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually

// @method addEventListener(): this
// Alias to [`on()`](#evented-on)
proto.addEventListener = proto.on;

// @method removeEventListener(): this
// Alias to [`off()`](#evented-off)

// @method clearAllEventListeners(): this
// Alias to [`off()`](#evented-off)
proto.removeEventListener = proto.clearAllEventListeners = proto.off;

// @method addOneTimeEventListener(): this
// Alias to [`once()`](#evented-once)
proto.addOneTimeEventListener = proto.once;

// @method fireEvent(): this
// Alias to [`fire()`](#evented-fire)
proto.fireEvent = proto.fire;

// @method hasEventListeners(): Boolean
// Alias to [`listens()`](#evented-listens)
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};



/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,
	    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

	    win = navigator.platform.indexOf('Win') === 0,

	    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
	    pointer = window.PointerEvent || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera12 = 'OTransition' in doc.style;


	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {

		// @property ie: Boolean
		// `true` for all Internet Explorer versions (not Edge).
		ie: ie,

		// @property ielt9: Boolean
		// `true` for Internet Explorer versions less than 9.
		ielt9: ie && !document.addEventListener,

		// @property edge: Boolean
		// `true` for the Edge web browser.
		edge: 'msLaunchUri' in navigator && !('documentMode' in document),

		// @property webkit: Boolean
		// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
		webkit: webkit,

		// @property gecko: Boolean
		// `true` for gecko-based browsers like Firefox.
		gecko: gecko,

		// @property android: Boolean
		// `true` for any browser running on an Android platform.
		android: ua.indexOf('android') !== -1,

		// @property android23: Boolean
		// `true` for browsers running on Android 2 or Android 3.
		android23: android23,

		// @property chrome: Boolean
		// `true` for the Chrome browser.
		chrome: chrome,

		// @property safari: Boolean
		// `true` for the Safari browser.
		safari: !chrome && ua.indexOf('safari') !== -1,


		// @property win: Boolean
		// `true` when the browser is running in a Windows platform
		win: win,


		// @property ie3d: Boolean
		// `true` for all Internet Explorer versions supporting CSS transforms.
		ie3d: ie3d,

		// @property webkit3d: Boolean
		// `true` for webkit-based browsers supporting CSS transforms.
		webkit3d: webkit3d,

		// @property gecko3d: Boolean
		// `true` for gecko-based browsers supporting CSS transforms.
		gecko3d: gecko3d,

		// @property opera12: Boolean
		// `true` for the Opera browser supporting CSS transforms (version 12 or later).
		opera12: opera12,

		// @property any3d: Boolean
		// `true` for all browsers supporting CSS transforms.
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


		// @property mobile: Boolean
		// `true` for all browsers running in a mobile device.
		mobile: mobile,

		// @property mobileWebkit: Boolean
		// `true` for all webkit-based browsers in a mobile device.
		mobileWebkit: mobile && webkit,

		// @property mobileWebkit3d: Boolean
		// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
		mobileWebkit3d: mobile && webkit3d,

		// @property mobileOpera: Boolean
		// `true` for the Opera browser in a mobile device.
		mobileOpera: mobile && window.opera,

		// @property mobileGecko: Boolean
		// `true` for gecko-based browsers running in a mobile device.
		mobileGecko: mobile && gecko,


		// @property touch: Boolean
		// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
		touch: !!touch,

		// @property msPointer: Boolean
		// `true` for browsers implementing the Microsoft touch events model (notably IE10).
		msPointer: !!msPointer,

		// @property pointer: Boolean
		// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
		pointer: !!pointer,


		// @property retina: Boolean
		// `true` for browsers on a high-resolution "retina" screen.
		retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
	};

}());



/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

L.Point = function (x, y, round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(L.point(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new L.Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new L.Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new L.Point(x.x, x.y);
	}
	return new L.Point(x, y, round);
};



/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

L.Bounds = function (a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = L.point(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new L.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(topLeft: Point, bottomRight: Point)
// Creates a Bounds object from two coordinates (usually top-left and bottom-right corners).
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the points it contains
L.bounds = function (a, b) {
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};



/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = new L.Transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts real `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts real `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};



/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

L.DomUtil = {

	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	empty: function (el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	},

	// @function toFront(el: HTMLElement)
	// Makes `el` the last children of its parent, so it renders in front of the other children.
	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	// @function toBack(el: HTMLElement)
	// Makes `el` the first children of its parent, so it renders back from the other children.
	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {
			L.DomUtil._setOpacityIE(el, value);
		}
	},

	_setOpacityIE: function (el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	},

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0);

		el.style[L.DomUtil.TRANSFORM] =
			(L.Browser.ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	},

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

		/*eslint-disable */
		el._leaflet_pos = point;
		/*eslint-enable */

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new L.Point(0, 0);
	}
};


(function () {
	// prefix style property names

	// @property TRANSFORM: String
	// Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transform style name.
	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	L.DomUtil.preventOutline = function (element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element || !element.style) { return; }
		L.DomUtil.restoreOutline();
		this._outlineElement = element;
		this._outlineStyle = element.style.outline;
		element.style.outline = 'none';
		L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
	};

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	L.DomUtil.restoreOutline = function () {
		if (!this._outlineElement) { return; }
		this._outlineElement.style.outline = this._outlineStyle;
		delete this._outlineElement;
		delete this._outlineStyle;
		L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
})();



/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return L.latLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new L.LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

L.latLng = function (a, b, c) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new L.LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b, c);
};



/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var southWest = L.latLng(40.712, -74.227),
 * northEast = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(southWest, northEast);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
	equals: function (bounds) {
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(southWest: LatLng, northEast: LatLng)
// Creates a `LatLngBounds` object by defining south-west and north-east corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
L.latLngBounds = function (a, b) {
	if (a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};



/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection  the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:3395` and `Simple` CRS.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};



/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection  the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

L.Projection.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};



/*
 * @class CRS
 * @aka L.CRS
 * Abstract class that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

L.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return L.latLng(lat, lng, alt);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});



/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) +
		        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});



/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API  it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

L.Map = L.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: L.CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = undefined
		// Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
		minZoom: undefined,

		// @option maxZoom: Number = undefined
		// Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back when he tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom) {
		// replaced by animation-powered implementation in Map.PanAnimation.js
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), zoom);
		return this;
	},

	// @method setZoom(zoom: Number, options: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && (this.getZoom() > this.options.maxZoom)) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so 
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so 
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},


	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/*eslint-enable */
			this._containerId = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		for (var i in this._layers) {
			this._layers[i].remove();
		}

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a children of `container`, or
	// as a children of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);
		padding = L.point(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;

		var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return L.DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
		this._containerId = L.Util.stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		L.Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove) {
		if (!L.DomEvent) { return; }

		this._targets = {};
		this._targets[L.stamp(this._container)] = this;

		var onOff = remove ? 'off' : 'on';

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}

		if (L.Browser.any3d && this.options.transform3DLimit) {
			this[onOff]('moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[L.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && L.DomEvent._isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

		if (type === 'mousedown') {
			// prevents outline when clicking on keyboard-focusable element
			L.DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = L.Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			L.DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target instanceof L.Marker;
			data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = L.bounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
L.map = function (id, options) {
	return new L.Map(id, options);
};




/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


L.Layer = L.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',
		nonBubblingEvents: []  // Array of events that should not be bubbled to DOM parents (like the map)
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map): this
	 * Adds the layer to the given map
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[L.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[L.stamp(targetEl)];
		return this;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	}
});



/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection  more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});



/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


L.GridLayer = L.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = depends
		// If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
		updateWhenIdle: L.Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. " Mapbox".
		attribution: null,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level that tiles will be loaded at. By default the entire map.
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level that tiles will be loaded at.
		maxZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof L.Point ? s : new L.Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (L.Browser.ielt9) { return; }

		L.DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			L.DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) { willPrune = true; }
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
			} else {
				L.DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			L.Util.falseFn(level.el.offsetWidth);
		}

		this._level = level;

		return level;
	},

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			L.DomUtil.remove(this._levels[z].el);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new L.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new L.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = Math.round(zoom);
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(level.el, translate, scale);
		} else {
			L.DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = map.getZoom();

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new L.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),

		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),

		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z);

		if (!this.options.noWrap) {
			nw = map.wrapLatLng(nw);
			se = map.wrapLatLng(se);
		}

		return new L.LatLngBounds(nw, se);
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new L.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		L.DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		L.DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
		}

		L.DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			L.DomUtil.setOpacity(tile.el, 0);
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (L.Browser.ielt9 || !this._map._fadeAnimated) {
				L.Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(L.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new L.Point(
			this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new L.Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
L.gridLayer = function (options) {
	return new L.GridLayer(options);
};



/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add @2x to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


L.TileLayer = L.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// Minimum zoom number.
		minZoom: 0,

		// @option maxZoom: Number = 18
		// Maximum zoom number.
		maxZoom: 18,

		// @option maxNativeZoom: Number = null
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: null,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
		L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: L.Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return L.Util.template(this._url, L.extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (L.Browser.ielt9) {
			setTimeout(L.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	getTileSize: function () {
		var map = this._map,
		    tileSize = L.GridLayer.prototype.getTileSize.call(this),
		    zoom = this._tileZoom + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom;

		// increase tile size when overscaling
		return zoomN !== null && zoom > zoomN ?
				tileSize.divideBy(map.getZoomScale(zoomN, zoom)).round() :
				tileSize;
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._tileZoom;

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom !== null ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;

				if (!tile.complete) {
					tile.src = L.Util.emptyImageUrl;
					L.DomUtil.remove(tile);
				}
			}
		}
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};



/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data  2012 IEM Nexrad"
 * });
 * ```
 */

L.TileLayer.WMS = L.TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);

		return url +
			L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};



/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

L.ImageOverlay = L.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option attribution: String = null
		// An optional string containing HTML to be shown on the `Attribution control`
		attribution: null,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			L.DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	setBounds: function (bounds) {
		this._bounds = bounds;

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	getBounds: function () {
		return this._bounds;
	},

	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);

		L.DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};



/*
 * @class Icon
 * @aka L.Icon
 * @inherits Layer
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

L.Icon = L.Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = null
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	initialize: function (options) {
		L.setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = L.point(sizeOption),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
L.icon = function (options) {
	return new L.Icon(options);
};



/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to change the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!L.Icon.Default.imagePath) {	// Deprecated, backwards-compatibility only
			L.Icon.Default.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `L.Icon.Default` will try to auto-detect the absolute location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right absolute path.
		return (this.options.imagePath || L.Icon.Default.imagePath) + L.Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = L.DomUtil.create('div',  'leaflet-default-icon-path', document.body);
		var path = L.DomUtil.getStyle(el, 'background-image') ||
		           L.DomUtil.getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		return path.indexOf('url') === 0 ?
			path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '') : '';
	}
});



/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

L.Marker = L.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. If not specified, a new `L.Icon.Default` is used.
		icon: new L.Icon.Default(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// FIXME: shadowPane is no longer a valid option
		nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		L.DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (L.Handler.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new L.Handler.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};



/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

L.DivIcon = L.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = L.point(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
L.divIcon = function (options) {
	return new L.DivIcon(options);
};



/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
L.DivOverlay = L.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});



/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
L.Popup = L.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when user clicks the map (set globally by
		// the Map's [closePopupOnClick](#map-closepopuponclick) option).
		autoClose: true,

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof L.Path)) {
				this._source.on('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof L.Path)) {
				this._source.off('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		L.DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

		var map = this._map,
		    marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(L.DomUtil.getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return L.point(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
L.popup = function (options, source) {
	return new L.Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
L.Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof L.Popup)) {
			popup = new L.Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});



/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
L.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return this._popup.isOpen();
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		L.DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof L.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});



/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor || [0, 0];
	}
});



/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
L.Tooltip = L.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if (L.Browser.touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = L.DomUtil.create('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(L.point(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y));
		} else if (direction === 'bottom') {
			pos = pos.subtract(L.point(tooltipWidth / 2 - offset.x, -offset.y));
		} else if (direction === 'center') {
			pos = pos.subtract(L.point(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add([offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y]);
		} else {
			direction = 'left';
			pos = pos.subtract(L.point(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y));
		}

		L.DomUtil.removeClass(container, 'leaflet-tooltip-right');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-left');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-top');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		L.DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		L.DomUtil.setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return L.point(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
L.tooltip = function (options, source) {
	return new L.Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof L.Tooltip)) {
			tooltip = new L.Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});



/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
L.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof L.Tooltip) {
			L.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = L.tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove) {
		if (!remove && this._tooltipHandlersAdded) { return; }
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (L.Browser.touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});



/*
 * Tooltip extension to L.Marker, adding tooltip-related methods.
 */

L.Marker.include({
	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});



/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, ): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});


// @factory L.layerGroup(layers: Layer[])
// Create a layer group, optionally given an initial set of layers.
L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};



/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};



/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

L.Renderer = L.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = L.DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			L.DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});


L.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});



/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

L.Path = L.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
		this._renderer.on('update', this._update, this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
		this._renderer.off('update', this._update, this);
	},

	getEvents: function () {
		return {
			zoomend: this._project,
			viewreset: this._reset
		};
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in children classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});



/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	pointToSegmentDistance:  function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},


	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	clipSegment: function (a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = this._getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, round);
	},

	_getBitCode: function (p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};



/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[-122.68, 45.51],
 * 	[-122.43, 37.77],
 * 	[-118.2, 34.04]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[-122.68, 45.51],
 * 	 [-122.43, 37.77],
 * 	 [-118.2, 34.04]],
 * 	[[-73.91, 40.78],
 * 	 [-87.62, 41.83],
 * 	 [-96.72, 32.76]]
 * ];
 * ```
 */

L.Polyline = L.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = L.latLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = L.Polyline._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new L.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};

L.Polyline._flat = function (latlngs) {
	// true if it's a flat array of latlngs; false if nested
	return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};



/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

L.PolyUtil = {};

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
L.PolyUtil.clipPolygon = function (points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};



/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *   [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *     [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 *   ],
 *   [ // second polygon
 *     [[-109.05, 37],[-109.03, 41],[-102.05, 41],[-102.04, 37],[-109.05, 38]]
 *   ]
 * ];
 * ```
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		L.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (L.Polyline._flat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};



/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};



/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

L.CircleMarker = L.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};



/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = L.extend({}, legacyOptions, {radius: options});
		}
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
L.circle = function (latlng, options, legacyOptions) {
	return new L.Circle(latlng, options, legacyOptions);
};



/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.SVG = L.Renderer.extend({

	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = L.SVG.create('g');
		this._container.appendChild(this._rootGroup);
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			L.DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		L.DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	}
});


// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:
L.extend(L.SVG, {
	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	create: function (name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	},

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
		    i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

// @namespace Browser; @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);


// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};



/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// @namespace Browser; @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._container);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._container);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}



/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.Canvas = L.Renderer.extend({

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		this._layers = this._layers || {};

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
			.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		this._drawnLayers = {};

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: L.Util.falseFn,

	_removePath: function (layer) {
		layer._removed = true;
		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		this._redrawBounds = layer._pxBounds;
		this._draw(true);
		layer._project();
		layer._update();
		this._draw();
		this._redrawBounds = null;
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		var padding = (layer.options.weight || 0) + 1;
		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
		this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));

		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_redraw: function () {
		this._redrawRequest = null;

		this._draw(true); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_draw: function (clear) {
		this._clear = clear;
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
			this._ctx.clip();
		}

		for (var id in this._layers) {
			layer = this._layers[id];
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
			if (clear && layer._removed) {
				delete layer._removed;
				delete this._layers[id];
			}
		}
		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		if (ctx.setLineDash) {
			ctx.setLineDash(layer.options && layer.options._dashArray || []);
		}

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var clear = this._clear,
		    options = layer.options;

		ctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';

		if (options.fill) {
			ctx.globalAlpha = clear ? 1 : options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			ctx.globalAlpha = clear ? 1 : options.opacity;

			// if clearing shape, do it with the previously drawn line width
			layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;

			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layers = [], layer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				L.DomEvent._fakeStop(e);
				layers.push(layer);
			}
		}
		if (layers.length)  {
			this._fireEvent(layers, e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseOut(e, point);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e, point) {
		var layer = this._hoveredLayer;
		if (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var id, layer;

		for (id in this._drawnLayers) {
			layer = this._drawnLayers[id];
			if (layer.options.interactive && layer._containsPoint(point)) {
				L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([layer], e, 'mouseover');
				this._hoveredLayer = layer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	// TODO _bringToFront & _bringToBack, pretty tricky

	_bringToFront: L.Util.falseFn,
	_bringToBack: L.Util.falseFn
});

// @namespace Browser; @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @namespace Canvas
// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};



/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

L.GeoJSON = L.FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): Layer
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): Layer
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = L.Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): Layer
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:
L.extend(L.GeoJSON, {
	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	// @function latLngToCoords(latlng: LatLng): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	asFeature: function (geojson) {
		if (geojson.type === 'Feature') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
L.Polyline.prototype.toGeoJSON = function () {
	var multi = !L.Polyline._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
L.Polygon.prototype.toGeoJSON = function () {
	var holes = !L.Polyline._flat(this._latlngs),
	    multi = holes && !L.Polyline._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


// @namespace LayerGroup
L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `GeometryCollection`).
	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
L.geoJSON = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};
// Backward compatibility.
L.geoJson = L.geoJSON;



/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.



var eventsKey = '_leaflet_events';

L.DomEvent = {

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function. If no function is specified,
	// it will remove all the listeners of that particular DOM event from the element.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.addPointerListener(obj, type, handler, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (L.DomEvent._isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel', L.DomEvent.stopPropagation);
	},

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	// @function stop(ev): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` or to the whole page if not specified.
	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	_wheelPxFactor: (L.Browser.win && L.Browser.chrome) ? 2 :
	                L.Browser.gecko ? window.devicePixelRatio :
	                1,

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	getWheelDelta: function (e) {
		return (L.Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / L.DomEvent._wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_isExternalTarget: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		handler(e);
	}
};

// @function addListener(): this
// Alias to [`L.DomEvent.on`](#domevent-on)
L.DomEvent.addListener = L.DomEvent.on;

// @function removeListener(): this
// Alias to [`L.DomEvent.off`](#domevent-off)
L.DomEvent.removeListener = L.DomEvent.off;



/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

L.Draggable = L.Evented.extend({

	options: {
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline: Boolean)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches) || !this._enabled) { return; }
		L.Draggable._dragging = true;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			L.DomUtil.preventOutline(this._element);
		}

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);

		L.DomEvent
			.on(document, L.Draggable.MOVE[e.type], this._onMove, this)
			.on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		L.DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
				.off(document, L.Draggable.MOVE[i], this._onMove, this)
				.off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		L.Draggable._dragging = false;
	}
});



/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});



/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !L.Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second.
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		L.DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-grab');
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDown: function () {
		this._map._stop();
	},

	_onDragStart: function () {
		var map = this._map;

		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = L.latLngBounds(this._map.options.maxBounds);

			this._offsetLimit = L.bounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);



/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

L.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);



/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);



/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				count = L.DomEvent._pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd() {
			if (doubleTap && !touch.cancelBubble) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;
		obj[pre + 'dblclick' + id] = handler;

		obj.addEventListener(touchstart, onTouchStart, false);
		obj.addEventListener(touchend, onTouchEnd, false);

		// On some platforms (notably, chrome on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		if (!L.Browser.edge) {
			obj.addEventListener('dblclick', handler, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    touchstart = obj[pre + this._touchstart + id],
		    touchend = obj[pre + this._touchend + id],
		    dblclick = obj[pre + 'dblclick' + id];

		obj.removeEventListener(this._touchstart, touchstart, false);
		obj.removeEventListener(this._touchend, touchend, false);
		if (!L.Browser.edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}
});



/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
	TAG_WHITE_LIST: ['INPUT', 'SELECT', 'OPTION'],

	_pointers: {},
	_pointersCount: 0,

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (this.TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					L.DomEvent.preventDefault(e);
				} else {
					return;
				}
			}

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!this._pointerDocListener) {
			var pointerUp = L.bind(this._globalPointerUp, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
			document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
			document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
			document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

			this._pointerDocListener = true;
		}
	},

	_globalPointerDown: function (e) {
		this._pointers[e.pointerId] = e;
		this._pointersCount++;
	},

	_globalPointerMove: function (e) {
		if (this._pointers[e.pointerId]) {
			this._pointers[e.pointerId] = e;
		}
	},

	_globalPointerUp: function (e) {
		delete this._pointers[e.pointerId];
		this._pointersCount--;
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});



/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: L.Browser.touch && !L.Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;


		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);

		var moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);

		L.DomEvent.preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);



/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}



/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_resetState: function () {
		this._moved = false;
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		this._resetState();

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		setTimeout(L.bind(this._resetState, this), 0);

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);



/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
L.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = L.point(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27) {
			map.closePopup();

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);



/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch).
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});



/*
 * @class Control
 * @aka L.Control
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});



/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

L.Control.Zoom = L.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '-'
		// The text set on the 'zoom out' button.
		zoomOutText: '-',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		L.DomEvent
		    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
		    .on(link, 'click', L.DomEvent.stop)
		    .on(link, 'click', fn, this)
		    .on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

L.Control.Attribution = L.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		if (L.DomEvent) {
			L.DomEvent.disableClickPropagation(this._container);
		}

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new L.Control.Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};



/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

L.Control.Scale = L.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
L.control.scale = function (options) {
	return new L.Control.Scale(options);
};



/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control.html)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */


L.Control.Layers = L.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		return this._container;
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(L.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		L.DomEvent.disableClickPropagation(container);
		if (!L.Browser.touch) {
			L.DomEvent.disableScrollPropagation(container);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}

			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this.expand, this);
			} else {
				L.DomEvent.on(link, 'focus', this.expand, this);
			}

			// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this.collapse, this);
			// TODO keyboard accessibility
		} else {
			this.expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return this; }

		L.DomUtil.empty(this._baseLayersList);
		L.DomUtil.empty(this._overlaysList);

		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(L.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				addedLayers.push(layer);

			} else if (!input.checked && hasLayer) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			this._map.removeLayer(removedLayers[i]);
		}
		for (i = 0; i < addedLayers.length; i++) {
			this._map.addLayer(addedLayers[i]);
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};



/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

L.PosAnimation = L.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		L.DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});



/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});



/*
 * Extends L.Map to handle zoom animations.
 */

// @namespace Map
// @section Animation Options
L.Map.mergeOptions({
	// @option zoomAnimation: Boolean = true
	// Whether the map zoom animation is enabled. By default it's enabled
	// in all browsers that support CSS3 Transitions except Android.
	zoomAnimation: true,

	// @option zoomAnimationThreshold: Number = 4
	// Won't animate zoom if the zoom difference exceeds this value.
	zoomAnimationThreshold: 4
});

var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;

if (zoomAnimated) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {

			this._createAnimProxy();

			L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!zoomAnimated ? {} : {

	_createAnimProxy: function () {

		var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = L.DomUtil.TRANSFORM,
			    transform = proxy.style[prop];

			L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    ._moveStart(true)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		L.Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});



// @namespace Map
// @section Methods for modifying map state
L.Map.include({

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !L.Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = L.latLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = L.Util.requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	}
});



/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

// @namespace Map

L.Map.include({
	// @section Geolocation methods
	_defaultLocateOptions: {
		timeout: 10000,
		watch: false
		// setView: false
		// maxZoom: <Number>
		// maximumAge: 0
		// enableHighAccuracy: false
	},

	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
		    onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	}
});



}(window, document));

},{}],10:[function(require,module,exports){
module.exports={
  "_args": [
    [
      {
        "raw": "mapbox.js",
        "scope": null,
        "escapedName": "mapbox.js",
        "name": "mapbox.js",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/karlg/Documents/Repos/topotime"
    ]
  ],
  "_from": "mapbox.js@latest",
  "_id": "mapbox.js@3.0.0",
  "_inCache": true,
  "_location": "/mapbox.js",
  "_nodeVersion": "4.6.1",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/mapbox.js-3.0.0.tgz_1477086076178_0.3623190941289067"
  },
  "_npmUser": {
    "name": "tmcw",
    "email": "tom@macwright.org"
  },
  "_npmVersion": "2.15.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "mapbox.js",
    "scope": null,
    "escapedName": "mapbox.js",
    "name": "mapbox.js",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/mapbox.js/-/mapbox.js-3.0.0.tgz",
  "_shasum": "8cd3b256feb4d22a947838e4069361158d5ed2a8",
  "_shrinkwrap": null,
  "_spec": "mapbox.js",
  "_where": "/Users/karlg/Documents/Repos/topotime",
  "author": {
    "name": "Mapbox"
  },
  "bugs": {
    "url": "https://github.com/mapbox/mapbox.js/issues"
  },
  "dependencies": {
    "corslite": "0.0.6",
    "isarray": "0.0.1",
    "leaflet": "1.0.1",
    "mustache": "2.2.1",
    "sanitize-caja": "0.1.4"
  },
  "description": "mapbox javascript api",
  "devDependencies": {
    "browserify": "^13.0.0",
    "clean-css": "~2.0.7",
    "eslint": "^0.23.0",
    "expect.js": "0.3.1",
    "happen": "0.1.3",
    "leaflet-fullscreen": "0.0.4",
    "leaflet-hash": "0.2.1",
    "marked": "~0.3.0",
    "minifyify": "^6.1.0",
    "minimist": "0.0.5",
    "mocha": "2.4.5",
    "mocha-phantomjs-core": "2.0.1",
    "phantomjs-prebuilt": "2.1.12",
    "sinon": "1.10.2"
  },
  "directories": {},
  "dist": {
    "shasum": "8cd3b256feb4d22a947838e4069361158d5ed2a8",
    "tarball": "https://registry.npmjs.org/mapbox.js/-/mapbox.js-3.0.0.tgz"
  },
  "engines": {
    "node": "*"
  },
  "gitHead": "d9a5af0f0316fa803508fb50e17ee1f301895afa",
  "homepage": "http://mapbox.com/",
  "license": "BSD-3-Clause",
  "main": "src/index.js",
  "maintainers": [
    {
      "name": "1ec5",
      "email": "mxn@1ec5.org"
    },
    {
      "name": "aaronlidman",
      "email": "aaronlidman@gmail.com"
    },
    {
      "name": "ajashton",
      "email": "aj.ashton@gmail.com"
    },
    {
      "name": "alulsh",
      "email": "ulsh@mapbox.com"
    },
    {
      "name": "ansis",
      "email": "ansis.brammanis@gmail.com"
    },
    {
      "name": "apendleton",
      "email": "andrew@mapbox.com"
    },
    {
      "name": "bergwerkgis",
      "email": "wb@bergwerk-gis.at"
    },
    {
      "name": "bhousel",
      "email": "bryan@mapbox.com"
    },
    {
      "name": "bsudekum",
      "email": "bobby@mapbox.com"
    },
    {
      "name": "camilleanne",
      "email": "camille@mapbox.com"
    },
    {
      "name": "dnomadb",
      "email": "damon@mapbox.com"
    },
    {
      "name": "dthompson",
      "email": "dthompson@gmail.com"
    },
    {
      "name": "emilymcafee",
      "email": "emily@mapbox.com"
    },
    {
      "name": "flippmoke",
      "email": "flippmoke@gmail.com"
    },
    {
      "name": "freenerd",
      "email": "spam@freenerd.de"
    },
    {
      "name": "gretacb",
      "email": "carol@mapbox.com"
    },
    {
      "name": "ian29",
      "email": "ian.villeda@gmail.com"
    },
    {
      "name": "ianshward",
      "email": "ian@mapbox.com"
    },
    {
      "name": "ingalls",
      "email": "nicholas.ingalls@gmail.com"
    },
    {
      "name": "jfirebaugh",
      "email": "john.firebaugh@gmail.com"
    },
    {
      "name": "jrpruit1",
      "email": "jake@jakepruitt.com"
    },
    {
      "name": "karenzshea",
      "email": "karen@mapbox.com"
    },
    {
      "name": "kelvinabrokwa",
      "email": "kelvinabrokwa@gmail.com"
    },
    {
      "name": "kkaefer",
      "email": "kkaefer@gmail.com"
    },
    {
      "name": "lbud",
      "email": "lauren@mapbox.com"
    },
    {
      "name": "lucaswoj",
      "email": "lucas@lucaswoj.com"
    },
    {
      "name": "lxbarth",
      "email": "alex@mapbox.com"
    },
    {
      "name": "lyzidiamond",
      "email": "lyzi@mapbox.com"
    },
    {
      "name": "mapbox-admin",
      "email": "accounts@mapbox.com"
    },
    {
      "name": "mateov",
      "email": "matt@mapbox.com"
    },
    {
      "name": "mcwhittemore",
      "email": "mcwhittemore@gmail.com"
    },
    {
      "name": "miccolis",
      "email": "jeff@miccolis.net"
    },
    {
      "name": "mikemorris",
      "email": "michael.patrick.morris@gmail.com"
    },
    {
      "name": "morganherlocker",
      "email": "morgan.herlocker@gmail.com"
    },
    {
      "name": "mourner",
      "email": "agafonkin@gmail.com"
    },
    {
      "name": "mtirwin",
      "email": "irwin@mapbox.com"
    },
    {
      "name": "nickidlugash",
      "email": "nicki@mapbox.com"
    },
    {
      "name": "rclark",
      "email": "ryan.clark.j@gmail.com"
    },
    {
      "name": "samanbb",
      "email": "saman@mapbox.com"
    },
    {
      "name": "sbma44",
      "email": "tlee@mapbox.com"
    },
    {
      "name": "scothis",
      "email": "scothis@gmail.com"
    },
    {
      "name": "sgillies",
      "email": "sean@mapbox.com"
    },
    {
      "name": "springmeyer",
      "email": "dane@mapbox.com"
    },
    {
      "name": "themarex",
      "email": "patrick@mapbox.com"
    },
    {
      "name": "tmcw",
      "email": "tom@macwright.org"
    },
    {
      "name": "tristen",
      "email": "tristen.brown@gmail.com"
    },
    {
      "name": "willwhite",
      "email": "will@mapbox.com"
    },
    {
      "name": "yhahn",
      "email": "young@mapbox.com"
    }
  ],
  "name": "mapbox.js",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git://github.com/mapbox/mapbox.js.git"
  },
  "scripts": {
    "test": "eslint --no-eslintrc -c .eslintrc src && phantomjs node_modules/mocha-phantomjs-core/mocha-phantomjs-core.js test/index.html"
  },
  "version": "3.0.0"
}

},{}],11:[function(require,module,exports){
'use strict';

module.exports = {
    HTTP_URL: 'http://a.tiles.mapbox.com/v4',
    HTTPS_URL: 'https://a.tiles.mapbox.com/v4',
    FORCE_HTTPS: false,
    REQUIRE_ACCESS_TOKEN: true
};

},{}],12:[function(require,module,exports){
'use strict';

var util = require('./util'),
    format_url = require('./format_url'),
    request = require('./request'),
    marker = require('./marker'),
    simplestyle = require('./simplestyle');

// # featureLayer
//
// A layer of features, loaded from Mapbox or else. Adds the ability
// to reset features, filter them, and load them from a GeoJSON URL.
var FeatureLayer = L.FeatureGroup.extend({
    options: {
        filter: function() { return true; },
        sanitizer: require('sanitize-caja'),
        style: simplestyle.style,
        popupOptions: { closeButton: false }
    },

    initialize: function(_, options) {
        L.setOptions(this, options);

        this._layers = {};

        if (typeof _ === 'string') {
            util.idUrl(_, this);
        // javascript object of TileJSON data
        } else if (_ && typeof _ === 'object') {
            this.setGeoJSON(_);
        }
    },

    setGeoJSON: function(_) {
        this._geojson = _;
        this.clearLayers();
        this._initialize(_);
        return this;
    },

    getGeoJSON: function() {
        return this._geojson;
    },

    loadURL: function(url) {
        if (this._request && 'abort' in this._request) this._request.abort();
        this._request = request(url, L.bind(function(err, json) {
            this._request = null;
            if (err && err.type !== 'abort') {
                util.log('could not load features at ' + url);
                this.fire('error', {error: err});
            } else if (json) {
                this.setGeoJSON(json);
                this.fire('ready');
            }
        }, this));
        return this;
    },

    loadID: function(id) {
        return this.loadURL(format_url('/v4/' + id + '/features.json', this.options.accessToken));
    },

    setFilter: function(_) {
        this.options.filter = _;
        if (this._geojson) {
            this.clearLayers();
            this._initialize(this._geojson);
        }
        return this;
    },

    getFilter: function() {
        return this.options.filter;
    },

    _initialize: function(json) {
        var features = L.Util.isArray(json) ? json : json.features,
            i, len;

        if (features) {
            for (i = 0, len = features.length; i < len; i++) {
                // Only add this if geometry or geometries are set and not null
                if (features[i].geometries || features[i].geometry || features[i].features) {
                    this._initialize(features[i]);
                }
            }
        } else if (this.options.filter(json)) {

            var opts = {accessToken: this.options.accessToken},
                pointToLayer = this.options.pointToLayer || function(feature, latlon) {
                  return marker.style(feature, latlon, opts);
                },
                layer = L.GeoJSON.geometryToLayer(json, {
                    pointToLayer: pointToLayer
                }),
                popupHtml = marker.createPopup(json, this.options.sanitizer),
                style = this.options.style,
                defaultStyle = style === simplestyle.style;

            if (style && 'setStyle' in layer &&
                // if the style method is the simplestyle default, then
                // never style L.Circle or L.CircleMarker because
                // simplestyle has no rules over them, only over geometry
                // primitives directly from GeoJSON
                (!(defaultStyle && (layer instanceof L.Circle ||
                  layer instanceof L.CircleMarker)))) {
                if (typeof style === 'function') {
                    style = style(json);
                }
                layer.setStyle(style);
            }

            layer.feature = json;

            if (popupHtml) {
                layer.bindPopup(popupHtml, this.options.popupOptions);
            }

            this.addLayer(layer);
        }
    }
});

module.exports.FeatureLayer = FeatureLayer;

module.exports.featureLayer = function(_, options) {
    return new FeatureLayer(_, options);
};

},{"./format_url":14,"./marker":27,"./request":28,"./simplestyle":30,"./util":33,"sanitize-caja":39}],13:[function(require,module,exports){
'use strict';

var Feedback = L.Class.extend({
    includes: L.Mixin.Events,
    data: {},
    record: function(data) {
        L.extend(this.data, data);
        this.fire('change');
    }
});

module.exports = new Feedback();

},{}],14:[function(require,module,exports){
'use strict';

var config = require('./config'),
    version = require('../package.json').version;

module.exports = function(path, accessToken) {
    accessToken = accessToken || L.mapbox.accessToken;

    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
        throw new Error('An API access token is required to use Mapbox.js. ' +
            'See https://www.mapbox.com/mapbox.js/api/v' + version + '/api-access-tokens/');
    }

    var url = (document.location.protocol === 'https:' || config.FORCE_HTTPS) ? config.HTTPS_URL : config.HTTP_URL;
    url = url.replace(/\/v4$/, '');
    url += path;

    if (config.REQUIRE_ACCESS_TOKEN) {
        if (accessToken[0] === 's') {
            throw new Error('Use a public access token (pk.*) with Mapbox.js, not a secret access token (sk.*). ' +
                'See https://www.mapbox.com/mapbox.js/api/v' + version + '/api-access-tokens/');
        }

        url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';
        url += accessToken;
    }

    return url;
};

module.exports.tileJSON = function(urlOrMapID, accessToken) {

    if (urlOrMapID.indexOf('mapbox://styles') === 0) {
        throw new Error('Styles created with Mapbox Studio need to be used with ' +
            'L.mapbox.styleLayer, not L.mapbox.tileLayer');
    }

    if (urlOrMapID.indexOf('/') !== -1)
        return urlOrMapID;

    var url = module.exports('/v4/' + urlOrMapID + '.json', accessToken);

    // TileJSON requests need a secure flag appended to their URLs so
    // that the server knows to send SSL-ified resource references.
    if (url.indexOf('https') === 0)
        url += '&secure';

    return url;
};


module.exports.style = function(styleURL, accessToken) {
    if (styleURL.indexOf('mapbox://styles/') === -1) throw new Error('Incorrectly formatted Mapbox style at ' + styleURL);

    var ownerIDStyle = styleURL.split('mapbox://styles/')[1];
    var url = module.exports('/styles/v1/' + ownerIDStyle, accessToken)
        .replace('http://', 'https://');

    return url;
};

},{"../package.json":10,"./config":11}],15:[function(require,module,exports){
'use strict';

var isArray = require('isarray'),
    util = require('./util'),
    format_url = require('./format_url'),
    feedback = require('./feedback'),
    request = require('./request');

// Low-level geocoding interface - wraps specific API calls and their
// return values.
module.exports = function(url, options) {
    if (!options) options = {};
    var geocoder = {};

    util.strict(url, 'string');

    if (url.indexOf('/') === -1) {
        url = format_url('/geocoding/v5/' + url + '/{query}.json', options.accessToken, 5);
    }

    function roundTo(latLng, precision) {
        var mult = Math.pow(10, precision);
        latLng.lat = Math.round(latLng.lat * mult) / mult;
        latLng.lng = Math.round(latLng.lng * mult) / mult;
        return latLng;
    }

    geocoder.getURL = function() {
        return url;
    };

    geocoder.queryURL = function(_) {
        var isObject = !(isArray(_) || typeof _ === 'string'),
            query = isObject ? _.query : _;

        if (isArray(query)) {
            var parts = [];
            for (var i = 0; i < query.length; i++) {
                parts[i] = encodeURIComponent(query[i]);
            }
            query = parts.join(';');
        } else {
            query = encodeURIComponent(query);
        }

        feedback.record({ geocoding: query });

        var url = L.Util.template(geocoder.getURL(), {query: query});

        if (isObject) {
            if (_.types) {
                if (isArray(_.types)) {
                    url += '&types=' + _.types.join();
                } else {
                    url += '&types=' + _.types;
                }
            }

            if (_.country) {
                if (isArray(_.country)) {
                    url += '&country=' + _.country.join();
                } else {
                    url += '&country=' + _.country;
                }
            }

            if (_.proximity) {
                var proximity = roundTo(L.latLng(_.proximity), 3);
                url += '&proximity=' + proximity.lng + ',' + proximity.lat;
            }

            if (typeof _.autocomplete === 'boolean') {
                url += '&autocomplete=' + _.autocomplete;
            }
        }

        return url;
    };

    geocoder.query = function(_, callback) {
        util.strict(callback, 'function');

        request(geocoder.queryURL(_), function(err, json) {
            if (json && (json.length || json.features)) {
                var res = {
                    results: json
                };
                if (json.features && json.features.length) {
                    res.latlng = [
                        json.features[0].center[1],
                        json.features[0].center[0]];

                    if (json.features[0].bbox) {
                        res.bounds = json.features[0].bbox;
                        res.lbounds = util.lbounds(res.bounds);
                    }
                }
                callback(null, res);
            } else callback(err || true);
        });

        return geocoder;
    };

    // a reverse geocode:
    //
    //  geocoder.reverseQuery([80, 20])
    geocoder.reverseQuery = function(_, callback) {
        var q = '';

        // sort through different ways people represent lat and lon pairs
        function normalize(x) {
            var latLng;
            if (x.lat !== undefined && x.lng !== undefined) {
                latLng = L.latLng(x.lat, x.lng);
            } else if (x.lat !== undefined && x.lon !== undefined) {
                latLng = L.latLng(x.lat, x.lon);
            } else {
                latLng = L.latLng(x[1], x[0]);
            }
            latLng = roundTo(latLng, 5);
            return latLng.lng + ',' + latLng.lat;
        }

        if (_.length && _[0].length) {
            for (var i = 0, pts = []; i < _.length; i++) {
                pts.push(normalize(_[i]));
            }
            q = pts.join(';');
        } else {
            q = normalize(_);
        }

        request(geocoder.queryURL(q), function(err, json) {
            callback(err, json);
        });

        return geocoder;
    };

    return geocoder;
};

},{"./feedback":13,"./format_url":14,"./request":28,"./util":33,"isarray":7}],16:[function(require,module,exports){
'use strict';

var geocoder = require('./geocoder'),
    util = require('./util');

var GeocoderControl = L.Control.extend({
    includes: L.Mixin.Events,

    options: {
        proximity: true,
        position: 'topleft',
        pointZoom: 16,
        keepOpen: false,
        autocomplete: false,
        queryOptions: {}
    },

    initialize: function(_, options) {
        L.Util.setOptions(this, options);
        this.setURL(_);
        this._updateSubmit = L.bind(this._updateSubmit, this);
        this._updateAutocomplete = L.bind(this._updateAutocomplete, this);
        this._chooseResult = L.bind(this._chooseResult, this);
    },

    setURL: function(_) {
        this.geocoder = geocoder(_, {
            accessToken: this.options.accessToken
        });
        return this;
    },

    getURL: function() {
        return this.geocoder.getURL();
    },

    setID: function(_) {
        return this.setURL(_);
    },

    setTileJSON: function(_) {
        return this.setURL(_.geocoder);
    },

    _toggle: function(e) {
        if (e) L.DomEvent.stop(e);
        if (L.DomUtil.hasClass(this._container, 'active')) {
            L.DomUtil.removeClass(this._container, 'active');
            this._results.innerHTML = '';
            this._input.blur();
        } else {
            L.DomUtil.addClass(this._container, 'active');
            this._input.focus();
            this._input.select();
        }
    },

    _closeIfOpen: function() {
        if (L.DomUtil.hasClass(this._container, 'active') &&
            !this.options.keepOpen) {
            L.DomUtil.removeClass(this._container, 'active');
            this._results.innerHTML = '';
            this._input.blur();
        }
    },

    onAdd: function(map) {

        var container = L.DomUtil.create('div', 'leaflet-control-mapbox-geocoder leaflet-bar leaflet-control'),
            link = L.DomUtil.create('a', 'leaflet-control-mapbox-geocoder-toggle mapbox-icon mapbox-icon-geocoder', container),
            results = L.DomUtil.create('div', 'leaflet-control-mapbox-geocoder-results', container),
            wrap = L.DomUtil.create('div', 'leaflet-control-mapbox-geocoder-wrap', container),
            form = L.DomUtil.create('form', 'leaflet-control-mapbox-geocoder-form', wrap),
            input = L.DomUtil.create('input', '', form);

        link.href = '#';
        link.innerHTML = '&nbsp;';

        input.type = 'text';
        input.setAttribute('placeholder', 'Search');

        L.DomEvent.addListener(form, 'submit', this._geocode, this);
        L.DomEvent.addListener(input, 'keyup', this._autocomplete, this);
        L.DomEvent.disableClickPropagation(container);

        this._map = map;
        this._results = results;
        this._input = input;
        this._form = form;

        if (this.options.keepOpen) {
            L.DomUtil.addClass(container, 'active');
        } else {
            this._map.on('click', this._closeIfOpen, this);
            L.DomEvent.addListener(link, 'click', this._toggle, this);
        }

        return container;
    },

    _updateSubmit: function(err, resp) {
        L.DomUtil.removeClass(this._container, 'searching');
        this._results.innerHTML = '';
        if (err || !resp) {
            this.fire('error', {error: err});
        } else {
            var features = [];
            if (resp.results && resp.results.features) {
                features = resp.results.features;
            }
            if (features.length === 1) {
                this.fire('autoselect', { feature: features[0] });
                this.fire('found', {results: resp.results});
                this._chooseResult(features[0]);
                this._closeIfOpen();
            } else if (features.length > 1) {
                this.fire('found', {results: resp.results});
                this._displayResults(features);
            } else {
                this.fire('notfound');
                this._displayResults(features);
            }
        }
    },

    _updateAutocomplete: function(err, resp) {
        this._results.innerHTML = '';
        if (err || !resp) {
            this.fire('error', {error: err});
        } else {
            var features = [];
            if (resp.results && resp.results.features) {
                features = resp.results.features;
            }
            if (features.length) {
                this.fire('found', {results: resp.results});
            } else {
                this.fire('notfound');
            }
            this._displayResults(features);
        }
    },

    _displayResults: function(features) {
        for (var i = 0, l = Math.min(features.length, 5); i < l; i++) {
            var feature = features[i];
            var name = feature.place_name;
            if (!name.length) continue;

            var r = L.DomUtil.create('a', '', this._results);
            var text = ('innerText' in r) ? 'innerText' : 'textContent';
            r[text] = name;
            r.setAttribute('title', name);
            r.href = '#';

            (L.bind(function(feature) {
                L.DomEvent.addListener(r, 'click', function(e) {
                    this._chooseResult(feature);
                    L.DomEvent.stop(e);
                    this.fire('select', { feature: feature });
                }, this);
            }, this))(feature);
        }
        if (features.length > 5) {
            var outof = L.DomUtil.create('span', '', this._results);
            outof.innerHTML = 'Top 5 of ' + features.length + '  results';
        }
    },

    _chooseResult: function(result) {
        if (result.bbox) {
            this._map.fitBounds(util.lbounds(result.bbox));
        } else if (result.center) {
            this._map.setView([result.center[1], result.center[0]], (this._map.getZoom() === undefined) ?
                this.options.pointZoom :
                Math.max(this._map.getZoom(), this.options.pointZoom));
        }
    },

    _geocode: function(e) {
        L.DomEvent.preventDefault(e);
        if (this._input.value === '') return this._updateSubmit();
        L.DomUtil.addClass(this._container, 'searching');
        this.geocoder.query(L.Util.extend({
            query: this._input.value,
            proximity: this.options.proximity ? this._map.getCenter() : false
        }, this.options.queryOptions), this._updateSubmit);
    },

    _autocomplete: function() {
        if (!this.options.autocomplete) return;
        if (this._input.value === '') return this._updateAutocomplete();
        this.geocoder.query(L.Util.extend({
            query: this._input.value,
            proximity: this.options.proximity ? this._map.getCenter() : false
        }, this.options.queryOptions), this._updateAutocomplete);
    }
});

module.exports.GeocoderControl = GeocoderControl;

module.exports.geocoderControl = function(_, options) {
    return new GeocoderControl(_, options);
};

},{"./geocoder":15,"./util":33}],17:[function(require,module,exports){
'use strict';

function utfDecode(c) {
    if (c >= 93) c--;
    if (c >= 35) c--;
    return c - 32;
}

module.exports = function(data) {
    return function(x, y) {
        if (!data) return;
        var idx = utfDecode(data.grid[y].charCodeAt(x)),
            key = data.keys[idx];
        return data.data[key];
    };
};

},{}],18:[function(require,module,exports){
'use strict';

var util = require('./util'),
    Mustache = require('mustache');

var GridControl = L.Control.extend({

    options: {
        pinnable: true,
        follow: false,
        sanitizer: require('sanitize-caja'),
        touchTeaser: true,
        location: true
    },

    _currentContent: '',

    // pinned means that this control is on a feature and the user has likely
    // clicked. pinned will not become false unless the user clicks off
    // of the feature onto another or clicks x
    _pinned: false,

    initialize: function(_, options) {
        L.Util.setOptions(this, options);
        util.strict_instance(_, L.Class, 'L.mapbox.gridLayer');
        this._layer = _;
    },

    setTemplate: function(template) {
        util.strict(template, 'string');
        this.options.template = template;
        return this;
    },

    _template: function(format, data) {
        if (!data) return;
        var template = this.options.template || this._layer.getTileJSON().template;
        if (template) {
            var d = {};
            d['__' + format + '__'] = true;
            return this.options.sanitizer(
                Mustache.to_html(template, L.extend(d, data)));
        }
    },

    // change the content of the tooltip HTML if it has changed, otherwise
    // noop
    _show: function(content, o) {
        if (content === this._currentContent) return;

        this._currentContent = content;

        if (this.options.follow) {
            this._popup.setContent(content)
                .setLatLng(o.latLng);
            if (this._map._popup !== this._popup) this._popup.openOn(this._map);
        } else {
            this._container.style.display = 'block';
            this._contentWrapper.innerHTML = content;
        }
    },

    hide: function() {
        this._pinned = false;
        this._currentContent = '';

        this._map.closePopup();
        this._container.style.display = 'none';
        this._contentWrapper.innerHTML = '';

        L.DomUtil.removeClass(this._container, 'closable');

        return this;
    },

    _mouseover: function(o) {
        if (o.data) {
            L.DomUtil.addClass(this._map._container, 'map-clickable');
        } else {
            L.DomUtil.removeClass(this._map._container, 'map-clickable');
        }

        if (this._pinned) return;

        var content = this._template('teaser', o.data);
        if (content) {
            this._show(content, o);
        } else {
            this.hide();
        }
    },

    _mousemove: function(o) {
        if (this._pinned) return;
        if (!this.options.follow) return;

        this._popup.setLatLng(o.latLng);
    },

    _navigateTo: function(url) {
        window.top.location.href = url;
    },

    _click: function(o) {

        var location_formatted = this._template('location', o.data);
        if (this.options.location && location_formatted &&
            location_formatted.search(/^https?:/) === 0) {
            return this._navigateTo(this._template('location', o.data));
        }

        if (!this.options.pinnable) return;

        var content = this._template('full', o.data);

        if (!content && this.options.touchTeaser && L.Browser.touch) {
            content = this._template('teaser', o.data);
        }

        if (content) {
            L.DomUtil.addClass(this._container, 'closable');
            this._pinned = true;
            this._show(content, o);
        } else if (this._pinned) {
            L.DomUtil.removeClass(this._container, 'closable');
            this._pinned = false;
            this.hide();
        }
    },

    _onPopupClose: function() {
        this._currentContent = null;
        this._pinned = false;
    },

    _createClosebutton: function(container, fn) {
        var link = L.DomUtil.create('a', 'close', container);

        link.innerHTML = 'close';
        link.href = '#';
        link.title = 'close';

        L.DomEvent
            .on(link, 'click', L.DomEvent.stopPropagation)
            .on(link, 'mousedown', L.DomEvent.stopPropagation)
            .on(link, 'dblclick', L.DomEvent.stopPropagation)
            .on(link, 'click', L.DomEvent.preventDefault)
            .on(link, 'click', fn, this);

        return link;
    },

    onAdd: function(map) {
        this._map = map;

        var className = 'leaflet-control-grid map-tooltip',
            container = L.DomUtil.create('div', className),
            contentWrapper = L.DomUtil.create('div', 'map-tooltip-content');

        // hide the container element initially
        container.style.display = 'none';
        this._createClosebutton(container, this.hide);
        container.appendChild(contentWrapper);

        this._contentWrapper = contentWrapper;
        this._popup = new L.Popup({ autoPan: false, closeOnClick: false });

        map.on('popupclose', this._onPopupClose, this);

        L.DomEvent
            .disableClickPropagation(container)
            // allow people to scroll tooltips with mousewheel
            .addListener(container, 'mousewheel', L.DomEvent.stopPropagation);

        this._layer
            .on('mouseover', this._mouseover, this)
            .on('mousemove', this._mousemove, this)
            .on('click', this._click, this);

        return container;
    },

    onRemove: function (map) {

        map.off('popupclose', this._onPopupClose, this);

        this._layer
            .off('mouseover', this._mouseover, this)
            .off('mousemove', this._mousemove, this)
            .off('click', this._click, this);
    }
});

module.exports.GridControl = GridControl;

module.exports.gridControl = function(_, options) {
    return new GridControl(_, options);
};

},{"./util":33,"mustache":34,"sanitize-caja":39}],19:[function(require,module,exports){
'use strict';

var util = require('./util'),
    request = require('./request'),
    grid = require('./grid');

// forked from danzel/L.UTFGrid
var GridLayer = L.Layer.extend({
    includes: [require('./load_tilejson')],

    options: {
        template: function() { return ''; }
    },

    _mouseOn: null,
    _tilejson: {},
    _cache: {},

    initialize: function(_, options) {
        L.Util.setOptions(this, options);
        this._loadTileJSON(_);
    },

    _setTileJSON: function(json) {
        util.strict(json, 'object');

        L.extend(this.options, {
            grids: json.grids,
            minZoom: json.minzoom,
            maxZoom: json.maxzoom,
            bounds: json.bounds && util.lbounds(json.bounds)
        });

        this._tilejson = json;
        this._cache = {};
        this._update();

        return this;
    },

    getTileJSON: function() {
        return this._tilejson;
    },

    active: function() {
        return !!(this._map && this.options.grids && this.options.grids.length);
    },

    onAdd: function(map) {
        this._map = map;
        this._update();

        this._map
            .on('click', this._click, this)
            .on('mousemove', this._move, this)
            .on('moveend', this._update, this);
    },

    onRemove: function() {
        this._map
            .off('click', this._click, this)
            .off('mousemove', this._move, this)
            .off('moveend', this._update, this);
    },

    getData: function(latlng, callback) {
        if (!this.active()) return;

        var map = this._map,
            point = map.project(latlng.wrap()),
            tileSize = 256,
            resolution = 4,
            x = Math.floor(point.x / tileSize),
            y = Math.floor(point.y / tileSize),
            max = map.options.crs.scale(map.getZoom()) / tileSize;

        x = (x + max) % max;
        y = (y + max) % max;

        this._getTile(map.getZoom(), x, y, function(grid) {
            var gridX = Math.floor((point.x - (x * tileSize)) / resolution),
                gridY = Math.floor((point.y - (y * tileSize)) / resolution);

            callback(grid(gridX, gridY));
        });

        return this;
    },

    _click: function(e) {
        this.getData(e.latlng, L.bind(function(data) {
            this.fire('click', {
                latLng: e.latlng,
                data: data
            });
        }, this));
    },

    _move: function(e) {
        this.getData(e.latlng, L.bind(function(data) {
            if (data !== this._mouseOn) {
                if (this._mouseOn) {
                    this.fire('mouseout', {
                        latLng: e.latlng,
                        data: this._mouseOn
                    });
                }

                this.fire('mouseover', {
                    latLng: e.latlng,
                    data: data
                });

                this._mouseOn = data;
            } else {
                this.fire('mousemove', {
                    latLng: e.latlng,
                    data: data
                });
            }
        }, this));
    },

    _getTileURL: function(tilePoint) {
        var urls = this.options.grids,
            index = (tilePoint.x + tilePoint.y) % urls.length,
            url = urls[index];

        return L.Util.template(url, tilePoint);
    },

    // Load up all required json grid files
    _update: function() {
        if (!this.active()) return;

        var bounds = this._map.getPixelBounds(),
            z = this._map.getZoom(),
            tileSize = 256;

        if (z > this.options.maxZoom || z < this.options.minZoom) return;

        var tileBounds = L.bounds(
                bounds.min.divideBy(tileSize)._floor(),
                bounds.max.divideBy(tileSize)._floor()),
            max = this._map.options.crs.scale(z) / tileSize;

        for (var x = tileBounds.min.x; x <= tileBounds.max.x; x++) {
            for (var y = tileBounds.min.y; y <= tileBounds.max.y; y++) {
                // x wrapped
                this._getTile(z, ((x % max) + max) % max, ((y % max) + max) % max);
            }
        }
    },

    _getTile: function(z, x, y, callback) {
        var key = z + '_' + x + '_' + y,
            tilePoint = L.point(x, y);

        tilePoint.z = z;

        if (!this._tileShouldBeLoaded(tilePoint)) {
            return;
        }

        if (key in this._cache) {
            if (!callback) return;

            if (typeof this._cache[key] === 'function') {
                callback(this._cache[key]); // Already loaded
            } else {
                this._cache[key].push(callback); // Pending
            }

            return;
        }

        this._cache[key] = [];

        if (callback) {
            this._cache[key].push(callback);
        }

        request(this._getTileURL(tilePoint), L.bind(function(err, json) {
            var callbacks = this._cache[key];
            this._cache[key] = grid(json);
            for (var i = 0; i < callbacks.length; ++i) {
                callbacks[i](this._cache[key]);
            }
        }, this));
    },

    _tileShouldBeLoaded: function(tilePoint) {
        if (tilePoint.z > this.options.maxZoom || tilePoint.z < this.options.minZoom) {
            return false;
        }

        if (this.options.bounds) {
            var tileSize = 256,
                nwPoint = tilePoint.multiplyBy(tileSize),
                sePoint = nwPoint.add(new L.Point(tileSize, tileSize)),
                nw = this._map.unproject(nwPoint),
                se = this._map.unproject(sePoint),
                bounds = new L.LatLngBounds([nw, se]);

            if (!this.options.bounds.intersects(bounds)) {
                return false;
            }
        }

        return true;
    }
});

module.exports.GridLayer = GridLayer;

module.exports.gridLayer = function(_, options) {
    return new GridLayer(_, options);
};

},{"./grid":17,"./load_tilejson":23,"./request":28,"./util":33}],20:[function(require,module,exports){
'use strict';

var leaflet = require('./leaflet');

require('./mapbox');

module.exports = leaflet;

},{"./leaflet":21,"./mapbox":25}],21:[function(require,module,exports){
module.exports = window.L = require('leaflet/dist/leaflet-src');

},{"leaflet/dist/leaflet-src":9}],22:[function(require,module,exports){
'use strict';

var LegendControl = L.Control.extend({

    options: {
        position: 'bottomright',
        sanitizer: require('sanitize-caja')
    },

    initialize: function(options) {
        L.setOptions(this, options);
        this._legends = {};
    },

    onAdd: function() {
        this._container = L.DomUtil.create('div', 'map-legends wax-legends');
        L.DomEvent.disableClickPropagation(this._container);

        this._update();

        return this._container;
    },

    addLegend: function(text) {
        if (!text) { return this; }

        if (!this._legends[text]) {
            this._legends[text] = 0;
        }

        this._legends[text]++;
        return this._update();
    },

    removeLegend: function(text) {
        if (!text) { return this; }
        if (this._legends[text]) this._legends[text]--;
        return this._update();
    },

    _update: function() {
        if (!this._map) { return this; }

        this._container.innerHTML = '';
        var hide = 'none';

        for (var i in this._legends) {
            if (this._legends.hasOwnProperty(i) && this._legends[i]) {
                var div = L.DomUtil.create('div', 'map-legend wax-legend', this._container);
                div.innerHTML = this.options.sanitizer(i);
                hide = 'block';
            }
        }

        // hide the control entirely unless there is at least one legend;
        // otherwise there will be a small grey blemish on the map.
        this._container.style.display = hide;

        return this;
    }
});

module.exports.LegendControl = LegendControl;

module.exports.legendControl = function(options) {
    return new LegendControl(options);
};

},{"sanitize-caja":39}],23:[function(require,module,exports){
'use strict';

var request = require('./request'),
    format_url = require('./format_url'),
    util = require('./util');

module.exports = {
    _loadTileJSON: function(_) {
        if (typeof _ === 'string') {
            _ = format_url.tileJSON(_, this.options && this.options.accessToken);
            request(_, L.bind(function(err, json) {
                if (err) {
                    util.log('could not load TileJSON at ' + _);
                    this.fire('error', {error: err});
                } else if (json) {
                    this._setTileJSON(json);
                    this.fire('ready');
                }
            }, this));
        } else if (_ && typeof _ === 'object') {
            this._setTileJSON(_);
        }
    }
};

},{"./format_url":14,"./request":28,"./util":33}],24:[function(require,module,exports){
'use strict';

var tileLayer = require('./tile_layer').tileLayer,
    featureLayer = require('./feature_layer').featureLayer,
    gridLayer = require('./grid_layer').gridLayer,
    gridControl = require('./grid_control').gridControl,
    shareControl = require('./share_control').shareControl,
    legendControl = require('./legend_control').legendControl,
    mapboxLogoControl = require('./mapbox_logo').mapboxLogoControl,
    feedback = require('./feedback');

function withAccessToken(options, accessToken) {
    if (!accessToken || options.accessToken)
        return options;
    return L.extend({accessToken: accessToken}, options);
}

var LMap = L.Map.extend({
    includes: [require('./load_tilejson')],

    options: {
        tileLayer: {},
        featureLayer: {},
        gridLayer: {},
        legendControl: {},
        gridControl: {},
        shareControl: false,
        sanitizer: require('sanitize-caja')
    },

    _tilejson: {},

    initialize: function(element, _, options) {

        L.Map.prototype.initialize.call(this, element,
            L.extend({}, L.Map.prototype.options, options));

        // Disable the default 'Leaflet' text
        if (this.attributionControl) {
            this.attributionControl.setPrefix('');

            var compact = this.options.attributionControl.compact;
            // Set a compact display if map container width is < 640 or
            // compact is set to `true` in attributionControl options.
            if (compact || (compact !== false && this._container.offsetWidth <= 640)) {
                L.DomUtil.addClass(this.attributionControl._container, 'leaflet-compact-attribution');
            }

            if (compact === undefined) {
                this.on('resize', function() {
                    if (this._container.offsetWidth > 640) {
                        L.DomUtil.removeClass(this.attributionControl._container, 'leaflet-compact-attribution');
                    } else {
                        L.DomUtil.addClass(this.attributionControl._container, 'leaflet-compact-attribution');
                    }
                });
            }
        }

        if (this.options.tileLayer) {
            this.tileLayer = tileLayer(undefined,
                withAccessToken(this.options.tileLayer, this.options.accessToken));
            this.addLayer(this.tileLayer);
        }

        if (this.options.featureLayer) {
            this.featureLayer = featureLayer(undefined,
                withAccessToken(this.options.featureLayer, this.options.accessToken));
            this.addLayer(this.featureLayer);
        }

        if (this.options.gridLayer) {
            this.gridLayer = gridLayer(undefined,
                withAccessToken(this.options.gridLayer, this.options.accessToken));
            this.addLayer(this.gridLayer);
        }

        if (this.options.gridLayer && this.options.gridControl) {
            this.gridControl = gridControl(this.gridLayer, this.options.gridControl);
            this.addControl(this.gridControl);
        }

        if (this.options.legendControl) {
            this.legendControl = legendControl(this.options.legendControl);
            this.addControl(this.legendControl);
        }

        if (this.options.shareControl) {
            this.shareControl = shareControl(undefined,
                withAccessToken(this.options.shareControl, this.options.accessToken));
            this.addControl(this.shareControl);
        }

        this._mapboxLogoControl = mapboxLogoControl(this.options.mapboxLogoControl);
        this.addControl(this._mapboxLogoControl);

        this._loadTileJSON(_);

        this.on('layeradd', this._onLayerAdd, this)
            .on('layerremove', this._onLayerRemove, this)
            .on('moveend', this._updateMapFeedbackLink, this);

        this.whenReady(function () {
            feedback.on('change', this._updateMapFeedbackLink, this);
        });

        this.on('unload', function () {
            feedback.off('change', this._updateMapFeedbackLink, this);
        });
    },

    // use a javascript object of tilejson data to configure this layer
    _setTileJSON: function(_) {
        this._tilejson = _;
        this._initialize(_);
        return this;
    },

    getTileJSON: function() {
        return this._tilejson;
    },

    _initialize: function(json) {
        if (this.tileLayer) {
            this.tileLayer._setTileJSON(json);
            this._updateLayer(this.tileLayer);
        }

        if (this.featureLayer && !this.featureLayer.getGeoJSON() && json.data && json.data[0]) {
            this.featureLayer.loadURL(json.data[0]);
        }

        if (this.gridLayer) {
            this.gridLayer._setTileJSON(json);
            this._updateLayer(this.gridLayer);
        }

        if (this.legendControl && json.legend) {
            this.legendControl.addLegend(json.legend);
        }

        if (this.shareControl) {
            this.shareControl._setTileJSON(json);
        }

        this._mapboxLogoControl._setTileJSON(json);

        if (!this._loaded && json.center) {
            var zoom = this.getZoom() !== undefined ? this.getZoom() : json.center[2],
                center = L.latLng(json.center[1], json.center[0]);

            this.setView(center, zoom);
        }
    },

    _updateMapFeedbackLink: function() {
        if (!this._controlContainer.getElementsByClassName) return;
        var link = this._controlContainer.getElementsByClassName('mapbox-improve-map');
        if (link.length && this._loaded) {
            var center = this.getCenter().wrap();
            var tilejson = this._tilejson || {};
            var id = tilejson.id || '';

            var hash = '#' + id + '/' +
                center.lng.toFixed(3) + '/' +
                center.lat.toFixed(3) + '/' +
                this.getZoom();

            for (var key in feedback.data) {
                hash += '/' + key + '=' + feedback.data[key];
            }

            for (var i = 0; i < link.length; i++) {
                link[i].hash = hash;
            }
        }
    },

    _onLayerAdd: function(e) {
        if ('on' in e.layer) {
            e.layer.on('ready', this._onLayerReady, this);
        }
        window.setTimeout(L.bind(this._updateMapFeedbackLink, this), 0); // Update after attribution control resets the HTML.
    },

    _onLayerRemove: function(e) {
        if ('on' in e.layer) {
            e.layer.off('ready', this._onLayerReady, this);
        }
        window.setTimeout(L.bind(this._updateMapFeedbackLink, this), 0); // Update after attribution control resets the HTML.
    },

    _onLayerReady: function(e) {
        this._updateLayer(e.target);
    },

    _updateLayer: function(layer) {
        if (!layer.options) return;

        if (this.attributionControl && this._loaded && layer.getAttribution) {
            this.attributionControl.addAttribution(layer.getAttribution());
        }

        if (!(L.stamp(layer) in this._zoomBoundLayers) &&
                (layer.options.maxZoom || layer.options.minZoom)) {
            this._zoomBoundLayers[L.stamp(layer)] = layer;
        }

        this._updateMapFeedbackLink();
        this._updateZoomLevels();
    }
});

module.exports.Map = LMap;

module.exports.map = function(element, _, options) {
    return new LMap(element, _, options);
};

},{"./feature_layer":12,"./feedback":13,"./grid_control":18,"./grid_layer":19,"./legend_control":22,"./load_tilejson":23,"./mapbox_logo":26,"./share_control":29,"./tile_layer":32,"sanitize-caja":39}],25:[function(require,module,exports){
'use strict';

var geocoderControl = require('./geocoder_control'),
    gridControl = require('./grid_control'),
    featureLayer = require('./feature_layer'),
    legendControl = require('./legend_control'),
    shareControl = require('./share_control'),
    tileLayer = require('./tile_layer'),
    map = require('./map'),
    gridLayer = require('./grid_layer'),
    styleLayer = require('./style_layer');

L.mapbox = module.exports = {
    VERSION: require('../package.json').version,
    geocoder: require('./geocoder'),
    marker: require('./marker'),
    simplestyle: require('./simplestyle'),
    tileLayer: tileLayer.tileLayer,
    TileLayer: tileLayer.TileLayer,
    styleLayer: styleLayer.styleLayer,
    StyleLayer: styleLayer.StyleLayer,
    shareControl: shareControl.shareControl,
    ShareControl: shareControl.ShareControl,
    legendControl: legendControl.legendControl,
    LegendControl: legendControl.LegendControl,
    geocoderControl: geocoderControl.geocoderControl,
    GeocoderControl: geocoderControl.GeocoderControl,
    gridControl: gridControl.gridControl,
    GridControl: gridControl.GridControl,
    gridLayer: gridLayer.gridLayer,
    GridLayer: gridLayer.GridLayer,
    featureLayer: featureLayer.featureLayer,
    FeatureLayer: featureLayer.FeatureLayer,
    map: map.map,
    Map: map.Map,
    config: require('./config'),
    sanitize: require('sanitize-caja'),
    template: require('mustache').to_html,
    feedback: require('./feedback')
};


// Hardcode image path, because Leaflet's autodetection
// fails, because mapbox.js is not named leaflet.js
window.L.Icon.Default.imagePath =
    // Detect bad-news protocols like file:// and hardcode
    // to https if they're detected.
    ((document.location.protocol === 'https:' ||
    document.location.protocol === 'http:') ? '' : 'https:') +
    '//api.tiles.mapbox.com/mapbox.js/' + 'v' +
    require('../package.json').version + '/images';

},{"../package.json":10,"./config":11,"./feature_layer":12,"./feedback":13,"./geocoder":15,"./geocoder_control":16,"./grid_control":18,"./grid_layer":19,"./legend_control":22,"./map":24,"./marker":27,"./share_control":29,"./simplestyle":30,"./style_layer":31,"./tile_layer":32,"mustache":34,"sanitize-caja":39}],26:[function(require,module,exports){
'use strict';

var MapboxLogoControl = L.Control.extend({

    options: {
        position: 'bottomleft'
    },

    initialize: function(options) {
        L.setOptions(this, options);
    },

    onAdd: function() {
        this._container = L.DomUtil.create('div', 'mapbox-logo');
        return this._container;
    },

    _setTileJSON: function(json) {
        // Check if account referenced by the accessToken
        // is asscociated with the Mapbox Logo
        // as determined by mapbox-maps.
        if (json.mapbox_logo) {
            L.DomUtil.addClass(this._container, 'mapbox-logo-true');
        }
    }
});

module.exports.MapboxLogoControl = MapboxLogoControl;

module.exports.mapboxLogoControl = function(options) {
    return new MapboxLogoControl(options);
};

},{}],27:[function(require,module,exports){
'use strict';

var format_url = require('./format_url'),
    util = require('./util'),
    sanitize = require('sanitize-caja');

// mapbox-related markers functionality
// provide an icon from mapbox's simple-style spec and hosted markers
// service
function icon(fp, options) {
    fp = fp || {};

    var sizes = {
            small: [20, 50],
            medium: [30, 70],
            large: [35, 90]
        },
        size = fp['marker-size'] || 'medium',
        symbol = ('marker-symbol' in fp && fp['marker-symbol'] !== '') ? '-' + fp['marker-symbol'] : '',
        color = (fp['marker-color'] || '7e7e7e').replace('#', '');

    return L.icon({
        iconUrl: format_url('/v4/marker/' +
            'pin-' + size.charAt(0) + symbol + '+' + color +
            // detect and use retina markers, which are x2 resolution
            (L.Browser.retina ? '@2x' : '') + '.png', options && options.accessToken),
        iconSize: sizes[size],
        iconAnchor: [sizes[size][0] / 2, sizes[size][1] / 2],
        popupAnchor: [0, -sizes[size][1] / 2]
    });
}

// a factory that provides markers for Leaflet from Mapbox's
// [simple-style specification](https://github.com/mapbox/simplestyle-spec)
// and [Markers API](http://mapbox.com/developers/api/#markers).
function style(f, latlon, options) {
    return L.marker(latlon, {
        icon: icon(f.properties, options),
        title: util.strip_tags(
            sanitize((f.properties && f.properties.title) || ''))
    });
}

// Sanitize and format properties of a GeoJSON Feature object in order
// to form the HTML string used as the argument for `L.createPopup`
function createPopup(f, sanitizer) {
    if (!f || !f.properties) return '';
    var popup = '';

    if (f.properties.title) {
        popup += '<div class="marker-title">' + f.properties.title + '</div>';
    }

    if (f.properties.description) {
        popup += '<div class="marker-description">' + f.properties.description + '</div>';
    }

    return (sanitizer || sanitize)(popup);
}

module.exports = {
    icon: icon,
    style: style,
    createPopup: createPopup
};

},{"./format_url":14,"./util":33,"sanitize-caja":39}],28:[function(require,module,exports){
'use strict';

var corslite = require('corslite'),
    strict = require('./util').strict,
    config = require('./config');

var protocol = /^(https?:)?(?=\/\/(.|api)\.tiles\.mapbox\.com\/)/;

module.exports = function(url, callback) {
    strict(url, 'string');
    strict(callback, 'function');

    url = url.replace(protocol, function(match, protocol) {
        if (!('withCredentials' in new window.XMLHttpRequest())) {
            // XDomainRequest in use; doesn't support cross-protocol requests
            return document.location.protocol;
        } else if (protocol === 'https:' || document.location.protocol === 'https:' || config.FORCE_HTTPS) {
            return 'https:';
        } else {
            return 'http:';
        }
    });

    function onload(err, resp) {
        if (!err && resp) {
            resp = JSON.parse(resp.responseText);
        }
        callback(err, resp);
    }

    return corslite(url, onload);
};

},{"./config":11,"./util":33,"corslite":5}],29:[function(require,module,exports){
'use strict';

var format_url = require('./format_url');

var ShareControl = L.Control.extend({
    includes: [require('./load_tilejson')],

    options: {
        position: 'topleft',
        url: ''
    },

    initialize: function(_, options) {
        L.setOptions(this, options);
        this._loadTileJSON(_);
    },

    _setTileJSON: function(json) {
        this._tilejson = json;
    },

    onAdd: function(map) {
        this._map = map;

        var container = L.DomUtil.create('div', 'leaflet-control-mapbox-share leaflet-bar');
        var link = L.DomUtil.create('a', 'mapbox-share mapbox-icon mapbox-icon-share', container);
        link.href = '#';

        this._modal = L.DomUtil.create('div', 'mapbox-modal', this._map._container);
        this._mask = L.DomUtil.create('div', 'mapbox-modal-mask', this._modal);
        this._content = L.DomUtil.create('div', 'mapbox-modal-content', this._modal);

        L.DomEvent.addListener(link, 'click', this._shareClick, this);
        L.DomEvent.disableClickPropagation(container);

        this._map.on('mousedown', this._clickOut, this);

        return container;
    },

    _clickOut: function(e) {
        if (this._sharing) {
            L.DomEvent.preventDefault(e);
            L.DomUtil.removeClass(this._modal, 'active');
            this._content.innerHTML = '';
            this._sharing = null;
            return;
        }
    },

    _shareClick: function(e) {
        L.DomEvent.stop(e);
        if (this._sharing) return this._clickOut(e);

        var tilejson = this._tilejson || this._map._tilejson || {},
            url = encodeURIComponent(this.options.url || tilejson.webpage || window.location),
            name = encodeURIComponent(tilejson.name),
            image = format_url('/v4/' + tilejson.id + '/' + this._map.getCenter().lng + ',' + this._map.getCenter().lat + ',' + this._map.getZoom() + '/600x600.png', this.options.accessToken),
            embed = format_url('/v4/' + tilejson.id + '.html', this.options.accessToken),
            twitterURL = '//twitter.com/intent/tweet?status=' + name + ' ' + url,
            facebookURL = '//www.facebook.com/sharer.php?u=' + url + '&t=' + name,
            pinterestURL = '//www.pinterest.com/pin/create/button/?url=' + url + '&media=' + image + '&description=' + name,
            embedValue = '<iframe width="100%" height="500px" frameBorder="0" src="' + embed + '"></iframe>',
            embedLabel = 'Copy and paste this <strong>HTML code</strong> into documents to embed this map on web pages.';

        function createShareButton(buttonClass, href, socialMediaName) {
            var elem = document.createElement('a');
            elem.setAttribute('class', buttonClass);
            elem.setAttribute('href', href);
            elem.setAttribute('target', '_blank');
            socialMediaName = document.createTextNode(socialMediaName);
            elem.appendChild(socialMediaName);

            return elem;
        }

        L.DomUtil.addClass(this._modal, 'active');

        this._sharing = L.DomUtil.create('div', 'mapbox-modal-body', this._content);

        var twitterButton = createShareButton('mapbox-button mapbox-button-icon mapbox-icon-twitter', twitterURL, 'Twitter');
        var facebookButton = createShareButton('mapbox-button mapbox-button-icon mapbox-icon-facebook', facebookURL, 'Facebook');
        var pinterestButton = createShareButton('mapbox-button mapbox-button-icon mapbox-icon-pinterest', pinterestURL, 'Pinterest');

        var shareHeader = document.createElement('h3');
        var shareText = document.createTextNode('Share this map');
        shareHeader.appendChild(shareText);

        var shareButtons = document.createElement('div');
        shareButtons.setAttribute('class', 'mapbox-share-buttons');
        shareButtons.appendChild(facebookButton);
        shareButtons.appendChild(twitterButton);
        shareButtons.appendChild(pinterestButton);

        this._sharing.appendChild(shareHeader);
        this._sharing.appendChild(shareButtons);

        var input = L.DomUtil.create('input', 'mapbox-embed', this._sharing);
        input.type = 'text';
        input.value = embedValue;

        var label = L.DomUtil.create('label', 'mapbox-embed-description', this._sharing);
        label.innerHTML = embedLabel;

        var close = L.DomUtil.create('a', 'leaflet-popup-close-button', this._sharing);
        close.href = '#';

        L.DomEvent.disableClickPropagation(this._sharing);
        L.DomEvent.addListener(close, 'click', this._clickOut, this);
        L.DomEvent.addListener(input, 'click', function(e) {
            e.target.focus();
            e.target.select();
        });
    }
});

module.exports.ShareControl = ShareControl;

module.exports.shareControl = function(_, options) {
    return new ShareControl(_, options);
};

},{"./format_url":14,"./load_tilejson":23}],30:[function(require,module,exports){
'use strict';

// an implementation of the simplestyle spec for polygon and linestring features
// https://github.com/mapbox/simplestyle-spec
var defaults = {
    stroke: '#555555',
    'stroke-width': 2,
    'stroke-opacity': 1,
    fill: '#555555',
    'fill-opacity': 0.5
};

var mapping = [
    ['stroke', 'color'],
    ['stroke-width', 'weight'],
    ['stroke-opacity', 'opacity'],
    ['fill', 'fillColor'],
    ['fill-opacity', 'fillOpacity']
];

function fallback(a, b) {
    var c = {};
    for (var k in b) {
        if (a[k] === undefined) c[k] = b[k];
        else c[k] = a[k];
    }
    return c;
}

function remap(a) {
    var d = {};
    for (var i = 0; i < mapping.length; i++) {
        d[mapping[i][1]] = a[mapping[i][0]];
    }
    return d;
}

function style(feature) {
    return remap(fallback(feature.properties || {}, defaults));
}

module.exports = {
    style: style,
    defaults: defaults
};

},{}],31:[function(require,module,exports){
'use strict';

var util = require('./util');
var format_url = require('./format_url');
var request = require('./request');

var StyleLayer = L.TileLayer.extend({

    options: {
        sanitizer: require('sanitize-caja')
    },

    initialize: function(_, options) {
        L.TileLayer.prototype.initialize.call(this, undefined, options);

        this.options.tiles = this._formatTileURL(_);
        this.options.tileSize = 512;
        this.options.zoomOffset = -1;
        this.options.tms = false;

        this._getAttribution(_);
    },

    _getAttribution: function(_) {
        var styleURL = format_url.style(_, this.options && this.options.accessToken);
        request(styleURL, L.bind(function(err, style) {
            if (err) {
                util.log('could not load Mapbox style at ' + styleURL);
                this.fire('error', {error: err});
            }
            var sources = [];
            for (var id in style.sources) {
                var source = style.sources[id].url.split('mapbox://')[1];
                sources.push(source);
            }
            request(format_url.tileJSON(sources.join(), this.options.accessToken), L.bind(function(err, json) {
                if (err) {
                    util.log('could not load TileJSON at ' + _);
                    this.fire('error', {error: err});
                } else if (json) {
                    util.strict(json, 'object');

                    this.options.attribution = this.options.sanitizer(json.attribution);

                    this._tilejson = json;
                    this.fire('ready');
                }
            }, this));
        }, this));
    },

    // disable the setUrl function, which is not available on mapbox tilelayers
    setUrl: null,

    _formatTileURL: function(style) {
        var retina = L.Browser.retina ? '@2x' : '';
        if (typeof style === 'string') {
            if (style.indexOf('mapbox://styles/') === -1) {
                util.log('Incorrectly formatted Mapbox style at ' + style);
                this.fire('error');
            }
            var ownerIDStyle = style.split('mapbox://styles/')[1];
            return format_url('/styles/v1/' + ownerIDStyle + '/tiles/{z}/{x}/{y}' + retina, this.options.accessToken);
        } else if (typeof style === 'object') {
            return format_url('/styles/v1/' + style.owner + '/' + style.id + '/tiles/{z}/{x}/{y}' + retina, this.options.accessToken);
        }
    },

    // this is an exception to mapbox.js naming rules because it's called
    // by `L.map`
    getTileUrl: function(tilePoint) {
        var templated = L.Util.template(this.options.tiles, tilePoint);
        return templated;
    }
});

module.exports.StyleLayer = StyleLayer;

module.exports.styleLayer = function(_, options) {
    return new StyleLayer(_, options);
};

},{"./format_url":14,"./request":28,"./util":33,"sanitize-caja":39}],32:[function(require,module,exports){
'use strict';

var util = require('./util');
var formatPattern = /\.((?:png|jpg)\d*)(?=$|\?)/;

var TileLayer = L.TileLayer.extend({
    includes: [require('./load_tilejson')],

    options: {
        sanitizer: require('sanitize-caja')
    },

    // http://mapbox.com/developers/api/#image_quality
    formats: [
        'png', 'jpg',
        // PNG
        'png32', 'png64', 'png128', 'png256',
        // JPG
        'jpg70', 'jpg80', 'jpg90'],

    scalePrefix: '@2x.',

    initialize: function(_, options) {
        L.TileLayer.prototype.initialize.call(this, undefined, options);

        this._tilejson = {};

        if (options && options.format) {
            util.strict_oneof(options.format, this.formats);
        }

        this._loadTileJSON(_);
    },

    setFormat: function(_) {
        util.strict(_, 'string');
        this.options.format = _;
        this.redraw();
        return this;
    },

    // disable the setUrl function, which is not available on mapbox tilelayers
    setUrl: null,

    _setTileJSON: function(json) {
        util.strict(json, 'object');

        this.options.format = this.options.format ||
            json.tiles[0].match(formatPattern)[1];

        L.extend(this.options, {
            tiles: json.tiles,
            attribution: this.options.sanitizer(json.attribution),
            minZoom: json.minzoom || 0,
            maxZoom: json.maxzoom || 18,
            tms: json.scheme === 'tms',
            bounds: json.bounds && util.lbounds(json.bounds)
        });

        this._tilejson = json;
        this.redraw();
        return this;
    },

    getTileJSON: function() {
        return this._tilejson;
    },

    // this is an exception to mapbox.js naming rules because it's called
    // by `L.map`
    getTileUrl: function(tilePoint) {
        var tiles = this.options.tiles,
            index = Math.floor(Math.abs(tilePoint.x + tilePoint.y) % tiles.length),
            url = tiles[index];

        var templated = L.Util.template(url, tilePoint);
        if (!templated) {
            return templated;
        } else {
            return templated.replace(formatPattern,
                (L.Browser.retina ? this.scalePrefix : '.') + this.options.format);
        }
    },

    // TileJSON.TileLayers are added to the map immediately, so that they get
    // the desired z-index, but do not update until the TileJSON has been loaded.
    _update: function() {
        if (this.options.tiles) {
            L.TileLayer.prototype._update.call(this);
        }
    }
});

module.exports.TileLayer = TileLayer;

module.exports.tileLayer = function(_, options) {
    return new TileLayer(_, options);
};

},{"./load_tilejson":23,"./util":33,"sanitize-caja":39}],33:[function(require,module,exports){
'use strict';

function contains(item, list) {
    if (!list || !list.length) return false;
    for (var i = 0; i < list.length; i++) {
        if (list[i] === item) return true;
    }
    return false;
}

module.exports = {
    idUrl: function(_, t) {
        if (_.indexOf('/') === -1) t.loadID(_);
        else t.loadURL(_);
    },
    log: function(_) {
        if (typeof console === 'object' &&
            typeof console.error === 'function') {
            console.error(_);
        }
    },
    strict: function(_, type) {
        if (typeof _ !== type) {
            throw new Error('Invalid argument: ' + type + ' expected');
        }
    },
    strict_instance: function(_, klass, name) {
        if (!(_ instanceof klass)) {
            throw new Error('Invalid argument: ' + name + ' expected');
        }
    },
    strict_oneof: function(_, values) {
        if (!contains(_, values)) {
            throw new Error('Invalid argument: ' + _ + ' given, valid values are ' +
                values.join(', '));
        }
    },
    strip_tags: function(_) {
        return _.replace(/<[^<]+>/g, '');
    },
    lbounds: function(_) {
        // leaflet-compatible bounds, since leaflet does not do geojson
        return new L.LatLngBounds([[_[1], _[0]], [_[3], _[2]]]);
    }
};

},{}],34:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(global.Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.2.1';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],35:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],37:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],38:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":36,"./encode":37}],39:[function(require,module,exports){
var html_sanitize = require('./sanitizer-bundle.js');

module.exports = function(_) {
    if (!_) return '';
    return html_sanitize(_, cleanUrl, cleanId);
};

// https://bugzilla.mozilla.org/show_bug.cgi?id=255107
function cleanUrl(url) {
    'use strict';
    if (/^https?/.test(url.getScheme())) return url.toString();
    if (/^mailto?/.test(url.getScheme())) return url.toString();
    if ('data' == url.getScheme() && /^image/.test(url.getPath())) {
        return url.toString();
    }
}

function cleanId(id) { return id; }

},{"./sanitizer-bundle.js":40}],40:[function(require,module,exports){

// Copyright (C) 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview
 * Implements RFC 3986 for parsing/formatting URIs.
 *
 * @author mikesamuel@gmail.com
 * \@provides URI
 * \@overrides window
 */

var URI = (function () {

/**
 * creates a uri from the string form.  The parser is relaxed, so special
 * characters that aren't escaped but don't cause ambiguities will not cause
 * parse failures.
 *
 * @return {URI|null}
 */
function parse(uriStr) {
  var m = ('' + uriStr).match(URI_RE_);
  if (!m) { return null; }
  return new URI(
      nullIfAbsent(m[1]),
      nullIfAbsent(m[2]),
      nullIfAbsent(m[3]),
      nullIfAbsent(m[4]),
      nullIfAbsent(m[5]),
      nullIfAbsent(m[6]),
      nullIfAbsent(m[7]));
}


/**
 * creates a uri from the given parts.
 *
 * @param scheme {string} an unencoded scheme such as "http" or null
 * @param credentials {string} unencoded user credentials or null
 * @param domain {string} an unencoded domain name or null
 * @param port {number} a port number in [1, 32768].
 *    -1 indicates no port, as does null.
 * @param path {string} an unencoded path
 * @param query {Array.<string>|string|null} a list of unencoded cgi
 *   parameters where even values are keys and odds the corresponding values
 *   or an unencoded query.
 * @param fragment {string} an unencoded fragment without the "#" or null.
 * @return {URI}
 */
function create(scheme, credentials, domain, port, path, query, fragment) {
  var uri = new URI(
      encodeIfExists2(scheme, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),
      encodeIfExists2(
          credentials, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),
      encodeIfExists(domain),
      port > 0 ? port.toString() : null,
      encodeIfExists2(path, URI_DISALLOWED_IN_PATH_),
      null,
      encodeIfExists(fragment));
  if (query) {
    if ('string' === typeof query) {
      uri.setRawQuery(query.replace(/[^?&=0-9A-Za-z_\-~.%]/g, encodeOne));
    } else {
      uri.setAllParameters(query);
    }
  }
  return uri;
}
function encodeIfExists(unescapedPart) {
  if ('string' == typeof unescapedPart) {
    return encodeURIComponent(unescapedPart);
  }
  return null;
};
/**
 * if unescapedPart is non null, then escapes any characters in it that aren't
 * valid characters in a url and also escapes any special characters that
 * appear in extra.
 *
 * @param unescapedPart {string}
 * @param extra {RegExp} a character set of characters in [\01-\177].
 * @return {string|null} null iff unescapedPart == null.
 */
function encodeIfExists2(unescapedPart, extra) {
  if ('string' == typeof unescapedPart) {
    return encodeURI(unescapedPart).replace(extra, encodeOne);
  }
  return null;
};
/** converts a character in [\01-\177] to its url encoded equivalent. */
function encodeOne(ch) {
  var n = ch.charCodeAt(0);
  return '%' + '0123456789ABCDEF'.charAt((n >> 4) & 0xf) +
      '0123456789ABCDEF'.charAt(n & 0xf);
}

/**
 * {@updoc
 *  $ normPath('foo/./bar')
 *  # 'foo/bar'
 *  $ normPath('./foo')
 *  # 'foo'
 *  $ normPath('foo/.')
 *  # 'foo'
 *  $ normPath('foo//bar')
 *  # 'foo/bar'
 * }
 */
function normPath(path) {
  return path.replace(/(^|\/)\.(?:\/|$)/g, '$1').replace(/\/{2,}/g, '/');
}

var PARENT_DIRECTORY_HANDLER = new RegExp(
    ''
    // A path break
    + '(/|^)'
    // followed by a non .. path element
    // (cannot be . because normPath is used prior to this RegExp)
    + '(?:[^./][^/]*|\\.{2,}(?:[^./][^/]*)|\\.{3,}[^/]*)'
    // followed by .. followed by a path break.
    + '/\\.\\.(?:/|$)');

var PARENT_DIRECTORY_HANDLER_RE = new RegExp(PARENT_DIRECTORY_HANDLER);

var EXTRA_PARENT_PATHS_RE = /^(?:\.\.\/)*(?:\.\.$)?/;

/**
 * Normalizes its input path and collapses all . and .. sequences except for
 * .. sequences that would take it above the root of the current parent
 * directory.
 * {@updoc
 *  $ collapse_dots('foo/../bar')
 *  # 'bar'
 *  $ collapse_dots('foo/./bar')
 *  # 'foo/bar'
 *  $ collapse_dots('foo/../bar/./../../baz')
 *  # 'baz'
 *  $ collapse_dots('../foo')
 *  # '../foo'
 *  $ collapse_dots('../foo').replace(EXTRA_PARENT_PATHS_RE, '')
 *  # 'foo'
 * }
 */
function collapse_dots(path) {
  if (path === null) { return null; }
  var p = normPath(path);
  // Only /../ left to flatten
  var r = PARENT_DIRECTORY_HANDLER_RE;
  // We replace with $1 which matches a / before the .. because this
  // guarantees that:
  // (1) we have at most 1 / between the adjacent place,
  // (2) always have a slash if there is a preceding path section, and
  // (3) we never turn a relative path into an absolute path.
  for (var q; (q = p.replace(r, '$1')) != p; p = q) {};
  return p;
}

/**
 * resolves a relative url string to a base uri.
 * @return {URI}
 */
function resolve(baseUri, relativeUri) {
  // there are several kinds of relative urls:
  // 1. //foo - replaces everything from the domain on.  foo is a domain name
  // 2. foo - replaces the last part of the path, the whole query and fragment
  // 3. /foo - replaces the the path, the query and fragment
  // 4. ?foo - replace the query and fragment
  // 5. #foo - replace the fragment only

  var absoluteUri = baseUri.clone();
  // we satisfy these conditions by looking for the first part of relativeUri
  // that is not blank and applying defaults to the rest

  var overridden = relativeUri.hasScheme();

  if (overridden) {
    absoluteUri.setRawScheme(relativeUri.getRawScheme());
  } else {
    overridden = relativeUri.hasCredentials();
  }

  if (overridden) {
    absoluteUri.setRawCredentials(relativeUri.getRawCredentials());
  } else {
    overridden = relativeUri.hasDomain();
  }

  if (overridden) {
    absoluteUri.setRawDomain(relativeUri.getRawDomain());
  } else {
    overridden = relativeUri.hasPort();
  }

  var rawPath = relativeUri.getRawPath();
  var simplifiedPath = collapse_dots(rawPath);
  if (overridden) {
    absoluteUri.setPort(relativeUri.getPort());
    simplifiedPath = simplifiedPath
        && simplifiedPath.replace(EXTRA_PARENT_PATHS_RE, '');
  } else {
    overridden = !!rawPath;
    if (overridden) {
      // resolve path properly
      if (simplifiedPath.charCodeAt(0) !== 0x2f /* / */) {  // path is relative
        var absRawPath = collapse_dots(absoluteUri.getRawPath() || '')
            .replace(EXTRA_PARENT_PATHS_RE, '');
        var slash = absRawPath.lastIndexOf('/') + 1;
        simplifiedPath = collapse_dots(
            (slash ? absRawPath.substring(0, slash) : '')
            + collapse_dots(rawPath))
            .replace(EXTRA_PARENT_PATHS_RE, '');
      }
    } else {
      simplifiedPath = simplifiedPath
          && simplifiedPath.replace(EXTRA_PARENT_PATHS_RE, '');
      if (simplifiedPath !== rawPath) {
        absoluteUri.setRawPath(simplifiedPath);
      }
    }
  }

  if (overridden) {
    absoluteUri.setRawPath(simplifiedPath);
  } else {
    overridden = relativeUri.hasQuery();
  }

  if (overridden) {
    absoluteUri.setRawQuery(relativeUri.getRawQuery());
  } else {
    overridden = relativeUri.hasFragment();
  }

  if (overridden) {
    absoluteUri.setRawFragment(relativeUri.getRawFragment());
  }

  return absoluteUri;
}

/**
 * a mutable URI.
 *
 * This class contains setters and getters for the parts of the URI.
 * The <tt>getXYZ</tt>/<tt>setXYZ</tt> methods return the decoded part -- so
 * <code>uri.parse('/foo%20bar').getPath()</code> will return the decoded path,
 * <tt>/foo bar</tt>.
 *
 * <p>The raw versions of fields are available too.
 * <code>uri.parse('/foo%20bar').getRawPath()</code> will return the raw path,
 * <tt>/foo%20bar</tt>.  Use the raw setters with care, since
 * <code>URI::toString</code> is not guaranteed to return a valid url if a
 * raw setter was used.
 *
 * <p>All setters return <tt>this</tt> and so may be chained, a la
 * <code>uri.parse('/foo').setFragment('part').toString()</code>.
 *
 * <p>You should not use this constructor directly -- please prefer the factory
 * functions {@link uri.parse}, {@link uri.create}, {@link uri.resolve}
 * instead.</p>
 *
 * <p>The parameters are all raw (assumed to be properly escaped) parts, and
 * any (but not all) may be null.  Undefined is not allowed.</p>
 *
 * @constructor
 */
function URI(
    rawScheme,
    rawCredentials, rawDomain, port,
    rawPath, rawQuery, rawFragment) {
  this.scheme_ = rawScheme;
  this.credentials_ = rawCredentials;
  this.domain_ = rawDomain;
  this.port_ = port;
  this.path_ = rawPath;
  this.query_ = rawQuery;
  this.fragment_ = rawFragment;
  /**
   * @type {Array|null}
   */
  this.paramCache_ = null;
}

/** returns the string form of the url. */
URI.prototype.toString = function () {
  var out = [];
  if (null !== this.scheme_) { out.push(this.scheme_, ':'); }
  if (null !== this.domain_) {
    out.push('//');
    if (null !== this.credentials_) { out.push(this.credentials_, '@'); }
    out.push(this.domain_);
    if (null !== this.port_) { out.push(':', this.port_.toString()); }
  }
  if (null !== this.path_) { out.push(this.path_); }
  if (null !== this.query_) { out.push('?', this.query_); }
  if (null !== this.fragment_) { out.push('#', this.fragment_); }
  return out.join('');
};

URI.prototype.clone = function () {
  return new URI(this.scheme_, this.credentials_, this.domain_, this.port_,
                 this.path_, this.query_, this.fragment_);
};

URI.prototype.getScheme = function () {
  // HTML5 spec does not require the scheme to be lowercased but
  // all common browsers except Safari lowercase the scheme.
  return this.scheme_ && decodeURIComponent(this.scheme_).toLowerCase();
};
URI.prototype.getRawScheme = function () {
  return this.scheme_;
};
URI.prototype.setScheme = function (newScheme) {
  this.scheme_ = encodeIfExists2(
      newScheme, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);
  return this;
};
URI.prototype.setRawScheme = function (newScheme) {
  this.scheme_ = newScheme ? newScheme : null;
  return this;
};
URI.prototype.hasScheme = function () {
  return null !== this.scheme_;
};


URI.prototype.getCredentials = function () {
  return this.credentials_ && decodeURIComponent(this.credentials_);
};
URI.prototype.getRawCredentials = function () {
  return this.credentials_;
};
URI.prototype.setCredentials = function (newCredentials) {
  this.credentials_ = encodeIfExists2(
      newCredentials, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);

  return this;
};
URI.prototype.setRawCredentials = function (newCredentials) {
  this.credentials_ = newCredentials ? newCredentials : null;
  return this;
};
URI.prototype.hasCredentials = function () {
  return null !== this.credentials_;
};


URI.prototype.getDomain = function () {
  return this.domain_ && decodeURIComponent(this.domain_);
};
URI.prototype.getRawDomain = function () {
  return this.domain_;
};
URI.prototype.setDomain = function (newDomain) {
  return this.setRawDomain(newDomain && encodeURIComponent(newDomain));
};
URI.prototype.setRawDomain = function (newDomain) {
  this.domain_ = newDomain ? newDomain : null;
  // Maintain the invariant that paths must start with a slash when the URI
  // is not path-relative.
  return this.setRawPath(this.path_);
};
URI.prototype.hasDomain = function () {
  return null !== this.domain_;
};


URI.prototype.getPort = function () {
  return this.port_ && decodeURIComponent(this.port_);
};
URI.prototype.setPort = function (newPort) {
  if (newPort) {
    newPort = Number(newPort);
    if (newPort !== (newPort & 0xffff)) {
      throw new Error('Bad port number ' + newPort);
    }
    this.port_ = '' + newPort;
  } else {
    this.port_ = null;
  }
  return this;
};
URI.prototype.hasPort = function () {
  return null !== this.port_;
};


URI.prototype.getPath = function () {
  return this.path_ && decodeURIComponent(this.path_);
};
URI.prototype.getRawPath = function () {
  return this.path_;
};
URI.prototype.setPath = function (newPath) {
  return this.setRawPath(encodeIfExists2(newPath, URI_DISALLOWED_IN_PATH_));
};
URI.prototype.setRawPath = function (newPath) {
  if (newPath) {
    newPath = String(newPath);
    this.path_ = 
      // Paths must start with '/' unless this is a path-relative URL.
      (!this.domain_ || /^\//.test(newPath)) ? newPath : '/' + newPath;
  } else {
    this.path_ = null;
  }
  return this;
};
URI.prototype.hasPath = function () {
  return null !== this.path_;
};


URI.prototype.getQuery = function () {
  // From http://www.w3.org/Addressing/URL/4_URI_Recommentations.html
  // Within the query string, the plus sign is reserved as shorthand notation
  // for a space.
  return this.query_ && decodeURIComponent(this.query_).replace(/\+/g, ' ');
};
URI.prototype.getRawQuery = function () {
  return this.query_;
};
URI.prototype.setQuery = function (newQuery) {
  this.paramCache_ = null;
  this.query_ = encodeIfExists(newQuery);
  return this;
};
URI.prototype.setRawQuery = function (newQuery) {
  this.paramCache_ = null;
  this.query_ = newQuery ? newQuery : null;
  return this;
};
URI.prototype.hasQuery = function () {
  return null !== this.query_;
};

/**
 * sets the query given a list of strings of the form
 * [ key0, value0, key1, value1, ... ].
 *
 * <p><code>uri.setAllParameters(['a', 'b', 'c', 'd']).getQuery()</code>
 * will yield <code>'a=b&c=d'</code>.
 */
URI.prototype.setAllParameters = function (params) {
  if (typeof params === 'object') {
    if (!(params instanceof Array)
        && (params instanceof Object
            || Object.prototype.toString.call(params) !== '[object Array]')) {
      var newParams = [];
      var i = -1;
      for (var k in params) {
        var v = params[k];
        if ('string' === typeof v) {
          newParams[++i] = k;
          newParams[++i] = v;
        }
      }
      params = newParams;
    }
  }
  this.paramCache_ = null;
  var queryBuf = [];
  var separator = '';
  for (var j = 0; j < params.length;) {
    var k = params[j++];
    var v = params[j++];
    queryBuf.push(separator, encodeURIComponent(k.toString()));
    separator = '&';
    if (v) {
      queryBuf.push('=', encodeURIComponent(v.toString()));
    }
  }
  this.query_ = queryBuf.join('');
  return this;
};
URI.prototype.checkParameterCache_ = function () {
  if (!this.paramCache_) {
    var q = this.query_;
    if (!q) {
      this.paramCache_ = [];
    } else {
      var cgiParams = q.split(/[&\?]/);
      var out = [];
      var k = -1;
      for (var i = 0; i < cgiParams.length; ++i) {
        var m = cgiParams[i].match(/^([^=]*)(?:=(.*))?$/);
        // From http://www.w3.org/Addressing/URL/4_URI_Recommentations.html
        // Within the query string, the plus sign is reserved as shorthand
        // notation for a space.
        out[++k] = decodeURIComponent(m[1]).replace(/\+/g, ' ');
        out[++k] = decodeURIComponent(m[2] || '').replace(/\+/g, ' ');
      }
      this.paramCache_ = out;
    }
  }
};
/**
 * sets the values of the named cgi parameters.
 *
 * <p>So, <code>uri.parse('foo?a=b&c=d&e=f').setParameterValues('c', ['new'])
 * </code> yields <tt>foo?a=b&c=new&e=f</tt>.</p>
 *
 * @param key {string}
 * @param values {Array.<string>} the new values.  If values is a single string
 *   then it will be treated as the sole value.
 */
URI.prototype.setParameterValues = function (key, values) {
  // be nice and avoid subtle bugs where [] operator on string performs charAt
  // on some browsers and crashes on IE
  if (typeof values === 'string') {
    values = [ values ];
  }

  this.checkParameterCache_();
  var newValueIndex = 0;
  var pc = this.paramCache_;
  var params = [];
  for (var i = 0, k = 0; i < pc.length; i += 2) {
    if (key === pc[i]) {
      if (newValueIndex < values.length) {
        params.push(key, values[newValueIndex++]);
      }
    } else {
      params.push(pc[i], pc[i + 1]);
    }
  }
  while (newValueIndex < values.length) {
    params.push(key, values[newValueIndex++]);
  }
  this.setAllParameters(params);
  return this;
};
URI.prototype.removeParameter = function (key) {
  return this.setParameterValues(key, []);
};
/**
 * returns the parameters specified in the query part of the uri as a list of
 * keys and values like [ key0, value0, key1, value1, ... ].
 *
 * @return {Array.<string>}
 */
URI.prototype.getAllParameters = function () {
  this.checkParameterCache_();
  return this.paramCache_.slice(0, this.paramCache_.length);
};
/**
 * returns the value<b>s</b> for a given cgi parameter as a list of decoded
 * query parameter values.
 * @return {Array.<string>}
 */
URI.prototype.getParameterValues = function (paramNameUnescaped) {
  this.checkParameterCache_();
  var values = [];
  for (var i = 0; i < this.paramCache_.length; i += 2) {
    if (paramNameUnescaped === this.paramCache_[i]) {
      values.push(this.paramCache_[i + 1]);
    }
  }
  return values;
};
/**
 * returns a map of cgi parameter names to (non-empty) lists of values.
 * @return {Object.<string,Array.<string>>}
 */
URI.prototype.getParameterMap = function (paramNameUnescaped) {
  this.checkParameterCache_();
  var paramMap = {};
  for (var i = 0; i < this.paramCache_.length; i += 2) {
    var key = this.paramCache_[i++],
      value = this.paramCache_[i++];
    if (!(key in paramMap)) {
      paramMap[key] = [value];
    } else {
      paramMap[key].push(value);
    }
  }
  return paramMap;
};
/**
 * returns the first value for a given cgi parameter or null if the given
 * parameter name does not appear in the query string.
 * If the given parameter name does appear, but has no '<tt>=</tt>' following
 * it, then the empty string will be returned.
 * @return {string|null}
 */
URI.prototype.getParameterValue = function (paramNameUnescaped) {
  this.checkParameterCache_();
  for (var i = 0; i < this.paramCache_.length; i += 2) {
    if (paramNameUnescaped === this.paramCache_[i]) {
      return this.paramCache_[i + 1];
    }
  }
  return null;
};

URI.prototype.getFragment = function () {
  return this.fragment_ && decodeURIComponent(this.fragment_);
};
URI.prototype.getRawFragment = function () {
  return this.fragment_;
};
URI.prototype.setFragment = function (newFragment) {
  this.fragment_ = newFragment ? encodeURIComponent(newFragment) : null;
  return this;
};
URI.prototype.setRawFragment = function (newFragment) {
  this.fragment_ = newFragment ? newFragment : null;
  return this;
};
URI.prototype.hasFragment = function () {
  return null !== this.fragment_;
};

function nullIfAbsent(matchPart) {
  return ('string' == typeof matchPart) && (matchPart.length > 0)
         ? matchPart
         : null;
}




/**
 * a regular expression for breaking a URI into its component parts.
 *
 * <p>http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234 says
 * As the "first-match-wins" algorithm is identical to the "greedy"
 * disambiguation method used by POSIX regular expressions, it is natural and
 * commonplace to use a regular expression for parsing the potential five
 * components of a URI reference.
 *
 * <p>The following line is the regular expression for breaking-down a
 * well-formed URI reference into its components.
 *
 * <pre>
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 * </pre>
 *
 * <p>The numbers in the second line above are only to assist readability; they
 * indicate the reference points for each subexpression (i.e., each paired
 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
 * For example, matching the above expression to
 * <pre>
 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
 * </pre>
 * results in the following subexpression matches:
 * <pre>
 *    $1 = http:
 *    $2 = http
 *    $3 = //www.ics.uci.edu
 *    $4 = www.ics.uci.edu
 *    $5 = /pub/ietf/uri/
 *    $6 = <undefined>
 *    $7 = <undefined>
 *    $8 = #Related
 *    $9 = Related
 * </pre>
 * where <undefined> indicates that the component is not present, as is the
 * case for the query component in the above example. Therefore, we can
 * determine the value of the five components as
 * <pre>
 *    scheme    = $2
 *    authority = $4
 *    path      = $5
 *    query     = $7
 *    fragment  = $9
 * </pre>
 *
 * <p>msamuel: I have modified the regular expression slightly to expose the
 * credentials, domain, and port separately from the authority.
 * The modified version yields
 * <pre>
 *    $1 = http              scheme
 *    $2 = <undefined>       credentials -\
 *    $3 = www.ics.uci.edu   domain       | authority
 *    $4 = <undefined>       port        -/
 *    $5 = /pub/ietf/uri/    path
 *    $6 = <undefined>       query without ?
 *    $7 = Related           fragment without #
 * </pre>
 */
var URI_RE_ = new RegExp(
      "^" +
      "(?:" +
        "([^:/?#]+)" +         // scheme
      ":)?" +
      "(?://" +
        "(?:([^/?#]*)@)?" +    // credentials
        "([^/?#:@]*)" +        // domain
        "(?::([0-9]+))?" +     // port
      ")?" +
      "([^?#]+)?" +            // path
      "(?:\\?([^#]*))?" +      // query
      "(?:#(.*))?" +           // fragment
      "$"
      );

var URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_ = /[#\/\?@]/g;
var URI_DISALLOWED_IN_PATH_ = /[\#\?]/g;

URI.parse = parse;
URI.create = create;
URI.resolve = resolve;
URI.collapse_dots = collapse_dots;  // Visible for testing.

// lightweight string-based api for loadModuleMaker
URI.utils = {
  mimeTypeOf: function (uri) {
    var uriObj = parse(uri);
    if (/\.html$/.test(uriObj.getPath())) {
      return 'text/html';
    } else {
      return 'application/javascript';
    }
  },
  resolve: function (base, uri) {
    if (base) {
      return resolve(parse(base), parse(uri)).toString();
    } else {
      return '' + uri;
    }
  }
};


return URI;
})();

// Copyright Google Inc.
// Licensed under the Apache Licence Version 2.0
// Autogenerated at Mon Feb 25 13:05:42 EST 2013
// @overrides window
// @provides html4
var html4 = {};
html4.atype = {
  'NONE': 0,
  'URI': 1,
  'URI_FRAGMENT': 11,
  'SCRIPT': 2,
  'STYLE': 3,
  'HTML': 12,
  'ID': 4,
  'IDREF': 5,
  'IDREFS': 6,
  'GLOBAL_NAME': 7,
  'LOCAL_NAME': 8,
  'CLASSES': 9,
  'FRAME_TARGET': 10,
  'MEDIA_QUERY': 13
};
html4[ 'atype' ] = html4.atype;
html4.ATTRIBS = {
  '*::class': 9,
  '*::dir': 0,
  '*::draggable': 0,
  '*::hidden': 0,
  '*::id': 4,
  '*::inert': 0,
  '*::itemprop': 0,
  '*::itemref': 6,
  '*::itemscope': 0,
  '*::lang': 0,
  '*::onblur': 2,
  '*::onchange': 2,
  '*::onclick': 2,
  '*::ondblclick': 2,
  '*::onfocus': 2,
  '*::onkeydown': 2,
  '*::onkeypress': 2,
  '*::onkeyup': 2,
  '*::onload': 2,
  '*::onmousedown': 2,
  '*::onmousemove': 2,
  '*::onmouseout': 2,
  '*::onmouseover': 2,
  '*::onmouseup': 2,
  '*::onreset': 2,
  '*::onscroll': 2,
  '*::onselect': 2,
  '*::onsubmit': 2,
  '*::onunload': 2,
  '*::spellcheck': 0,
  '*::style': 3,
  '*::title': 0,
  '*::translate': 0,
  'a::accesskey': 0,
  'a::coords': 0,
  'a::href': 1,
  'a::hreflang': 0,
  'a::name': 7,
  'a::onblur': 2,
  'a::onfocus': 2,
  'a::shape': 0,
  'a::tabindex': 0,
  'a::target': 10,
  'a::type': 0,
  'area::accesskey': 0,
  'area::alt': 0,
  'area::coords': 0,
  'area::href': 1,
  'area::nohref': 0,
  'area::onblur': 2,
  'area::onfocus': 2,
  'area::shape': 0,
  'area::tabindex': 0,
  'area::target': 10,
  'audio::controls': 0,
  'audio::loop': 0,
  'audio::mediagroup': 5,
  'audio::muted': 0,
  'audio::preload': 0,
  'bdo::dir': 0,
  'blockquote::cite': 1,
  'br::clear': 0,
  'button::accesskey': 0,
  'button::disabled': 0,
  'button::name': 8,
  'button::onblur': 2,
  'button::onfocus': 2,
  'button::tabindex': 0,
  'button::type': 0,
  'button::value': 0,
  'canvas::height': 0,
  'canvas::width': 0,
  'caption::align': 0,
  'col::align': 0,
  'col::char': 0,
  'col::charoff': 0,
  'col::span': 0,
  'col::valign': 0,
  'col::width': 0,
  'colgroup::align': 0,
  'colgroup::char': 0,
  'colgroup::charoff': 0,
  'colgroup::span': 0,
  'colgroup::valign': 0,
  'colgroup::width': 0,
  'command::checked': 0,
  'command::command': 5,
  'command::disabled': 0,
  'command::icon': 1,
  'command::label': 0,
  'command::radiogroup': 0,
  'command::type': 0,
  'data::value': 0,
  'del::cite': 1,
  'del::datetime': 0,
  'details::open': 0,
  'dir::compact': 0,
  'div::align': 0,
  'dl::compact': 0,
  'fieldset::disabled': 0,
  'font::color': 0,
  'font::face': 0,
  'font::size': 0,
  'form::accept': 0,
  'form::action': 1,
  'form::autocomplete': 0,
  'form::enctype': 0,
  'form::method': 0,
  'form::name': 7,
  'form::novalidate': 0,
  'form::onreset': 2,
  'form::onsubmit': 2,
  'form::target': 10,
  'h1::align': 0,
  'h2::align': 0,
  'h3::align': 0,
  'h4::align': 0,
  'h5::align': 0,
  'h6::align': 0,
  'hr::align': 0,
  'hr::noshade': 0,
  'hr::size': 0,
  'hr::width': 0,
  'iframe::align': 0,
  'iframe::frameborder': 0,
  'iframe::height': 0,
  'iframe::marginheight': 0,
  'iframe::marginwidth': 0,
  'iframe::width': 0,
  'img::align': 0,
  'img::alt': 0,
  'img::border': 0,
  'img::height': 0,
  'img::hspace': 0,
  'img::ismap': 0,
  'img::name': 7,
  'img::src': 1,
  'img::usemap': 11,
  'img::vspace': 0,
  'img::width': 0,
  'input::accept': 0,
  'input::accesskey': 0,
  'input::align': 0,
  'input::alt': 0,
  'input::autocomplete': 0,
  'input::checked': 0,
  'input::disabled': 0,
  'input::inputmode': 0,
  'input::ismap': 0,
  'input::list': 5,
  'input::max': 0,
  'input::maxlength': 0,
  'input::min': 0,
  'input::multiple': 0,
  'input::name': 8,
  'input::onblur': 2,
  'input::onchange': 2,
  'input::onfocus': 2,
  'input::onselect': 2,
  'input::placeholder': 0,
  'input::readonly': 0,
  'input::required': 0,
  'input::size': 0,
  'input::src': 1,
  'input::step': 0,
  'input::tabindex': 0,
  'input::type': 0,
  'input::usemap': 11,
  'input::value': 0,
  'ins::cite': 1,
  'ins::datetime': 0,
  'label::accesskey': 0,
  'label::for': 5,
  'label::onblur': 2,
  'label::onfocus': 2,
  'legend::accesskey': 0,
  'legend::align': 0,
  'li::type': 0,
  'li::value': 0,
  'map::name': 7,
  'menu::compact': 0,
  'menu::label': 0,
  'menu::type': 0,
  'meter::high': 0,
  'meter::low': 0,
  'meter::max': 0,
  'meter::min': 0,
  'meter::value': 0,
  'ol::compact': 0,
  'ol::reversed': 0,
  'ol::start': 0,
  'ol::type': 0,
  'optgroup::disabled': 0,
  'optgroup::label': 0,
  'option::disabled': 0,
  'option::label': 0,
  'option::selected': 0,
  'option::value': 0,
  'output::for': 6,
  'output::name': 8,
  'p::align': 0,
  'pre::width': 0,
  'progress::max': 0,
  'progress::min': 0,
  'progress::value': 0,
  'q::cite': 1,
  'select::autocomplete': 0,
  'select::disabled': 0,
  'select::multiple': 0,
  'select::name': 8,
  'select::onblur': 2,
  'select::onchange': 2,
  'select::onfocus': 2,
  'select::required': 0,
  'select::size': 0,
  'select::tabindex': 0,
  'source::type': 0,
  'table::align': 0,
  'table::bgcolor': 0,
  'table::border': 0,
  'table::cellpadding': 0,
  'table::cellspacing': 0,
  'table::frame': 0,
  'table::rules': 0,
  'table::summary': 0,
  'table::width': 0,
  'tbody::align': 0,
  'tbody::char': 0,
  'tbody::charoff': 0,
  'tbody::valign': 0,
  'td::abbr': 0,
  'td::align': 0,
  'td::axis': 0,
  'td::bgcolor': 0,
  'td::char': 0,
  'td::charoff': 0,
  'td::colspan': 0,
  'td::headers': 6,
  'td::height': 0,
  'td::nowrap': 0,
  'td::rowspan': 0,
  'td::scope': 0,
  'td::valign': 0,
  'td::width': 0,
  'textarea::accesskey': 0,
  'textarea::autocomplete': 0,
  'textarea::cols': 0,
  'textarea::disabled': 0,
  'textarea::inputmode': 0,
  'textarea::name': 8,
  'textarea::onblur': 2,
  'textarea::onchange': 2,
  'textarea::onfocus': 2,
  'textarea::onselect': 2,
  'textarea::placeholder': 0,
  'textarea::readonly': 0,
  'textarea::required': 0,
  'textarea::rows': 0,
  'textarea::tabindex': 0,
  'textarea::wrap': 0,
  'tfoot::align': 0,
  'tfoot::char': 0,
  'tfoot::charoff': 0,
  'tfoot::valign': 0,
  'th::abbr': 0,
  'th::align': 0,
  'th::axis': 0,
  'th::bgcolor': 0,
  'th::char': 0,
  'th::charoff': 0,
  'th::colspan': 0,
  'th::headers': 6,
  'th::height': 0,
  'th::nowrap': 0,
  'th::rowspan': 0,
  'th::scope': 0,
  'th::valign': 0,
  'th::width': 0,
  'thead::align': 0,
  'thead::char': 0,
  'thead::charoff': 0,
  'thead::valign': 0,
  'tr::align': 0,
  'tr::bgcolor': 0,
  'tr::char': 0,
  'tr::charoff': 0,
  'tr::valign': 0,
  'track::default': 0,
  'track::kind': 0,
  'track::label': 0,
  'track::srclang': 0,
  'ul::compact': 0,
  'ul::type': 0,
  'video::controls': 0,
  'video::height': 0,
  'video::loop': 0,
  'video::mediagroup': 5,
  'video::muted': 0,
  'video::poster': 1,
  'video::preload': 0,
  'video::width': 0
};
html4[ 'ATTRIBS' ] = html4.ATTRIBS;
html4.eflags = {
  'OPTIONAL_ENDTAG': 1,
  'EMPTY': 2,
  'CDATA': 4,
  'RCDATA': 8,
  'UNSAFE': 16,
  'FOLDABLE': 32,
  'SCRIPT': 64,
  'STYLE': 128,
  'VIRTUALIZED': 256
};
html4[ 'eflags' ] = html4.eflags;
// these are bitmasks of the eflags above.
html4.ELEMENTS = {
  'a': 0,
  'abbr': 0,
  'acronym': 0,
  'address': 0,
  'applet': 272,
  'area': 2,
  'article': 0,
  'aside': 0,
  'audio': 0,
  'b': 0,
  'base': 274,
  'basefont': 274,
  'bdi': 0,
  'bdo': 0,
  'big': 0,
  'blockquote': 0,
  'body': 305,
  'br': 2,
  'button': 0,
  'canvas': 0,
  'caption': 0,
  'center': 0,
  'cite': 0,
  'code': 0,
  'col': 2,
  'colgroup': 1,
  'command': 2,
  'data': 0,
  'datalist': 0,
  'dd': 1,
  'del': 0,
  'details': 0,
  'dfn': 0,
  'dialog': 272,
  'dir': 0,
  'div': 0,
  'dl': 0,
  'dt': 1,
  'em': 0,
  'fieldset': 0,
  'figcaption': 0,
  'figure': 0,
  'font': 0,
  'footer': 0,
  'form': 0,
  'frame': 274,
  'frameset': 272,
  'h1': 0,
  'h2': 0,
  'h3': 0,
  'h4': 0,
  'h5': 0,
  'h6': 0,
  'head': 305,
  'header': 0,
  'hgroup': 0,
  'hr': 2,
  'html': 305,
  'i': 0,
  'iframe': 16,
  'img': 2,
  'input': 2,
  'ins': 0,
  'isindex': 274,
  'kbd': 0,
  'keygen': 274,
  'label': 0,
  'legend': 0,
  'li': 1,
  'link': 274,
  'map': 0,
  'mark': 0,
  'menu': 0,
  'meta': 274,
  'meter': 0,
  'nav': 0,
  'nobr': 0,
  'noembed': 276,
  'noframes': 276,
  'noscript': 276,
  'object': 272,
  'ol': 0,
  'optgroup': 0,
  'option': 1,
  'output': 0,
  'p': 1,
  'param': 274,
  'pre': 0,
  'progress': 0,
  'q': 0,
  's': 0,
  'samp': 0,
  'script': 84,
  'section': 0,
  'select': 0,
  'small': 0,
  'source': 2,
  'span': 0,
  'strike': 0,
  'strong': 0,
  'style': 148,
  'sub': 0,
  'summary': 0,
  'sup': 0,
  'table': 0,
  'tbody': 1,
  'td': 1,
  'textarea': 8,
  'tfoot': 1,
  'th': 1,
  'thead': 1,
  'time': 0,
  'title': 280,
  'tr': 1,
  'track': 2,
  'tt': 0,
  'u': 0,
  'ul': 0,
  'var': 0,
  'video': 0,
  'wbr': 2
};
html4[ 'ELEMENTS' ] = html4.ELEMENTS;
html4.ELEMENT_DOM_INTERFACES = {
  'a': 'HTMLAnchorElement',
  'abbr': 'HTMLElement',
  'acronym': 'HTMLElement',
  'address': 'HTMLElement',
  'applet': 'HTMLAppletElement',
  'area': 'HTMLAreaElement',
  'article': 'HTMLElement',
  'aside': 'HTMLElement',
  'audio': 'HTMLAudioElement',
  'b': 'HTMLElement',
  'base': 'HTMLBaseElement',
  'basefont': 'HTMLBaseFontElement',
  'bdi': 'HTMLElement',
  'bdo': 'HTMLElement',
  'big': 'HTMLElement',
  'blockquote': 'HTMLQuoteElement',
  'body': 'HTMLBodyElement',
  'br': 'HTMLBRElement',
  'button': 'HTMLButtonElement',
  'canvas': 'HTMLCanvasElement',
  'caption': 'HTMLTableCaptionElement',
  'center': 'HTMLElement',
  'cite': 'HTMLElement',
  'code': 'HTMLElement',
  'col': 'HTMLTableColElement',
  'colgroup': 'HTMLTableColElement',
  'command': 'HTMLCommandElement',
  'data': 'HTMLElement',
  'datalist': 'HTMLDataListElement',
  'dd': 'HTMLElement',
  'del': 'HTMLModElement',
  'details': 'HTMLDetailsElement',
  'dfn': 'HTMLElement',
  'dialog': 'HTMLDialogElement',
  'dir': 'HTMLDirectoryElement',
  'div': 'HTMLDivElement',
  'dl': 'HTMLDListElement',
  'dt': 'HTMLElement',
  'em': 'HTMLElement',
  'fieldset': 'HTMLFieldSetElement',
  'figcaption': 'HTMLElement',
  'figure': 'HTMLElement',
  'font': 'HTMLFontElement',
  'footer': 'HTMLElement',
  'form': 'HTMLFormElement',
  'frame': 'HTMLFrameElement',
  'frameset': 'HTMLFrameSetElement',
  'h1': 'HTMLHeadingElement',
  'h2': 'HTMLHeadingElement',
  'h3': 'HTMLHeadingElement',
  'h4': 'HTMLHeadingElement',
  'h5': 'HTMLHeadingElement',
  'h6': 'HTMLHeadingElement',
  'head': 'HTMLHeadElement',
  'header': 'HTMLElement',
  'hgroup': 'HTMLElement',
  'hr': 'HTMLHRElement',
  'html': 'HTMLHtmlElement',
  'i': 'HTMLElement',
  'iframe': 'HTMLIFrameElement',
  'img': 'HTMLImageElement',
  'input': 'HTMLInputElement',
  'ins': 'HTMLModElement',
  'isindex': 'HTMLUnknownElement',
  'kbd': 'HTMLElement',
  'keygen': 'HTMLKeygenElement',
  'label': 'HTMLLabelElement',
  'legend': 'HTMLLegendElement',
  'li': 'HTMLLIElement',
  'link': 'HTMLLinkElement',
  'map': 'HTMLMapElement',
  'mark': 'HTMLElement',
  'menu': 'HTMLMenuElement',
  'meta': 'HTMLMetaElement',
  'meter': 'HTMLMeterElement',
  'nav': 'HTMLElement',
  'nobr': 'HTMLElement',
  'noembed': 'HTMLElement',
  'noframes': 'HTMLElement',
  'noscript': 'HTMLElement',
  'object': 'HTMLObjectElement',
  'ol': 'HTMLOListElement',
  'optgroup': 'HTMLOptGroupElement',
  'option': 'HTMLOptionElement',
  'output': 'HTMLOutputElement',
  'p': 'HTMLParagraphElement',
  'param': 'HTMLParamElement',
  'pre': 'HTMLPreElement',
  'progress': 'HTMLProgressElement',
  'q': 'HTMLQuoteElement',
  's': 'HTMLElement',
  'samp': 'HTMLElement',
  'script': 'HTMLScriptElement',
  'section': 'HTMLElement',
  'select': 'HTMLSelectElement',
  'small': 'HTMLElement',
  'source': 'HTMLSourceElement',
  'span': 'HTMLSpanElement',
  'strike': 'HTMLElement',
  'strong': 'HTMLElement',
  'style': 'HTMLStyleElement',
  'sub': 'HTMLElement',
  'summary': 'HTMLElement',
  'sup': 'HTMLElement',
  'table': 'HTMLTableElement',
  'tbody': 'HTMLTableSectionElement',
  'td': 'HTMLTableDataCellElement',
  'textarea': 'HTMLTextAreaElement',
  'tfoot': 'HTMLTableSectionElement',
  'th': 'HTMLTableHeaderCellElement',
  'thead': 'HTMLTableSectionElement',
  'time': 'HTMLTimeElement',
  'title': 'HTMLTitleElement',
  'tr': 'HTMLTableRowElement',
  'track': 'HTMLTrackElement',
  'tt': 'HTMLElement',
  'u': 'HTMLElement',
  'ul': 'HTMLUListElement',
  'var': 'HTMLElement',
  'video': 'HTMLVideoElement',
  'wbr': 'HTMLElement'
};
html4[ 'ELEMENT_DOM_INTERFACES' ] = html4.ELEMENT_DOM_INTERFACES;
html4.ueffects = {
  'NOT_LOADED': 0,
  'SAME_DOCUMENT': 1,
  'NEW_DOCUMENT': 2
};
html4[ 'ueffects' ] = html4.ueffects;
html4.URIEFFECTS = {
  'a::href': 2,
  'area::href': 2,
  'blockquote::cite': 0,
  'command::icon': 1,
  'del::cite': 0,
  'form::action': 2,
  'img::src': 1,
  'input::src': 1,
  'ins::cite': 0,
  'q::cite': 0,
  'video::poster': 1
};
html4[ 'URIEFFECTS' ] = html4.URIEFFECTS;
html4.ltypes = {
  'UNSANDBOXED': 2,
  'SANDBOXED': 1,
  'DATA': 0
};
html4[ 'ltypes' ] = html4.ltypes;
html4.LOADERTYPES = {
  'a::href': 2,
  'area::href': 2,
  'blockquote::cite': 2,
  'command::icon': 1,
  'del::cite': 2,
  'form::action': 2,
  'img::src': 1,
  'input::src': 1,
  'ins::cite': 2,
  'q::cite': 2,
  'video::poster': 1
};
html4[ 'LOADERTYPES' ] = html4.LOADERTYPES;

// Copyright (C) 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview
 * An HTML sanitizer that can satisfy a variety of security policies.
 *
 * <p>
 * The HTML sanitizer is built around a SAX parser and HTML element and
 * attributes schemas.
 *
 * If the cssparser is loaded, inline styles are sanitized using the
 * css property and value schemas.  Else they are remove during
 * sanitization.
 *
 * If it exists, uses parseCssDeclarations, sanitizeCssProperty,  cssSchema
 *
 * @author mikesamuel@gmail.com
 * @author jasvir@gmail.com
 * \@requires html4, URI
 * \@overrides window
 * \@provides html, html_sanitize
 */

// The Turkish i seems to be a non-issue, but abort in case it is.
if ('I'.toLowerCase() !== 'i') { throw 'I/i problem'; }

/**
 * \@namespace
 */
var html = (function(html4) {

  // For closure compiler
  var parseCssDeclarations, sanitizeCssProperty, cssSchema;
  if ('undefined' !== typeof window) {
    parseCssDeclarations = window['parseCssDeclarations'];
    sanitizeCssProperty = window['sanitizeCssProperty'];
    cssSchema = window['cssSchema'];
  }

  // The keys of this object must be 'quoted' or JSCompiler will mangle them!
  // This is a partial list -- lookupEntity() uses the host browser's parser
  // (when available) to implement full entity lookup.
  // Note that entities are in general case-sensitive; the uppercase ones are
  // explicitly defined by HTML5 (presumably as compatibility).
  var ENTITIES = {
    'lt': '<',
    'LT': '<',
    'gt': '>',
    'GT': '>',
    'amp': '&',
    'AMP': '&',
    'quot': '"',
    'apos': '\'',
    'nbsp': '\u00A0'
  };

  // Patterns for types of entity/character reference names.
  var decimalEscapeRe = /^#(\d+)$/;
  var hexEscapeRe = /^#x([0-9A-Fa-f]+)$/;
  // contains every entity per http://www.w3.org/TR/2011/WD-html5-20110113/named-character-references.html
  var safeEntityNameRe = /^[A-Za-z][A-za-z0-9]+$/;
  // Used as a hook to invoke the browser's entity parsing. <textarea> is used
  // because its content is parsed for entities but not tags.
  // TODO(kpreid): This retrieval is a kludge and leads to silent loss of
  // functionality if the document isn't available.
  var entityLookupElement =
      ('undefined' !== typeof window && window['document'])
          ? window['document'].createElement('textarea') : null;
  /**
   * Decodes an HTML entity.
   *
   * {\@updoc
   * $ lookupEntity('lt')
   * # '<'
   * $ lookupEntity('GT')
   * # '>'
   * $ lookupEntity('amp')
   * # '&'
   * $ lookupEntity('nbsp')
   * # '\xA0'
   * $ lookupEntity('apos')
   * # "'"
   * $ lookupEntity('quot')
   * # '"'
   * $ lookupEntity('#xa')
   * # '\n'
   * $ lookupEntity('#10')
   * # '\n'
   * $ lookupEntity('#x0a')
   * # '\n'
   * $ lookupEntity('#010')
   * # '\n'
   * $ lookupEntity('#x00A')
   * # '\n'
   * $ lookupEntity('Pi')      // Known failure
   * # '\u03A0'
   * $ lookupEntity('pi')      // Known failure
   * # '\u03C0'
   * }
   *
   * @param {string} name the content between the '&' and the ';'.
   * @return {string} a single unicode code-point as a string.
   */
  function lookupEntity(name) {
    // TODO: entity lookup as specified by HTML5 actually depends on the
    // presence of the ";".
    if (ENTITIES.hasOwnProperty(name)) { return ENTITIES[name]; }
    var m = name.match(decimalEscapeRe);
    if (m) {
      return String.fromCharCode(parseInt(m[1], 10));
    } else if (!!(m = name.match(hexEscapeRe))) {
      return String.fromCharCode(parseInt(m[1], 16));
    } else if (entityLookupElement && safeEntityNameRe.test(name)) {
      entityLookupElement.innerHTML = '&' + name + ';';
      var text = entityLookupElement.textContent;
      ENTITIES[name] = text;
      return text;
    } else {
      return '&' + name + ';';
    }
  }

  function decodeOneEntity(_, name) {
    return lookupEntity(name);
  }

  var nulRe = /\0/g;
  function stripNULs(s) {
    return s.replace(nulRe, '');
  }

  var ENTITY_RE_1 = /&(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/g;
  var ENTITY_RE_2 = /^(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/;
  /**
   * The plain text of a chunk of HTML CDATA which possibly containing.
   *
   * {\@updoc
   * $ unescapeEntities('')
   * # ''
   * $ unescapeEntities('hello World!')
   * # 'hello World!'
   * $ unescapeEntities('1 &lt; 2 &amp;&AMP; 4 &gt; 3&#10;')
   * # '1 < 2 && 4 > 3\n'
   * $ unescapeEntities('&lt;&lt <- unfinished entity&gt;')
   * # '<&lt <- unfinished entity>'
   * $ unescapeEntities('/foo?bar=baz&copy=true')  // & often unescaped in URLS
   * # '/foo?bar=baz&copy=true'
   * $ unescapeEntities('pi=&pi;&#x3c0;, Pi=&Pi;\u03A0') // FIXME: known failure
   * # 'pi=\u03C0\u03c0, Pi=\u03A0\u03A0'
   * }
   *
   * @param {string} s a chunk of HTML CDATA.  It must not start or end inside
   *     an HTML entity.
   */
  function unescapeEntities(s) {
    return s.replace(ENTITY_RE_1, decodeOneEntity);
  }

  var ampRe = /&/g;
  var looseAmpRe = /&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi;
  var ltRe = /[<]/g;
  var gtRe = />/g;
  var quotRe = /\"/g;

  /**
   * Escapes HTML special characters in attribute values.
   *
   * {\@updoc
   * $ escapeAttrib('')
   * # ''
   * $ escapeAttrib('"<<&==&>>"')  // Do not just escape the first occurrence.
   * # '&#34;&lt;&lt;&amp;&#61;&#61;&amp;&gt;&gt;&#34;'
   * $ escapeAttrib('Hello <World>!')
   * # 'Hello &lt;World&gt;!'
   * }
   */
  function escapeAttrib(s) {
    return ('' + s).replace(ampRe, '&amp;').replace(ltRe, '&lt;')
        .replace(gtRe, '&gt;').replace(quotRe, '&#34;');
  }

  /**
   * Escape entities in RCDATA that can be escaped without changing the meaning.
   * {\@updoc
   * $ normalizeRCData('1 < 2 &&amp; 3 > 4 &amp;& 5 &lt; 7&8')
   * # '1 &lt; 2 &amp;&amp; 3 &gt; 4 &amp;&amp; 5 &lt; 7&amp;8'
   * }
   */
  function normalizeRCData(rcdata) {
    return rcdata
        .replace(looseAmpRe, '&amp;$1')
        .replace(ltRe, '&lt;')
        .replace(gtRe, '&gt;');
  }

  // TODO(felix8a): validate sanitizer regexs against the HTML5 grammar at
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html

  // We initially split input so that potentially meaningful characters
  // like '<' and '>' are separate tokens, using a fast dumb process that
  // ignores quoting.  Then we walk that token stream, and when we see a
  // '<' that's the start of a tag, we use ATTR_RE to extract tag
  // attributes from the next token.  That token will never have a '>'
  // character.  However, it might have an unbalanced quote character, and
  // when we see that, we combine additional tokens to balance the quote.

  var ATTR_RE = new RegExp(
    '^\\s*' +
    '([-.:\\w]+)' +             // 1 = Attribute name
    '(?:' + (
      '\\s*(=)\\s*' +           // 2 = Is there a value?
      '(' + (                   // 3 = Attribute value
        // TODO(felix8a): maybe use backref to match quotes
        '(\")[^\"]*(\"|$)' +    // 4, 5 = Double-quoted string
        '|' +
        '(\')[^\']*(\'|$)' +    // 6, 7 = Single-quoted string
        '|' +
        // Positive lookahead to prevent interpretation of
        // <foo a= b=c> as <foo a='b=c'>
        // TODO(felix8a): might be able to drop this case
        '(?=[a-z][-\\w]*\\s*=)' +
        '|' +
        // Unquoted value that isn't an attribute name
        // (since we didn't match the positive lookahead above)
        '[^\"\'\\s]*' ) +
      ')' ) +
    ')?',
    'i');

  // false on IE<=8, true on most other browsers
  var splitWillCapture = ('a,b'.split(/(,)/).length === 3);

  // bitmask for tags with special parsing, like <script> and <textarea>
  var EFLAGS_TEXT = html4.eflags['CDATA'] | html4.eflags['RCDATA'];

  /**
   * Given a SAX-like event handler, produce a function that feeds those
   * events and a parameter to the event handler.
   *
   * The event handler has the form:{@code
   * {
   *   // Name is an upper-case HTML tag name.  Attribs is an array of
   *   // alternating upper-case attribute names, and attribute values.  The
   *   // attribs array is reused by the parser.  Param is the value passed to
   *   // the saxParser.
   *   startTag: function (name, attribs, param) { ... },
   *   endTag:   function (name, param) { ... },
   *   pcdata:   function (text, param) { ... },
   *   rcdata:   function (text, param) { ... },
   *   cdata:    function (text, param) { ... },
   *   startDoc: function (param) { ... },
   *   endDoc:   function (param) { ... }
   * }}
   *
   * @param {Object} handler a record containing event handlers.
   * @return {function(string, Object)} A function that takes a chunk of HTML
   *     and a parameter.  The parameter is passed on to the handler methods.
   */
  function makeSaxParser(handler) {
    // Accept quoted or unquoted keys (Closure compat)
    var hcopy = {
      cdata: handler.cdata || handler['cdata'],
      comment: handler.comment || handler['comment'],
      endDoc: handler.endDoc || handler['endDoc'],
      endTag: handler.endTag || handler['endTag'],
      pcdata: handler.pcdata || handler['pcdata'],
      rcdata: handler.rcdata || handler['rcdata'],
      startDoc: handler.startDoc || handler['startDoc'],
      startTag: handler.startTag || handler['startTag']
    };
    return function(htmlText, param) {
      return parse(htmlText, hcopy, param);
    };
  }

  // Parsing strategy is to split input into parts that might be lexically
  // meaningful (every ">" becomes a separate part), and then recombine
  // parts if we discover they're in a different context.

  // TODO(felix8a): Significant performance regressions from -legacy,
  // tested on
  //    Chrome 18.0
  //    Firefox 11.0
  //    IE 6, 7, 8, 9
  //    Opera 11.61
  //    Safari 5.1.3
  // Many of these are unusual patterns that are linearly slower and still
  // pretty fast (eg 1ms to 5ms), so not necessarily worth fixing.

  // TODO(felix8a): "<script> && && && ... <\/script>" is slower on all
  // browsers.  The hotspot is htmlSplit.

  // TODO(felix8a): "<p title='>>>>...'><\/p>" is slower on all browsers.
  // This is partly htmlSplit, but the hotspot is parseTagAndAttrs.

  // TODO(felix8a): "<a><\/a><a><\/a>..." is slower on IE9.
  // "<a>1<\/a><a>1<\/a>..." is faster, "<a><\/a>2<a><\/a>2..." is faster.

  // TODO(felix8a): "<p<p<p..." is slower on IE[6-8]

  var continuationMarker = {};
  function parse(htmlText, handler, param) {
    var m, p, tagName;
    var parts = htmlSplit(htmlText);
    var state = {
      noMoreGT: false,
      noMoreEndComments: false
    };
    parseCPS(handler, parts, 0, state, param);
  }

  function continuationMaker(h, parts, initial, state, param) {
    return function () {
      parseCPS(h, parts, initial, state, param);
    };
  }

  function parseCPS(h, parts, initial, state, param) {
    try {
      if (h.startDoc && initial == 0) { h.startDoc(param); }
      var m, p, tagName;
      for (var pos = initial, end = parts.length; pos < end;) {
        var current = parts[pos++];
        var next = parts[pos];
        switch (current) {
        case '&':
          if (ENTITY_RE_2.test(next)) {
            if (h.pcdata) {
              h.pcdata('&' + next, param, continuationMarker,
                continuationMaker(h, parts, pos, state, param));
            }
            pos++;
          } else {
            if (h.pcdata) { h.pcdata("&amp;", param, continuationMarker,
                continuationMaker(h, parts, pos, state, param));
            }
          }
          break;
        case '<\/':
          if (m = /^([-\w:]+)[^\'\"]*/.exec(next)) {
            if (m[0].length === next.length && parts[pos + 1] === '>') {
              // fast case, no attribute parsing needed
              pos += 2;
              tagName = m[1].toLowerCase();
              if (h.endTag) {
                h.endTag(tagName, param, continuationMarker,
                  continuationMaker(h, parts, pos, state, param));
              }
            } else {
              // slow case, need to parse attributes
              // TODO(felix8a): do we really care about misparsing this?
              pos = parseEndTag(
                parts, pos, h, param, continuationMarker, state);
            }
          } else {
            if (h.pcdata) {
              h.pcdata('&lt;/', param, continuationMarker,
                continuationMaker(h, parts, pos, state, param));
            }
          }
          break;
        case '<':
          if (m = /^([-\w:]+)\s*\/?/.exec(next)) {
            if (m[0].length === next.length && parts[pos + 1] === '>') {
              // fast case, no attribute parsing needed
              pos += 2;
              tagName = m[1].toLowerCase();
              if (h.startTag) {
                h.startTag(tagName, [], param, continuationMarker,
                  continuationMaker(h, parts, pos, state, param));
              }
              // tags like <script> and <textarea> have special parsing
              var eflags = html4.ELEMENTS[tagName];
              if (eflags & EFLAGS_TEXT) {
                var tag = { name: tagName, next: pos, eflags: eflags };
                pos = parseText(
                  parts, tag, h, param, continuationMarker, state);
              }
            } else {
              // slow case, need to parse attributes
              pos = parseStartTag(
                parts, pos, h, param, continuationMarker, state);
            }
          } else {
            if (h.pcdata) {
              h.pcdata('&lt;', param, continuationMarker,
                continuationMaker(h, parts, pos, state, param));
            }
          }
          break;
        case '<\!--':
          // The pathological case is n copies of '<\!--' without '-->', and
          // repeated failure to find '-->' is quadratic.  We avoid that by
          // remembering when search for '-->' fails.
          if (!state.noMoreEndComments) {
            // A comment <\!--x--> is split into three tokens:
            //   '<\!--', 'x--', '>'
            // We want to find the next '>' token that has a preceding '--'.
            // pos is at the 'x--'.
            for (p = pos + 1; p < end; p++) {
              if (parts[p] === '>' && /--$/.test(parts[p - 1])) { break; }
            }
            if (p < end) {
              if (h.comment) {
                var comment = parts.slice(pos, p).join('');
                h.comment(
                  comment.substr(0, comment.length - 2), param,
                  continuationMarker,
                  continuationMaker(h, parts, p + 1, state, param));
              }
              pos = p + 1;
            } else {
              state.noMoreEndComments = true;
            }
          }
          if (state.noMoreEndComments) {
            if (h.pcdata) {
              h.pcdata('&lt;!--', param, continuationMarker,
                continuationMaker(h, parts, pos, state, param));
            }
          }
          break;
        case '<\!':
          if (!/^\w/.test(next)) {
            if (h.pcdata) {
              h.pcdata('&lt;!', param, continuationMarker,
                continuationMaker(h, parts, pos, state, param));
            }
          } else {
            // similar to noMoreEndComment logic
            if (!state.noMoreGT) {
              for (p = pos + 1; p < end; p++) {
                if (parts[p] === '>') { break; }
              }
              if (p < end) {
                pos = p + 1;
              } else {
                state.noMoreGT = true;
              }
            }
            if (state.noMoreGT) {
              if (h.pcdata) {
                h.pcdata('&lt;!', param, continuationMarker,
                  continuationMaker(h, parts, pos, state, param));
              }
            }
          }
          break;
        case '<?':
          // similar to noMoreEndComment logic
          if (!state.noMoreGT) {
            for (p = pos + 1; p < end; p++) {
              if (parts[p] === '>') { break; }
            }
            if (p < end) {
              pos = p + 1;
            } else {
              state.noMoreGT = true;
            }
          }
          if (state.noMoreGT) {
            if (h.pcdata) {
              h.pcdata('&lt;?', param, continuationMarker,
                continuationMaker(h, parts, pos, state, param));
            }
          }
          break;
        case '>':
          if (h.pcdata) {
            h.pcdata("&gt;", param, continuationMarker,
              continuationMaker(h, parts, pos, state, param));
          }
          break;
        case '':
          break;
        default:
          if (h.pcdata) {
            h.pcdata(current, param, continuationMarker,
              continuationMaker(h, parts, pos, state, param));
          }
          break;
        }
      }
      if (h.endDoc) { h.endDoc(param); }
    } catch (e) {
      if (e !== continuationMarker) { throw e; }
    }
  }

  // Split str into parts for the html parser.
  function htmlSplit(str) {
    // can't hoist this out of the function because of the re.exec loop.
    var re = /(<\/|<\!--|<[!?]|[&<>])/g;
    str += '';
    if (splitWillCapture) {
      return str.split(re);
    } else {
      var parts = [];
      var lastPos = 0;
      var m;
      while ((m = re.exec(str)) !== null) {
        parts.push(str.substring(lastPos, m.index));
        parts.push(m[0]);
        lastPos = m.index + m[0].length;
      }
      parts.push(str.substring(lastPos));
      return parts;
    }
  }

  function parseEndTag(parts, pos, h, param, continuationMarker, state) {
    var tag = parseTagAndAttrs(parts, pos);
    // drop unclosed tags
    if (!tag) { return parts.length; }
    if (h.endTag) {
      h.endTag(tag.name, param, continuationMarker,
        continuationMaker(h, parts, pos, state, param));
    }
    return tag.next;
  }

  function parseStartTag(parts, pos, h, param, continuationMarker, state) {
    var tag = parseTagAndAttrs(parts, pos);
    // drop unclosed tags
    if (!tag) { return parts.length; }
    if (h.startTag) {
      h.startTag(tag.name, tag.attrs, param, continuationMarker,
        continuationMaker(h, parts, tag.next, state, param));
    }
    // tags like <script> and <textarea> have special parsing
    if (tag.eflags & EFLAGS_TEXT) {
      return parseText(parts, tag, h, param, continuationMarker, state);
    } else {
      return tag.next;
    }
  }

  var endTagRe = {};

  // Tags like <script> and <textarea> are flagged as CDATA or RCDATA,
  // which means everything is text until we see the correct closing tag.
  function parseText(parts, tag, h, param, continuationMarker, state) {
    var end = parts.length;
    if (!endTagRe.hasOwnProperty(tag.name)) {
      endTagRe[tag.name] = new RegExp('^' + tag.name + '(?:[\\s\\/]|$)', 'i');
    }
    var re = endTagRe[tag.name];
    var first = tag.next;
    var p = tag.next + 1;
    for (; p < end; p++) {
      if (parts[p - 1] === '<\/' && re.test(parts[p])) { break; }
    }
    if (p < end) { p -= 1; }
    var buf = parts.slice(first, p).join('');
    if (tag.eflags & html4.eflags['CDATA']) {
      if (h.cdata) {
        h.cdata(buf, param, continuationMarker,
          continuationMaker(h, parts, p, state, param));
      }
    } else if (tag.eflags & html4.eflags['RCDATA']) {
      if (h.rcdata) {
        h.rcdata(normalizeRCData(buf), param, continuationMarker,
          continuationMaker(h, parts, p, state, param));
      }
    } else {
      throw new Error('bug');
    }
    return p;
  }

  // at this point, parts[pos-1] is either "<" or "<\/".
  function parseTagAndAttrs(parts, pos) {
    var m = /^([-\w:]+)/.exec(parts[pos]);
    var tag = {};
    tag.name = m[1].toLowerCase();
    tag.eflags = html4.ELEMENTS[tag.name];
    var buf = parts[pos].substr(m[0].length);
    // Find the next '>'.  We optimistically assume this '>' is not in a
    // quoted context, and further down we fix things up if it turns out to
    // be quoted.
    var p = pos + 1;
    var end = parts.length;
    for (; p < end; p++) {
      if (parts[p] === '>') { break; }
      buf += parts[p];
    }
    if (end <= p) { return void 0; }
    var attrs = [];
    while (buf !== '') {
      m = ATTR_RE.exec(buf);
      if (!m) {
        // No attribute found: skip garbage
        buf = buf.replace(/^[\s\S][^a-z\s]*/, '');

      } else if ((m[4] && !m[5]) || (m[6] && !m[7])) {
        // Unterminated quote: slurp to the next unquoted '>'
        var quote = m[4] || m[6];
        var sawQuote = false;
        var abuf = [buf, parts[p++]];
        for (; p < end; p++) {
          if (sawQuote) {
            if (parts[p] === '>') { break; }
          } else if (0 <= parts[p].indexOf(quote)) {
            sawQuote = true;
          }
          abuf.push(parts[p]);
        }
        // Slurp failed: lose the garbage
        if (end <= p) { break; }
        // Otherwise retry attribute parsing
        buf = abuf.join('');
        continue;

      } else {
        // We have an attribute
        var aName = m[1].toLowerCase();
        var aValue = m[2] ? decodeValue(m[3]) : '';
        attrs.push(aName, aValue);
        buf = buf.substr(m[0].length);
      }
    }
    tag.attrs = attrs;
    tag.next = p + 1;
    return tag;
  }

  function decodeValue(v) {
    var q = v.charCodeAt(0);
    if (q === 0x22 || q === 0x27) { // " or '
      v = v.substr(1, v.length - 2);
    }
    return unescapeEntities(stripNULs(v));
  }

  /**
   * Returns a function that strips unsafe tags and attributes from html.
   * @param {function(string, Array.<string>): ?Array.<string>} tagPolicy
   *     A function that takes (tagName, attribs[]), where tagName is a key in
   *     html4.ELEMENTS and attribs is an array of alternating attribute names
   *     and values.  It should return a record (as follows), or null to delete
   *     the element.  It's okay for tagPolicy to modify the attribs array,
   *     but the same array is reused, so it should not be held between calls.
   *     Record keys:
   *        attribs: (required) Sanitized attributes array.
   *        tagName: Replacement tag name.
   * @return {function(string, Array)} A function that sanitizes a string of
   *     HTML and appends result strings to the second argument, an array.
   */
  function makeHtmlSanitizer(tagPolicy) {
    var stack;
    var ignoring;
    var emit = function (text, out) {
      if (!ignoring) { out.push(text); }
    };
    return makeSaxParser({
      'startDoc': function(_) {
        stack = [];
        ignoring = false;
      },
      'startTag': function(tagNameOrig, attribs, out) {
        if (ignoring) { return; }
        if (!html4.ELEMENTS.hasOwnProperty(tagNameOrig)) { return; }
        var eflagsOrig = html4.ELEMENTS[tagNameOrig];
        if (eflagsOrig & html4.eflags['FOLDABLE']) {
          return;
        }

        var decision = tagPolicy(tagNameOrig, attribs);
        if (!decision) {
          ignoring = !(eflagsOrig & html4.eflags['EMPTY']);
          return;
        } else if (typeof decision !== 'object') {
          throw new Error('tagPolicy did not return object (old API?)');
        }
        if ('attribs' in decision) {
          attribs = decision['attribs'];
        } else {
          throw new Error('tagPolicy gave no attribs');
        }
        var eflagsRep;
        var tagNameRep;
        if ('tagName' in decision) {
          tagNameRep = decision['tagName'];
          eflagsRep = html4.ELEMENTS[tagNameRep];
        } else {
          tagNameRep = tagNameOrig;
          eflagsRep = eflagsOrig;
        }
        // TODO(mikesamuel): relying on tagPolicy not to insert unsafe
        // attribute names.

        // If this is an optional-end-tag element and either this element or its
        // previous like sibling was rewritten, then insert a close tag to
        // preserve structure.
        if (eflagsOrig & html4.eflags['OPTIONAL_ENDTAG']) {
          var onStack = stack[stack.length - 1];
          if (onStack && onStack.orig === tagNameOrig &&
              (onStack.rep !== tagNameRep || tagNameOrig !== tagNameRep)) {
                out.push('<\/', onStack.rep, '>');
          }
        }

        if (!(eflagsOrig & html4.eflags['EMPTY'])) {
          stack.push({orig: tagNameOrig, rep: tagNameRep});
        }

        out.push('<', tagNameRep);
        for (var i = 0, n = attribs.length; i < n; i += 2) {
          var attribName = attribs[i],
              value = attribs[i + 1];
          if (value !== null && value !== void 0) {
            out.push(' ', attribName, '="', escapeAttrib(value), '"');
          }
        }
        out.push('>');

        if ((eflagsOrig & html4.eflags['EMPTY'])
            && !(eflagsRep & html4.eflags['EMPTY'])) {
          // replacement is non-empty, synthesize end tag
          out.push('<\/', tagNameRep, '>');
        }
      },
      'endTag': function(tagName, out) {
        if (ignoring) {
          ignoring = false;
          return;
        }
        if (!html4.ELEMENTS.hasOwnProperty(tagName)) { return; }
        var eflags = html4.ELEMENTS[tagName];
        if (!(eflags & (html4.eflags['EMPTY'] | html4.eflags['FOLDABLE']))) {
          var index;
          if (eflags & html4.eflags['OPTIONAL_ENDTAG']) {
            for (index = stack.length; --index >= 0;) {
              var stackElOrigTag = stack[index].orig;
              if (stackElOrigTag === tagName) { break; }
              if (!(html4.ELEMENTS[stackElOrigTag] &
                    html4.eflags['OPTIONAL_ENDTAG'])) {
                // Don't pop non optional end tags looking for a match.
                return;
              }
            }
          } else {
            for (index = stack.length; --index >= 0;) {
              if (stack[index].orig === tagName) { break; }
            }
          }
          if (index < 0) { return; }  // Not opened.
          for (var i = stack.length; --i > index;) {
            var stackElRepTag = stack[i].rep;
            if (!(html4.ELEMENTS[stackElRepTag] &
                  html4.eflags['OPTIONAL_ENDTAG'])) {
              out.push('<\/', stackElRepTag, '>');
            }
          }
          if (index < stack.length) {
            tagName = stack[index].rep;
          }
          stack.length = index;
          out.push('<\/', tagName, '>');
        }
      },
      'pcdata': emit,
      'rcdata': emit,
      'cdata': emit,
      'endDoc': function(out) {
        for (; stack.length; stack.length--) {
          out.push('<\/', stack[stack.length - 1].rep, '>');
        }
      }
    });
  }

  var ALLOWED_URI_SCHEMES = /^(?:https?|mailto|data)$/i;

  function safeUri(uri, effect, ltype, hints, naiveUriRewriter) {
    if (!naiveUriRewriter) { return null; }
    try {
      var parsed = URI.parse('' + uri);
      if (parsed) {
        if (!parsed.hasScheme() ||
            ALLOWED_URI_SCHEMES.test(parsed.getScheme())) {
          var safe = naiveUriRewriter(parsed, effect, ltype, hints);
          return safe ? safe.toString() : null;
        }
      }
    } catch (e) {
      return null;
    }
    return null;
  }

  function log(logger, tagName, attribName, oldValue, newValue) {
    if (!attribName) {
      logger(tagName + " removed", {
        change: "removed",
        tagName: tagName
      });
    }
    if (oldValue !== newValue) {
      var changed = "changed";
      if (oldValue && !newValue) {
        changed = "removed";
      } else if (!oldValue && newValue)  {
        changed = "added";
      }
      logger(tagName + "." + attribName + " " + changed, {
        change: changed,
        tagName: tagName,
        attribName: attribName,
        oldValue: oldValue,
        newValue: newValue
      });
    }
  }

  function lookupAttribute(map, tagName, attribName) {
    var attribKey;
    attribKey = tagName + '::' + attribName;
    if (map.hasOwnProperty(attribKey)) {
      return map[attribKey];
    }
    attribKey = '*::' + attribName;
    if (map.hasOwnProperty(attribKey)) {
      return map[attribKey];
    }
    return void 0;
  }
  function getAttributeType(tagName, attribName) {
    return lookupAttribute(html4.ATTRIBS, tagName, attribName);
  }
  function getLoaderType(tagName, attribName) {
    return lookupAttribute(html4.LOADERTYPES, tagName, attribName);
  }
  function getUriEffect(tagName, attribName) {
    return lookupAttribute(html4.URIEFFECTS, tagName, attribName);
  }

  /**
   * Sanitizes attributes on an HTML tag.
   * @param {string} tagName An HTML tag name in lowercase.
   * @param {Array.<?string>} attribs An array of alternating names and values.
   * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
   *     apply to URI attributes; it can return a new string value, or null to
   *     delete the attribute.  If unspecified, URI attributes are deleted.
   * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
   *     to attributes containing HTML names, element IDs, and space-separated
   *     lists of classes; it can return a new string value, or null to delete
   *     the attribute.  If unspecified, these attributes are kept unchanged.
   * @return {Array.<?string>} The sanitized attributes as a list of alternating
   *     names and values, where a null value means to omit the attribute.
   */
  function sanitizeAttribs(tagName, attribs,
    opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
    // TODO(felix8a): it's obnoxious that domado duplicates much of this
    // TODO(felix8a): maybe consistently enforce constraints like target=
    for (var i = 0; i < attribs.length; i += 2) {
      var attribName = attribs[i];
      var value = attribs[i + 1];
      var oldValue = value;
      var atype = null, attribKey;
      if ((attribKey = tagName + '::' + attribName,
           html4.ATTRIBS.hasOwnProperty(attribKey)) ||
          (attribKey = '*::' + attribName,
           html4.ATTRIBS.hasOwnProperty(attribKey))) {
        atype = html4.ATTRIBS[attribKey];
      }
      if (atype !== null) {
        switch (atype) {
          case html4.atype['NONE']: break;
          case html4.atype['SCRIPT']:
            value = null;
            if (opt_logger) {
              log(opt_logger, tagName, attribName, oldValue, value);
            }
            break;
          case html4.atype['STYLE']:
            if ('undefined' === typeof parseCssDeclarations) {
              value = null;
              if (opt_logger) {
                log(opt_logger, tagName, attribName, oldValue, value);
	      }
              break;
            }
            var sanitizedDeclarations = [];
            parseCssDeclarations(
                value,
                {
                  declaration: function (property, tokens) {
                    var normProp = property.toLowerCase();
                    var schema = cssSchema[normProp];
                    if (!schema) {
                      return;
                    }
                    sanitizeCssProperty(
                        normProp, schema, tokens,
                        opt_naiveUriRewriter
                        ? function (url) {
                            return safeUri(
                                url, html4.ueffects.SAME_DOCUMENT,
                                html4.ltypes.SANDBOXED,
                                {
                                  "TYPE": "CSS",
                                  "CSS_PROP": normProp
                                }, opt_naiveUriRewriter);
                          }
                        : null);
                    sanitizedDeclarations.push(property + ': ' + tokens.join(' '));
                  }
                });
            value = sanitizedDeclarations.length > 0 ?
              sanitizedDeclarations.join(' ; ') : null;
            if (opt_logger) {
              log(opt_logger, tagName, attribName, oldValue, value);
            }
            break;
          case html4.atype['ID']:
          case html4.atype['IDREF']:
          case html4.atype['IDREFS']:
          case html4.atype['GLOBAL_NAME']:
          case html4.atype['LOCAL_NAME']:
          case html4.atype['CLASSES']:
            value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;
            if (opt_logger) {
              log(opt_logger, tagName, attribName, oldValue, value);
            }
            break;
          case html4.atype['URI']:
            value = safeUri(value,
              getUriEffect(tagName, attribName),
              getLoaderType(tagName, attribName),
              {
                "TYPE": "MARKUP",
                "XML_ATTR": attribName,
                "XML_TAG": tagName
              }, opt_naiveUriRewriter);
              if (opt_logger) {
              log(opt_logger, tagName, attribName, oldValue, value);
            }
            break;
          case html4.atype['URI_FRAGMENT']:
            if (value && '#' === value.charAt(0)) {
              value = value.substring(1);  // remove the leading '#'
              value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;
              if (value !== null && value !== void 0) {
                value = '#' + value;  // restore the leading '#'
              }
            } else {
              value = null;
            }
            if (opt_logger) {
              log(opt_logger, tagName, attribName, oldValue, value);
            }
            break;
          default:
            value = null;
            if (opt_logger) {
              log(opt_logger, tagName, attribName, oldValue, value);
            }
            break;
        }
      } else {
        value = null;
        if (opt_logger) {
          log(opt_logger, tagName, attribName, oldValue, value);
        }
      }
      attribs[i + 1] = value;
    }
    return attribs;
  }

  /**
   * Creates a tag policy that omits all tags marked UNSAFE in html4-defs.js
   * and applies the default attribute sanitizer with the supplied policy for
   * URI attributes and NMTOKEN attributes.
   * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
   *     apply to URI attributes.  If not given, URI attributes are deleted.
   * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
   *     to attributes containing HTML names, element IDs, and space-separated
   *     lists of classes.  If not given, such attributes are left unchanged.
   * @return {function(string, Array.<?string>)} A tagPolicy suitable for
   *     passing to html.sanitize.
   */
  function makeTagPolicy(
    opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
    return function(tagName, attribs) {
      if (!(html4.ELEMENTS[tagName] & html4.eflags['UNSAFE'])) {
        return {
          'attribs': sanitizeAttribs(tagName, attribs,
            opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger)
        };
      } else {
        if (opt_logger) {
          log(opt_logger, tagName, undefined, undefined, undefined);
        }
      }
    };
  }

  /**
   * Sanitizes HTML tags and attributes according to a given policy.
   * @param {string} inputHtml The HTML to sanitize.
   * @param {function(string, Array.<?string>)} tagPolicy A function that
   *     decides which tags to accept and sanitizes their attributes (see
   *     makeHtmlSanitizer above for details).
   * @return {string} The sanitized HTML.
   */
  function sanitizeWithPolicy(inputHtml, tagPolicy) {
    var outputArray = [];
    makeHtmlSanitizer(tagPolicy)(inputHtml, outputArray);
    return outputArray.join('');
  }

  /**
   * Strips unsafe tags and attributes from HTML.
   * @param {string} inputHtml The HTML to sanitize.
   * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
   *     apply to URI attributes.  If not given, URI attributes are deleted.
   * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
   *     to attributes containing HTML names, element IDs, and space-separated
   *     lists of classes.  If not given, such attributes are left unchanged.
   */
  function sanitize(inputHtml,
    opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
    var tagPolicy = makeTagPolicy(
      opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger);
    return sanitizeWithPolicy(inputHtml, tagPolicy);
  }

  // Export both quoted and unquoted names for Closure linkage.
  var html = {};
  html.escapeAttrib = html['escapeAttrib'] = escapeAttrib;
  html.makeHtmlSanitizer = html['makeHtmlSanitizer'] = makeHtmlSanitizer;
  html.makeSaxParser = html['makeSaxParser'] = makeSaxParser;
  html.makeTagPolicy = html['makeTagPolicy'] = makeTagPolicy;
  html.normalizeRCData = html['normalizeRCData'] = normalizeRCData;
  html.sanitize = html['sanitize'] = sanitize;
  html.sanitizeAttribs = html['sanitizeAttribs'] = sanitizeAttribs;
  html.sanitizeWithPolicy = html['sanitizeWithPolicy'] = sanitizeWithPolicy;
  html.unescapeEntities = html['unescapeEntities'] = unescapeEntities;
  return html;
})(html4);

var html_sanitize = html['sanitize'];

// Loosen restrictions of Caja's
// html-sanitizer to allow for styling
html4.ATTRIBS['*::style'] = 0;
html4.ELEMENTS['style'] = 0;
html4.ATTRIBS['a::target'] = 0;
html4.ELEMENTS['video'] = 0;
html4.ATTRIBS['video::src'] = 0;
html4.ATTRIBS['video::poster'] = 0;
html4.ATTRIBS['video::controls'] = 0;
html4.ELEMENTS['audio'] = 0;
html4.ATTRIBS['audio::src'] = 0;
html4.ATTRIBS['video::autoplay'] = 0;
html4.ATTRIBS['video::controls'] = 0;

if (typeof module !== 'undefined') {
    module.exports = html_sanitize;
}

},{}],41:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":42,"punycode":35,"querystring":38}],42:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],43:[function(require,module,exports){
require('mapbox.js');
querystring = require('querystring');
var url = require('url'),
    querystring = require('querystring'),
    ctr = require('@turf/centroid'),
    buf = require('@turf/buffer');
window.parsedUrl = url.parse(window.location.href, true, true);
window.searchParams = querystring.parse(parsedUrl.search.substring(1));
window.q = querystring;
window.cent = ctr;
window.buff = buf;
// require('leaflet-ajax');
// expose for debugging
window.idToFeature = { places: {} };
window.eventsObj = { 'dateTimeFormat': 'iso8601', 'events': [] };
window.myLayer = {};
window.pointFeatures = [];
window.lineFeatures = [];
window.tl = {};
window.tlMidpoint = '';

$(function () {
  startMapM(searchParams['d']);
  $("#menu").click(function () {
    $("#data").toggle("fast");
  });
  $(".data-header").html(searchParams['d']);
});

window.midpoint = function (ts, type) {
  // console.log('midpoint()',ts,type)
  if (type == 'start') {
    var mid = new Date(ts[0]);
  } else if (type == 'mid') {
    let start = new Date(ts[0]);
    let end = ts[3] == ('' || undefined) ? new Date(Date.now()) : new Date(ts[3]);
    var mid = new Date((start.getTime() + end.getTime()) / 2);
  }
  return mid;
};
window.initTimeline = function (events) {
  console.log('tlMidpoint', tlMidpoint);
  // let sourceFile = 'data/' + file
  // console.log('in initTimeline()', JSON.stringify(events.events[0]))
  window.eventSrc = new Timeline.DefaultEventSource(0);
  // Example of changing the theme from the defaults
  // The default theme is defined in
  // http://simile-widgets.googlecode.com/svn/timeline/tags/latest/src/webapp/api/scripts/themes.js
  var theme = Timeline.ClassicTheme.create();
  theme.event.bubble.width = 350;
  theme.event.bubble.height = 300;

  // var d = Timeline.DateTime.parseGregorianDateTime("2016-10-01")
  var d = Timeline.DateTime.parseGregorianDateTime(tlMidpoint);
  var bandInfos = [Timeline.createBandInfo({
    width: "75%",
    // intervalUnit:   Timeline.DateTime.DAY,
    intervalUnit: Timeline.DateTime.YEAR,
    // intervalUnit:   Timeline.DateTime.DECADE,
    // intervalUnit:   Timeline.DateTime.WEEK,
    // intervalUnit:   Timeline.DateTime.CENTURY,
    intervalPixels: 50,
    eventSource: eventSrc,
    date: d,
    theme: theme,
    layout: 'original' // original, overview, detailed
  }), Timeline.createBandInfo({
    width: "25%",
    // intervalUnit:   Timeline.DateTime.WEEK,
    // intervalUnit:   Timeline.DateTime.DECADE,
    // intervalUnit:   Timeline.DateTime.MONTH,
    intervalUnit: Timeline.DateTime.CENTURY,
    // intervalUnit:   Timeline.DateTime.MILLENIUM,
    intervalPixels: 120,
    eventSource: eventSrc,
    date: d,
    theme: theme,
    layout: 'overview' // original, overview, detailed
  })];
  bandInfos[1].syncWith = 0;
  bandInfos[1].highlight = true;

  tl = Timeline.create(document.getElementById("tl"), bandInfos, Timeline.HORIZONTAL);
  // from a file
  // tl.loadJSON("data/euro_poland.tl.json", function(json, url) {
  //   eventSrc.loadJSON(json, url);
  // });
  // from the dynamic object; no idea why it needs a dummy url
  eventSrc.loadJSON(events, 'dummyUrl');
};

var resizeTimerID = null;

function onResize() {
  if (resizeTimerID == null) {
    resizeTimerID = window.setTimeout(function () {
      resizeTimerID = null;
      tl.layout();
    }, 500);
  }
}

function validateWhen(place) {
  // does Topotime place record have valid when object?
}

function buildEvent(place) {
  // console.log(place)
  // need validate function here
  // if(validateWhen(place)==true {})
  var event = {};
  event['id'] = place.properties.id;
  event['title'] = place.properties.label;
  event['description'] = !place.properties.description ? "" : place.properties.description;
  // assuming valid; we know it's there in toy example
  event['start'] = place.when.timespans[0].start.earliest;
  event['latestStart'] = !place.when.timespans[0].start.latest ? "" : place.when.timespans[0].start.latest;
  event['end'] = place.when.timespans[0].end.latest;
  event['earliestEnd'] = !place.when.timespans[0].end.latest ? "" : place.when.timespans[0].end.latest;
  event['durationEvent'] = "true";
  event['link'] = "";
  event['image'] = "";

  return event;
}

function buildSegmentEvent(feat) {
  console.log(' in buildSegmentEvent()', feat.when.timespan);
  // need validate function here
  // if(validateWhen(place)==true {})
  var event = {};
  event['id'] = feat.properties.segment_id;
  event['title'] = feat.properties.label;
  event['description'] = !feat.properties.description ? "" : feat.properties.description;
  // assuming valid; we know it's there in toy example
  event['start'] = feat.when.timespan[0];
  event['latestStart'] = feat.when.timespan[1] == "" ? "" : feat.when.timespan[1];
  event['earliestEnd'] = feat.when.timespan[2] == "" ? "" : feat.when.timespan[2];
  event['end'] = feat.when.timespan[3] == "" ? "" : feat.when.timespan[3];
  event['durationEvent'] = "true";
  event['link'] = "";
  event['image'] = "";
  // console.log('built ', event)
  return event;
}

function buildCollectionPeriod(coll) {
  window.ts = coll.when.timespan;
  var event = {};
  event['id'] = 'LinkedPlaces001';
  event['title'] = 'valid period, ' + coll.attributes.title;
  event['description'] = ts[4];
  event['start'] = ts[0];
  event['latestStart'] = ts[1] == "" ? "" : ts[1];
  event['earliestEnd'] = ts[2] == "" ? "" : ts[2];
  event['end'] = ts[3] == "" ? "" : ts[3];
  event['durationEvent'] = "true";
  event['link'] = "";
  // event['link'] = coll.attributes.uri;
  event['image'] = "";
  console.log('event', JSON.stringify(event));
  tlMidpoint = midpoint(ts, 'start');
  return event;
}

var mapStyles = {
  areas: {
    "color": "#993333",
    "weight": 1,
    "opacity": .8,
    "fillColor": "orange",
    "fillOpacity": 0.3
  },
  points: {
    "color": "#000",
    "fillColor": "#990000",
    "marker-size": "small",
    "marker-color": "#006600"
  },
  lines: {
    "color": "#FB2E35",
    "weight": 2,
    "opacity": 0.6
  },
  segments: {
    "color": "green",
    "weight": 3,
    "opacity": 0.6
  }
};

var geojsonMarkerOptions = {
  radius: 8,
  fillColor: "#ff7800",
  color: "#000",
  weight: 1,
  opacity: 1,
  fillOpacity: 0.8
};

function writePopup(layer) {
  console.log(layer);
}
function summarizeEvents(eventsObj) {
  // get bounds, midpoint, granularity
  // multi-day, -week, -month, -year
  console.log(eventsObj);
}
function startMapM(dataset) {
  // mapbox.js (non-gl)
  L.mapbox.accessToken = 'pk.eyJ1Ijoia2dlb2dyYXBoZXIiLCJhIjoiUmVralBPcyJ9.mJegAI1R6KR21x_CVVTlqw';

  // AWMC tiles in mapbox
  window.ttmap = L.mapbox.map('map', 'isawnyu.map-knmctlkh');

  /*  read a single FeatureCollection of
      Places (geometry.type == Point), and
      Routes (geometry.type == GeometryCollection or undefined)
        - route geometry.geometries[i] == LineString or MultiLineString
  */
  let featureLayer = L.mapbox.featureLayer().loadURL('data/' + dataset + '.geojson').on('ready', function () {
    console.log(featureLayer);
    // get Collection attributes
    window.collection = featureLayer._geojson;
    // set timeline midpoint
    tlMidpoint = midpoint(collection.when.timespan, 'mid');

    // build separate L.featureGroup for points & lines
    featureLayer.eachLayer(function (layer) {
      let geomF = layer.feature.geometry;
      let whenF = layer.feature.when;
      /*  feature cases:
          Place if(geomF.type == 'Point')
      */
      // put places features pointFeatures array
      if (geomF.type == 'Point') {
        let latlng = new L.LatLng(geomF.coordinates[1], geomF.coordinates[0]);
        let placeFeature = new L.CircleMarker(latlng, {
          color: '#000',
          fillColor: '#ffff00',
          radius: 4,
          fillOpacity: 0.8,
          weight: 1
        });
        placeFeature.bindPopup(layer.feature.properties.toponym);
        pointFeatures.push(placeFeature);
      }
      // the rest are routes with segments in a GeometryCollection
      else if (geomF.type == 'GeometryCollection') {
          // console.log('layer.feature', layer.feature)
          //* TODO: create feature for each geometry
          for (i in geomF.geometries) {
            // console.log(geomF.geometries[i])
            let whenObj = geomF.geometries[i].when;
            let feat = {
              "type": "Feature",
              "geometry": {
                "type": geomF.geometries[i].type,
                "coordinates": geomF.geometries[i].coordinates
              },
              "when": whenObj,
              "properties": geomF.geometries[i].properties
            };
            // console.log('feat', feat)
            // console.log('whenObj', whenObj)
            segment = new L.GeoJSON(feat, {
              style: mapStyles.segments
            }).bindPopup('<b>' + feat.properties.label + '</b><br/>(segment ' + feat.properties.segment_id + ')');

            lineFeatures.push(segment);

            //* build event object for timeline
            if (whenObj != ({} || '')) {
              if (collection.attributes.segmentType == 'journey') {
                eventsObj.events.push(buildSegmentEvent(feat));
              }
            }
          }
          if (eventsObj.events.length == 0) {
            // needs a period
            eventsObj.events.push(buildCollectionPeriod(collection));
            console.log('buid', buildCollectionPeriod(collection));
            console.log('period eventsObj', eventsObj.events[0]);
          }
        } else {
          console.log(whenF == undefined ? 'whenF undef' : whenF);
        }
    });
    // console.log(summarizeEvents(eventsObj))
    window.places = L.featureGroup(pointFeatures).addTo(ttmap);
    ttmap.fitBounds(places.getBounds());
    window.segments = L.featureGroup(lineFeatures).addTo(ttmap);
    initTimeline(eventsObj);
  });

  /* xuanzang
          "when": {
            "follows": "20604",
            "duration": "?",
            "timespan": [
              "[0645-01-01",
              "",
              "",
              "0645-12-31",
              "]"
            ]
          }
  */

  /* polands
          "when": {
            "timespans": [
              {
                "label": "in 800",
                "start": {
                  "earliest": "0750-01-01"
                },
                "end": {
                  "latest": "0850-12-31"
                }
              }
            ]
          }
  */
  // if (geomF.type ='GeometryCollection') {
  //   console.log('collection w/', geomF.geometries.length, ' segments; when = ', whenF)
  // }
  // console.log(layer.feature.when)
  // console.log()


  // build temporal object and pass to timeline
  // eventsObj.events.push(buildEvent(layer.feature));
  //     idToFeature['places'][layer.feature.properties.id] = layer._leaflet_id;
  //   })
  //   initTimeline(eventsObj);
  //   // initTimeline('');
  // })
  // .addTo(ttmap);

  // }


  // open popup
  // featureLayer._layers[92].openPopup()
  // style
  // featureLayer._layers[idToFeature['places']['pol03']].setStyle({fillColor :'blue'})

  // event format
  // {
  // 'dateTimeFormat': 'iso8601',
  // 'events' :
  //   [
  //     {'start': '1900', 'latestStart': '1901', 'earliestEnd': '1903', 'end': '1902',
  //     'title': 'Test 6g: Bad dates: earliestEnd > end',
  //     'description': 'Test 6g: Bad dates: earliestEnd > end',
  //     'durationEvent': true, 'image':'<url>', 'link':'<url>'
  //     },
  //     {}
  //   ]
}
// function startMapL(){
//   // Leaflet style
//   let ttmap = L.map('map')
//     .setView([50.064191736659104, 15.556640624999998], 4);
//   window.featureLayer = L.geoJson.ajax('data/polands.tt_feature-when.json',{
//     onEachFeature: function(feature, layer){
//       layer.bindPopup('foo, dammit')
//     }
//   })
//   .addTo(ttmap);
//
//   initTimeline(eventsObj);
// }

},{"@turf/buffer":1,"@turf/centroid":2,"mapbox.js":20,"querystring":38,"url":41}]},{},[43])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQHR1cmYvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2NlbnRyb2lkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2hlbHBlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvbWV0YS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JzbGl0ZS9jb3JzbGl0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLW5vcm1hbGl6ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzdHMvZGlzdC9qc3RzLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LmpzL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL2NvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL2ZlYXR1cmVfbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LmpzL3NyYy9mZWVkYmFjay5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL2Zvcm1hdF91cmwuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LmpzL3NyYy9nZW9jb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL2dlb2NvZGVyX2NvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LmpzL3NyYy9ncmlkLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC5qcy9zcmMvZ3JpZF9jb250cm9sLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC5qcy9zcmMvZ3JpZF9sYXllci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC5qcy9zcmMvbGVhZmxldC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL2xlZ2VuZF9jb250cm9sLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC5qcy9zcmMvbG9hZF90aWxlanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL21hcGJveC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL21hcGJveF9sb2dvLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC5qcy9zcmMvbWFya2VyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC5qcy9zcmMvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL3NoYXJlX2NvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LmpzL3NyYy9zaW1wbGVzdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL3N0eWxlX2xheWVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC5qcy9zcmMvdGlsZV9sYXllci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3guanMvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbXVzdGFjaGUvbXVzdGFjaGUuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYW5pdGl6ZS1jYWphL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Nhbml0aXplLWNhamEvc2FuaXRpemVyLWJ1bmRsZS5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwic3JjL2phdmFzY3JpcHRzL21hcF90dC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ252WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBLFFBQVEsV0FBUjtBQUNBLGNBQWMsUUFBUSxhQUFSLENBQWQ7QUFDQSxJQUFJLE1BQU0sUUFBUSxLQUFSLENBQVY7QUFBQSxJQUNFLGNBQWMsUUFBUSxhQUFSLENBRGhCO0FBQUEsSUFFRSxNQUFNLFFBQVEsZ0JBQVIsQ0FGUjtBQUFBLElBR0UsTUFBTSxRQUFRLGNBQVIsQ0FIUjtBQUlBLE9BQU8sU0FBUCxHQUFtQixJQUFJLEtBQUosQ0FBVSxPQUFPLFFBQVAsQ0FBZ0IsSUFBMUIsRUFBZ0MsSUFBaEMsRUFBc0MsSUFBdEMsQ0FBbkI7QUFDQSxPQUFPLFlBQVAsR0FBc0IsWUFBWSxLQUFaLENBQWtCLFVBQVUsTUFBVixDQUFpQixTQUFqQixDQUEyQixDQUEzQixDQUFsQixDQUF0QjtBQUNBLE9BQU8sQ0FBUCxHQUFXLFdBQVg7QUFDQSxPQUFPLElBQVAsR0FBYyxHQUFkO0FBQ0EsT0FBTyxJQUFQLEdBQWMsR0FBZDtBQUNBO0FBQ0E7QUFDQSxPQUFPLFdBQVAsR0FBcUIsRUFBQyxRQUFPLEVBQVIsRUFBckI7QUFDQSxPQUFPLFNBQVAsR0FBbUIsRUFBQyxrQkFBa0IsU0FBbkIsRUFBNkIsVUFBUyxFQUF0QyxFQUFuQjtBQUNBLE9BQU8sT0FBUCxHQUFpQixFQUFqQjtBQUNBLE9BQU8sYUFBUCxHQUF1QixFQUF2QjtBQUNBLE9BQU8sWUFBUCxHQUFzQixFQUF0QjtBQUNBLE9BQU8sRUFBUCxHQUFZLEVBQVo7QUFDQSxPQUFPLFVBQVAsR0FBb0IsRUFBcEI7O0FBRUEsRUFBRSxZQUFXO0FBQ1gsWUFBVSxhQUFhLEdBQWIsQ0FBVjtBQUNBLElBQUUsT0FBRixFQUFXLEtBQVgsQ0FBaUIsWUFBVTtBQUN6QixNQUFFLE9BQUYsRUFBVyxNQUFYLENBQWtCLE1BQWxCO0FBQ0QsR0FGRDtBQUdBLElBQUUsY0FBRixFQUFrQixJQUFsQixDQUF1QixhQUFhLEdBQWIsQ0FBdkI7QUFDRCxDQU5EOztBQVFBLE9BQU8sUUFBUCxHQUFrQixVQUFTLEVBQVQsRUFBWSxJQUFaLEVBQWtCO0FBQ2xDO0FBQ0EsTUFBRyxRQUFRLE9BQVgsRUFBb0I7QUFDbEIsUUFBSSxNQUFNLElBQUksSUFBSixDQUFTLEdBQUcsQ0FBSCxDQUFULENBQVY7QUFDRCxHQUZELE1BRU8sSUFBRyxRQUFRLEtBQVgsRUFBa0I7QUFDdkIsUUFBSSxRQUFRLElBQUksSUFBSixDQUFTLEdBQUcsQ0FBSCxDQUFULENBQVo7QUFDQSxRQUFJLE1BQU0sR0FBRyxDQUFILE1BQVUsTUFBTSxTQUFoQixJQUE2QixJQUFJLElBQUosQ0FBUyxLQUFLLEdBQUwsRUFBVCxDQUE3QixHQUFvRCxJQUFJLElBQUosQ0FBUyxHQUFHLENBQUgsQ0FBVCxDQUE5RDtBQUNBLFFBQUksTUFBTSxJQUFJLElBQUosQ0FBUyxDQUFDLE1BQU0sT0FBTixLQUFrQixJQUFJLE9BQUosRUFBbkIsSUFBb0MsQ0FBN0MsQ0FBVjtBQUNEO0FBQ0QsU0FBTyxHQUFQO0FBQ0QsQ0FWRDtBQVdBLE9BQU8sWUFBUCxHQUFzQixVQUFTLE1BQVQsRUFBaUI7QUFDckMsVUFBUSxHQUFSLENBQVksWUFBWixFQUF5QixVQUF6QjtBQUNBO0FBQ0E7QUFDQSxTQUFPLFFBQVAsR0FBa0IsSUFBSSxTQUFTLGtCQUFiLENBQWdDLENBQWhDLENBQWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSSxRQUFRLFNBQVMsWUFBVCxDQUFzQixNQUF0QixFQUFaO0FBQ0EsUUFBTSxLQUFOLENBQVksTUFBWixDQUFtQixLQUFuQixHQUEyQixHQUEzQjtBQUNBLFFBQU0sS0FBTixDQUFZLE1BQVosQ0FBbUIsTUFBbkIsR0FBNEIsR0FBNUI7O0FBRUE7QUFDQSxNQUFJLElBQUksU0FBUyxRQUFULENBQWtCLHNCQUFsQixDQUF5QyxVQUF6QyxDQUFSO0FBQ0EsTUFBSSxZQUFZLENBQ1osU0FBUyxjQUFULENBQXdCO0FBQ3BCLFdBQWdCLEtBREk7QUFFcEI7QUFDQSxrQkFBZ0IsU0FBUyxRQUFULENBQWtCLElBSGQ7QUFJcEI7QUFDQTtBQUNBO0FBQ0Esb0JBQWdCLEVBUEk7QUFRcEIsaUJBQWdCLFFBUkk7QUFTcEIsVUFBZ0IsQ0FUSTtBQVVwQixXQUFnQixLQVZJO0FBV3BCLFlBQWdCLFVBWEksQ0FXUTtBQVhSLEdBQXhCLENBRFksRUFjWixTQUFTLGNBQVQsQ0FBd0I7QUFDcEIsV0FBZ0IsS0FESTtBQUVwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBZ0IsU0FBUyxRQUFULENBQWtCLE9BTGQ7QUFNcEI7QUFDQSxvQkFBZ0IsR0FQSTtBQVFwQixpQkFBZ0IsUUFSSTtBQVNwQixVQUFnQixDQVRJO0FBVXBCLFdBQWdCLEtBVkk7QUFXcEIsWUFBZ0IsVUFYSSxDQVdRO0FBWFIsR0FBeEIsQ0FkWSxDQUFoQjtBQTRCQSxZQUFVLENBQVYsRUFBYSxRQUFiLEdBQXdCLENBQXhCO0FBQ0EsWUFBVSxDQUFWLEVBQWEsU0FBYixHQUF5QixJQUF6Qjs7QUFFQSxPQUFLLFNBQVMsTUFBVCxDQUFnQixTQUFTLGNBQVQsQ0FBd0IsSUFBeEIsQ0FBaEIsRUFBK0MsU0FBL0MsRUFBMEQsU0FBUyxVQUFuRSxDQUFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVMsUUFBVCxDQUFrQixNQUFsQixFQUEwQixVQUExQjtBQUNELENBcEREOztBQXNEQSxJQUFJLGdCQUFnQixJQUFwQjs7QUFFQSxTQUFTLFFBQVQsR0FBb0I7QUFDaEIsTUFBSSxpQkFBaUIsSUFBckIsRUFBMkI7QUFDdkIsb0JBQWdCLE9BQU8sVUFBUCxDQUFrQixZQUFXO0FBQ3pDLHNCQUFnQixJQUFoQjtBQUNBLFNBQUcsTUFBSDtBQUNILEtBSGUsRUFHYixHQUhhLENBQWhCO0FBSUg7QUFDSjs7QUFFRCxTQUFTLFlBQVQsQ0FBc0IsS0FBdEIsRUFBNEI7QUFDMUI7QUFDRDs7QUFFRCxTQUFTLFVBQVQsQ0FBb0IsS0FBcEIsRUFBMEI7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsTUFBSSxRQUFRLEVBQVo7QUFDQSxRQUFNLElBQU4sSUFBYyxNQUFNLFVBQU4sQ0FBaUIsRUFBL0I7QUFDQSxRQUFNLE9BQU4sSUFBaUIsTUFBTSxVQUFOLENBQWlCLEtBQWxDO0FBQ0EsUUFBTSxhQUFOLElBQXVCLENBQUMsTUFBTSxVQUFOLENBQWlCLFdBQWxCLEdBQWdDLEVBQWhDLEdBQXFDLE1BQU0sVUFBTixDQUFpQixXQUE3RTtBQUNBO0FBQ0EsUUFBTSxPQUFOLElBQWlCLE1BQU0sSUFBTixDQUFXLFNBQVgsQ0FBcUIsQ0FBckIsRUFBd0IsS0FBeEIsQ0FBOEIsUUFBL0M7QUFDQSxRQUFNLGFBQU4sSUFBdUIsQ0FBQyxNQUFNLElBQU4sQ0FBVyxTQUFYLENBQXFCLENBQXJCLEVBQXdCLEtBQXhCLENBQThCLE1BQS9CLEdBQXdDLEVBQXhDLEdBQTRDLE1BQU0sSUFBTixDQUFXLFNBQVgsQ0FBcUIsQ0FBckIsRUFBd0IsS0FBeEIsQ0FBOEIsTUFBakc7QUFDQSxRQUFNLEtBQU4sSUFBZSxNQUFNLElBQU4sQ0FBVyxTQUFYLENBQXFCLENBQXJCLEVBQXdCLEdBQXhCLENBQTRCLE1BQTNDO0FBQ0EsUUFBTSxhQUFOLElBQXVCLENBQUMsTUFBTSxJQUFOLENBQVcsU0FBWCxDQUFxQixDQUFyQixFQUF3QixHQUF4QixDQUE0QixNQUE3QixHQUFzQyxFQUF0QyxHQUEwQyxNQUFNLElBQU4sQ0FBVyxTQUFYLENBQXFCLENBQXJCLEVBQXdCLEdBQXhCLENBQTRCLE1BQTdGO0FBQ0EsUUFBTSxlQUFOLElBQXlCLE1BQXpCO0FBQ0EsUUFBTSxNQUFOLElBQWdCLEVBQWhCO0FBQ0EsUUFBTSxPQUFOLElBQWlCLEVBQWpCOztBQUVBLFNBQU8sS0FBUDtBQUNEOztBQUVELFNBQVMsaUJBQVQsQ0FBMkIsSUFBM0IsRUFBZ0M7QUFDOUIsVUFBUSxHQUFSLENBQVkseUJBQVosRUFBc0MsS0FBSyxJQUFMLENBQVUsUUFBaEQ7QUFDQTtBQUNBO0FBQ0EsTUFBSSxRQUFRLEVBQVo7QUFDQSxRQUFNLElBQU4sSUFBYyxLQUFLLFVBQUwsQ0FBZ0IsVUFBOUI7QUFDQSxRQUFNLE9BQU4sSUFBaUIsS0FBSyxVQUFMLENBQWdCLEtBQWpDO0FBQ0EsUUFBTSxhQUFOLElBQXVCLENBQUMsS0FBSyxVQUFMLENBQWdCLFdBQWpCLEdBQStCLEVBQS9CLEdBQW9DLEtBQUssVUFBTCxDQUFnQixXQUEzRTtBQUNBO0FBQ0EsUUFBTSxPQUFOLElBQWlCLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsQ0FBbkIsQ0FBakI7QUFDQSxRQUFNLGFBQU4sSUFBdUIsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixDQUFuQixLQUF5QixFQUF6QixHQUE4QixFQUE5QixHQUFrQyxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CLENBQW5CLENBQXpEO0FBQ0EsUUFBTSxhQUFOLElBQXVCLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsQ0FBbkIsS0FBeUIsRUFBekIsR0FBOEIsRUFBOUIsR0FBa0MsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixDQUFuQixDQUF6RDtBQUNBLFFBQU0sS0FBTixJQUFlLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsQ0FBbkIsS0FBeUIsRUFBekIsR0FBOEIsRUFBOUIsR0FBa0MsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixDQUFuQixDQUFqRDtBQUNBLFFBQU0sZUFBTixJQUF5QixNQUF6QjtBQUNBLFFBQU0sTUFBTixJQUFnQixFQUFoQjtBQUNBLFFBQU0sT0FBTixJQUFpQixFQUFqQjtBQUNBO0FBQ0EsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBUyxxQkFBVCxDQUErQixJQUEvQixFQUFvQztBQUNsQyxTQUFPLEVBQVAsR0FBWSxLQUFLLElBQUwsQ0FBVSxRQUF0QjtBQUNBLE1BQUksUUFBUSxFQUFaO0FBQ0EsUUFBTSxJQUFOLElBQWMsaUJBQWQ7QUFDQSxRQUFNLE9BQU4sSUFBaUIsbUJBQWlCLEtBQUssVUFBTCxDQUFnQixLQUFsRDtBQUNBLFFBQU0sYUFBTixJQUF1QixHQUFHLENBQUgsQ0FBdkI7QUFDQSxRQUFNLE9BQU4sSUFBaUIsR0FBRyxDQUFILENBQWpCO0FBQ0EsUUFBTSxhQUFOLElBQXVCLEdBQUcsQ0FBSCxLQUFTLEVBQVQsR0FBYyxFQUFkLEdBQWtCLEdBQUcsQ0FBSCxDQUF6QztBQUNBLFFBQU0sYUFBTixJQUF1QixHQUFHLENBQUgsS0FBUyxFQUFULEdBQWMsRUFBZCxHQUFrQixHQUFHLENBQUgsQ0FBekM7QUFDQSxRQUFNLEtBQU4sSUFBZSxHQUFHLENBQUgsS0FBUyxFQUFULEdBQWMsRUFBZCxHQUFrQixHQUFHLENBQUgsQ0FBakM7QUFDQSxRQUFNLGVBQU4sSUFBeUIsTUFBekI7QUFDQSxRQUFNLE1BQU4sSUFBZ0IsRUFBaEI7QUFDQTtBQUNBLFFBQU0sT0FBTixJQUFpQixFQUFqQjtBQUNBLFVBQVEsR0FBUixDQUFZLE9BQVosRUFBcUIsS0FBSyxTQUFMLENBQWUsS0FBZixDQUFyQjtBQUNBLGVBQWEsU0FBUyxFQUFULEVBQVksT0FBWixDQUFiO0FBQ0EsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQsSUFBSSxZQUFZO0FBQ2QsU0FBTztBQUNILGFBQVMsU0FETjtBQUVILGNBQVUsQ0FGUDtBQUdILGVBQVcsRUFIUjtBQUlILGlCQUFhLFFBSlY7QUFLSCxtQkFBZTtBQUxaLEdBRE87QUFRZCxVQUFRO0FBQ04sYUFBUyxNQURIO0FBRU4saUJBQWEsU0FGUDtBQUdOLG1CQUFlLE9BSFQ7QUFJTixvQkFBZ0I7QUFKVixHQVJNO0FBY2QsU0FBTztBQUNILGFBQVMsU0FETjtBQUVILGNBQVUsQ0FGUDtBQUdILGVBQVc7QUFIUixHQWRPO0FBbUJkLFlBQVU7QUFDTixhQUFTLE9BREg7QUFFTixjQUFVLENBRko7QUFHTixlQUFXO0FBSEw7QUFuQkksQ0FBaEI7O0FBMEJBLElBQUksdUJBQXVCO0FBQ3ZCLFVBQVEsQ0FEZTtBQUV2QixhQUFXLFNBRlk7QUFHdkIsU0FBTyxNQUhnQjtBQUl2QixVQUFRLENBSmU7QUFLdkIsV0FBUyxDQUxjO0FBTXZCLGVBQWE7QUFOVSxDQUEzQjs7QUFTQSxTQUFTLFVBQVQsQ0FBb0IsS0FBcEIsRUFBMkI7QUFDekIsVUFBUSxHQUFSLENBQVksS0FBWjtBQUNEO0FBQ0QsU0FBUyxlQUFULENBQXlCLFNBQXpCLEVBQW1DO0FBQ2pDO0FBQ0E7QUFDQSxVQUFRLEdBQVIsQ0FBWSxTQUFaO0FBQ0Q7QUFDRCxTQUFTLFNBQVQsQ0FBbUIsT0FBbkIsRUFBMkI7QUFDekI7QUFDQSxJQUFFLE1BQUYsQ0FBUyxXQUFULEdBQXVCLHdFQUF2Qjs7QUFFQTtBQUNBLFNBQU8sS0FBUCxHQUFlLEVBQUUsTUFBRixDQUFTLEdBQVQsQ0FBYSxLQUFiLEVBQW9CLHNCQUFwQixDQUFmOztBQUVBOzs7OztBQUtBLE1BQUksZUFBZSxFQUFFLE1BQUYsQ0FBUyxZQUFULEdBQ2hCLE9BRGdCLENBQ1IsVUFBVSxPQUFWLEdBQW9CLFVBRFosRUFFaEIsRUFGZ0IsQ0FFYixPQUZhLEVBRUosWUFBVTtBQUNyQixZQUFRLEdBQVIsQ0FBWSxZQUFaO0FBQ0E7QUFDQSxXQUFPLFVBQVAsR0FBb0IsYUFBYSxRQUFqQztBQUNBO0FBQ0EsaUJBQWEsU0FBUyxXQUFXLElBQVgsQ0FBZ0IsUUFBekIsRUFBa0MsS0FBbEMsQ0FBYjs7QUFFQTtBQUNBLGlCQUFhLFNBQWIsQ0FBdUIsVUFBUyxLQUFULEVBQWU7QUFDcEMsVUFBSSxRQUFRLE1BQU0sT0FBTixDQUFjLFFBQTFCO0FBQ0EsVUFBSSxRQUFRLE1BQU0sT0FBTixDQUFjLElBQTFCO0FBQ0E7OztBQUdBO0FBQ0EsVUFBRyxNQUFNLElBQU4sSUFBYyxPQUFqQixFQUEwQjtBQUN0QixZQUFJLFNBQVMsSUFBSSxFQUFFLE1BQU4sQ0FBYSxNQUFNLFdBQU4sQ0FBa0IsQ0FBbEIsQ0FBYixFQUFrQyxNQUFNLFdBQU4sQ0FBa0IsQ0FBbEIsQ0FBbEMsQ0FBYjtBQUNBLFlBQUksZUFBZSxJQUFJLEVBQUUsWUFBTixDQUFtQixNQUFuQixFQUEyQjtBQUM1QyxpQkFBTyxNQURxQztBQUU1QyxxQkFBVyxTQUZpQztBQUc1QyxrQkFBUSxDQUhvQztBQUk1Qyx1QkFBYSxHQUorQjtBQUs1QyxrQkFBUTtBQUxvQyxTQUEzQixDQUFuQjtBQU9BLHFCQUFhLFNBQWIsQ0FBdUIsTUFBTSxPQUFOLENBQWMsVUFBZCxDQUF5QixPQUFoRDtBQUNBLHNCQUFjLElBQWQsQ0FBbUIsWUFBbkI7QUFDSDtBQUNEO0FBWkEsV0FhSyxJQUFHLE1BQU0sSUFBTixJQUFjLG9CQUFqQixFQUF1QztBQUMxQztBQUNBO0FBQ0EsZUFBSSxDQUFKLElBQVMsTUFBTSxVQUFmLEVBQTJCO0FBQ3pCO0FBQ0UsZ0JBQUksVUFBVSxNQUFNLFVBQU4sQ0FBaUIsQ0FBakIsRUFBb0IsSUFBbEM7QUFDQSxnQkFBSSxPQUFPO0FBQ1Qsc0JBQU8sU0FERTtBQUVULDBCQUFZO0FBQ1Ysd0JBQU8sTUFBTSxVQUFOLENBQWlCLENBQWpCLEVBQW9CLElBRGpCO0FBRVYsK0JBQWMsTUFBTSxVQUFOLENBQWlCLENBQWpCLEVBQW9CO0FBRnhCLGVBRkg7QUFNVCxzQkFBUSxPQU5DO0FBT1QsNEJBQWMsTUFBTSxVQUFOLENBQWlCLENBQWpCLEVBQW9CO0FBUHpCLGFBQVg7QUFTQTtBQUNBO0FBQ0Esc0JBQVUsSUFBSSxFQUFFLE9BQU4sQ0FBYyxJQUFkLEVBQW9CO0FBQzFCLHFCQUFPLFVBQVU7QUFEUyxhQUFwQixFQUVMLFNBRkssQ0FFSyxRQUFNLEtBQUssVUFBTCxDQUFnQixLQUF0QixHQUE0QixvQkFBNUIsR0FDWCxLQUFLLFVBQUwsQ0FBZ0IsVUFETCxHQUNnQixHQUhyQixDQUFWOztBQUtBLHlCQUFhLElBQWIsQ0FBa0IsT0FBbEI7O0FBRUE7QUFDQSxnQkFBSSxZQUFZLE1BQU0sRUFBbEIsQ0FBSixFQUEyQjtBQUN6QixrQkFBSSxXQUFXLFVBQVgsQ0FBc0IsV0FBdEIsSUFBcUMsU0FBekMsRUFBb0Q7QUFDbEQsMEJBQVUsTUFBVixDQUFpQixJQUFqQixDQUFzQixrQkFBa0IsSUFBbEIsQ0FBdEI7QUFDRDtBQUNGO0FBQ0o7QUFDRCxjQUFHLFVBQVUsTUFBVixDQUFpQixNQUFqQixJQUEyQixDQUE5QixFQUFpQztBQUMvQjtBQUNBLHNCQUFVLE1BQVYsQ0FBaUIsSUFBakIsQ0FBc0Isc0JBQXNCLFVBQXRCLENBQXRCO0FBQ0Esb0JBQVEsR0FBUixDQUFZLE1BQVosRUFBbUIsc0JBQXNCLFVBQXRCLENBQW5CO0FBQ0Esb0JBQVEsR0FBUixDQUFZLGtCQUFaLEVBQWdDLFVBQVUsTUFBVixDQUFpQixDQUFqQixDQUFoQztBQUNEO0FBQ0YsU0FyQ0ksTUFxQ0U7QUFDTCxrQkFBUSxHQUFSLENBQVksU0FBUyxTQUFULEdBQXFCLGFBQXJCLEdBQXFDLEtBQWpEO0FBQ0Q7QUFDRixLQTVERDtBQTZEQTtBQUNBLFdBQU8sTUFBUCxHQUFnQixFQUFFLFlBQUYsQ0FBZSxhQUFmLEVBQThCLEtBQTlCLENBQW9DLEtBQXBDLENBQWhCO0FBQ0EsVUFBTSxTQUFOLENBQWdCLE9BQU8sU0FBUCxFQUFoQjtBQUNBLFdBQU8sUUFBUCxHQUFrQixFQUFFLFlBQUYsQ0FBZSxZQUFmLEVBQTZCLEtBQTdCLENBQW1DLEtBQW5DLENBQWxCO0FBQ0EsaUJBQWEsU0FBYjtBQUNELEdBNUVnQixDQUFuQjs7QUErRUY7Ozs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7Ozs7OztBQWVRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUo7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84Mzk4OTkvaG93LWRvLWktY2FsY3VsYXRlLWEtcG9pbnQtb24tYS1jaXJjbGVzLWNpcmN1bWZlcmVuY2Vcbi8vIHJhZGlhbnMgPSBkZWdyZWVzICogKHBpLzE4MClcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvYnVmZmVyLmh0bWxcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJyk7XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSBoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uO1xudmFyIGpzdHMgPSByZXF1aXJlKCdqc3RzJyk7XG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnZ2VvanNvbi1ub3JtYWxpemUnKTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgYnVmZmVyIGZvciBpbnB1dCBmZWF0dXJlcyBmb3IgYSBnaXZlbiByYWRpdXMuIFVuaXRzIHN1cHBvcnRlZCBhcmUgbWlsZXMsIGtpbG9tZXRlcnMsIGFuZCBkZWdyZWVzLlxuICpcbiAqIEBuYW1lIGJ1ZmZlclxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGZlYXR1cmUgaW5wdXQgdG8gYmUgYnVmZmVyZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgZGlzdGFuY2UgdG8gZHJhdyB0aGUgYnVmZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdW5pdHMgYW55IG9mIHRoZSBvcHRpb25zIHN1cHBvcnRlZCBieSB0dXJmIHVuaXRzXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPnxGZWF0dXJlQ29sbGVjdGlvbjxNdWx0aVBvbHlnb24+fFBvbHlnb258TXVsdGlQb2x5Z29ufSBidWZmZXJlZCBmZWF0dXJlc1xuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy05MC41NDg2MzAsIDE0LjYxNjU5OV1cbiAqICAgfVxuICogfTtcbiAqIHZhciB1bml0ID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgYnVmZmVyZWQgPSB0dXJmLmJ1ZmZlcihwdCwgNTAwLCB1bml0KTtcbiAqIHZhciByZXN1bHQgPSB0dXJmLmZlYXR1cmVjb2xsZWN0aW9uKFtidWZmZXJlZCwgcHRdKTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmZWF0dXJlLCByYWRpdXMsIHVuaXRzKSB7XG5cbiAgICB2YXIgZGVncmVlcyA9IGhlbHBlcnMuZGlzdGFuY2VUb0RlZ3JlZXMocmFkaXVzLCB1bml0cyk7XG4gICAgdmFyIGZjID0gbm9ybWFsaXplKGZlYXR1cmUpO1xuICAgIHZhciBidWZmZXJlZCA9IG5vcm1hbGl6ZShmZWF0dXJlQ29sbGVjdGlvbihmYy5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlck9wKGYsIGRlZ3JlZXMpO1xuICAgIH0pKSk7XG5cbiAgICBpZiAoYnVmZmVyZWQuZmVhdHVyZXMubGVuZ3RoID4gMSkgcmV0dXJuIGJ1ZmZlcmVkO1xuICAgIGVsc2UgaWYgKGJ1ZmZlcmVkLmZlYXR1cmVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJ1ZmZlcmVkLmZlYXR1cmVzWzBdO1xufTtcblxuZnVuY3Rpb24gYnVmZmVyT3AoZmVhdHVyZSwgcmFkaXVzKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05SZWFkZXIoKTtcbiAgICB2YXIgZ2VvbSA9IHJlYWRlci5yZWFkKGZlYXR1cmUuZ2VvbWV0cnkpO1xuICAgIHZhciBidWZmZXJlZCA9IGdlb20uYnVmZmVyKHJhZGl1cyk7XG4gICAgdmFyIHdyaXRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05Xcml0ZXIoKTtcbiAgICBidWZmZXJlZCA9IHdyaXRlci53cml0ZShidWZmZXJlZCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5OiBidWZmZXJlZCxcbiAgICAgICAgcHJvcGVydGllczoge31cbiAgICB9O1xufVxuIiwidmFyIGVhY2ggPSByZXF1aXJlKCdAdHVyZi9tZXRhJykuY29vcmRFYWNoO1xudmFyIHBvaW50ID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLnBvaW50O1xuXG4vKipcbiAqIFRha2VzIG9uZSBvciBtb3JlIGZlYXR1cmVzIGFuZCBjYWxjdWxhdGVzIHRoZSBjZW50cm9pZCB1c2luZ1xuICogdGhlIG1lYW4gb2YgYWxsIHZlcnRpY2VzLlxuICogVGhpcyBsZXNzZW5zIHRoZSBlZmZlY3Qgb2Ygc21hbGwgaXNsYW5kcyBhbmQgYXJ0aWZhY3RzIHdoZW4gY2FsY3VsYXRpbmdcbiAqIHRoZSBjZW50cm9pZCBvZiBhIHNldCBvZiBwb2x5Z29ucy5cbiAqXG4gKiBAbmFtZSBjZW50cm9pZFxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGZlYXR1cmVzIGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvaW50Pn0gdGhlIGNlbnRyb2lkIG9mIHRoZSBpbnB1dCBmZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFsxMDUuODE4OTM5LDIxLjAwNDcxNF0sXG4gKiAgICAgICBbMTA1LjgxODkzOSwyMS4wNjE3NTRdLFxuICogICAgICAgWzEwNS44OTAwMDcsMjEuMDYxNzU0XSxcbiAqICAgICAgIFsxMDUuODkwMDA3LDIxLjAwNDcxNF0sXG4gKiAgICAgICBbMTA1LjgxODkzOSwyMS4wMDQ3MTRdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgY2VudHJvaWRQdCA9IHR1cmYuY2VudHJvaWQocG9seSk7XG4gKlxuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcG9seSwgY2VudHJvaWRQdF1cbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgdmFyIHhTdW0gPSAwLCB5U3VtID0gMCwgbGVuID0gMDtcbiAgICBlYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgeFN1bSArPSBjb29yZFswXTtcbiAgICAgICAgeVN1bSArPSBjb29yZFsxXTtcbiAgICAgICAgbGVuKys7XG4gICAgfSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBvaW50KFt4U3VtIC8gbGVuLCB5U3VtIC8gbGVuXSk7XG59O1xuIiwiLyoqXG4gKiBXcmFwcyBhIEdlb0pTT04ge0BsaW5rIEdlb21ldHJ5fSBpbiBhIEdlb0pTT04ge0BsaW5rIEZlYXR1cmV9LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IGlucHV0IGdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgaW5wdXQgZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2VvbWV0cnkgPSB7XG4gKiAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgICAgIDY3LjUsXG4gKiAgICAgICAgMzIuODQyNjczNjMxOTU0MzFcbiAqICAgICAgXVxuICogICAgfVxuICpcbiAqIHZhciBmZWF0dXJlID0gdHVyZi5mZWF0dXJlKGdlb21ldHJ5KTtcbiAqXG4gKiAvLz1mZWF0dXJlXG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmUoZ2VvbWV0cnksIHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMgfHwge30sXG4gICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeVxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLmZlYXR1cmUgPSBmZWF0dXJlO1xuXG4vKipcbiAqIFRha2VzIGNvb3JkaW5hdGVzIGFuZCBwcm9wZXJ0aWVzIChvcHRpb25hbCkgYW5kIHJldHVybnMgYSBuZXcge0BsaW5rIFBvaW50fSBmZWF0dXJlLlxuICpcbiAqIEBuYW1lIHBvaW50XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcG9zaXRpb24gKGVhY2ggaW4gZGVjaW1hbCBkZWdyZWVzKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCB0aGF0IGlzIHVzZWQgYXMgdGhlIHtAbGluayBGZWF0dXJlfSdzXG4gKiBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdDEgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqXG4gKiAvLz1wdDFcbiAqL1xubW9kdWxlLmV4cG9ydHMucG9pbnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXMpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nvb3JkaW5hdGVzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdDb29yZGluYXRlcyBtdXN0IGJlIGF0IGxlYXN0IDIgbnVtYmVycyBsb25nJyk7XG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMuc2xpY2UoKVxuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5ncyBhbmQgb3B0aW9uYWxseSBhbiB7QGxpbmsgT2JqZWN0fSB3aXRoIHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgUG9seWdvbn0gZmVhdHVyZS5cbiAqXG4gKiBAbmFtZSBwb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZWFyUmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhIHByb3BlcnRpZXMgb2JqZWN0XG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2x5Z29uPn0gYSBQb2x5Z29uIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiBhIExpbmVhclJpbmcgb2YgdGhlIHBvbHlnb24gaGFzIHRvbyBmZXcgcG9zaXRpb25zXG4gKiBvciBpZiBhIExpbmVhclJpbmcgb2YgdGhlIFBvbHlnb24gZG9lcyBub3QgaGF2ZSBtYXRjaGluZyBQb3NpdGlvbnMgYXQgdGhlXG4gKiBiZWdpbm5pbmcgJiBlbmQuXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tcbiAqICBbLTIuMjc1NTQzLCA1My40NjQ1NDddLFxuICogIFstMi4yNzU1NDMsIDUzLjQ4OTI3MV0sXG4gKiAgWy0yLjIxNTExOCwgNTMuNDg5MjcxXSxcbiAqICBbLTIuMjE1MTE4LCA1My40NjQ1NDddLFxuICogIFstMi4yNzU1NDMsIDUzLjQ2NDU0N11cbiAqIF1dLCB7IG5hbWU6ICdwb2x5MScsIHBvcHVsYXRpb246IDQwMH0pO1xuICpcbiAqIC8vPXBvbHlnb25cbiAqL1xubW9kdWxlLmV4cG9ydHMucG9seWdvbiA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuXG4gICAgaWYgKCFjb29yZGluYXRlcykgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgaWYgKHJpbmcubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFYWNoIExpbmVhclJpbmcgb2YgYSBQb2x5Z29uIG11c3QgaGF2ZSA0IG9yIG1vcmUgUG9zaXRpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZ1tyaW5nLmxlbmd0aCAtIDFdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocmluZ1tyaW5nLmxlbmd0aCAtIDFdW2pdICE9PSByaW5nWzBdW2pdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhbmQgbGFzdCBQb3NpdGlvbiBhcmUgbm90IGVxdWl2YWxlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTGluZVN0cmluZ30gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBsaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb3NpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gYSBMaW5lU3RyaW5nIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmVzdHJpbmcxID0gdHVyZi5saW5lU3RyaW5nKFtcbiAqXHRbLTIxLjk2NDQxNiwgNjQuMTQ4MjAzXSxcbiAqXHRbLTIxLjk1NjE3NiwgNjQuMTQxMzE2XSxcbiAqXHRbLTIxLjkzOTAxLCA2NC4xMzU5MjRdLFxuICpcdFstMjEuOTI3MzM3LCA2NC4xMzY2NzNdXG4gKiBdKTtcbiAqIHZhciBsaW5lc3RyaW5nMiA9IHR1cmYubGluZVN0cmluZyhbXG4gKlx0Wy0yMS45MjkwNTQsIDY0LjEyNzk4NV0sXG4gKlx0Wy0yMS45MTI5MTgsIDY0LjEzNDcyNl0sXG4gKlx0Wy0yMS45MTYwMDcsIDY0LjE0MTAxNl0sXG4gKiBcdFstMjEuOTMwMDg0LCA2NC4xNDQ0Nl1cbiAqIF0sIHtuYW1lOiAnbGluZSAxJywgZGlzdGFuY2U6IDE0NX0pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmcxXG4gKlxuICogLy89bGluZXN0cmluZzJcbiAqL1xubW9kdWxlLmV4cG9ydHMubGluZVN0cmluZyA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBvbmUgb3IgbW9yZSB7QGxpbmsgRmVhdHVyZXxGZWF0dXJlc30gYW5kIGNyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0ZlYXR1cmVbXX0gZmVhdHVyZXMgaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbn0gYSBGZWF0dXJlQ29sbGVjdGlvbiBvZiBpbnB1dCBmZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IFtcbiAqICB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdLCB7bmFtZTogJ0xvY2F0aW9uIEEnfSksXG4gKiAgdHVyZi5wb2ludChbLTc1LjgzMywgMzkuMjg0XSwge25hbWU6ICdMb2NhdGlvbiBCJ30pLFxuICogIHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10sIHtuYW1lOiAnTG9jYXRpb24gQyd9KVxuICogXTtcbiAqXG4gKiB2YXIgZmMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbiAqXG4gKiAvLz1mY1xuICovXG5tb2R1bGUuZXhwb3J0cy5mZWF0dXJlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGZlYXR1cmVzOiBmZWF0dXJlc1xuICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpTGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVTdHJpbmdzXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gYSBNdWx0aUxpbmVTdHJpbmcgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlMaW5lID0gdHVyZi5tdWx0aUxpbmVTdHJpbmcoW1tbMCwwXSxbMTAsMTBdXV0pO1xuICpcbiAqIC8vPW11bHRpTGluZVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMubXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb3JkaW5hdGVzIHBhc3NlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpUG9pbnQ+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9pbnRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9pbnQ+fSBhIE11bHRpUG9pbnQgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlQdCA9IHR1cmYubXVsdGlQb2ludChbWzAsMF0sWzEwLDEwXV0pO1xuICpcbiAqIC8vPW11bHRpUHRcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLm11bHRpUG9pbnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aVBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbnNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aVBvbHlnb24+fSBhIG11bHRpcG9seWdvbiBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbW1tbMCwwXSxbMCwxMF0sWzEwLDEwXSxbMTAsMF0sWzAsMF1dXSk7XG4gKlxuICogLy89bXVsdGlQb2x5XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5tdWx0aVBvbHlnb24gPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBnZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8e0dlb21ldHJ5fT59IGdlb21ldHJpZXMgYW4gYXJyYXkgb2YgR2VvSlNPTiBHZW9tZXRyaWVzXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYSBHZW9KU09OIEdlb21ldHJ5Q29sbGVjdGlvbiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0ge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMDAsIDBdXG4gKiAgICAgfTtcbiAqIHZhciBsaW5lID0ge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsgWzEwMSwgMF0sIFsxMDIsIDFdIF1cbiAqICAgfTtcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5nZW9tZXRyeUNvbGxlY3Rpb24oW3B0LCBsaW5lXSk7XG4gKlxuICogLy89Y29sbGVjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoZ2VvbWV0cmllcywgcHJvcGVydGllcykge1xuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbicsXG4gICAgICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cbnZhciBmYWN0b3JzID0ge1xuICAgIG1pbGVzOiAzOTYwLFxuICAgIG5hdXRpY2FsbWlsZXM6IDM0NDEuMTQ1LFxuICAgIGRlZ3JlZXM6IDU3LjI5NTc3OTUsXG4gICAgcmFkaWFuczogMSxcbiAgICBpbmNoZXM6IDI1MDkwNTYwMCxcbiAgICB5YXJkczogNjk2OTYwMCxcbiAgICBtZXRlcnM6IDYzNzMwMDAsXG4gICAgbWV0cmVzOiA2MzczMDAwLFxuICAgIGtpbG9tZXRlcnM6IDYzNzMsXG4gICAga2lsb21ldHJlczogNjM3M1xufTtcblxuLypcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCBmcm9tIHJhZGlhbnMgdG8gYSBtb3JlIGZyaWVuZGx5IHVuaXQuXG4gKlxuICogQG5hbWUgcmFkaWFuc1RvRGlzdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBpbiByYWRpYW5zIGFjcm9zcyB0aGUgc3BoZXJlXG4gKiBAcGFyYW0ge3N0cmluZz1raWxvbWV0ZXJzfSB1bml0czogb25lIG9mIG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBkZWdyZWVzLCByYWRpYW5zLFxuICogaW5jaGVzLCB5YXJkcywgbWV0cmVzLCBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZVxuICovXG5tb2R1bGUuZXhwb3J0cy5yYWRpYW5zVG9EaXN0YW5jZSA9IGZ1bmN0aW9uIChyYWRpYW5zLCB1bml0cykge1xuICAgIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzIHx8ICdraWxvbWV0ZXJzJ107XG4gICAgaWYgKGZhY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG4gICAgfVxuICAgIHJldHVybiByYWRpYW5zICogZmFjdG9yO1xufTtcblxuLypcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCBmcm9tIGEgcmVhbC13b3JsZCB1bml0IGludG8gcmFkaWFuc1xuICpcbiAqIEBuYW1lIGRpc3RhbmNlVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmc9a2lsb21ldGVyc30gdW5pdHM6IG9uZSBvZiBtaWxlcywgbmF1dGljYWxtaWxlcywgZGVncmVlcywgcmFkaWFucyxcbiAqIGluY2hlcywgeWFyZHMsIG1ldHJlcywgbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gcmFkaWFuc1xuICovXG5tb2R1bGUuZXhwb3J0cy5kaXN0YW5jZVRvUmFkaWFucyA9IGZ1bmN0aW9uIChkaXN0YW5jZSwgdW5pdHMpIHtcbiAgICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0cyB8fCAna2lsb21ldGVycyddO1xuICAgIGlmIChmYWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5pdCcpO1xuICAgIH1cbiAgICByZXR1cm4gZGlzdGFuY2UgLyBmYWN0b3I7XG59O1xuXG4vKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byBkZWdyZWVzXG4gKlxuICogQG5hbWUgZGlzdGFuY2VUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBpbiByZWFsIHVuaXRzXG4gKiBAcGFyYW0ge3N0cmluZz1raWxvbWV0ZXJzfSB1bml0czogb25lIG9mIG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBkZWdyZWVzLCByYWRpYW5zLFxuICogaW5jaGVzLCB5YXJkcywgbWV0cmVzLCBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZWdyZWVzXG4gKi9cbm1vZHVsZS5leHBvcnRzLmRpc3RhbmNlVG9EZWdyZWVzID0gZnVuY3Rpb24gKGRpc3RhbmNlLCB1bml0cykge1xuICAgIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzIHx8ICdraWxvbWV0ZXJzJ107XG4gICAgaWYgKGZhY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG4gICAgfVxuICAgIHJldHVybiAoZGlzdGFuY2UgLyBmYWN0b3IpICogNTcuMjk1ODtcbn07XG4iLCIvKipcbiAqIEl0ZXJhdGUgb3ZlciBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgY29vcmRFYWNoXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzICh2YWx1ZSlcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGV4Y2x1ZGVXcmFwQ29vcmQgd2hldGhlciBvciBub3QgdG8gaW5jbHVkZVxuICogdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFswLCAwXSB9O1xuICogY29vcmRFYWNoKHBvaW50LCBmdW5jdGlvbihjb29yZHMpIHtcbiAqICAgLy8gY29vcmRzIGlzIGVxdWFsIHRvIFswLCAwXVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkRWFjaChsYXllciwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgICB2YXIgaSwgaiwgaywgZywgbCwgZ2VvbWV0cnksIHN0b3BHLCBjb29yZHMsXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxuICAgICAgICB3cmFwU2hyaW5rID0gMCxcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSBsYXllci50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBpc0ZlYXR1cmUgPSBsYXllci50eXBlID09PSAnRmVhdHVyZScsXG4gICAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gbGF5ZXIuZmVhdHVyZXMubGVuZ3RoIDogMTtcblxuICAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxuICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XG4gIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXG4gIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxuICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXG4gICAgZm9yIChpID0gMDsgaSA8IHN0b3A7IGkrKykge1xuXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBsYXllci5mZWF0dXJlc1tpXS5nZW9tZXRyeSA6XG4gICAgICAgIChpc0ZlYXR1cmUgPyBsYXllci5nZW9tZXRyeSA6IGxheWVyKSk7XG4gICAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbic7XG4gICAgICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA6IDE7XG5cbiAgICAgICAgZm9yIChnID0gMDsgZyA8IHN0b3BHOyBnKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gP1xuICAgICAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnXSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuICAgICAgICAgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgICAgIHdyYXBTaHJpbmsgPSAoZXhjbHVkZVdyYXBDb29yZCAmJlxuICAgICAgICAgICAgICAgIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpKSA/XG4gICAgICAgICAgICAgICAgMSA6IDA7XG5cbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIGNhbGxiYWNrKGNvb3Jkc1tqXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoIC0gd3JhcFNocmluazsgaysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzW2pdW2tdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8IGNvb3Jkc1tqXVtrXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBsKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzW2pdW2tdW2xdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgY29vcmRFYWNoKGdlb21ldHJ5Lmdlb21ldHJpZXNbal0sIGNhbGxiYWNrLCBleGNsdWRlV3JhcENvb3JkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEdlb21ldHJ5IFR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLmNvb3JkRWFjaCA9IGNvb3JkRWFjaDtcblxuLyoqXG4gKiBSZWR1Y2UgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXG4gKiB0aGUgcmVkdWN0aW9uLCBzbyBhbiBhcnJheSBvZiBhbGwgY29vcmRpbmF0ZXMgaXMgdW5uZWNlc3NhcnkuXG4gKlxuICogQG5hbWUgY29vcmRSZWR1Y2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKG1lbW8sIHZhbHVlKSBhbmQgcmV0dXJuc1xuICogYSBuZXcgbWVtb1xuICogQHBhcmFtIHsqfSBtZW1vIHRoZSBzdGFydGluZyB2YWx1ZSBvZiBtZW1vOiBjYW4gYmUgYW55IHR5cGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlV3JhcENvb3JkIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGVcbiAqIHRoZSBmaW5hbCBjb29yZGluYXRlIG9mIExpbmVhclJpbmdzIHRoYXQgd3JhcHMgdGhlIHJpbmcgaW4gaXRzIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBjb21iaW5lZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBjb29yZFJlZHVjZShsYXllciwgY2FsbGJhY2ssIG1lbW8sIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgICBjb29yZEVhY2gobGF5ZXIsIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICBtZW1vID0gY2FsbGJhY2sobWVtbywgY29vcmQpO1xuICAgIH0sIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICAgIHJldHVybiBtZW1vO1xufVxubW9kdWxlLmV4cG9ydHMuY29vcmRSZWR1Y2UgPSBjb29yZFJlZHVjZTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgcHJvcGVydHkgb2JqZWN0cyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgcHJvcEVhY2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHZhbHVlKVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHsgdHlwZTogJ0ZlYXR1cmUnLCBnZW9tZXRyeTogbnVsbCwgcHJvcGVydGllczogeyBmb286IDEgfSB9O1xuICogcHJvcEVhY2gocG9pbnQsIGZ1bmN0aW9uKHByb3BzKSB7XG4gKiAgIC8vIHByb3BzIGlzIGVxdWFsIHRvIHsgZm9vOiAxfVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHByb3BFYWNoKGxheWVyLCBjYWxsYmFjaykge1xuICAgIHZhciBpO1xuICAgIHN3aXRjaCAobGF5ZXIudHlwZSkge1xuICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhsYXllci5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgY2FsbGJhY2sobGF5ZXIucHJvcGVydGllcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLnByb3BFYWNoID0gcHJvcEVhY2g7XG5cbi8qKlxuICogUmVkdWNlIHByb3BlcnRpZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXG4gKiB0aGUgcmVkdWN0aW9uLCBzbyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyBpcyB1bm5lY2Vzc2FyeS5cbiAqXG4gKiBAbmFtZSBwcm9wUmVkdWNlXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChtZW1vLCBjb29yZCkgYW5kIHJldHVybnNcbiAqIGEgbmV3IG1lbW9cbiAqIEBwYXJhbSB7Kn0gbWVtbyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgbWVtbzogY2FuIGJlIGFueSB0eXBlLlxuICogQHJldHVybnMgeyp9IGNvbWJpbmVkIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogLy8gYW4gZXhhbXBsZSBvZiBhbiBldmVuIG1vcmUgYWR2YW5jZWQgZnVuY3Rpb24gdGhhdCBnaXZlcyB5b3UgdGhlXG4gKiAvLyBqYXZhc2NyaXB0IHR5cGUgb2YgZWFjaCBwcm9wZXJ0eSBvZiBldmVyeSBmZWF0dXJlXG4gKiBmdW5jdGlvbiBwcm9wVHlwZXMgKGxheWVyKSB7XG4gKiAgIG9wdHMgPSBvcHRzIHx8IHt9XG4gKiAgIHJldHVybiBwcm9wUmVkdWNlKGxheWVyLCBmdW5jdGlvbiAocHJldiwgcHJvcHMpIHtcbiAqICAgICBmb3IgKHZhciBwcm9wIGluIHByb3BzKSB7XG4gKiAgICAgICBpZiAocHJldltwcm9wXSkgY29udGludWVcbiAqICAgICAgIHByZXZbcHJvcF0gPSB0eXBlb2YgcHJvcHNbcHJvcF1cbiAqICAgICB9XG4gKiAgIH0sIHt9KVxuICogfVxuICovXG5mdW5jdGlvbiBwcm9wUmVkdWNlKGxheWVyLCBjYWxsYmFjaywgbWVtbykge1xuICAgIHByb3BFYWNoKGxheWVyLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBtZW1vID0gY2FsbGJhY2sobWVtbywgcHJvcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lbW87XG59XG5tb2R1bGUuZXhwb3J0cy5wcm9wUmVkdWNlID0gcHJvcFJlZHVjZTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVFYWNoXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzICh2YWx1ZSlcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZSA9IHsgdHlwZTogJ0ZlYXR1cmUnLCBnZW9tZXRyeTogbnVsbCwgcHJvcGVydGllczoge30gfTtcbiAqIGZlYXR1cmVFYWNoKGZlYXR1cmUsIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAqICAgLy8gZmVhdHVyZSA9PSBmZWF0dXJlXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZmVhdHVyZUVhY2gobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGxheWVyLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBjYWxsYmFjayhsYXllcik7XG4gICAgfSBlbHNlIGlmIChsYXllci50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyLmZlYXR1cmVzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLmZlYXR1cmVFYWNoID0gZmVhdHVyZUVhY2g7XG5cbi8qKlxuICogR2V0IGFsbCBjb29yZGluYXRlcyBmcm9tIGFueSBHZW9KU09OIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGNvb3JkaW5hdGVcbiAqIGFycmF5cy5cbiAqXG4gKiBAbmFtZSBjb29yZEFsbFxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxuICogQHJldHVybnMge0FycmF5PEFycmF5PE51bWJlcj4+fSBjb29yZGluYXRlIHBvc2l0aW9uIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvb3JkQWxsKGxheWVyKSB7XG4gICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgIGNvb3JkRWFjaChsYXllciwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIGNvb3Jkcy5wdXNoKGNvb3JkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29vcmRzO1xufVxubW9kdWxlLmV4cG9ydHMuY29vcmRBbGwgPSBjb29yZEFsbDtcbiIsImZ1bmN0aW9uIGNvcnNsaXRlKHVybCwgY2FsbGJhY2ssIGNvcnMpIHtcbiAgICB2YXIgc2VudCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvcignQnJvd3NlciBub3Qgc3VwcG9ydGVkJykpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29ycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIG0gPSB1cmwubWF0Y2goL15cXHMqaHR0cHM/OlxcL1xcL1teXFwvXSovKTtcbiAgICAgICAgY29ycyA9IG0gJiYgKG1bMF0gIT09IGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmRvbWFpbiArXG4gICAgICAgICAgICAgICAgKGxvY2F0aW9uLnBvcnQgPyAnOicgKyBsb2NhdGlvbi5wb3J0IDogJycpKTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIGZ1bmN0aW9uIGlzU3VjY2Vzc2Z1bChzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuICAgIH1cblxuICAgIGlmIChjb3JzICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4geCkpIHtcbiAgICAgICAgLy8gSUU4LTlcbiAgICAgICAgeCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcblxuICAgICAgICAvLyBFbnN1cmUgY2FsbGJhY2sgaXMgbmV2ZXIgY2FsbGVkIHN5bmNocm9ub3VzbHksIGkuZS4sIGJlZm9yZVxuICAgICAgICAvLyB4LnNlbmQoKSByZXR1cm5zICh0aGlzIGhhcyBiZWVuIG9ic2VydmVkIGluIHRoZSB3aWxkKS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LmpzL2lzc3Vlcy80NzJcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc2VudCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbC5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRlZCgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gWERvbWFpblJlcXVlc3RcbiAgICAgICAgICAgIHguc3RhdHVzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAgICAgaXNTdWNjZXNzZnVsKHguc3RhdHVzKSkgY2FsbGJhY2suY2FsbCh4LCBudWxsLCB4KTtcbiAgICAgICAgZWxzZSBjYWxsYmFjay5jYWxsKHgsIHgsIG51bGwpO1xuICAgIH1cblxuICAgIC8vIEJvdGggYG9ucmVhZHlzdGF0ZWNoYW5nZWAgYW5kIGBvbmxvYWRgIGNhbiBmaXJlLiBgb25yZWFkeXN0YXRlY2hhbmdlYFxuICAgIC8vIGhhcyBbYmVlbiBzdXBwb3J0ZWQgZm9yIGxvbmdlcl0oaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTE4MTUwOC8yMjkwMDEpLlxuICAgIGlmICgnb25sb2FkJyBpbiB4KSB7XG4gICAgICAgIHgub25sb2FkID0gbG9hZGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHgub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gcmVhZHlzdGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICh4LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBsb2FkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBYTUxIdHRwUmVxdWVzdCBvYmplY3QgYXMgYW4gZXJyb3IgYW5kIHByZXZlbnRcbiAgICAvLyBpdCBmcm9tIGV2ZXIgYmVpbmcgY2FsbGVkIGFnYWluIGJ5IHJlYXNzaWduaW5nIGl0IHRvIGBub29wYFxuICAgIHgub25lcnJvciA9IGZ1bmN0aW9uIGVycm9yKGV2dCkge1xuICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBwcm92aWRlcyBubyBldnQgcGFyYW1ldGVyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZ0IHx8IHRydWUsIG51bGwpO1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIH07XG5cbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuICAgIHgub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4gICAgeC5vbnRpbWVvdXQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldnQsIG51bGwpO1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIH07XG5cbiAgICB4Lm9uYWJvcnQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldnQsIG51bGwpO1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIH07XG5cbiAgICAvLyBHRVQgaXMgdGhlIG9ubHkgc3VwcG9ydGVkIEhUVFAgVmVyYiBieSBYRG9tYWluUmVxdWVzdCBhbmQgaXMgdGhlXG4gICAgLy8gb25seSBvbmUgc3VwcG9ydGVkIGhlcmUuXG4gICAgeC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdC4gU2VuZGluZyBkYXRhIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgeC5zZW5kKG51bGwpO1xuICAgIHNlbnQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHg7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBjb3JzbGl0ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplO1xuXG52YXIgdHlwZXMgPSB7XG4gICAgUG9pbnQ6ICdnZW9tZXRyeScsXG4gICAgTXVsdGlQb2ludDogJ2dlb21ldHJ5JyxcbiAgICBMaW5lU3RyaW5nOiAnZ2VvbWV0cnknLFxuICAgIE11bHRpTGluZVN0cmluZzogJ2dlb21ldHJ5JyxcbiAgICBQb2x5Z29uOiAnZ2VvbWV0cnknLFxuICAgIE11bHRpUG9seWdvbjogJ2dlb21ldHJ5JyxcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb246ICdnZW9tZXRyeScsXG4gICAgRmVhdHVyZTogJ2ZlYXR1cmUnLFxuICAgIEZlYXR1cmVDb2xsZWN0aW9uOiAnZmVhdHVyZWNvbGxlY3Rpb24nXG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIEdlb0pTT04gZmVhdHVyZSBpbnRvIGEgRmVhdHVyZUNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdqIGdlb2pzb24gZGF0YVxuICogQHJldHVybnMge29iamVjdH0gbm9ybWFsaXplZCBnZW9qc29uIGRhdGFcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGdqKSB7XG4gICAgaWYgKCFnaiB8fCAhZ2oudHlwZSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHR5cGUgPSB0eXBlc1tnai50eXBlXTtcbiAgICBpZiAoIXR5cGUpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKHR5cGUgPT09ICdnZW9tZXRyeScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICBmZWF0dXJlczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdqXG4gICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ZlYXR1cmUnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgZmVhdHVyZXM6IFtnal1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmZWF0dXJlY29sbGVjdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGdqO1xuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIEpTVFMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzXG4vLyBMaWNlbnNlczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FREx2MS50eHRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FUEx2MS50eHRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9MSUNFTlNFX0VTNl9DT0xMRUNUSU9OUy50eHRcbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUodC5qc3RzPXQuanN0c3x8e30pfSh0aGlzLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUodCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKX1mdW5jdGlvbiBuKCl7fWZ1bmN0aW9uIGkoKXt9ZnVuY3Rpb24gcigpe31mdW5jdGlvbiBzKCl7fWZ1bmN0aW9uIG8oKXt9ZnVuY3Rpb24gYSgpe31mdW5jdGlvbiB1KCl7fWZ1bmN0aW9uIGwodCl7dGhpcy5uYW1lPVwiUnVudGltZUV4Y2VwdGlvblwiLHRoaXMubWVzc2FnZT10LHRoaXMuc3RhY2s9KG5ldyBFcnJvcikuc3RhY2ssRXJyb3IuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIGgodCxlKXt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10fWZ1bmN0aW9uIGMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClsLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2wuY2FsbCh0aGlzLHQpfX1mdW5jdGlvbiBmKCl7fWZ1bmN0aW9uIGcoKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLno9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClnLmNhbGwodGhpcywwLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtnLmNhbGwodGhpcyx0LngsdC55LHQueil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2cuY2FsbCh0aGlzLGUsbixnLk5VTExfT1JESU5BVEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLng9aSx0aGlzLnk9cix0aGlzLno9c319ZnVuY3Rpb24gZCgpe2lmKHRoaXMuZGltZW5zaW9uc1RvVGVzdD0yLDA9PT1hcmd1bWVudHMubGVuZ3RoKWQuY2FsbCh0aGlzLDIpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtpZigyIT09dCYmMyE9PXQpdGhyb3cgbmV3IGkoXCJvbmx5IDIgb3IgMyBkaW1lbnNpb25zIG1heSBiZSBzcGVjaWZpZWRcIik7dGhpcy5kaW1lbnNpb25zVG9UZXN0PXR9fWZ1bmN0aW9uIHAoKXt9ZnVuY3Rpb24gdigpe31mdW5jdGlvbiBtKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIHkoKXt9ZnVuY3Rpb24geCh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBFKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIEkoKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9ZnVuY3Rpb24gTigpe2lmKEkuYXBwbHkodGhpcyksMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmVuc3VyZUNhcGFjaXR5KHQubGVuZ3RoKSx0aGlzLmFkZCh0LCEwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5lbnN1cmVDYXBhY2l0eShlLmxlbmd0aCksdGhpcy5hZGQoZSxuKX19ZnVuY3Rpb24gQygpe2lmKHRoaXMubWlueD1udWxsLHRoaXMubWF4eD1udWxsLHRoaXMubWlueT1udWxsLHRoaXMubWF4eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5pbml0KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5pbml0KG4ueCxpLngsbi55LGkueSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9YXJndW1lbnRzWzNdO3RoaXMuaW5pdChyLHMsbyxhKX19ZnVuY3Rpb24gUygpe31mdW5jdGlvbiB3KCl7Uy5jYWxsKHRoaXMsXCJQcm9qZWN0aXZlIHBvaW50IG5vdCByZXByZXNlbnRhYmxlIG9uIHRoZSBDYXJ0ZXNpYW4gcGxhbmUuXCIpfWZ1bmN0aW9uIEwoKXt9ZnVuY3Rpb24gUih0LGUpe3JldHVybiB0LmludGVyZmFjZXNfJiZ0LmludGVyZmFjZXNfKCkuaW5kZXhPZihlKT4tMX1mdW5jdGlvbiBUKCl7fWZ1bmN0aW9uIFAodCl7dGhpcy5zdHI9dH1mdW5jdGlvbiBiKHQpe3RoaXMudmFsdWU9dH1mdW5jdGlvbiBPKCl7fWZ1bmN0aW9uIF8oKXtpZih0aGlzLmhpPTAsdGhpcy5sbz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5pbml0KGUpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIG49YXJndW1lbnRzWzBdO18uY2FsbCh0aGlzLF8ucGFyc2UobikpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07dGhpcy5pbml0KGkscil9fWZ1bmN0aW9uIE0oKXt9ZnVuY3Rpb24gRCgpe31mdW5jdGlvbiBBKCl7fWZ1bmN0aW9uIEYoKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLnc9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLng9MCx0aGlzLnk9MCx0aGlzLnc9MTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMudz0xfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLng9ZSx0aGlzLnk9bix0aGlzLnc9MX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBGKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07dGhpcy54PWkueSpyLnctci55Kmkudyx0aGlzLnk9ci54Kmkudy1pLngqci53LHRoaXMudz1pLngqci55LXIueCppLnl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdO3RoaXMueD1zLnktby55LHRoaXMueT1vLngtcy54LHRoaXMudz1zLngqby55LW8ueCpzLnl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXSxsPWFyZ3VtZW50c1syXTt0aGlzLng9YSx0aGlzLnk9dSx0aGlzLnc9bH1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaD1hcmd1bWVudHNbMF0sYz1hcmd1bWVudHNbMV0sZj1hcmd1bWVudHNbMl0sZD1hcmd1bWVudHNbM10scD1oLnktYy55LHY9Yy54LWgueCxtPWgueCpjLnktYy54KmgueSx5PWYueS1kLnkseD1kLngtZi54LEU9Zi54KmQueS1kLngqZi55O3RoaXMueD12KkUteCptLHRoaXMueT15Km0tcCpFLHRoaXMudz1wKngteSp2fX1mdW5jdGlvbiBHKCl7fWZ1bmN0aW9uIHEoKXt9ZnVuY3Rpb24gQigpe3RoaXMuZW52ZWxvcGU9bnVsbCx0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLlNSSUQ9bnVsbCx0aGlzLnVzZXJEYXRhPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10LHRoaXMuU1JJRD10LmdldFNSSUQoKX1mdW5jdGlvbiB6KCl7fWZ1bmN0aW9uIFYoKXt9ZnVuY3Rpb24gaygpe31mdW5jdGlvbiBZKCl7fWZ1bmN0aW9uIFUoKXt9ZnVuY3Rpb24gWCgpe31mdW5jdGlvbiBIKCl7fWZ1bmN0aW9uIFcoKXt9ZnVuY3Rpb24gaigpe31mdW5jdGlvbiBLKCl7fWZ1bmN0aW9uIFooKXt9ZnVuY3Rpb24gUSgpe31mdW5jdGlvbiBKKCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB2JiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfWZ1bmN0aW9uICQodCl7cmV0dXJuIG51bGw9PXQ/JHM6dC5jb2xvcn1mdW5jdGlvbiB0dCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucGFyZW50fWZ1bmN0aW9uIGV0KHQsZSl7bnVsbCE9PXQmJih0LmNvbG9yPWUpfWZ1bmN0aW9uIG50KHQpe3JldHVybiBudWxsPT10P251bGw6dC5sZWZ0fWZ1bmN0aW9uIGl0KHQpe3JldHVybiBudWxsPT10P251bGw6dC5yaWdodH1mdW5jdGlvbiBydCgpe3RoaXMucm9vdF89bnVsbCx0aGlzLnNpemVfPTB9ZnVuY3Rpb24gc3QoKXt9ZnVuY3Rpb24gb3QoKXt9ZnVuY3Rpb24gYXQoKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9ZnVuY3Rpb24gdXQoKXt9ZnVuY3Rpb24gbHQoKXt9ZnVuY3Rpb24gaHQoKXt9ZnVuY3Rpb24gY3QoKXt9ZnVuY3Rpb24gZnQoKXt0aGlzLmdlb21ldHJpZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoQi5jYWxsKHRoaXMsZSksbnVsbD09PXQmJih0PVtdKSxCLmhhc051bGxFbGVtZW50cyh0KSl0aHJvdyBuZXcgaShcImdlb21ldHJpZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO3RoaXMuZ2VvbWV0cmllcz10fWZ1bmN0aW9uIGd0KCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Z0LmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIGR0KCl7aWYodGhpcy5nZW9tPW51bGwsdGhpcy5nZW9tRmFjdD1udWxsLHRoaXMuYm5SdWxlPW51bGwsdGhpcy5lbmRwb2ludE1hcD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07ZHQuY2FsbCh0aGlzLHQsVi5NT0QyX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmdlb209ZSx0aGlzLmdlb21GYWN0PWUuZ2V0RmFjdG9yeSgpLHRoaXMuYm5SdWxlPW59fWZ1bmN0aW9uIHB0KCl7dGhpcy5jb3VudD1udWxsfWZ1bmN0aW9uIHZ0KCl7fWZ1bmN0aW9uIG10KCl7fWZ1bmN0aW9uIHl0KCl7fWZ1bmN0aW9uIHh0KCl7fWZ1bmN0aW9uIEV0KCl7fWZ1bmN0aW9uIEl0KCl7fWZ1bmN0aW9uIE50KCl7fWZ1bmN0aW9uIEN0KCl7fWZ1bmN0aW9uIFN0KCl7dGhpcy5wb2ludHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Qi5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfWZ1bmN0aW9uIHd0KCl7fWZ1bmN0aW9uIEx0KCl7dGhpcy5jb29yZGluYXRlcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtCLmNhbGwodGhpcyxlKSx0aGlzLmluaXQodCl9ZnVuY3Rpb24gUnQoKXt9ZnVuY3Rpb24gVHQoKXt0aGlzLnNoZWxsPW51bGwsdGhpcy5ob2xlcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihCLmNhbGwodGhpcyxuKSxudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZygpKSxudWxsPT09ZSYmKGU9W10pLEIuaGFzTnVsbEVsZW1lbnRzKGUpKXRocm93IG5ldyBpKFwiaG9sZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO2lmKHQuaXNFbXB0eSgpJiZCLmhhc05vbkVtcHR5RWxlbWVudHMoZSkpdGhyb3cgbmV3IGkoXCJzaGVsbCBpcyBlbXB0eSBidXQgaG9sZXMgYXJlIG5vdFwiKTt0aGlzLnNoZWxsPXQsdGhpcy5ob2xlcz1lfWZ1bmN0aW9uIFB0KCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Z0LmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIGJ0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGllKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YnQuY2FsbCh0aGlzLGUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KSxlKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLEQpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGllKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07U3QuY2FsbCh0aGlzLG4saSksdGhpcy52YWxpZGF0ZUNvbnN0cnVjdGlvbigpfX1mdW5jdGlvbiBPdCgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmdC5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBfdCgpe2lmKHRoaXMuZmFjdG9yeT1udWxsLHRoaXMuaXNVc2VyRGF0YUNvcGllZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fX1mdW5jdGlvbiBNdCgpe31mdW5jdGlvbiBEdCgpe31mdW5jdGlvbiBBdCgpe31mdW5jdGlvbiBGdCgpe31mdW5jdGlvbiBHdCgpe2lmKHRoaXMuZGltZW5zaW9uPTMsdGhpcy5jb29yZGluYXRlcz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07R3QuY2FsbCh0aGlzLHQsMyl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2Zvcih2YXIgbj0wO2U+bjtuKyspdGhpcy5jb29yZGluYXRlc1tuXT1uZXcgZ31lbHNlIGlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgaT1hcmd1bWVudHNbMF07aWYobnVsbD09PWkpcmV0dXJuIHRoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KDApLmZpbGwobnVsbCksbnVsbDt0aGlzLmRpbWVuc2lvbj1pLmdldERpbWVuc2lvbigpLHRoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KGkuc2l6ZSgpKS5maWxsKG51bGwpO2Zvcih2YXIgbj0wO248dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7bisrKXRoaXMuY29vcmRpbmF0ZXNbbl09aS5nZXRDb29yZGluYXRlQ29weShuKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXTt0aGlzLmNvb3JkaW5hdGVzPXIsdGhpcy5kaW1lbnNpb249cyxudWxsPT09ciYmKHRoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KDApLmZpbGwobnVsbCkpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXTt0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheShvKS5maWxsKG51bGwpLHRoaXMuZGltZW5zaW9uPWE7Zm9yKHZhciBuPTA7bz5uO24rKyl0aGlzLmNvb3JkaW5hdGVzW25dPW5ldyBnfX1mdW5jdGlvbiBxdCgpe31mdW5jdGlvbiBCdCh0LGUpe3JldHVybiB0PT09ZXx8dCE9PXQmJmUhPT1lfWZ1bmN0aW9uIHp0KHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdGhpcyYmdGhpcy5jb25zdHJ1Y3Rvcj09PW4/KHRoaXMuX2tleXM9W10sdGhpcy5fdmFsdWVzPVtdLHRoaXMuX2l0cD1bXSx0aGlzLm9iamVjdE9ubHk9ZSx2b2lkKHQmJlZ0LmNhbGwodGhpcyx0KSkpOm5ldyBuKHQpfXJldHVybiBlfHxpbyh0LFwic2l6ZVwiLHtnZXQ6SnR9KSx0LmNvbnN0cnVjdG9yPW4sbi5wcm90b3R5cGU9dCxufWZ1bmN0aW9uIFZ0KHQpe3RoaXMuYWRkP3QuZm9yRWFjaCh0aGlzLmFkZCx0aGlzKTp0LmZvckVhY2goZnVuY3Rpb24odCl7dGhpcy5zZXQodFswXSx0WzFdKX0sdGhpcyl9ZnVuY3Rpb24ga3QodCl7cmV0dXJuIHRoaXMuaGFzKHQpJiYodGhpcy5fa2V5cy5zcGxpY2Uobm8sMSksdGhpcy5fdmFsdWVzLnNwbGljZShubywxKSx0aGlzLl9pdHAuZm9yRWFjaChmdW5jdGlvbih0KXtubzx0WzBdJiZ0WzBdLS19KSksbm8+LTF9ZnVuY3Rpb24gWXQodCl7cmV0dXJuIHRoaXMuaGFzKHQpP3RoaXMuX3ZhbHVlc1tub106dm9pZCAwfWZ1bmN0aW9uIFV0KHQsZSl7aWYodGhpcy5vYmplY3RPbmx5JiZlIT09T2JqZWN0KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHZhbHVlIHVzZWQgYXMgd2VhayBjb2xsZWN0aW9uIGtleVwiKTtpZihlIT09ZXx8MD09PWUpZm9yKG5vPXQubGVuZ3RoO25vLS0mJiFCdCh0W25vXSxlKTspO2Vsc2Ugbm89dC5pbmRleE9mKGUpO3JldHVybiBubz4tMX1mdW5jdGlvbiBYdCh0KXtyZXR1cm4gVXQuY2FsbCh0aGlzLHRoaXMuX2tleXMsdCl9ZnVuY3Rpb24gSHQodCxlKXtyZXR1cm4gdGhpcy5oYXModCk/dGhpcy5fdmFsdWVzW25vXT1lOnRoaXMuX3ZhbHVlc1t0aGlzLl9rZXlzLnB1c2godCktMV09ZSx0aGlzfWZ1bmN0aW9uIFd0KCl7KHRoaXMuX2tleXN8fDApLmxlbmd0aD10aGlzLl92YWx1ZXMubGVuZ3RoPTB9ZnVuY3Rpb24ganQoKXtyZXR1cm4gUXQodGhpcy5faXRwLHRoaXMuX2tleXMpfWZ1bmN0aW9uIEt0KCl7cmV0dXJuIFF0KHRoaXMuX2l0cCx0aGlzLl92YWx1ZXMpfWZ1bmN0aW9uIFp0KCl7cmV0dXJuIFF0KHRoaXMuX2l0cCx0aGlzLl9rZXlzLHRoaXMuX3ZhbHVlcyl9ZnVuY3Rpb24gUXQodCxlLG4pe3ZhciBpPVswXSxyPSExO3JldHVybiB0LnB1c2goaSkse25leHQ6ZnVuY3Rpb24oKXt2YXIgcyxvPWlbMF07cmV0dXJuIXImJm88ZS5sZW5ndGg/KHM9bj9bZVtvXSxuW29dXTplW29dLGlbMF0rKyk6KHI9ITAsdC5zcGxpY2UodC5pbmRleE9mKGkpLDEpKSx7ZG9uZTpyLHZhbHVlOnN9fX19ZnVuY3Rpb24gSnQoKXtyZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aH1mdW5jdGlvbiAkdCh0LGUpe2Zvcih2YXIgbj10aGlzLmVudHJpZXMoKTs7KXt2YXIgaT1uLm5leHQoKTtpZihpLmRvbmUpYnJlYWs7dC5jYWxsKGUsaS52YWx1ZVsxXSxpLnZhbHVlWzBdLHRoaXMpfX1mdW5jdGlvbiB0ZSgpe3RoaXMubWFwXz1uZXcgc299ZnVuY3Rpb24gZWUoKXtpZih0aGlzLm1vZGVsVHlwZT1udWxsLHRoaXMuc2NhbGU9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLm1vZGVsVHlwZT1lZS5GTE9BVElORztlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbmUpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1vZGVsVHlwZT10LHQ9PT1lZS5GSVhFRCYmdGhpcy5zZXRTY2FsZSgxKX1lbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLm1vZGVsVHlwZT1lZS5GSVhFRCx0aGlzLnNldFNjYWxlKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7dmFyIG49YXJndW1lbnRzWzBdO3RoaXMubW9kZWxUeXBlPW4ubW9kZWxUeXBlLHRoaXMuc2NhbGU9bi5zY2FsZX19ZnVuY3Rpb24gbmUoKXt0aGlzLm5hbWU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5uYW1lPXQsbmUubmFtZVRvVHlwZU1hcC5wdXQodCx0aGlzKX1mdW5jdGlvbiBpZSgpe2lmKHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bnVsbCx0aGlzLlNSSUQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClpZS5jYWxsKHRoaXMsbmV3IGVlLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLEcpKXt2YXIgdD1hcmd1bWVudHNbMF07aWUuY2FsbCh0aGlzLG5ldyBlZSwwLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7dmFyIGU9YXJndW1lbnRzWzBdO2llLmNhbGwodGhpcyxlLDAsaWUuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtpZS5jYWxsKHRoaXMsbixpLGllLmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTt0aGlzLnByZWNpc2lvbk1vZGVsPXIsdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW8sdGhpcy5TUklEPXN9fWZ1bmN0aW9uIHJlKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZX1mdW5jdGlvbiBzZSh0KXt0aGlzLnBhcnNlcj1uZXcgcmUodCl9ZnVuY3Rpb24gb2UoKXt0aGlzLnJlc3VsdD1udWxsLHRoaXMuaW5wdXRMaW5lcz1BcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5KDIpfSksdGhpcy5pbnRQdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmludExpbmVJbmRleD1udWxsLHRoaXMuX2lzUHJvcGVyPW51bGwsdGhpcy5wYT1udWxsLHRoaXMucGI9bnVsbCx0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5pbnRQdFswXT1uZXcgZyx0aGlzLmludFB0WzFdPW5ldyBnLHRoaXMucGE9dGhpcy5pbnRQdFswXSx0aGlzLnBiPXRoaXMuaW50UHRbMV0sdGhpcy5yZXN1bHQ9MH1mdW5jdGlvbiBhZSgpe29lLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIHVlKCl7fWZ1bmN0aW9uIGxlKCl7dGhpcy5wPW51bGwsdGhpcy5jcm9zc2luZ0NvdW50PTAsdGhpcy5pc1BvaW50T25TZWdtZW50PSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnA9dH1mdW5jdGlvbiBoZSgpe31mdW5jdGlvbiBjZSgpe2lmKHRoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpY2UuY2FsbCh0aGlzLG5ldyBnLG5ldyBnKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Y2UuY2FsbCh0aGlzLHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucDA9ZSx0aGlzLnAxPW59ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdO2NlLmNhbGwodGhpcyxuZXcgZyhpLHIpLG5ldyBnKHMsbykpfX1mdW5jdGlvbiBmZSgpe2lmKHRoaXMubWF0cml4PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5tYXRyaXg9QXJyYXkoMykuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgzKX0pLHRoaXMuc2V0QWxsKGx0LkZBTFNFKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtmZS5jYWxsKHRoaXMpLHRoaXMuc2V0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmZSl7dmFyIGU9YXJndW1lbnRzWzBdO2ZlLmNhbGwodGhpcyksdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl09ZS5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0sdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV09ZS5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV0sdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09ZS5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl0sdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl09ZS5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl0sdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV09ZS5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV0sdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09ZS5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl0sdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09ZS5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl0sdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09ZS5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV0sdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5FWFRFUklPUl09ZS5tYXRyaXhbTC5FWFRFUklPUl1bTC5FWFRFUklPUl19fWZ1bmN0aW9uIGdlKCl7dGhpcy5hcmVhQmFzZVB0PW51bGwsdGhpcy50cmlhbmdsZUNlbnQzPW5ldyBnLHRoaXMuYXJlYXN1bTI9MCx0aGlzLmNnMz1uZXcgZyx0aGlzLmxpbmVDZW50U3VtPW5ldyBnLHRoaXMudG90YWxMZW5ndGg9MCx0aGlzLnB0Q291bnQ9MCx0aGlzLnB0Q2VudFN1bT1uZXcgZzt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hcmVhQmFzZVB0PW51bGwsdGhpcy5hZGQodCl9ZnVuY3Rpb24gZGUodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gcGUoKXt0aGlzLmFycmF5Xz1bXX1mdW5jdGlvbiB2ZSgpe3RoaXMudHJlZVNldD1uZXcgYXQsdGhpcy5saXN0PW5ldyBJfWZ1bmN0aW9uIG1lKCl7aWYodGhpcy5nZW9tRmFjdG9yeT1udWxsLHRoaXMuaW5wdXRQdHM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO21lLmNhbGwodGhpcyxtZS5leHRyYWN0Q29vcmRpbmF0ZXModCksdC5nZXRGYWN0b3J5KCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmlucHV0UHRzPXZlLmZpbHRlckNvb3JkaW5hdGVzKGUpLHRoaXMuZ2VvbUZhY3Rvcnk9bn19ZnVuY3Rpb24geWUoKXt0aGlzLm9yaWdpbj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm9yaWdpbj10fWZ1bmN0aW9uIHhlKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLnBydW5lRW1wdHlHZW9tZXRyeT0hMCx0aGlzLnByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT0hMCx0aGlzLnByZXNlcnZlQ29sbGVjdGlvbnM9ITEsdGhpcy5wcmVzZXJ2ZVR5cGU9ITF9ZnVuY3Rpb24gRWUoKXtpZih0aGlzLnNuYXBUb2xlcmFuY2U9MCx0aGlzLnNyY1B0cz1udWxsLHRoaXMuc2VnPW5ldyBjZSx0aGlzLmFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPSExLHRoaXMuX2lzQ2xvc2VkPSExLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3QmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtFZS5jYWxsKHRoaXMsdC5nZXRDb29yZGluYXRlcygpLGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuc3JjUHRzPW4sdGhpcy5faXNDbG9zZWQ9RWUuaXNDbG9zZWQobiksdGhpcy5zbmFwVG9sZXJhbmNlPWl9fWZ1bmN0aW9uIEllKCl7dGhpcy5zcmNHZW9tPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc3JjR2VvbT10fWZ1bmN0aW9uIE5lKCl7aWYoeGUuYXBwbHkodGhpcyksdGhpcy5zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5zbmFwUHRzPW51bGwsdGhpcy5pc1NlbGZTbmFwPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zbmFwVG9sZXJhbmNlPXQsdGhpcy5zbmFwUHRzPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuc25hcFRvbGVyYW5jZT1uLHRoaXMuc25hcFB0cz1pLHRoaXMuaXNTZWxmU25hcD1yfX1mdW5jdGlvbiBDZSgpe3RoaXMuaXNGaXJzdD0hMCx0aGlzLmNvbW1vbk1hbnRpc3NhQml0c0NvdW50PTUzLHRoaXMuY29tbW9uQml0cz0wLHRoaXMuY29tbW9uU2lnbkV4cD1udWxsfWZ1bmN0aW9uIFNlKCl7dGhpcy5jb21tb25Db29yZD1udWxsLHRoaXMuY2NGaWx0ZXI9bmV3IHdlfWZ1bmN0aW9uIHdlKCl7dGhpcy5jb21tb25CaXRzWD1uZXcgQ2UsdGhpcy5jb21tb25CaXRzWT1uZXcgQ2V9ZnVuY3Rpb24gTGUoKXt0aGlzLnRyYW5zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMudHJhbnM9dH1mdW5jdGlvbiBSZSgpe3RoaXMucGFyZW50PW51bGwsdGhpcy5hdFN0YXJ0PW51bGwsdGhpcy5tYXg9bnVsbCx0aGlzLmluZGV4PW51bGwsdGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wYXJlbnQ9dCx0aGlzLmF0U3RhcnQ9ITAsdGhpcy5pbmRleD0wLHRoaXMubWF4PXQuZ2V0TnVtR2VvbWV0cmllcygpfWZ1bmN0aW9uIFRlKCl7aWYodGhpcy5ib3VuZGFyeVJ1bGU9Vi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUsdGhpcy5pc0luPW51bGwsdGhpcy5udW1Cb3VuZGFyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dCl0aHJvdyBuZXcgaShcIlJ1bGUgbXVzdCBiZSBub24tbnVsbFwiKTt0aGlzLmJvdW5kYXJ5UnVsZT10fX1mdW5jdGlvbiBQZSgpe31mdW5jdGlvbiBiZSgpe31mdW5jdGlvbiBPZSgpe3RoaXMucHRzPW51bGwsdGhpcy5kYXRhPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucHRzPXQsdGhpcy5kYXRhPWV9ZnVuY3Rpb24gX2UoKXt9ZnVuY3Rpb24gTWUoKXt0aGlzLmJvdW5kcz1udWxsLHRoaXMuaXRlbT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmJvdW5kcz10LHRoaXMuaXRlbT1lfWZ1bmN0aW9uIERlKCl7dGhpcy5fc2l6ZT1udWxsLHRoaXMuaXRlbXM9bnVsbCx0aGlzLl9zaXplPTAsdGhpcy5pdGVtcz1uZXcgSSx0aGlzLml0ZW1zLmFkZChudWxsKX1mdW5jdGlvbiBBZSgpe31mdW5jdGlvbiBGZSgpe31mdW5jdGlvbiBHZSgpe2lmKHRoaXMuY2hpbGRCb3VuZGFibGVzPW5ldyBJLHRoaXMuYm91bmRzPW51bGwsdGhpcy5sZXZlbD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5sZXZlbD10fX1mdW5jdGlvbiBxZSgpe3RoaXMuYm91bmRhYmxlMT1udWxsLHRoaXMuYm91bmRhYmxlMj1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5pdGVtRGlzdGFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5ib3VuZGFibGUxPXQsdGhpcy5ib3VuZGFibGUyPWUsdGhpcy5pdGVtRGlzdGFuY2U9bix0aGlzLl9kaXN0YW5jZT10aGlzLmRpc3RhbmNlKCl9ZnVuY3Rpb24gQmUoKXtpZih0aGlzLnJvb3Q9bnVsbCx0aGlzLmJ1aWx0PSExLHRoaXMuaXRlbUJvdW5kYWJsZXM9bmV3IEksdGhpcy5ub2RlQ2FwYWNpdHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClCZS5jYWxsKHRoaXMsQmUuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zi5pc1RydWUodD4xLFwiTm9kZSBjYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxXCIpLHRoaXMubm9kZUNhcGFjaXR5PXR9fWZ1bmN0aW9uIHplKCl7fWZ1bmN0aW9uIFZlKCl7fWZ1bmN0aW9uIGtlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpa2UuY2FsbCh0aGlzLGtlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0JlLmNhbGwodGhpcyx0KX19ZnVuY3Rpb24gWWUoKXt2YXIgdD1hcmd1bWVudHNbMF07R2UuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIFVlKCl7fWZ1bmN0aW9uIFhlKCl7dGhpcy5zZWdTdHJpbmc9bnVsbCx0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLnNlZ21lbnRPY3RhbnQ9bnVsbCx0aGlzLl9pc0ludGVyaW9yPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3RoaXMuc2VnU3RyaW5nPXQsdGhpcy5jb29yZD1uZXcgZyhlKSx0aGlzLnNlZ21lbnRJbmRleD1uLHRoaXMuc2VnbWVudE9jdGFudD1pLHRoaXMuX2lzSW50ZXJpb3I9IWUuZXF1YWxzMkQodC5nZXRDb29yZGluYXRlKG4pKX1mdW5jdGlvbiBIZSgpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5lZGdlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fWZ1bmN0aW9uIFdlKCl7dGhpcy5ub2RlTGlzdD1udWxsLHRoaXMuZWRnZT1udWxsLHRoaXMubm9kZUl0PW51bGwsdGhpcy5jdXJyTm9kZT1udWxsLHRoaXMubmV4dE5vZGU9bnVsbCx0aGlzLmN1cnJTZWdJbmRleD0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVMaXN0PXQsdGhpcy5lZGdlPXQuZ2V0RWRnZSgpLHRoaXMubm9kZUl0PXQuaXRlcmF0b3IoKSx0aGlzLnJlYWROZXh0Tm9kZSgpfWZ1bmN0aW9uIGplKCl7fWZ1bmN0aW9uIEtlKCl7dGhpcy5ub2RlTGlzdD1uZXcgSGUodGhpcyksdGhpcy5wdHM9bnVsbCx0aGlzLmRhdGE9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wdHM9dCx0aGlzLmRhdGE9ZX1mdW5jdGlvbiBaZSgpe3RoaXMudGVtcEVudjE9bmV3IEMsdGhpcy50ZW1wRW52Mj1uZXcgQyx0aGlzLm92ZXJsYXBTZWcxPW5ldyBjZSx0aGlzLm92ZXJsYXBTZWcyPW5ldyBjZX1mdW5jdGlvbiBRZSgpe3RoaXMucHRzPW51bGwsdGhpcy5zdGFydD1udWxsLHRoaXMuZW5kPW51bGwsdGhpcy5lbnY9bnVsbCx0aGlzLmNvbnRleHQ9bnVsbCx0aGlzLmlkPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3RoaXMucHRzPXQsdGhpcy5zdGFydD1lLHRoaXMuZW5kPW4sdGhpcy5jb250ZXh0PWl9ZnVuY3Rpb24gSmUoKXt9ZnVuY3Rpb24gJGUoKXt9ZnVuY3Rpb24gdG4oKXt9ZnVuY3Rpb24gZW4oKXtpZih0aGlzLnNlZ0ludD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRTZWdtZW50SW50ZXJzZWN0b3IodCl9fWZ1bmN0aW9uIG5uKCl7aWYodGhpcy5tb25vQ2hhaW5zPW5ldyBJLHRoaXMuaW5kZXg9bmV3IGtlLHRoaXMuaWRDb3VudGVyPTAsdGhpcy5ub2RlZFNlZ1N0cmluZ3M9bnVsbCx0aGlzLm5PdmVybGFwcz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07ZW4uY2FsbCh0aGlzLHQpfX1mdW5jdGlvbiBybigpe1plLmFwcGx5KHRoaXMpLHRoaXMuc2k9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zaT10fWZ1bmN0aW9uIHNuKCl7aWYodGhpcy5wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07bC5jYWxsKHRoaXMsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2wuY2FsbCh0aGlzLHNuLm1zZ1dpdGhDb29yZChlLG4pKSx0aGlzLm5hbWU9XCJUb3BvbG9neUV4Y2VwdGlvblwiLHRoaXMucHQ9bmV3IGcobil9fWZ1bmN0aW9uIG9uKCl7fWZ1bmN0aW9uIGFuKCl7dGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLmlzQ2hlY2tFbmRTZWdtZW50c09ubHk9ITEsdGhpcy5saT1udWxsLHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb249bnVsbCx0aGlzLmludFNlZ21lbnRzPW51bGwsdGhpcy5pbnRlcnNlY3Rpb25zPW5ldyBJLHRoaXMuaW50ZXJzZWN0aW9uQ291bnQ9MCx0aGlzLmtlZXBJbnRlcnNlY3Rpb25zPSEwO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpPXQsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbj1udWxsfWZ1bmN0aW9uIHVuKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5zZWdTdHJpbmdzPW51bGwsdGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLnNlZ0ludD1udWxsLHRoaXMuX2lzVmFsaWQ9ITA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2VnU3RyaW5ncz10fWZ1bmN0aW9uIGxuKCl7dGhpcy5udj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm52PW5ldyB1bihsbi50b1NlZ21lbnRTdHJpbmdzKHQpKX1mdW5jdGlvbiBobigpe3RoaXMubWFwT3A9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tYXBPcD10fWZ1bmN0aW9uIGNuKCl7fWZ1bmN0aW9uIGZuKCl7aWYodGhpcy5sb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQubGVuZ3RoKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCgxKSx0aGlzLmxvY2F0aW9uW2NuLk9OXT1lfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmbil7dmFyIG49YXJndW1lbnRzWzBdO2lmKHRoaXMuaW5pdChuLmxvY2F0aW9uLmxlbmd0aCksbnVsbCE9PW4pZm9yKHZhciBpPTA7aTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtpKyspdGhpcy5sb2NhdGlvbltpXT1uLmxvY2F0aW9uW2ldfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5pbml0KDMpLHRoaXMubG9jYXRpb25bY24uT05dPXIsdGhpcy5sb2NhdGlvbltjbi5MRUZUXT1zLHRoaXMubG9jYXRpb25bY24uUklHSFRdPW99fWZ1bmN0aW9uIGduKCl7aWYodGhpcy5lbHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBmbih0KSx0aGlzLmVsdFsxXT1uZXcgZm4odCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGduKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IGZuKGUuZWx0WzBdKSx0aGlzLmVsdFsxXT1uZXcgZm4oZS5lbHRbMV0pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5lbHRbMF09bmV3IGZuKEwuTk9ORSksdGhpcy5lbHRbMV09bmV3IGZuKEwuTk9ORSksdGhpcy5lbHRbbl0uc2V0TG9jYXRpb24oaSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMuZWx0WzBdPW5ldyBmbihyLHMsbyksdGhpcy5lbHRbMV09bmV3IGZuKHIscyxvKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV0sbD1hcmd1bWVudHNbMl0saD1hcmd1bWVudHNbM107dGhpcy5lbHRbMF09bmV3IGZuKEwuTk9ORSxMLk5PTkUsTC5OT05FKSx0aGlzLmVsdFsxXT1uZXcgZm4oTC5OT05FLEwuTk9ORSxMLk5PTkUpLHRoaXMuZWx0W2FdLnNldExvY2F0aW9ucyh1LGwsaCl9fWZ1bmN0aW9uIGRuKCl7dGhpcy5zdGFydERlPW51bGwsdGhpcy5tYXhOb2RlRGVncmVlPS0xLHRoaXMuZWRnZXM9bmV3IEksdGhpcy5wdHM9bmV3IEksdGhpcy5sYWJlbD1uZXcgZ24oTC5OT05FKSx0aGlzLnJpbmc9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLnNoZWxsPW51bGwsdGhpcy5ob2xlcz1uZXcgSSx0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21ldHJ5RmFjdG9yeT1lLHRoaXMuY29tcHV0ZVBvaW50cyh0KSx0aGlzLmNvbXB1dGVSaW5nKCl9ZnVuY3Rpb24gcG4oKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZG4uY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gdm4oKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZG4uY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gbW4oKXtpZih0aGlzLmxhYmVsPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc0NvdmVyZWQ9ITEsdGhpcy5faXNDb3ZlcmVkU2V0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGFiZWw9dH19ZnVuY3Rpb24geW4oKXttbi5hcHBseSh0aGlzKSx0aGlzLmNvb3JkPW51bGwsdGhpcy5lZGdlcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmNvb3JkPXQsdGhpcy5lZGdlcz1lLHRoaXMubGFiZWw9bmV3IGduKDAsTC5OT05FKX1mdW5jdGlvbiB4bigpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5ub2RlRmFjdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVGYWN0PXR9ZnVuY3Rpb24gRW4oKXtpZih0aGlzLmVkZ2U9bnVsbCx0aGlzLmxhYmVsPW51bGwsdGhpcy5ub2RlPW51bGwsdGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLmR4PW51bGwsdGhpcy5keT1udWxsLHRoaXMucXVhZHJhbnQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWFyZ3VtZW50c1syXTtFbi5jYWxsKHRoaXMsZSxuLGksbnVsbCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9YXJndW1lbnRzWzNdO0VuLmNhbGwodGhpcyxyKSx0aGlzLmluaXQocyxvKSx0aGlzLmxhYmVsPWF9fWZ1bmN0aW9uIEluKCl7dGhpcy5faXNGb3J3YXJkPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5zeW09bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLm5leHRNaW49bnVsbCx0aGlzLmVkZ2VSaW5nPW51bGwsdGhpcy5taW5FZGdlUmluZz1udWxsLHRoaXMuZGVwdGg9WzAsLTk5OSwtOTk5XTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoRW4uY2FsbCh0aGlzLHQpLHRoaXMuX2lzRm9yd2FyZD1lLGUpdGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZSgwKSx0LmdldENvb3JkaW5hdGUoMSkpO2Vsc2V7dmFyIG49dC5nZXROdW1Qb2ludHMoKS0xO3RoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUobiksdC5nZXRDb29yZGluYXRlKG4tMSkpfXRoaXMuY29tcHV0ZURpcmVjdGVkTGFiZWwoKX1mdW5jdGlvbiBObigpe31mdW5jdGlvbiBDbigpe2lmKHRoaXMuZWRnZXM9bmV3IEksdGhpcy5ub2Rlcz1udWxsLHRoaXMuZWRnZUVuZExpc3Q9bmV3IEksMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5ub2Rlcz1uZXcgeG4obmV3IE5uKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ub2Rlcz1uZXcgeG4odCl9fWZ1bmN0aW9uIFNuKCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLnNoZWxsTGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dH1mdW5jdGlvbiB3bigpe3RoaXMub3A9bnVsbCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMucHRMb2NhdG9yPW51bGwsdGhpcy5saW5lRWRnZXNMaXN0PW5ldyBJLHRoaXMucmVzdWx0TGluZUxpc3Q9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMub3A9dCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1lLHRoaXMucHRMb2NhdG9yPW59ZnVuY3Rpb24gTG4oKXt0aGlzLm9wPW51bGwsdGhpcy5nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLnJlc3VsdFBvaW50TGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdO3RoaXMub3A9dCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1lfWZ1bmN0aW9uIFJuKCl7fWZ1bmN0aW9uIFRuKCl7dGhpcy5nZW9tPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbT10fWZ1bmN0aW9uIFBuKCl7dGhpcy5lZGdlTWFwPW5ldyBydCx0aGlzLmVkZ2VMaXN0PW51bGwsdGhpcy5wdEluQXJlYUxvY2F0aW9uPVtMLk5PTkUsTC5OT05FXX1mdW5jdGlvbiBibigpe1BuLmFwcGx5KHRoaXMpLHRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0PW51bGwsdGhpcy5sYWJlbD1udWxsLHRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HPTEsdGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HPTJ9ZnVuY3Rpb24gT24oKXtObi5hcHBseSh0aGlzKX1mdW5jdGlvbiBfbigpe3RoaXMubWNlPW51bGwsdGhpcy5jaGFpbkluZGV4PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubWNlPXQsdGhpcy5jaGFpbkluZGV4PWV9ZnVuY3Rpb24gTW4oKXtpZih0aGlzLmxhYmVsPW51bGwsdGhpcy54VmFsdWU9bnVsbCx0aGlzLmV2ZW50VHlwZT1udWxsLHRoaXMuaW5zZXJ0RXZlbnQ9bnVsbCx0aGlzLmRlbGV0ZUV2ZW50SW5kZXg9bnVsbCx0aGlzLm9iaj1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5ldmVudFR5cGU9TW4uREVMRVRFLHRoaXMueFZhbHVlPXQsdGhpcy5pbnNlcnRFdmVudD1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmV2ZW50VHlwZT1Nbi5JTlNFUlQsdGhpcy5sYWJlbD1uLHRoaXMueFZhbHVlPWksdGhpcy5vYmo9cn19ZnVuY3Rpb24gRG4oKXt9ZnVuY3Rpb24gQW4oKXt0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5oYXNQcm9wZXI9ITEsdGhpcy5oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5saT1udWxsLHRoaXMuaW5jbHVkZVByb3Blcj1udWxsLHRoaXMucmVjb3JkSXNvbGF0ZWQ9bnVsbCx0aGlzLmlzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMubnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtVGVzdHM9MCx0aGlzLmJkeU5vZGVzPW51bGwsdGhpcy5faXNEb25lPSExLHRoaXMuaXNEb25lV2hlblByb3BlckludD0hMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5saT10LHRoaXMuaW5jbHVkZVByb3Blcj1lLHRoaXMucmVjb3JkSXNvbGF0ZWQ9bn1mdW5jdGlvbiBGbigpe0RuLmFwcGx5KHRoaXMpLHRoaXMuZXZlbnRzPW5ldyBJLHRoaXMubk92ZXJsYXBzPW51bGx9ZnVuY3Rpb24gR24oKXt0aGlzLm1pbj1yLlBPU0lUSVZFX0lORklOSVRZLHRoaXMubWF4PXIuTkVHQVRJVkVfSU5GSU5JVFl9ZnVuY3Rpb24gcW4oKXt9ZnVuY3Rpb24gQm4oKXtHbi5hcHBseSh0aGlzKSx0aGlzLml0ZW09bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5taW49dCx0aGlzLm1heD1lLHRoaXMuaXRlbT1ufWZ1bmN0aW9uIHpuKCl7R24uYXBwbHkodGhpcyksdGhpcy5ub2RlMT1udWxsLHRoaXMubm9kZTI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5ub2RlMT10LHRoaXMubm9kZTI9ZSx0aGlzLmJ1aWxkRXh0ZW50KHRoaXMubm9kZTEsdGhpcy5ub2RlMil9ZnVuY3Rpb24gVm4oKXt0aGlzLmxlYXZlcz1uZXcgSSx0aGlzLnJvb3Q9bnVsbCx0aGlzLmxldmVsPTB9ZnVuY3Rpb24ga24oKXtpZih0aGlzLmxpbmVzPW51bGwsdGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZz0hMSwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGluZXM9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5saW5lcz1lLHRoaXMuaXNGb3JjZWRUb0xpbmVTdHJpbmc9bn19ZnVuY3Rpb24gWW4oKXt0aGlzLml0ZW1zPW5ldyBJfWZ1bmN0aW9uIFVuKCl7dGhpcy5pbmRleD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTtpZighUih0LFJ0KSl0aHJvdyBuZXcgaShcIkFyZ3VtZW50IG11c3QgYmUgUG9seWdvbmFsXCIpO3RoaXMuaW5kZXg9bmV3IEhuKHQpfWZ1bmN0aW9uIFhuKCl7dGhpcy5jb3VudGVyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY291bnRlcj10fWZ1bmN0aW9uIEhuKCl7dGhpcy5pbmRleD1uZXcgVm47dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1mdW5jdGlvbiBXbigpe3RoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuZGlzdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmNvb3JkPW5ldyBnKHQpLHRoaXMuc2VnbWVudEluZGV4PWUsdGhpcy5kaXN0PW59ZnVuY3Rpb24gam4oKXt0aGlzLm5vZGVNYXA9bmV3IHJ0LHRoaXMuZWRnZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmVkZ2U9dH1mdW5jdGlvbiBLbigpe31mdW5jdGlvbiBabigpe3RoaXMuZT1udWxsLHRoaXMucHRzPW51bGwsdGhpcy5zdGFydEluZGV4PW51bGwsdGhpcy5lbnYxPW5ldyBDLHRoaXMuZW52Mj1uZXcgQzt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lPXQsdGhpcy5wdHM9dC5nZXRDb29yZGluYXRlcygpO3ZhciBlPW5ldyBLbjt0aGlzLnN0YXJ0SW5kZXg9ZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyh0aGlzLnB0cyl9ZnVuY3Rpb24gUW4oKXt0aGlzLmRlcHRoPUFycmF5KDIpLmZpbGwoKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkoMyl9KTtmb3IodmFyIHQ9MDsyPnQ7dCsrKWZvcih2YXIgZT0wOzM+ZTtlKyspdGhpcy5kZXB0aFt0XVtlXT1Rbi5OVUxMX1ZBTFVFfWZ1bmN0aW9uIEpuKCl7aWYobW4uYXBwbHkodGhpcyksdGhpcy5wdHM9bnVsbCx0aGlzLmVudj1udWxsLHRoaXMuZWlMaXN0PW5ldyBqbih0aGlzKSx0aGlzLm5hbWU9bnVsbCx0aGlzLm1jZT1udWxsLHRoaXMuX2lzSXNvbGF0ZWQ9ITAsdGhpcy5kZXB0aD1uZXcgUW4sdGhpcy5kZXB0aERlbHRhPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtKbi5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wdHM9ZSx0aGlzLmxhYmVsPW59fWZ1bmN0aW9uICRuKCl7aWYoQ24uYXBwbHkodGhpcyksdGhpcy5wYXJlbnRHZW9tPW51bGwsdGhpcy5saW5lRWRnZU1hcD1uZXcgdGUsdGhpcy5ib3VuZGFyeU5vZGVSdWxlPW51bGwsdGhpcy51c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSEwLHRoaXMuYXJnSW5kZXg9bnVsbCx0aGlzLmJvdW5kYXJ5Tm9kZXM9bnVsbCx0aGlzLl9oYXNUb29GZXdQb2ludHM9ITEsdGhpcy5pbnZhbGlkUG9pbnQ9bnVsbCx0aGlzLmFyZWFQdExvY2F0b3I9bnVsbCx0aGlzLnB0TG9jYXRvcj1uZXcgVGUsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTskbi5jYWxsKHRoaXMsdCxlLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5hcmdJbmRleD1uLHRoaXMucGFyZW50R2VvbT1pLHRoaXMuYm91bmRhcnlOb2RlUnVsZT1yLG51bGwhPT1pJiZ0aGlzLmFkZChpKX19ZnVuY3Rpb24gdGkoKXtpZih0aGlzLmxpPW5ldyBhZSx0aGlzLnJlc3VsdFByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5hcmc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLmFyZz1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSx0aGlzLmFyZ1swXT1uZXcgJG4oMCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGkuY2FsbCh0aGlzLGUsbixWLk9HQ19TRlNfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO2kuZ2V0UHJlY2lzaW9uTW9kZWwoKS5jb21wYXJlVG8oci5nZXRQcmVjaXNpb25Nb2RlbCgpKT49MD90aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGkuZ2V0UHJlY2lzaW9uTW9kZWwoKSk6dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihyLmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuYXJnPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuYXJnWzBdPW5ldyAkbigwLGkscyksdGhpcy5hcmdbMV09bmV3ICRuKDEscixzKX19ZnVuY3Rpb24gZWkoKXt0aGlzLnB0cz1udWxsLHRoaXMuX29yaWVudGF0aW9uPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPXQsdGhpcy5fb3JpZW50YXRpb249ZWkub3JpZW50YXRpb24odCl9ZnVuY3Rpb24gbmkoKXt0aGlzLmVkZ2VzPW5ldyBJLHRoaXMub2NhTWFwPW5ldyBydH1mdW5jdGlvbiBpaSgpe3RoaXMucHRMb2NhdG9yPW5ldyBUZSx0aGlzLmdlb21GYWN0PW51bGwsdGhpcy5yZXN1bHRHZW9tPW51bGwsdGhpcy5ncmFwaD1udWxsLHRoaXMuZWRnZUxpc3Q9bmV3IG5pLHRoaXMucmVzdWx0UG9seUxpc3Q9bmV3IEksdGhpcy5yZXN1bHRMaW5lTGlzdD1uZXcgSSx0aGlzLnJlc3VsdFBvaW50TGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGkuY2FsbCh0aGlzLHQsZSksdGhpcy5ncmFwaD1uZXcgQ24obmV3IE9uKSx0aGlzLmdlb21GYWN0PXQuZ2V0RmFjdG9yeSgpfWZ1bmN0aW9uIHJpKCl7dGhpcy5nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuY2JyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZ2VvbVswXT10LHRoaXMuZ2VvbVsxXT1lLHRoaXMuY29tcHV0ZVNuYXBUb2xlcmFuY2UoKX1mdW5jdGlvbiBzaSgpe3RoaXMuZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5nZW9tWzBdPXQsdGhpcy5nZW9tWzFdPWV9ZnVuY3Rpb24gb2koKXt0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmludGVyaW9yUG9pbnQ9bnVsbCx0aGlzLm1heFdpZHRoPTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0aGlzLmFkZCh0KX1mdW5jdGlvbiBhaSgpe3RoaXMucG9seT1udWxsLHRoaXMuY2VudHJlWT1udWxsLHRoaXMuaGlZPXIuTUFYX1ZBTFVFLHRoaXMubG9ZPS1yLk1BWF9WQUxVRTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wb2x5PXQsdGhpcy5oaVk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWF4WSgpLHRoaXMubG9ZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1pblkoKSx0aGlzLmNlbnRyZVk9b2kuYXZnKHRoaXMubG9ZLHRoaXMuaGlZKX1mdW5jdGlvbiB1aSgpe3RoaXMuY2VudHJvaWQ9bnVsbCx0aGlzLm1pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuaW50ZXJpb3JQb2ludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNlbnRyb2lkPXQuZ2V0Q2VudHJvaWQoKS5nZXRDb29yZGluYXRlKCksdGhpcy5hZGRJbnRlcmlvcih0KSxudWxsPT09dGhpcy5pbnRlcmlvclBvaW50JiZ0aGlzLmFkZEVuZHBvaW50cyh0KX1mdW5jdGlvbiBsaSgpe3RoaXMuY2VudHJvaWQ9bnVsbCx0aGlzLm1pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuaW50ZXJpb3JQb2ludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNlbnRyb2lkPXQuZ2V0Q2VudHJvaWQoKS5nZXRDb29yZGluYXRlKCksdGhpcy5hZGQodCl9ZnVuY3Rpb24gaGkoKXt0aGlzLnRlbXBFbnYxPW5ldyBDLHRoaXMuc2VsZWN0ZWRTZWdtZW50PW5ldyBjZX1mdW5jdGlvbiBjaSgpe3RoaXMuaXRlbXM9bmV3IEksdGhpcy5zdWJub2RlPVtudWxsLG51bGxdfWZ1bmN0aW9uIGZpKCl7aWYodGhpcy5taW49bnVsbCx0aGlzLm1heD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMubWluPTAsdGhpcy5tYXg9MDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQubWluLHQubWF4KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbml0KGUsbil9fWZ1bmN0aW9uIGdpKCl7fWZ1bmN0aW9uIGRpKHQsZSl7dmFyIG4saSxyLHMsbz17MzI6e2Q6MTI3LGM6MTI4LGI6MCxhOjB9LDY0OntkOjMyNzUyLGM6MCxiOjAsYTowfX0sYT17MzI6OCw2NDoxMX1bdF07aWYoc3x8KG49MD5lfHwwPjEvZSxpc0Zpbml0ZShlKXx8KHM9b1t0XSxuJiYocy5kKz0xPDx0LzQtMSksaT1NYXRoLnBvdygyLGEpLTEscj0wKSksIXMpe2ZvcihpPXszMjoxMjcsNjQ6MTAyM31bdF0scj1NYXRoLmFicyhlKTtyPj0yOylpKyssci89Mjtmb3IoOzE+ciYmaT4wOylpLS0scio9MjswPj1pJiYoci89MiksMzI9PT10JiZpPjI1NCYmKHM9e2Q6bj8yNTU6MTI3LGM6MTI4LGI6MCxhOjB9LGk9TWF0aC5wb3coMixhKS0xLHI9MCl9cmV0dXJuIGl9ZnVuY3Rpb24gcGkoKXt0aGlzLnB0PTAsdGhpcy5sZXZlbD0wLHRoaXMuaW50ZXJ2YWw9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfWZ1bmN0aW9uIHZpKCl7Y2kuYXBwbHkodGhpcyksdGhpcy5pbnRlcnZhbD1udWxsLHRoaXMuY2VudHJlPW51bGwsdGhpcy5sZXZlbD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmludGVydmFsPXQsdGhpcy5sZXZlbD1lLHRoaXMuY2VudHJlPSh0LmdldE1pbigpK3QuZ2V0TWF4KCkpLzJ9ZnVuY3Rpb24gbWkoKXt9ZnVuY3Rpb24geWkoKXtjaS5hcHBseSh0aGlzKX1mdW5jdGlvbiB4aSgpe3RoaXMucm9vdD1udWxsLHRoaXMubWluRXh0ZW50PTEsdGhpcy5yb290PW5ldyB5aX1mdW5jdGlvbiBFaSgpe31mdW5jdGlvbiBJaSgpe3RoaXMucmluZz1udWxsLHRoaXMudHJlZT1udWxsLHRoaXMuY3Jvc3NpbmdzPTAsdGhpcy5pbnRlcnZhbD1uZXcgZmk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmluZz10LHRoaXMuYnVpbGRJbmRleCgpfWZ1bmN0aW9uIE5pKCl7aGkuYXBwbHkodGhpcyksdGhpcy5tY3A9bnVsbCx0aGlzLnA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5tY3A9dCx0aGlzLnA9ZX1mdW5jdGlvbiBDaSgpe31mdW5jdGlvbiBTaSgpe3RoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5wMj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLnAwPXQsdGhpcy5wMT1lLHRoaXMucDI9bn1mdW5jdGlvbiB3aSgpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLmV4dHJlbWFsUHRzPW51bGwsdGhpcy5jZW50cmU9bnVsbCx0aGlzLnJhZGl1cz0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0PXR9ZnVuY3Rpb24gTGkoKXtpZih0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuaXNDb252ZXg9bnVsbCx0aGlzLmNvbnZleEh1bGxQdHM9bnVsbCx0aGlzLm1pbkJhc2VTZWc9bmV3IGNlLHRoaXMubWluV2lkdGhQdD1udWxsLHRoaXMubWluUHRJbmRleD1udWxsLHRoaXMubWluV2lkdGg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0xpLmNhbGwodGhpcyx0LCExKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbnB1dEdlb209ZSx0aGlzLmlzQ29udmV4PW59fWZ1bmN0aW9uIFJpKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZnVuY3Rpb24gVGkoKXt4ZS5hcHBseSh0aGlzKSx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH1mdW5jdGlvbiBQaSgpe3RoaXMuX29yaWc9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuX29yaWc9dH1mdW5jdGlvbiBiaSgpe3RoaXMuX2lzTWFya2VkPSExO3ZhciB0PWFyZ3VtZW50c1swXTtQaS5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24gT2koKXt0aGlzLnZlcnRleE1hcD1uZXcgdGV9ZnVuY3Rpb24gX2koKXt0aGlzLl9pc1N0YXJ0PSExO3ZhciB0PWFyZ3VtZW50c1swXTtiaS5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24gTWkoKXtPaS5hcHBseSh0aGlzKX1mdW5jdGlvbiBEaSgpe3RoaXMucmVzdWx0PW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5ncmFwaD1udWxsLHRoaXMubGluZXM9bmV3IEksdGhpcy5ub2RlRWRnZVN0YWNrPW5ldyBwZSx0aGlzLnJpbmdTdGFydEVkZ2U9bnVsbCx0aGlzLmdyYXBoPW5ldyBNaX1mdW5jdGlvbiBBaSgpe3RoaXMuaXRlbXM9bmV3IEksdGhpcy5zdWJub2RlPW5ldyBBcnJheSg0KS5maWxsKG51bGwpfWZ1bmN0aW9uIEZpKCl7dGhpcy5wdD1uZXcgZyx0aGlzLmxldmVsPTAsdGhpcy5lbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfWZ1bmN0aW9uIEdpKCl7QWkuYXBwbHkodGhpcyksdGhpcy5lbnY9bnVsbCx0aGlzLmNlbnRyZXg9bnVsbCx0aGlzLmNlbnRyZXk9bnVsbCx0aGlzLmxldmVsPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZW52PXQsdGhpcy5sZXZlbD1lLHRoaXMuY2VudHJleD0odC5nZXRNaW5YKCkrdC5nZXRNYXhYKCkpLzIsdGhpcy5jZW50cmV5PSh0LmdldE1pblkoKSt0LmdldE1heFkoKSkvMn1mdW5jdGlvbiBxaSgpe0FpLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIEJpKCl7dGhpcy5yb290PW51bGwsdGhpcy5taW5FeHRlbnQ9MSx0aGlzLnJvb3Q9bmV3IHFpfWZ1bmN0aW9uIHppKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZX1mdW5jdGlvbiBWaSh0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgaWUsdGhpcy5wcmVjaXNpb25Nb2RlbD10aGlzLmdlb21ldHJ5RmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpLHRoaXMucGFyc2VyPW5ldyB6aSh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9ZnVuY3Rpb24ga2koKXt0aGlzLnBhcnNlcj1uZXcgemkodGhpcy5nZW9tZXRyeUZhY3RvcnkpfWZ1bmN0aW9uIFlpKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZSx0aGlzLnByZWNpc2lvbk1vZGVsPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCksdGhpcy5wYXJzZXI9bmV3IHJlKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX1mdW5jdGlvbiBVaSh0KXtyZXR1cm5bdC54LHQueV19ZnVuY3Rpb24gWGkodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllfWZ1bmN0aW9uIEhpKCl7aWYodGhpcy5ub2Rlcj1udWxsLHRoaXMuc2NhbGVGYWN0b3I9bnVsbCx0aGlzLm9mZnNldFg9bnVsbCx0aGlzLm9mZnNldFk9bnVsbCx0aGlzLmlzU2NhbGVkPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SGkuY2FsbCh0aGlzLHQsZSwwLDApfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdO3RoaXMubm9kZXI9bix0aGlzLnNjYWxlRmFjdG9yPWksdGhpcy5pc1NjYWxlZD0hdGhpcy5pc0ludGVnZXJQcmVjaXNpb24oKX19ZnVuY3Rpb24gV2koKXtpZih0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuaXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSEwLHRoaXMubm9uU2ltcGxlTG9jYXRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuaW5wdXRHZW9tPWUsXG50aGlzLmlzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hbi5pc0luQm91bmRhcnkoMil9fWZ1bmN0aW9uIGppKCl7dGhpcy5wdD1udWxsLHRoaXMuaXNDbG9zZWQ9bnVsbCx0aGlzLmRlZ3JlZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnB0PXQsdGhpcy5pc0Nsb3NlZD0hMSx0aGlzLmRlZ3JlZT0wfWZ1bmN0aW9uIEtpKCl7aWYodGhpcy5xdWFkcmFudFNlZ21lbnRzPUtpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMsdGhpcy5lbmRDYXBTdHlsZT1LaS5DQVBfUk9VTkQsdGhpcy5qb2luU3R5bGU9S2kuSk9JTl9ST1VORCx0aGlzLm1pdHJlTGltaXQ9S2kuREVGQVVMVF9NSVRSRV9MSU1JVCx0aGlzLl9pc1NpbmdsZVNpZGVkPSExLHRoaXMuc2ltcGxpZnlGYWN0b3I9S2kuREVGQVVMVF9TSU1QTElGWV9GQUNUT1IsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhlKSx0aGlzLnNldEVuZENhcFN0eWxlKG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxvPWFyZ3VtZW50c1szXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHMoaSksdGhpcy5zZXRFbmRDYXBTdHlsZShyKSx0aGlzLnNldEpvaW5TdHlsZShzKSx0aGlzLnNldE1pdHJlTGltaXQobyl9fWZ1bmN0aW9uIFppKCl7dGhpcy5taW5JbmRleD0tMSx0aGlzLm1pbkNvb3JkPW51bGwsdGhpcy5taW5EZT1udWxsLHRoaXMub3JpZW50ZWREZT1udWxsfWZ1bmN0aW9uIFFpKCl7dGhpcy5hcnJheV89W119ZnVuY3Rpb24gSmkoKXt0aGlzLmZpbmRlcj1udWxsLHRoaXMuZGlyRWRnZUxpc3Q9bmV3IEksdGhpcy5ub2Rlcz1uZXcgSSx0aGlzLnJpZ2h0TW9zdENvb3JkPW51bGwsdGhpcy5lbnY9bnVsbCx0aGlzLmZpbmRlcj1uZXcgWml9ZnVuY3Rpb24gJGkoKXt0aGlzLmlucHV0TGluZT1udWxsLHRoaXMuZGlzdGFuY2VUb2w9bnVsbCx0aGlzLmlzRGVsZXRlZD1udWxsLHRoaXMuYW5nbGVPcmllbnRhdGlvbj1oZS5DT1VOVEVSQ0xPQ0tXSVNFO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0TGluZT10fWZ1bmN0aW9uIHRyKCl7dGhpcy5wdExpc3Q9bnVsbCx0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5taW5pbWltVmVydGV4RGlzdGFuY2U9MCx0aGlzLnB0TGlzdD1uZXcgSX1mdW5jdGlvbiBlcigpe3RoaXMubWF4Q3VydmVTZWdtZW50RXJyb3I9MCx0aGlzLmZpbGxldEFuZ2xlUXVhbnR1bT1udWxsLHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj0xLHRoaXMuc2VnTGlzdD1udWxsLHRoaXMuZGlzdGFuY2U9MCx0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5idWZQYXJhbXM9bnVsbCx0aGlzLmxpPW51bGwsdGhpcy5zMD1udWxsLHRoaXMuczE9bnVsbCx0aGlzLnMyPW51bGwsdGhpcy5zZWcwPW5ldyBjZSx0aGlzLnNlZzE9bmV3IGNlLHRoaXMub2Zmc2V0MD1uZXcgY2UsdGhpcy5vZmZzZXQxPW5ldyBjZSx0aGlzLnNpZGU9MCx0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITE7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMucHJlY2lzaW9uTW9kZWw9dCx0aGlzLmJ1ZlBhcmFtcz1lLHRoaXMubGk9bmV3IGFlLHRoaXMuZmlsbGV0QW5nbGVRdWFudHVtPU1hdGguUEkvMi9lLmdldFF1YWRyYW50U2VnbWVudHMoKSxlLmdldFF1YWRyYW50U2VnbWVudHMoKT49OCYmZS5nZXRKb2luU3R5bGUoKT09PUtpLkpPSU5fUk9VTkQmJih0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3I9ZXIuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1IpLHRoaXMuaW5pdChuKX1mdW5jdGlvbiBucigpe3RoaXMuZGlzdGFuY2U9MCx0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5idWZQYXJhbXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wcmVjaXNpb25Nb2RlbD10LHRoaXMuYnVmUGFyYW1zPWV9ZnVuY3Rpb24gaXIoKXt0aGlzLnN1YmdyYXBocz1udWxsLHRoaXMuc2VnPW5ldyBjZSx0aGlzLmNnYT1uZXcgaGU7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc3ViZ3JhcGhzPXR9ZnVuY3Rpb24gcnIoKXt0aGlzLnVwd2FyZFNlZz1udWxsLHRoaXMubGVmdERlcHRoPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMudXB3YXJkU2VnPW5ldyBjZSh0KSx0aGlzLmxlZnREZXB0aD1lfWZ1bmN0aW9uIHNyKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmRpc3RhbmNlPW51bGwsdGhpcy5jdXJ2ZUJ1aWxkZXI9bnVsbCx0aGlzLmN1cnZlTGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5pbnB1dEdlb209dCx0aGlzLmRpc3RhbmNlPWUsdGhpcy5jdXJ2ZUJ1aWxkZXI9bn1mdW5jdGlvbiBvcigpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLmhhc1Byb3Blcj0hMSx0aGlzLmhhc1Byb3BlckludGVyaW9yPSExLHRoaXMuaGFzSW50ZXJpb3I9ITEsdGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMubGk9bnVsbCx0aGlzLmlzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMubnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpPXR9ZnVuY3Rpb24gYXIoKXt0aGlzLmJ1ZlBhcmFtcz1udWxsLHRoaXMud29ya2luZ1ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy53b3JraW5nTm9kZXI9bnVsbCx0aGlzLmdlb21GYWN0PW51bGwsdGhpcy5ncmFwaD1udWxsLHRoaXMuZWRnZUxpc3Q9bmV3IG5pO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmJ1ZlBhcmFtcz10fWZ1bmN0aW9uIHVyKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5zZWdTdHJpbmdzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2VnU3RyaW5ncz10fWZ1bmN0aW9uIGxyKCl7dGhpcy5saT1udWxsLHRoaXMucHQ9bnVsbCx0aGlzLm9yaWdpbmFsUHQ9bnVsbCx0aGlzLnB0U2NhbGVkPW51bGwsdGhpcy5wMFNjYWxlZD1udWxsLHRoaXMucDFTY2FsZWQ9bnVsbCx0aGlzLnNjYWxlRmFjdG9yPW51bGwsdGhpcy5taW54PW51bGwsdGhpcy5tYXh4PW51bGwsdGhpcy5taW55PW51bGwsdGhpcy5tYXh5PW51bGwsdGhpcy5jb3JuZXI9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5zYWZlRW52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMub3JpZ2luYWxQdD10LHRoaXMucHQ9dCx0aGlzLnNjYWxlRmFjdG9yPWUsdGhpcy5saT1uLDA+PWUpdGhyb3cgbmV3IGkoXCJTY2FsZSBmYWN0b3IgbXVzdCBiZSBub24temVyb1wiKTsxIT09ZSYmKHRoaXMucHQ9bmV3IGcodGhpcy5zY2FsZSh0LngpLHRoaXMuc2NhbGUodC55KSksdGhpcy5wMFNjYWxlZD1uZXcgZyx0aGlzLnAxU2NhbGVkPW5ldyBnKSx0aGlzLmluaXRDb3JuZXJzKHRoaXMucHQpfWZ1bmN0aW9uIGhyKCl7dGhpcy5pbmRleD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluZGV4PXR9ZnVuY3Rpb24gY3IoKXtoaS5hcHBseSh0aGlzKSx0aGlzLmhvdFBpeGVsPW51bGwsdGhpcy5wYXJlbnRFZGdlPW51bGwsdGhpcy5ob3RQaXhlbFZlcnRleEluZGV4PW51bGwsdGhpcy5faXNOb2RlQWRkZWQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuaG90UGl4ZWw9dCx0aGlzLnBhcmVudEVkZ2U9ZSx0aGlzLmhvdFBpeGVsVmVydGV4SW5kZXg9bn1mdW5jdGlvbiBmcigpe3RoaXMubGk9bnVsbCx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ucz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpPXQsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbnM9bmV3IEl9ZnVuY3Rpb24gZ3IoKXt0aGlzLnBtPW51bGwsdGhpcy5saT1udWxsLHRoaXMuc2NhbGVGYWN0b3I9bnVsbCx0aGlzLm5vZGVyPW51bGwsdGhpcy5wb2ludFNuYXBwZXI9bnVsbCx0aGlzLm5vZGVkU2VnU3RyaW5ncz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBtPXQsdGhpcy5saT1uZXcgYWUsdGhpcy5saS5zZXRQcmVjaXNpb25Nb2RlbCh0KSx0aGlzLnNjYWxlRmFjdG9yPXQuZ2V0U2NhbGUoKX1mdW5jdGlvbiBkcigpe2lmKHRoaXMuYXJnR2VvbT1udWxsLHRoaXMuZGlzdGFuY2U9bnVsbCx0aGlzLmJ1ZlBhcmFtcz1uZXcgS2ksdGhpcy5yZXN1bHRHZW9tZXRyeT1udWxsLHRoaXMuc2F2ZUV4Y2VwdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hcmdHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuYXJnR2VvbT1lLHRoaXMuYnVmUGFyYW1zPW59fWZ1bmN0aW9uIHByKCl7dGhpcy5jb21wcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXBzPXR9ZnVuY3Rpb24gdnIoKXtpZih0aGlzLmNvbXBvbmVudD1udWxsLHRoaXMuc2VnSW5kZXg9bnVsbCx0aGlzLnB0PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt2ci5jYWxsKHRoaXMsdCx2ci5JTlNJREVfQVJFQSxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5jb21wb25lbnQ9bix0aGlzLnNlZ0luZGV4PWksdGhpcy5wdD1yfX1mdW5jdGlvbiBtcigpe3RoaXMucHRzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPXR9ZnVuY3Rpb24geXIoKXt0aGlzLmxvY2F0aW9ucz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxvY2F0aW9ucz10fWZ1bmN0aW9uIHhyKCl7aWYodGhpcy5nZW9tPW51bGwsdGhpcy50ZXJtaW5hdGVEaXN0YW5jZT0wLHRoaXMucHRMb2NhdG9yPW5ldyBUZSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb249bnVsbCx0aGlzLm1pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07eHIuY2FsbCh0aGlzLHQsZSwwKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy5nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuZ2VvbVswXT1uLHRoaXMuZ2VvbVsxXT1pLHRoaXMudGVybWluYXRlRGlzdGFuY2U9c319ZnVuY3Rpb24gRXIoKXt0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmRpcmVjdGVkRWRnZXM9bmV3IEksdGhpcy5jb29yZGluYXRlcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dH1mdW5jdGlvbiBJcigpe3RoaXMuX2lzTWFya2VkPSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLmRhdGE9bnVsbH1mdW5jdGlvbiBOcigpe0lyLmFwcGx5KHRoaXMpLHRoaXMucGFyZW50RWRnZT1udWxsLHRoaXMuZnJvbT1udWxsLHRoaXMudG89bnVsbCx0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMuc3ltPW51bGwsdGhpcy5lZGdlRGlyZWN0aW9uPW51bGwsdGhpcy5xdWFkcmFudD1udWxsLHRoaXMuYW5nbGU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dGhpcy5mcm9tPXQsdGhpcy50bz1lLHRoaXMuZWRnZURpcmVjdGlvbj1pLHRoaXMucDA9dC5nZXRDb29yZGluYXRlKCksdGhpcy5wMT1uO3ZhciByPXRoaXMucDEueC10aGlzLnAwLngscz10aGlzLnAxLnktdGhpcy5wMC55O3RoaXMucXVhZHJhbnQ9SmUucXVhZHJhbnQocixzKSx0aGlzLmFuZ2xlPU1hdGguYXRhbjIocyxyKX1mdW5jdGlvbiBDcigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTtOci5jYWxsKHRoaXMsdCxlLG4saSl9ZnVuY3Rpb24gU3IoKXtpZihJci5hcHBseSh0aGlzKSx0aGlzLmRpckVkZ2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc2V0RGlyZWN0ZWRFZGdlcyh0LGUpfX1mdW5jdGlvbiB3cigpe3RoaXMub3V0RWRnZXM9bmV3IEksdGhpcy5zb3J0ZWQ9ITF9ZnVuY3Rpb24gTHIoKXtpZihJci5hcHBseSh0aGlzKSx0aGlzLnB0PW51bGwsdGhpcy5kZVN0YXI9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0xyLmNhbGwodGhpcyx0LG5ldyB3cil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucHQ9ZSx0aGlzLmRlU3Rhcj1ufX1mdW5jdGlvbiBScigpe1NyLmFwcGx5KHRoaXMpLHRoaXMubGluZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpbmU9dH1mdW5jdGlvbiBUcigpe3RoaXMubm9kZU1hcD1uZXcgcnR9ZnVuY3Rpb24gUHIoKXt0aGlzLmVkZ2VzPW5ldyBKLHRoaXMuZGlyRWRnZXM9bmV3IEosdGhpcy5ub2RlTWFwPW5ldyBUcn1mdW5jdGlvbiBicigpe1ByLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIE9yKCl7dGhpcy5ncmFwaD1uZXcgYnIsdGhpcy5tZXJnZWRMaW5lU3RyaW5ncz1udWxsLHRoaXMuZmFjdG9yeT1udWxsLHRoaXMuZWRnZVN0cmluZ3M9bnVsbH1mdW5jdGlvbiBfcigpe3RoaXMuZWRnZVJpbmc9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLmxhYmVsPS0xO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTtOci5jYWxsKHRoaXMsdCxlLG4saSl9ZnVuY3Rpb24gTXIoKXtTci5hcHBseSh0aGlzKSx0aGlzLmxpbmU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lPXR9ZnVuY3Rpb24gRHIoKXt0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmRlTGlzdD1uZXcgSSx0aGlzLmxvd2VzdEVkZ2U9bnVsbCx0aGlzLnJpbmc9bnVsbCx0aGlzLnJpbmdQdHM9bnVsbCx0aGlzLmhvbGVzPW51bGwsdGhpcy5zaGVsbD1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuX2lzUHJvY2Vzc2VkPSExLHRoaXMuX2lzSW5jbHVkZWRTZXQ9ITEsdGhpcy5faXNJbmNsdWRlZD0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXR9ZnVuY3Rpb24gQXIoKXt9ZnVuY3Rpb24gRnIoKXtQci5hcHBseSh0aGlzKSx0aGlzLmZhY3Rvcnk9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXR9ZnVuY3Rpb24gR3IoKXtpZih0aGlzLmxpbmVTdHJpbmdBZGRlcj1uZXcgcXIodGhpcyksdGhpcy5ncmFwaD1udWxsLHRoaXMuZGFuZ2xlcz1uZXcgSSx0aGlzLmN1dEVkZ2VzPW5ldyBJLHRoaXMuaW52YWxpZFJpbmdMaW5lcz1uZXcgSSx0aGlzLmhvbGVMaXN0PW51bGwsdGhpcy5zaGVsbExpc3Q9bnVsbCx0aGlzLnBvbHlMaXN0PW51bGwsdGhpcy5pc0NoZWNraW5nUmluZ3NWYWxpZD0hMCx0aGlzLmV4dHJhY3RPbmx5UG9seWdvbmFsPW51bGwsdGhpcy5nZW9tRmFjdG9yeT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKUdyLmNhbGwodGhpcywhMSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdE9ubHlQb2x5Z29uYWw9dH19ZnVuY3Rpb24gcXIoKXt0aGlzLnA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wPXR9ZnVuY3Rpb24gQnIoKXt9ZnVuY3Rpb24genIoKXtpZih0aGlzLmVkZ2VFbmRzPW5ldyBJLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07enIuY2FsbCh0aGlzLG51bGwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9KGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pO0VuLmNhbGwodGhpcyxlLmdldEVkZ2UoKSxlLmdldENvb3JkaW5hdGUoKSxlLmdldERpcmVjdGVkQ29vcmRpbmF0ZSgpLG5ldyBnbihlLmdldExhYmVsKCkpKSx0aGlzLmluc2VydChlKX19ZnVuY3Rpb24gVnIoKXtQbi5hcHBseSh0aGlzKX1mdW5jdGlvbiBrcigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt5bi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBZcigpe05uLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIFVyKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5wdExvY2F0b3I9bmV3IFRlLHRoaXMuYXJnPW51bGwsdGhpcy5ub2Rlcz1uZXcgeG4obmV3IFlyKSx0aGlzLmltPW51bGwsdGhpcy5pc29sYXRlZEVkZ2VzPW5ldyBJLHRoaXMuaW52YWxpZFBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYXJnPXR9ZnVuY3Rpb24gWHIoKXt0aGlzLnJlY3RFbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWZ1bmN0aW9uIEhyKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5yZWN0RW52PW51bGwsdGhpcy5kaWFnVXAwPW51bGwsdGhpcy5kaWFnVXAxPW51bGwsdGhpcy5kaWFnRG93bjA9bnVsbCx0aGlzLmRpYWdEb3duMT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RFbnY9dCx0aGlzLmRpYWdVcDA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuZGlhZ1VwMT1uZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSksdGhpcy5kaWFnRG93bjA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLHRoaXMuZGlhZ0Rvd24xPW5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKX1mdW5jdGlvbiBXcigpe3RoaXMuX2lzRG9uZT0hMX1mdW5jdGlvbiBqcigpe3RoaXMucmVjdGFuZ2xlPW51bGwsdGhpcy5yZWN0RW52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdGFuZ2xlPXQsdGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWZ1bmN0aW9uIEtyKCl7V3IuYXBwbHkodGhpcyksdGhpcy5yZWN0RW52PW51bGwsdGhpcy5faW50ZXJzZWN0cz0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXR9ZnVuY3Rpb24gWnIoKXtXci5hcHBseSh0aGlzKSx0aGlzLnJlY3RTZXE9bnVsbCx0aGlzLnJlY3RFbnY9bnVsbCx0aGlzLl9jb250YWluc1BvaW50PSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RTZXE9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0aGlzLnJlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9ZnVuY3Rpb24gUXIoKXtXci5hcHBseSh0aGlzKSx0aGlzLnJlY3RFbnY9bnVsbCx0aGlzLnJlY3RJbnRlcnNlY3Rvcj1udWxsLHRoaXMuaGFzSW50ZXJzZWN0aW9uPSExLHRoaXMucDA9bmV3IGcsdGhpcy5wMT1uZXcgZzt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHRoaXMucmVjdEludGVyc2VjdG9yPW5ldyBIcih0aGlzLnJlY3RFbnYpfWZ1bmN0aW9uIEpyKCl7aWYodGhpcy5fcmVsYXRlPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsdCxlKSx0aGlzLl9yZWxhdGU9bmV3IFVyKHRoaXMuYXJnKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGkuY2FsbCh0aGlzLG4saSxyKSx0aGlzLl9yZWxhdGU9bmV3IFVyKHRoaXMuYXJnKX19ZnVuY3Rpb24gJHIoKXt0aGlzLmdlb21GYWN0b3J5PW51bGwsdGhpcy5za2lwRW1wdHk9ITEsdGhpcy5pbnB1dEdlb21zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUZhY3Rvcnk9JHIuZXh0cmFjdEZhY3RvcnkodCksdGhpcy5pbnB1dEdlb21zPXR9ZnVuY3Rpb24gdHMoKXt0aGlzLnBvaW50R2VvbT1udWxsLHRoaXMub3RoZXJHZW9tPW51bGwsdGhpcy5nZW9tRmFjdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnBvaW50R2VvbT10LHRoaXMub3RoZXJHZW9tPWUsdGhpcy5nZW9tRmFjdD1lLmdldEZhY3RvcnkoKX1mdW5jdGlvbiBlcygpe3RoaXMuc29ydEluZGV4PS0xLHRoaXMuY29tcHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zb3J0SW5kZXg9dCx0aGlzLmNvbXBzPWV9ZnVuY3Rpb24gbnMoKXt0aGlzLmlucHV0UG9seXM9bnVsbCx0aGlzLmdlb21GYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRQb2x5cz10LG51bGw9PT10aGlzLmlucHV0UG9seXMmJih0aGlzLmlucHV0UG9seXM9bmV3IEkpfWZ1bmN0aW9uIGlzKCl7aWYodGhpcy5wb2x5Z29ucz1uZXcgSSx0aGlzLmxpbmVzPW5ldyBJLHRoaXMucG9pbnRzPW5ldyBJLHRoaXMuZ2VvbUZhY3Q9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21GYWN0PWksdGhpcy5leHRyYWN0KG4pfX1mdW5jdGlvbiBycygpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PW5ldyBpZSx0aGlzLmdlb21HcmFwaD1udWxsLHRoaXMuZGlzY29ubmVjdGVkUmluZ2Nvb3JkPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUdyYXBoPXR9ZnVuY3Rpb24gc3MoKXt0aGlzLm5vZGVzPW5ldyB4bihuZXcgWXIpfWZ1bmN0aW9uIG9zKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5nZW9tR3JhcGg9bnVsbCx0aGlzLm5vZGVHcmFwaD1uZXcgc3MsdGhpcy5pbnZhbGlkUG9pbnQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tR3JhcGg9dH1mdW5jdGlvbiBhcygpe3RoaXMuZ3JhcGg9bnVsbCx0aGlzLnJpbmdzPW5ldyBJLHRoaXMudG90YWxFbnY9bmV3IEMsdGhpcy5pbmRleD1udWxsLHRoaXMubmVzdGVkUHQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ncmFwaD10fWZ1bmN0aW9uIHVzKCl7aWYodGhpcy5lcnJvclR5cGU9bnVsbCx0aGlzLnB0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt1cy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5lcnJvclR5cGU9ZSxudWxsIT09biYmKHRoaXMucHQ9bi5jb3B5KCkpfX1mdW5jdGlvbiBscygpe3RoaXMucGFyZW50R2VvbWV0cnk9bnVsbCx0aGlzLmlzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9ITEsdGhpcy52YWxpZEVycj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBhcmVudEdlb21ldHJ5PXR9ZnVuY3Rpb24gaHMoKXtfdC5Db29yZGluYXRlT3BlcmF0aW9uLmFwcGx5KHRoaXMpLHRoaXMudGFyZ2V0UE09bnVsbCx0aGlzLnJlbW92ZUNvbGxhcHNlZD0hMDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy50YXJnZXRQTT10LHRoaXMucmVtb3ZlQ29sbGFwc2VkPWV9ZnVuY3Rpb24gY3MoKXt0aGlzLnRhcmdldFBNPW51bGwsdGhpcy5yZW1vdmVDb2xsYXBzZWQ9ITAsdGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbD0hMSx0aGlzLmlzUG9pbnR3aXNlPSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRhcmdldFBNPXR9ZnVuY3Rpb24gZnMoKXt0aGlzLnB0cz1udWxsLHRoaXMudXNlUHQ9bnVsbCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5zZWc9bmV3IGNlO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnB0cz10fWZ1bmN0aW9uIGdzKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZnVuY3Rpb24gZHMoKXt4ZS5hcHBseSh0aGlzKSx0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT0hMCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5PXQsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1lfWZ1bmN0aW9uIHBzKCl7aWYodGhpcy5wYXJlbnQ9bnVsbCx0aGlzLmluZGV4PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtwcy5jYWxsKHRoaXMsdCxlLG51bGwsLTEpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtjZS5jYWxsKHRoaXMsbixpKSx0aGlzLnBhcmVudD1yLHRoaXMuaW5kZXg9c319ZnVuY3Rpb24gdnMoKXtpZih0aGlzLnBhcmVudExpbmU9bnVsbCx0aGlzLnNlZ3M9bnVsbCx0aGlzLnJlc3VsdFNlZ3M9bmV3IEksdGhpcy5taW5pbXVtU2l6ZT1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dnMuY2FsbCh0aGlzLHQsMil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucGFyZW50TGluZT1lLHRoaXMubWluaW11bVNpemU9bix0aGlzLmluaXQoKX19ZnVuY3Rpb24gbXMoKXt0aGlzLmluZGV4PW5ldyBCaX1mdW5jdGlvbiB5cygpe3RoaXMucXVlcnlTZWc9bnVsbCx0aGlzLml0ZW1zPW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnF1ZXJ5U2VnPXR9ZnVuY3Rpb24geHMoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLmlucHV0SW5kZXg9bmV3IG1zLHRoaXMub3V0cHV0SW5kZXg9bmV3IG1zLHRoaXMubGluZT1udWxsLHRoaXMubGluZVB0cz1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9MDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbnB1dEluZGV4PXQsdGhpcy5vdXRwdXRJbmRleD1lfWZ1bmN0aW9uIEVzKCl7dGhpcy5pbnB1dEluZGV4PW5ldyBtcyx0aGlzLm91dHB1dEluZGV4PW5ldyBtcyx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPTB9ZnVuY3Rpb24gSXMoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMubGluZVNpbXBsaWZpZXI9bmV3IEVzLHRoaXMubGluZXN0cmluZ01hcD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0R2VvbT10fWZ1bmN0aW9uIE5zKCl7eGUuYXBwbHkodGhpcyksdGhpcy5saW5lc3RyaW5nTWFwPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGluZXN0cmluZ01hcD10fWZ1bmN0aW9uIENzKCl7dGhpcy50cHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy50cHM9dH1mdW5jdGlvbiBTcygpe3RoaXMuc2VnPW51bGwsdGhpcy5zZWdMZW49bnVsbCx0aGlzLnNwbGl0UHQ9bnVsbCx0aGlzLm1pbmltdW1MZW49MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZWc9dCx0aGlzLnNlZ0xlbj10LmdldExlbmd0aCgpfWZ1bmN0aW9uIHdzKCl7fWZ1bmN0aW9uIExzKCl7fWZ1bmN0aW9uIFJzKCl7fWZ1bmN0aW9uIFRzKCl7aWYodGhpcy5wPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnA9bmV3IGcodCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucD1uZXcgZyhlLG4pfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLnA9bmV3IGcoaSxyLHMpfX1mdW5jdGlvbiBQcygpe3RoaXMuX2lzT25Db25zdHJhaW50PW51bGwsdGhpcy5jb25zdHJhaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO1RzLmNhbGwodGhpcyx0KX1mdW5jdGlvbiBicygpe3RoaXMuX3JvdD1udWxsLHRoaXMudmVydGV4PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5kYXRhPW51bGx9ZnVuY3Rpb24gT3MoKXt0aGlzLnN1YmRpdj1udWxsLHRoaXMuaXNVc2luZ1RvbGVyYW5jZT0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zdWJkaXY9dCx0aGlzLmlzVXNpbmdUb2xlcmFuY2U9dC5nZXRUb2xlcmFuY2UoKT4wfWZ1bmN0aW9uIF9zKCl7fWZ1bmN0aW9uIE1zKCl7dGhpcy5zdWJkaXY9bnVsbCx0aGlzLmxhc3RFZGdlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc3ViZGl2PXQsdGhpcy5pbml0KCl9ZnVuY3Rpb24gRHMoKXtpZih0aGlzLnNlZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07bC5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgZT1hcmd1bWVudHNbMF07bC5jYWxsKHRoaXMsXCJMb2NhdGUgZmFpbGVkIHRvIGNvbnZlcmdlIChhdCBlZGdlOiBcIitlK1wiKS4gIFBvc3NpYmxlIGNhdXNlcyBpbmNsdWRlIGludmFsaWQgU3ViZGl2aXNpb24gdG9wb2xvZ3kgb3IgdmVyeSBjbG9zZSBzaXRlc1wiKSx0aGlzLnNlZz1uZXcgY2UoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtsLmNhbGwodGhpcyxEcy5tc2dXaXRoU3BhdGlhbChuLGkpKSx0aGlzLnNlZz1uZXcgY2UoaSl9fWZ1bmN0aW9uIEFzKCl7fWZ1bmN0aW9uIEZzKCl7dGhpcy52aXNpdGVkS2V5PTAsdGhpcy5xdWFkRWRnZXM9bmV3IEksdGhpcy5zdGFydGluZ0VkZ2U9bnVsbCx0aGlzLnRvbGVyYW5jZT1udWxsLHRoaXMuZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5mcmFtZVZlcnRleD1uZXcgQXJyYXkoMykuZmlsbChudWxsKSx0aGlzLmZyYW1lRW52PW51bGwsdGhpcy5sb2NhdG9yPW51bGwsdGhpcy5zZWc9bmV3IGNlLHRoaXMudHJpRWRnZXM9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMudG9sZXJhbmNlPWUsdGhpcy5lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9ZS9Gcy5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1IsdGhpcy5jcmVhdGVGcmFtZSh0KSx0aGlzLnN0YXJ0aW5nRWRnZT10aGlzLmluaXRTdWJkaXYoKSx0aGlzLmxvY2F0b3I9bmV3IE1zKHRoaXMpfWZ1bmN0aW9uIEdzKCl7fWZ1bmN0aW9uIHFzKCl7dGhpcy50cmlMaXN0PW5ldyBJfWZ1bmN0aW9uIEJzKCl7dGhpcy50cmlMaXN0PW5ldyBJfWZ1bmN0aW9uIHpzKCl7dGhpcy5jb29yZExpc3Q9bmV3IE4sdGhpcy50cmlDb29yZHM9bmV3IEl9ZnVuY3Rpb24gVnMoKXtpZih0aGlzLmxzPW51bGwsdGhpcy5kYXRhPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmxzPW5ldyBjZSh0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmxzPW5ldyBjZShuLGkpLHRoaXMuZGF0YT1yfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPWFyZ3VtZW50c1syXSx1PWFyZ3VtZW50c1szXSxsPWFyZ3VtZW50c1s0XSxoPWFyZ3VtZW50c1s1XTtWcy5jYWxsKHRoaXMsbmV3IGcocyxvLGEpLG5ldyBnKHUsbCxoKSl9ZWxzZSBpZig3PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGM9YXJndW1lbnRzWzBdLGY9YXJndW1lbnRzWzFdLGQ9YXJndW1lbnRzWzJdLHA9YXJndW1lbnRzWzNdLHY9YXJndW1lbnRzWzRdLG09YXJndW1lbnRzWzVdLHk9YXJndW1lbnRzWzZdO1ZzLmNhbGwodGhpcyxuZXcgZyhjLGYsZCksbmV3IGcocCx2LG0pLHkpfX1mdW5jdGlvbiBrcygpe31mdW5jdGlvbiBZcygpe2lmKHRoaXMucD1udWxsLHRoaXMuZGF0YT1udWxsLHRoaXMubGVmdD1udWxsLHRoaXMucmlnaHQ9bnVsbCx0aGlzLmNvdW50PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnA9bmV3IGcodCksdGhpcy5sZWZ0PW51bGwsdGhpcy5yaWdodD1udWxsLHRoaXMuY291bnQ9MSx0aGlzLmRhdGE9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5wPW5ldyBnKG4saSksdGhpcy5sZWZ0PW51bGwsdGhpcy5yaWdodD1udWxsLHRoaXMuY291bnQ9MSx0aGlzLmRhdGE9cn19ZnVuY3Rpb24gVXMoKXtpZih0aGlzLnJvb3Q9bnVsbCx0aGlzLm51bWJlck9mTm9kZXM9bnVsbCx0aGlzLnRvbGVyYW5jZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKVVzLmNhbGwodGhpcywwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy50b2xlcmFuY2U9dH19ZnVuY3Rpb24gWHMoKXt0aGlzLnRvbGVyYW5jZT1udWxsLHRoaXMubWF0Y2hOb2RlPW51bGwsdGhpcy5tYXRjaERpc3Q9MCx0aGlzLnA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wPXQsdGhpcy50b2xlcmFuY2U9ZX1mdW5jdGlvbiBIcygpe3RoaXMuaW5pdGlhbFZlcnRpY2VzPW51bGwsdGhpcy5zZWdWZXJ0aWNlcz1udWxsLHRoaXMuc2VnbWVudHM9bmV3IEksdGhpcy5zdWJkaXY9bnVsbCx0aGlzLmluY0RlbD1udWxsLHRoaXMuY29udmV4SHVsbD1udWxsLHRoaXMuc3BsaXRGaW5kZXI9bmV3IExzLHRoaXMua2R0PW51bGwsdGhpcy52ZXJ0ZXhGYWN0b3J5PW51bGwsdGhpcy5jb21wdXRlQXJlYUVudj1udWxsLHRoaXMuc3BsaXRQdD1udWxsLHRoaXMudG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdGlhbFZlcnRpY2VzPW5ldyBJKHQpLHRoaXMudG9sZXJhbmNlPWUsdGhpcy5rZHQ9bmV3IFVzKGUpfWZ1bmN0aW9uIFdzKCl7dGhpcy5zaXRlQ29vcmRzPW51bGwsdGhpcy50b2xlcmFuY2U9MCx0aGlzLnN1YmRpdj1udWxsfWZ1bmN0aW9uIGpzKCl7dGhpcy5zaXRlQ29vcmRzPW51bGwsdGhpcy5jb25zdHJhaW50TGluZXM9bnVsbCx0aGlzLnRvbGVyYW5jZT0wLHRoaXMuc3ViZGl2PW51bGwsdGhpcy5jb25zdHJhaW50VmVydGV4TWFwPW5ldyBydH1mdW5jdGlvbiBLcygpe3RoaXMuc2l0ZUNvb3Jkcz1udWxsLHRoaXMudG9sZXJhbmNlPTAsdGhpcy5zdWJkaXY9bnVsbCx0aGlzLmNsaXBFbnY9bnVsbCx0aGlzLmRpYWdyYW1FbnY9bnVsbH1mdW5jdGlvbiBacygpe31BcnJheS5wcm90b3R5cGUuZmlsbHx8KEFycmF5LnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1PYmplY3QodGhpcyksbj1wYXJzZUludChlLmxlbmd0aCwxMCksaT1hcmd1bWVudHNbMV0scj1wYXJzZUludChpLDEwKXx8MCxzPTA+cj9NYXRoLm1heChuK3IsMCk6TWF0aC5taW4ocixuKSxvPWFyZ3VtZW50c1syXSxhPXZvaWQgMD09PW8/bjpwYXJzZUludChvLDEwKXx8MCx1PTA+YT9NYXRoLm1heChuK2EsMCk6TWF0aC5taW4oYSxuKTt1PnM7cysrKWVbc109dDtyZXR1cm4gZX0pLE51bWJlci5pc0Zpbml0ZT1OdW1iZXIuaXNGaW5pdGV8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KX0sTnVtYmVyLmlzSW50ZWdlcj1OdW1iZXIuaXNJbnRlZ2VyfHxmdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmaXNGaW5pdGUodCkmJk1hdGguZmxvb3IodCk9PT10fSxOdW1iZXIucGFyc2VGbG9hdD1OdW1iZXIucGFyc2VGbG9hdHx8cGFyc2VGbG9hdCxOdW1iZXIuaXNOYU49TnVtYmVyLmlzTmFOfHxmdW5jdGlvbih0KXtyZXR1cm4gdCE9PXR9LE1hdGgudHJ1bmM9TWF0aC50cnVuY3x8ZnVuY3Rpb24odCl7cmV0dXJuIDA+dD9NYXRoLmNlaWwodCk6TWF0aC5mbG9vcih0KX0sZShuLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KSxuLmVxdWFsc1dpdGhUb2xlcmFuY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBNYXRoLmFicyh0LWUpPD1ufSxyLmlzTmFOPWZ1bmN0aW9uKHQpe3JldHVybiBOdW1iZXIuaXNOYU4odCl9LHIuZG91YmxlVG9Mb25nQml0cz1mdW5jdGlvbih0KXtyZXR1cm4gdH0sci5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxyLmlzSW5maW5pdGU9ZnVuY3Rpb24odCl7cmV0dXJuIU51bWJlci5pc0Zpbml0ZSh0KX0sci5NQVhfVkFMVUU9TnVtYmVyLk1BWF9WQUxVRSxsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSksbC5wcm90b3R5cGUuY29uc3RydWN0b3I9RXJyb3IsaChjLGwpLGUoYy5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGN9fSksZShmLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZn19KSxmLnNob3VsZE5ldmVyUmVhY2hIZXJlPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZi5zaG91bGROZXZlclJlYWNoSGVyZShudWxsKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhyb3cgbmV3IGMoXCJTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZVwiKyhudWxsIT09dD9cIjogXCIrdDpcIlwiKSl9fSxmLmlzVHJ1ZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zi5pc1RydWUodCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07aWYoIWUpdGhyb3cgbnVsbD09PW4/bmV3IGM6bmV3IGMobil9fSxmLmVxdWFscz1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zi5lcXVhbHModCxlLG51bGwpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTtpZighaS5lcXVhbHMobikpdGhyb3cgbmV3IGMoXCJFeHBlY3RlZCBcIituK1wiIGJ1dCBlbmNvdW50ZXJlZCBcIitpKyhudWxsIT09cj9cIjogXCIrcjpcIlwiKSl9fSxlKGcucHJvdG90eXBlLHtzZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUpe3N3aXRjaCh0KXtjYXNlIGcuWDp0aGlzLng9ZTticmVhaztjYXNlIGcuWTp0aGlzLnk9ZTticmVhaztjYXNlIGcuWjp0aGlzLno9ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBpKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fSxlcXVhbHMyRDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMueCE9PXQueD8hMTp0aGlzLnk9PT10Lnl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gbi5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueCxlLngsaSk/ISFuLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy55LGUueSxpKTohMX19LGdldE9yZGluYXRlOmZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIGcuWDpyZXR1cm4gdGhpcy54O2Nhc2UgZy5ZOnJldHVybiB0aGlzLnk7Y2FzZSBnLlo6cmV0dXJuIHRoaXMuen10aHJvdyBuZXcgaShcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfSxlcXVhbHMzRDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54PT09dC54JiZ0aGlzLnk9PT10LnkmJih0aGlzLno9PT10Lnp8fHIuaXNOYU4odGhpcy56KSYmci5pc05hTih0LnopKX0sZXF1YWxzOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZz90aGlzLmVxdWFsczJEKHQpOiExfSxlcXVhbEluWjpmdW5jdGlvbih0LGUpe3JldHVybiBuLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy56LHQueixlKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMueDxlLng/LTE6dGhpcy54PmUueD8xOnRoaXMueTxlLnk/LTE6dGhpcy55PmUueT8xOjB9LGNsb25lOmZ1bmN0aW9uKCl7dHJ5e3ZhciB0PW51bGw7cmV0dXJuIHR9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiBmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgdGhpcyBjbGFzcyBpcyBDbG9uZWFibGVcIiksbnVsbDt0aHJvdyBlfWZpbmFsbHl7fX0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgZyh0aGlzKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIiwgXCIrdGhpcy56K1wiKVwifSxkaXN0YW5jZTNEOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMueC10Lngsbj10aGlzLnktdC55LGk9dGhpcy56LXQuejtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4raSppKX0sZGlzdGFuY2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy54LXQueCxuPXRoaXMueS10Lnk7cmV0dXJuIE1hdGguc3FydChlKmUrbipuKX0saGFzaENvZGU6ZnVuY3Rpb24oKXt2YXIgdD0xNztyZXR1cm4gdD0zNyp0K2cuaGFzaENvZGUodGhpcy54KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLnkpfSxzZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzLG8sdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGd9fSksZy5oYXNoQ29kZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1yLmRvdWJsZVRvTG9uZ0JpdHModCk7cmV0dXJuIE1hdGgudHJ1bmMoZV5lPj4+MzIpfX0sZShkLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lLHI9ZC5jb21wYXJlKG4ueCxpLngpO2lmKDAhPT1yKXJldHVybiByO3ZhciBzPWQuY29tcGFyZShuLnksaS55KTtpZigwIT09cylyZXR1cm4gcztpZih0aGlzLmRpbWVuc2lvbnNUb1Rlc3Q8PTIpcmV0dXJuIDA7dmFyIG89ZC5jb21wYXJlKG4ueixpLnopO3JldHVybiBvfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZH19KSxkLmNvbXBhcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT50Py0xOnQ+ZT8xOnIuaXNOYU4odCk/ci5pc05hTihlKT8wOi0xOnIuaXNOYU4oZSk/MTowfSxnLkRpbWVuc2lvbmFsQ29tcGFyYXRvcj1kLGcuc2VyaWFsVmVyc2lvblVJRD0weDVjYmYyYzIzNWM3ZTU4MDAsZy5OVUxMX09SRElOQVRFPXIuTmFOLGcuWD0wLGcuWT0xLGcuWj0yLHAucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXt9LHAucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXt9LHAucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt9LG0ucHJvdG90eXBlPW5ldyBFcnJvcixtLnByb3RvdHlwZS5uYW1lPVwiSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvblwiLHkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodi5wcm90b3R5cGUpLHkucHJvdG90eXBlLmNvbnN0cnVjdG9yPXkseS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7fSx5LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oKXt9LHkucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXt9LHgucHJvdG90eXBlPW5ldyBFcnJvcix4LnByb3RvdHlwZS5uYW1lPVwiTm9TdWNoRWxlbWVudEV4Y2VwdGlvblwiLEUucHJvdG90eXBlPW5ldyBFcnJvcixFLnByb3RvdHlwZS5uYW1lPVwiT3BlcmF0aW9uTm90U3VwcG9ydGVkXCIsSS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh5LnByb3RvdHlwZSksSS5wcm90b3R5cGUuY29uc3RydWN0b3I9SSxJLnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eT1mdW5jdGlvbigpe30sSS5wcm90b3R5cGUuaW50ZXJmYWNlc189ZnVuY3Rpb24oKXtyZXR1cm5beSx2XX0sSS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aD90aGlzLmFycmF5Xy5wdXNoKHQpOnRoaXMuYXJyYXlfLnNwbGljZShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKSwhMH0sSS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmFycmF5Xz1bXX0sSS5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sSS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5hcnJheV9bdF07cmV0dXJuIHRoaXMuYXJyYXlfW3RdPWUsbn0sSS5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFFzKHRoaXMpfSxJLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYoMD50fHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgbTtyZXR1cm4gdGhpcy5hcnJheV9bdF19LEkucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sSS5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LEkucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sSS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0hMSxuPTAsaT10aGlzLmFycmF5Xy5sZW5ndGg7aT5uO24rKylpZih0aGlzLmFycmF5X1tuXT09PXQpe3RoaXMuYXJyYXlfLnNwbGljZShuLDEpLGU9ITA7YnJlYWt9cmV0dXJuIGV9O3ZhciBRcz1mdW5jdGlvbih0KXt0aGlzLmFycmF5TGlzdF89dCx0aGlzLnBvc2l0aW9uXz0wfTtRcy5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5hcnJheUxpc3RfLnNpemUoKSl0aHJvdyBuZXcgeDtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXysrKX0sUXMucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy5hcnJheUxpc3RfLnNpemUoKX0sUXMucHJvdG90eXBlLnNldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLnNldCh0aGlzLnBvc2l0aW9uXy0xLHQpfSxRcy5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEV9LGgoTixJKSxlKE4ucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sYWRkQWxsOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj0hMSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspdGhpcy5hZGQoaS5uZXh0KCksZSksbj0hMDtyZXR1cm4gbn1yZXR1cm4gSS5wcm90b3R5cGUuYWRkQWxsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sY2xvbmU6ZnVuY3Rpb24gR28oKXtmb3IodmFyIEdvPUkucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyksdD0wO3Q8dGhpcy5zaXplKCk7dCsrKUdvLmFkZCh0LHRoaXMuZ2V0KHQpLmNvcHkoKSk7cmV0dXJuIEdvfSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvQXJyYXkoTi5jb29yZEFycmF5VHlwZSl9LGFkZDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07SS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcyx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZChlLG4sITApLCEwfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTtpZighciYmdGhpcy5zaXplKCk+PTEpe3ZhciBzPXRoaXMuZ2V0KHRoaXMuc2l6ZSgpLTEpO2lmKHMuZXF1YWxzMkQoaSkpcmV0dXJuIG51bGx9SS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcyxpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZChvLGEpLCEwfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB1PWFyZ3VtZW50c1swXSxsPWFyZ3VtZW50c1sxXSxoPWFyZ3VtZW50c1syXTtpZihoKWZvcih2YXIgYz0wO2M8dS5sZW5ndGg7YysrKXRoaXMuYWRkKHVbY10sbCk7ZWxzZSBmb3IodmFyIGM9dS5sZW5ndGgtMTtjPj0wO2MtLSl0aGlzLmFkZCh1W2NdLGwpO3JldHVybiEwfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7dmFyIGY9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdO2lmKCFwKXt2YXIgdj10aGlzLnNpemUoKTtpZih2PjApe2lmKGY+MCl7dmFyIG09dGhpcy5nZXQoZi0xKTtpZihtLmVxdWFsczJEKGQpKXJldHVybiBudWxsfWlmKHY+Zil7dmFyIHk9dGhpcy5nZXQoZik7aWYoeS5lcXVhbHMyRChkKSlyZXR1cm4gbnVsbH19fUkucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsZixkKX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHg9YXJndW1lbnRzWzBdLEU9YXJndW1lbnRzWzFdLE49YXJndW1lbnRzWzJdLEM9YXJndW1lbnRzWzNdLFM9MTtOPkMmJihTPS0xKTtmb3IodmFyIGM9TjtjIT09QztjKz1TKXRoaXMuYWRkKHhbY10sRSk7cmV0dXJuITB9fSxjbG9zZVJpbmc6ZnVuY3Rpb24oKXt0aGlzLnNpemUoKT4wJiZ0aGlzLmFkZChuZXcgZyh0aGlzLmdldCgwKSksITEpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOfX0pLE4uY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCksZShDLnByb3RvdHlwZSx7Z2V0QXJlYTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFdpZHRoKCkqdGhpcy5nZXRIZWlnaHQoKX0sZXF1YWxzOmZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEMpKXJldHVybiExO3ZhciBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKTp0aGlzLm1heHg9PT1lLmdldE1heFgoKSYmdGhpcy5tYXh5PT09ZS5nZXRNYXhZKCkmJnRoaXMubWlueD09PWUuZ2V0TWluWCgpJiZ0aGlzLm1pbnk9PT1lLmdldE1pblkoKX0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNOdWxsKCl8fHQuaXNOdWxsKCl8fCF0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIG5ldyBDO3ZhciBlPXRoaXMubWlueD50Lm1pbng/dGhpcy5taW54OnQubWlueCxuPXRoaXMubWlueT50Lm1pbnk/dGhpcy5taW55OnQubWlueSxpPXRoaXMubWF4eDx0Lm1heHg/dGhpcy5tYXh4OnQubWF4eCxyPXRoaXMubWF4eTx0Lm1heHk/dGhpcy5tYXh5OnQubWF4eTtyZXR1cm4gbmV3IEMoZSxpLG4scil9LGlzTnVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heHg8dGhpcy5taW54fSxnZXRNYXhYOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4eH0sY292ZXJzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0LngsdC55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc051bGwoKXx8ZS5pc051bGwoKT8hMTplLmdldE1pblgoKT49dGhpcy5taW54JiZlLmdldE1heFgoKTw9dGhpcy5tYXh4JiZlLmdldE1pblkoKT49dGhpcy5taW55JiZlLmdldE1heFkoKTw9dGhpcy5tYXh5fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNOdWxsKCk/ITE6bj49dGhpcy5taW54JiZuPD10aGlzLm1heHgmJmk+PXRoaXMubWlueSYmaTw9dGhpcy5tYXh5fX0saW50ZXJzZWN0czpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc051bGwoKXx8dC5pc051bGwoKT8hMTohKHQubWlueD50aGlzLm1heHh8fHQubWF4eDx0aGlzLm1pbnh8fHQubWlueT50aGlzLm1heHl8fHQubWF4eTx0aGlzLm1pbnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmludGVyc2VjdHMoZS54LGUueSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc051bGwoKT8hMTohKG4+dGhpcy5tYXh4fHxuPHRoaXMubWlueHx8aT50aGlzLm1heHl8fGk8dGhpcy5taW55KX19LGdldE1pblk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW55fSxnZXRNaW5YOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWlueH0sZXhwYW5kVG9JbmNsdWRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZXhwYW5kVG9JbmNsdWRlKHQueCx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07aWYoZS5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLmlzTnVsbCgpPyh0aGlzLm1pbng9ZS5nZXRNaW5YKCksdGhpcy5tYXh4PWUuZ2V0TWF4WCgpLHRoaXMubWlueT1lLmdldE1pblkoKSx0aGlzLm1heHk9ZS5nZXRNYXhZKCkpOihlLm1pbng8dGhpcy5taW54JiYodGhpcy5taW54PWUubWlueCksZS5tYXh4PnRoaXMubWF4eCYmKHRoaXMubWF4eD1lLm1heHgpLGUubWlueTx0aGlzLm1pbnkmJih0aGlzLm1pbnk9ZS5taW55KSxlLm1heHk+dGhpcy5tYXh5JiYodGhpcy5tYXh5PWUubWF4eSkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5pc051bGwoKT8odGhpcy5taW54PW4sdGhpcy5tYXh4PW4sdGhpcy5taW55PWksdGhpcy5tYXh5PWkpOihuPHRoaXMubWlueCYmKHRoaXMubWlueD1uKSxuPnRoaXMubWF4eCYmKHRoaXMubWF4eD1uKSxpPHRoaXMubWlueSYmKHRoaXMubWlueT1pKSxpPnRoaXMubWF4eSYmKHRoaXMubWF4eT1pKSl9fSxtaW5FeHRlbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO3ZhciB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIGU+dD90OmV9LGdldFdpZHRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLm1heHgtdGhpcy5taW54fSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpPzA6LTE6ZS5pc051bGwoKT8xOnRoaXMubWlueDxlLm1pbng/LTE6dGhpcy5taW54PmUubWlueD8xOnRoaXMubWlueTxlLm1pbnk/LTE6dGhpcy5taW55PmUubWlueT8xOnRoaXMubWF4eDxlLm1heHg/LTE6dGhpcy5tYXh4PmUubWF4eD8xOnRoaXMubWF4eTxlLm1heHk/LTE6dGhpcy5tYXh5PmUubWF4eT8xOjB9LHRyYW5zbGF0ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6dm9pZCB0aGlzLmluaXQodGhpcy5nZXRNaW5YKCkrdCx0aGlzLmdldE1heFgoKSt0LHRoaXMuZ2V0TWluWSgpK2UsdGhpcy5nZXRNYXhZKCkrZSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJFbnZbXCIrdGhpcy5taW54K1wiIDogXCIrdGhpcy5tYXh4K1wiLCBcIit0aGlzLm1pbnkrXCIgOiBcIit0aGlzLm1heHkrXCJdXCJ9LHNldFRvTnVsbDpmdW5jdGlvbigpe3RoaXMubWlueD0wLHRoaXMubWF4eD0tMSx0aGlzLm1pbnk9MCx0aGlzLm1heHk9LTF9LGdldEhlaWdodDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTnVsbCgpPzA6dGhpcy5tYXh5LXRoaXMubWlueX0sbWF4RXh0ZW50OmZ1bmN0aW9uKCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDt2YXIgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiB0PmU/dDplfSxleHBhbmRCeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRCeSh0LHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtpZih0aGlzLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMubWlueC09ZSx0aGlzLm1heHgrPWUsdGhpcy5taW55LT1uLHRoaXMubWF4eSs9biwodGhpcy5taW54PnRoaXMubWF4eHx8dGhpcy5taW55PnRoaXMubWF4eSkmJnRoaXMuc2V0VG9OdWxsKCl9fSxjb250YWluczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY292ZXJzKG4saSl9fSxjZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc051bGwoKT9udWxsOm5ldyBnKCh0aGlzLmdldE1pblgoKSt0aGlzLmdldE1heFgoKSkvMiwodGhpcy5nZXRNaW5ZKCkrdGhpcy5nZXRNYXhZKCkpLzIpfSxpbml0OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb051bGwoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMubWlueD1lLm1pbngsdGhpcy5tYXh4PWUubWF4eCx0aGlzLm1pbnk9ZS5taW55LHRoaXMubWF4eT1lLm1heHl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQobi54LGkueCxuLnksaS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM107cz5yPyh0aGlzLm1pbng9cix0aGlzLm1heHg9cyk6KHRoaXMubWlueD1zLHRoaXMubWF4eD1yKSxhPm8/KHRoaXMubWlueT1vLHRoaXMubWF4eT1hKToodGhpcy5taW55PWEsdGhpcy5tYXh5PW8pfX0sZ2V0TWF4WTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heHl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gMDt2YXIgZT0wO3RoaXMubWF4eDx0Lm1pbng/ZT10Lm1pbngtdGhpcy5tYXh4OnRoaXMubWlueD50Lm1heHgmJihlPXRoaXMubWlueC10Lm1heHgpO3ZhciBuPTA7cmV0dXJuIHRoaXMubWF4eTx0Lm1pbnk/bj10Lm1pbnktdGhpcy5tYXh5OnRoaXMubWlueT50Lm1heHkmJihuPXRoaXMubWlueS10Lm1heHkpLDA9PT1lP246MD09PW4/ZTpNYXRoLnNxcnQoZSplK24qbil9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9MTc7cmV0dXJuIHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMubWlueCksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5tYXh4KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLm1pbnkpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMubWF4eSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3MsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEN9fSksQy5pbnRlcnNlY3RzPWZ1bmN0aW9uKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbi54Pj0odC54PGUueD90Lng6ZS54KSYmbi54PD0odC54PmUueD90Lng6ZS54KSYmbi55Pj0odC55PGUueT90Lnk6ZS55KSYmbi55PD0odC55PmUueT90Lnk6ZS55KX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdLGE9TWF0aC5taW4ocy54LG8ueCksdT1NYXRoLm1heChzLngsby54KSxsPU1hdGgubWluKGkueCxyLngpLGg9TWF0aC5tYXgoaS54LHIueCk7cmV0dXJuIGw+dT8hMTphPmg/ITE6KGE9TWF0aC5taW4ocy55LG8ueSksdT1NYXRoLm1heChzLnksby55KSxsPU1hdGgubWluKGkueSxyLnkpLGg9TWF0aC5tYXgoaS55LHIueSksbD51PyExOiEoYT5oKSl9fSxDLnNlcmlhbFZlcnNpb25VSUQ9MHg1MTg0NWNkNTUyMTg5ODAwLGgodyxTKSxlKHcucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3fX0pLGUoTC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEx9fSksTC50b0xvY2F0aW9uU3ltYm9sPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIEwuRVhURVJJT1I6cmV0dXJuXCJlXCI7Y2FzZSBMLkJPVU5EQVJZOnJldHVyblwiYlwiO2Nhc2UgTC5JTlRFUklPUjpyZXR1cm5cImlcIjtjYXNlIEwuTk9ORTpyZXR1cm5cIi1cIn10aHJvdyBuZXcgaShcIlVua25vd24gbG9jYXRpb24gdmFsdWU6IFwiK3QpfSxMLklOVEVSSU9SPTAsTC5CT1VOREFSWT0xLEwuRVhURVJJT1I9MixMLk5PTkU9LTEsZShULnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVH19KSxULmxvZzEwPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGgubG9nKHQpO3JldHVybiByLmlzSW5maW5pdGUoZSk/ZTpyLmlzTmFOKGUpP2U6ZS9ULkxPR18xMH0sVC5taW49ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dDtyZXR1cm4gcj5lJiYocj1lKSxyPm4mJihyPW4pLHI+aSYmKHI9aSkscn0sVC5jbGFtcD1mdW5jdGlvbigpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gZT50P2U6dD5uP246dH1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07cmV0dXJuIHI+aT9yOmk+cz9zOml9fSxULndyYXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD50P2UtIC10JWU6dCVlfSxULm1heD1mdW5jdGlvbigpe1xuaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPXQ7cmV0dXJuIGU+aSYmKGk9ZSksbj5pJiYoaT1uKSxpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM10saT1yO3JldHVybiBzPmkmJihpPXMpLG8+aSYmKGk9byksYT5pJiYoaT1hKSxpfX0sVC5hdmVyYWdlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQrZSkvMn0sVC5MT0dfMTA9TWF0aC5sb2coMTApLFAucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbih0KXt0aGlzLnN0cis9dH0sUC5wcm90b3R5cGUuc2V0Q2hhckF0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3RyLnN1YnN0cigwLHQpK2UrdGhpcy5zdHIuc3Vic3RyKHQrMSl9LFAucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0cn0sYi5wcm90b3R5cGUuaW50VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sYi5wcm90b3R5cGUuY29tcGFyZVRvPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnZhbHVlPHQ/LTE6dGhpcy52YWx1ZT50PzE6MH0sYi5pc05hTj1mdW5jdGlvbih0KXtyZXR1cm4gTnVtYmVyLmlzTmFOKHQpfSxPLmlzV2hpdGVzcGFjZT1mdW5jdGlvbih0KXtyZXR1cm4gMzI+PXQmJnQ+PTB8fDEyNz09dH0sTy50b1VwcGVyQ2FzZT1mdW5jdGlvbih0KXtyZXR1cm4gdC50b1VwcGVyQ2FzZSgpfSxlKF8ucHJvdG90eXBlLHtsZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaTx0LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbzw9dC5sb30sZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5hYnMoKSxpPV8ubWFnbml0dWRlKG4uaGkpLHI9Xy5URU4ucG93KGkpO249bi5kaXZpZGUociksbi5ndChfLlRFTik/KG49bi5kaXZpZGUoXy5URU4pLGkrPTEpOm4ubHQoXy5PTkUpJiYobj1uLm11bHRpcGx5KF8uVEVOKSxpLT0xKTtmb3IodmFyIHM9aSsxLG89bmV3IFAsYT1fLk1BWF9QUklOVF9ESUdJVFMtMSx1PTA7YT49dTt1Kyspe3QmJnU9PT1zJiZvLmFwcGVuZChcIi5cIik7dmFyIGw9TWF0aC50cnVuYyhuLmhpKTtpZigwPmwpYnJlYWs7dmFyIGg9ITEsYz0wO2w+OT8oaD0hMCxjPVwiOVwiKTpjPVwiMFwiK2wsby5hcHBlbmQoYyksbj1uLnN1YnRyYWN0KF8udmFsdWVPZihsKSkubXVsdGlwbHkoXy5URU4pLGgmJm4uc2VsZkFkZChfLlRFTik7dmFyIGY9ITAsZz1fLm1hZ25pdHVkZShuLmhpKTtpZigwPmcmJk1hdGguYWJzKGcpPj1hLXUmJihmPSExKSwhZilicmVha31yZXR1cm4gZVswXT1pLG8udG9TdHJpbmcoKX0sc3FyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubXVsdGlwbHkodGhpcyl9LGRvdWJsZVZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGkrdGhpcy5sb30sc3VidHJhY3Q6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQodC5uZWdhdGUoKSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCgtZSl9fSxlcXVhbHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmhpPT09dC5oaSYmdGhpcy5sbz09PXQubG99fSxpc1plcm86ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuaGkmJjA9PT10aGlzLmxvfSxzZWxmU3VidHJhY3Q6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC10LmhpLC10LmxvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtZSwwKX19LGdldFNwZWNpYWxOdW1iZXJTdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1plcm8oKT9cIjAuMFwiOnRoaXMuaXNOYU4oKT9cIk5hTiBcIjpudWxsfSxtaW46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGUodCk/dGhpczp0fSxzZWxmRGl2aWRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUodC5oaSx0LmxvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZShlLDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1udWxsLHM9bnVsbCxvPW51bGwsYT1udWxsLHU9bnVsbCxsPW51bGwsaD1udWxsLGM9bnVsbDtyZXR1cm4gdT10aGlzLmhpL24sbD1fLlNQTElUKnUscj1sLXUsYz1fLlNQTElUKm4scj1sLXIscz11LXIsbz1jLW4saD11Km4sbz1jLW8sYT1uLW8sYz1yKm8taCtyKmErcypvK3MqYSxsPSh0aGlzLmhpLWgtYyt0aGlzLmxvLXUqaSkvbixjPXUrbCx0aGlzLmhpPWMsdGhpcy5sbz11LWMrbCx0aGlzfX0sZHVtcDpmdW5jdGlvbigpe3JldHVyblwiREQ8XCIrdGhpcy5oaStcIiwgXCIrdGhpcy5sbytcIj5cIn0sZGl2aWRlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1udWxsLG49bnVsbCxpPW51bGwscz1udWxsLG89bnVsbCxhPW51bGwsdT1udWxsLGw9bnVsbDtvPXRoaXMuaGkvdC5oaSxhPV8uU1BMSVQqbyxlPWEtbyxsPV8uU1BMSVQqdC5oaSxlPWEtZSxuPW8tZSxpPWwtdC5oaSx1PW8qdC5oaSxpPWwtaSxzPXQuaGktaSxsPWUqaS11K2UqcytuKmkrbipzLGE9KHRoaXMuaGktdS1sK3RoaXMubG8tbyp0LmxvKS90LmhpLGw9bythO3ZhciBoPWwsYz1vLWwrYTtyZXR1cm4gbmV3IF8oaCxjKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZj1hcmd1bWVudHNbMF07cmV0dXJuIHIuaXNOYU4oZik/Xy5jcmVhdGVOYU4oKTpfLmNvcHkodGhpcykuc2VsZkRpdmlkZShmLDApfX0sZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGk+dC5oaXx8dGhpcy5oaT09PXQuaGkmJnRoaXMubG8+PXQubG99LHBvdzpmdW5jdGlvbih0KXtpZigwPT09dClyZXR1cm4gXy52YWx1ZU9mKDEpO3ZhciBlPW5ldyBfKHRoaXMpLG49Xy52YWx1ZU9mKDEpLGk9TWF0aC5hYnModCk7aWYoaT4xKWZvcig7aT4wOylpJTI9PT0xJiZuLnNlbGZNdWx0aXBseShlKSxpLz0yLGk+MCYmKGU9ZS5zcXIoKSk7ZWxzZSBuPWU7cmV0dXJuIDA+dD9uLnJlY2lwcm9jYWwoKTpufSxjZWlsOmZ1bmN0aW9uKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBfLk5hTjt2YXIgdD1NYXRoLmNlaWwodGhpcy5oaSksZT0wO3JldHVybiB0PT09dGhpcy5oaSYmKGU9TWF0aC5jZWlsKHRoaXMubG8pKSxuZXcgXyh0LGUpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5oaTxlLmhpPy0xOnRoaXMuaGk+ZS5oaT8xOnRoaXMubG88ZS5sbz8tMTp0aGlzLmxvPmUubG8/MTowfSxyaW50OmZ1bmN0aW9uKCl7aWYodGhpcy5pc05hTigpKXJldHVybiB0aGlzO3ZhciB0PXRoaXMuYWRkKC41KTtyZXR1cm4gdC5mbG9vcigpfSxzZXRWYWx1ZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQodCksdGhpc31pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdChlKSx0aGlzfX0sbWF4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlKHQpP3RoaXM6dH0sc3FydDpmdW5jdGlvbigpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIF8udmFsdWVPZigwKTtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gXy5OYU47dmFyIHQ9MS9NYXRoLnNxcnQodGhpcy5oaSksZT10aGlzLmhpKnQsbj1fLnZhbHVlT2YoZSksaT10aGlzLnN1YnRyYWN0KG4uc3FyKCkpLHI9aS5oaSooLjUqdCk7cmV0dXJuIG4uYWRkKHIpfSxzZWxmQWRkOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZBZGQodC5oaSx0LmxvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1udWxsLGk9bnVsbCxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGw7cmV0dXJuIHI9dGhpcy5oaStlLG89ci10aGlzLmhpLHM9ci1vLHM9ZS1vKyh0aGlzLmhpLXMpLGE9cyt0aGlzLmxvLG49cithLGk9YSsoci1uKSx0aGlzLmhpPW4raSx0aGlzLmxvPWkrKG4tdGhpcy5oaSksdGhpc319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdLG49bnVsbCxpPW51bGwsaD1udWxsLGM9bnVsbCxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGw7cj10aGlzLmhpK3UsaD10aGlzLmxvK2wsbz1yLXRoaXMuaGksYT1oLXRoaXMubG8scz1yLW8sYz1oLWEscz11LW8rKHRoaXMuaGktcyksYz1sLWErKHRoaXMubG8tYyksbz1zK2gsbj1yK28saT1vKyhyLW4pLG89YytpO3ZhciBmPW4rbyxnPW8rKG4tZik7cmV0dXJuIHRoaXMuaGk9Zix0aGlzLmxvPWcsdGhpc319LHNlbGZNdWx0aXBseTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodC5oaSx0LmxvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KGUsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGwsdT1udWxsLGw9bnVsbDt1PV8uU1BMSVQqdGhpcy5oaSxyPXUtdGhpcy5oaSxsPV8uU1BMSVQqbixyPXUtcixzPXRoaXMuaGktcixvPWwtbix1PXRoaXMuaGkqbixvPWwtbyxhPW4tbyxsPXIqby11K3IqYStzKm8rcyphKyh0aGlzLmhpKmkrdGhpcy5sbypuKTt2YXIgaD11K2w7cj11LWg7dmFyIGM9bCtyO3JldHVybiB0aGlzLmhpPWgsdGhpcy5sbz1jLHRoaXN9fSxzZWxmU3FyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHRoaXMpfSxmbG9vcjpmdW5jdGlvbigpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gXy5OYU47dmFyIHQ9TWF0aC5mbG9vcih0aGlzLmhpKSxlPTA7cmV0dXJuIHQ9PT10aGlzLmhpJiYoZT1NYXRoLmZsb29yKHRoaXMubG8pKSxuZXcgXyh0LGUpfSxuZWdhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6bmV3IF8oLXRoaXMuaGksLXRoaXMubG8pfSxjbG9uZTpmdW5jdGlvbigpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIG51bGw7dGhyb3cgdH1maW5hbGx5e319LG11bHRpcGx5OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuaXNOYU4oKT9fLmNyZWF0ZU5hTigpOl8uY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKGUpP18uY3JlYXRlTmFOKCk6Xy5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseShlLDApfX0saXNOYU46ZnVuY3Rpb24oKXtyZXR1cm4gci5pc05hTih0aGlzLmhpKX0saW50VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC50cnVuYyh0aGlzLmhpKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1fLm1hZ25pdHVkZSh0aGlzLmhpKTtyZXR1cm4gdD49LTMmJjIwPj10P3RoaXMudG9TdGFuZGFyZE5vdGF0aW9uKCk6dGhpcy50b1NjaU5vdGF0aW9uKCl9LHRvU3RhbmRhcmROb3RhdGlvbjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O3ZhciBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITAsZSksaT1lWzBdKzEscj1uO2lmKFwiLlwiPT09bi5jaGFyQXQoMCkpcj1cIjBcIituO2Vsc2UgaWYoMD5pKXI9XCIwLlwiK18uc3RyaW5nT2ZDaGFyKFwiMFwiLC1pKStuO2Vsc2UgaWYoLTE9PT1uLmluZGV4T2YoXCIuXCIpKXt2YXIgcz1pLW4ubGVuZ3RoLG89Xy5zdHJpbmdPZkNoYXIoXCIwXCIscyk7cj1uK28rXCIuMFwifXJldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIityOnJ9LHJlY2lwcm9jYWw6ZnVuY3Rpb24oKXt2YXIgdD1udWxsLGU9bnVsbCxuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyPTEvdGhpcy5oaSxzPV8uU1BMSVQqcix0PXMtcixhPV8uU1BMSVQqdGhpcy5oaSx0PXMtdCxlPXItdCxuPWEtdGhpcy5oaSxvPXIqdGhpcy5oaSxuPWEtbixpPXRoaXMuaGktbixhPXQqbi1vK3QqaStlKm4rZSppLHM9KDEtby1hLXIqdGhpcy5sbykvdGhpcy5oaTt2YXIgdT1yK3MsbD1yLXUrcztyZXR1cm4gbmV3IF8odSxsKX0sdG9TY2lOb3RhdGlvbjpmdW5jdGlvbigpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIF8uU0NJX05PVF9aRVJPO3ZhciB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O3ZhciBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITEsZSksaT1fLlNDSV9OT1RfRVhQT05FTlRfQ0hBUitlWzBdO2lmKFwiMFwiPT09bi5jaGFyQXQoMCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkZvdW5kIGxlYWRpbmcgemVybzogXCIrbik7dmFyIHI9XCJcIjtuLmxlbmd0aD4xJiYocj1uLnN1YnN0cmluZygxKSk7dmFyIHM9bi5jaGFyQXQoMCkrXCIuXCIrcjtyZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIrcytpOnMraX0sYWJzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9fLk5hTjp0aGlzLmlzTmVnYXRpdmUoKT90aGlzLm5lZ2F0ZSgpOm5ldyBfKHRoaXMpfSxpc1Bvc2l0aXZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk+MHx8MD09PXRoaXMuaGkmJnRoaXMubG8+MH0sbHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGk8dC5oaXx8dGhpcy5oaT09PXQuaGkmJnRoaXMubG88dC5sb30sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIF8uY29weSh0aGlzKS5zZWxmQWRkKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gXy5jb3B5KHRoaXMpLnNlbGZBZGQoZSl9fSxpbml0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmhpPXQsdGhpcy5sbz0wfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5oaT1lLmhpLHRoaXMubG89ZS5sb319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaGk9bix0aGlzLmxvPWl9fSxndDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaT50LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbz50LmxvfSxpc05lZ2F0aXZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk8MHx8MD09PXRoaXMuaGkmJnRoaXMubG88MH0sdHJ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc05hTigpP18uTmFOOnRoaXMuaXNQb3NpdGl2ZSgpP3RoaXMuZmxvb3IoKTp0aGlzLmNlaWwoKX0sc2lnbnVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk+MD8xOnRoaXMuaGk8MD8tMTp0aGlzLmxvPjA/MTp0aGlzLmxvPDA/LTE6MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdSxzLG9dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBffX0pLF8uc3FyPWZ1bmN0aW9uKHQpe3JldHVybiBfLnZhbHVlT2YodCkuc2VsZk11bHRpcGx5KHQpfSxfLnZhbHVlT2Y9ZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIF8ucGFyc2UodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgXyhlKX19LF8uc3FydD1mdW5jdGlvbih0KXtyZXR1cm4gXy52YWx1ZU9mKHQpLnNxcnQoKX0sXy5wYXJzZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXQubGVuZ3RoO08uaXNXaGl0ZXNwYWNlKHQuY2hhckF0KGUpKTspZSsrO3ZhciBpPSExO2lmKG4+ZSl7dmFyIHI9dC5jaGFyQXQoZSk7XCItXCIhPT1yJiZcIitcIiE9PXJ8fChlKyssXCItXCI9PT1yJiYoaT0hMCkpfWZvcih2YXIgcz1uZXcgXyxvPTAsYT0wLHU9MDs7KXtpZihlPj1uKWJyZWFrO3ZhciBsPXQuY2hhckF0KGUpO2lmKGUrKyxPLmlzRGlnaXQobCkpe3ZhciBoPWwtXCIwXCI7cy5zZWxmTXVsdGlwbHkoXy5URU4pLHMuc2VsZkFkZChoKSxvKyt9ZWxzZXtpZihcIi5cIiE9PWwpe2lmKFwiZVwiPT09bHx8XCJFXCI9PT1sKXt2YXIgYz10LnN1YnN0cmluZyhlKTt0cnl7dT1iLnBhcnNlSW50KGMpfWNhdGNoKGYpe3Rocm93IGYgaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb24/bmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIkludmFsaWQgZXhwb25lbnQgXCIrYytcIiBpbiBzdHJpbmcgXCIrdCk6Zn1maW5hbGx5e31icmVha310aHJvdyBuZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK2wrXCInIGF0IHBvc2l0aW9uIFwiK2UrXCIgaW4gc3RyaW5nIFwiK3QpfWE9b319dmFyIGc9cyxkPW8tYS11O2lmKDA9PT1kKWc9cztlbHNlIGlmKGQ+MCl7dmFyIHA9Xy5URU4ucG93KGQpO2c9cy5kaXZpZGUocCl9ZWxzZSBpZigwPmQpe3ZhciBwPV8uVEVOLnBvdygtZCk7Zz1zLm11bHRpcGx5KHApfXJldHVybiBpP2cubmVnYXRlKCk6Z30sXy5jcmVhdGVOYU49ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IF8oci5OYU4sci5OYU4pfSxfLmNvcHk9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBfKHQpfSxfLm1hZ25pdHVkZT1mdW5jdGlvbih0KXt2YXIgZT1NYXRoLmFicyh0KSxuPU1hdGgubG9nKGUpL01hdGgubG9nKDEwKSxpPU1hdGgudHJ1bmMoTWF0aC5mbG9vcihuKSkscj1NYXRoLnBvdygxMCxpKTtyZXR1cm4gZT49MTAqciYmKGkrPTEpLGl9LF8uc3RyaW5nT2ZDaGFyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBQLGk9MDtlPmk7aSsrKW4uYXBwZW5kKHQpO3JldHVybiBuLnRvU3RyaW5nKCl9LF8uUEk9bmV3IF8oMy4xNDE1OTI2NTM1ODk3OTMsMS4yMjQ2NDY3OTkxNDczNTMyZS0xNiksXy5UV09fUEk9bmV3IF8oNi4yODMxODUzMDcxNzk1ODYsMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiksXy5QSV8yPW5ldyBfKDEuNTcwNzk2MzI2Nzk0ODk2Niw2LjEyMzIzMzk5NTczNjc2NmUtMTcpLF8uRT1uZXcgXygyLjcxODI4MTgyODQ1OTA0NSwxLjQ0NTY0Njg5MTcyOTI1MDJlLTE2KSxfLk5hTj1uZXcgXyhyLk5hTixyLk5hTiksXy5FUFM9MS4yMzI1OTUxNjQ0MDc4M2UtMzIsXy5TUExJVD0xMzQyMTc3MjksXy5NQVhfUFJJTlRfRElHSVRTPTMyLF8uVEVOPV8udmFsdWVPZigxMCksXy5PTkU9Xy52YWx1ZU9mKDEpLF8uU0NJX05PVF9FWFBPTkVOVF9DSEFSPVwiRVwiLF8uU0NJX05PVF9aRVJPPVwiMC4wRTBcIixlKE0ucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNfX0pLE0ub3JpZW50YXRpb25JbmRleD1mdW5jdGlvbih0LGUsbil7dmFyIGk9TS5vcmllbnRhdGlvbkluZGV4RmlsdGVyKHQsZSxuKTtpZigxPj1pKXJldHVybiBpO3ZhciByPV8udmFsdWVPZihlLngpLnNlbGZBZGQoLXQueCkscz1fLnZhbHVlT2YoZS55KS5zZWxmQWRkKC10LnkpLG89Xy52YWx1ZU9mKG4ueCkuc2VsZkFkZCgtZS54KSxhPV8udmFsdWVPZihuLnkpLnNlbGZBZGQoLWUueSk7cmV0dXJuIHIuc2VsZk11bHRpcGx5KGEpLnNlbGZTdWJ0cmFjdChzLnNlbGZNdWx0aXBseShvKSkuc2lnbnVtKCl9LE0uc2lnbk9mRGV0MngyPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQubXVsdGlwbHkoaSkuc2VsZlN1YnRyYWN0KGUubXVsdGlwbHkobikpO3JldHVybiByLnNpZ251bSgpfSxNLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1fLnZhbHVlT2YoaS55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkpLHM9Xy52YWx1ZU9mKGkueCkuc2VsZlN1YnRyYWN0KG4ueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxvPXIuc3VidHJhY3QocyksYT1fLnZhbHVlT2YoaS54KS5zZWxmU3VidHJhY3Qobi54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLHU9Xy52YWx1ZU9mKGkueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxsPWEuc3VidHJhY3QodSksaD1sLnNlbGZEaXZpZGUobykuZG91YmxlVmFsdWUoKSxjPV8udmFsdWVPZih0LngpLnNlbGZBZGQoXy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KGgpKS5kb3VibGVWYWx1ZSgpLGY9Xy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChuLnkpKSxkPV8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qobi54KSkscD1mLnN1YnRyYWN0KGQpLHY9cC5zZWxmRGl2aWRlKG8pLmRvdWJsZVZhbHVlKCksbT1fLnZhbHVlT2Yobi55KS5zZWxmQWRkKF8udmFsdWVPZihpLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseSh2KSkuZG91YmxlVmFsdWUoKTtyZXR1cm4gbmV3IGcoYyxtKX0sTS5vcmllbnRhdGlvbkluZGV4RmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1udWxsLHI9KHQueC1uLngpKihlLnktbi55KSxzPSh0Lnktbi55KSooZS54LW4ueCksbz1yLXM7aWYocj4wKXtpZigwPj1zKXJldHVybiBNLnNpZ251bShvKTtpPXIrc31lbHNle2lmKCEoMD5yKSlyZXR1cm4gTS5zaWdudW0obyk7aWYocz49MClyZXR1cm4gTS5zaWdudW0obyk7aT0tci1zfXZhciBhPU0uRFBfU0FGRV9FUFNJTE9OKmk7cmV0dXJuIG8+PWF8fC1vPj1hP00uc2lnbnVtKG8pOjJ9LE0uc2lnbnVtPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/MTowPnQ/LTE6MH0sTS5EUF9TQUZFX0VQU0lMT049MWUtMTUsZShELnByb3RvdHlwZSx7c2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlLG4pe30sc2l6ZTpmdW5jdGlvbigpe30sZ2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlKXt9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxnZXRDb29yZGluYXRlQ29weTpmdW5jdGlvbih0KXt9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe30sZ2V0WDpmdW5jdGlvbih0KXt9LGNsb25lOmZ1bmN0aW9uKCl7fSxleHBhbmRFbnZlbG9wZTpmdW5jdGlvbih0KXt9LGNvcHk6ZnVuY3Rpb24oKXt9LGdldFk6ZnVuY3Rpb24odCl7fSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIER9fSksRC5YPTAsRC5ZPTEsRC5aPTIsRC5NPTMsQS5hcnJheWNvcHk9ZnVuY3Rpb24odCxlLG4saSxyKXtmb3IodmFyIHM9MCxvPWU7ZStyPm87bysrKW5baStzXT10W29dLHMrK30sQS5nZXRQcm9wZXJ0eT1mdW5jdGlvbih0KXtyZXR1cm57XCJsaW5lLnNlcGFyYXRvclwiOlwiXFxuXCJ9W3RdfSxlKEYucHJvdG90eXBlLHtnZXRZOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy55L3RoaXMudztpZihyLmlzTmFOKHQpfHxyLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IHc7cmV0dXJuIHR9LGdldFg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLngvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdztyZXR1cm4gdH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBnO3JldHVybiB0Lng9dGhpcy5nZXRYKCksdC55PXRoaXMuZ2V0WSgpLHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZ9fSksRi5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlLG4saSl7dmFyIHM9dC55LWUueSxvPWUueC10LngsYT10LngqZS55LWUueCp0LnksdT1uLnktaS55LGw9aS54LW4ueCxoPW4ueCppLnktaS54Km4ueSxjPW8qaC1sKmEsZj11KmEtcypoLGQ9cypsLXUqbyxwPWMvZCx2PWYvZDtpZihyLmlzTmFOKHApfHxyLmlzSW5maW5pdGUocCl8fHIuaXNOYU4odil8fHIuaXNJbmZpbml0ZSh2KSl0aHJvdyBuZXcgdztyZXR1cm4gbmV3IGcocCx2KX0sZShHLnByb3RvdHlwZSx7Y3JlYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2FyZ3VtZW50c1swXX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLEQpKXthcmd1bWVudHNbMF19fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHfX0pLGUocS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHF9fSksZShCLnByb3RvdHlwZSx7aXNHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTn0sZ2V0RmFjdG9yeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZhY3Rvcnl9LGdldEdlb21ldHJ5TjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpc30sZ2V0QXJlYTpmdW5jdGlvbigpe3JldHVybiAwfSxpc1JlY3RhbmdsZTpmdW5jdGlvbigpe3JldHVybiExfSxlcXVhbHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG51bGw9PT10PyExOnRoaXMuZXF1YWxzVG9wbyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCl7dmFyIGU9YXJndW1lbnRzWzBdO2lmKCEoZSBpbnN0YW5jZW9mIEIpKXJldHVybiExO3ZhciBuPWU7cmV0dXJuIHRoaXMuZXF1YWxzRXhhY3Qobil9fX0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXM9PT10fHx0aGlzLmVxdWFsc0V4YWN0KHQsMCl9LGdlb21ldHJ5Q2hhbmdlZDpmdW5jdGlvbigpe3RoaXMuYXBwbHkoQi5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIpfSxnZW9tZXRyeUNoYW5nZWRBY3Rpb246ZnVuY3Rpb24oKXt0aGlzLmVudmVsb3BlPW51bGx9LGVxdWFsc05vcm06ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PT10PyExOnRoaXMubm9ybSgpLmVxdWFsc0V4YWN0KHQubm9ybSgpKX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LGdldE51bUdlb21ldHJpZXM6ZnVuY3Rpb24oKXtyZXR1cm4gMX0sY29tcGFyZVRvOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQ7cmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkhPT1lLmdldFNvcnRJbmRleCgpP3RoaXMuZ2V0U29ydEluZGV4KCktZS5nZXRTb3J0SW5kZXgoKTp0aGlzLmlzRW1wdHkoKSYmZS5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTplLmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1uO3JldHVybiB0aGlzLmdldFNvcnRJbmRleCgpIT09ZS5nZXRTb3J0SW5kZXgoKT90aGlzLmdldFNvcnRJbmRleCgpLWUuZ2V0U29ydEluZGV4KCk6dGhpcy5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6ZS5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhuLGkpfX0sZ2V0VXNlckRhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51c2VyRGF0YX0sZ2V0U1JJRDpmdW5jdGlvbigpe3JldHVybiB0aGlzLlNSSUR9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkpfSxjaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtpZih0LmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OKXRocm93IG5ldyBpKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpfSxlcXVhbDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIDA9PT1uP3QuZXF1YWxzKGUpOnQuZGlzdGFuY2UoZSk8PW59LG5vcm06ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvcHkoKTtyZXR1cm4gdC5ub3JtYWxpemUoKSx0fSxnZXRQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX0sZ2V0RW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5lbnZlbG9wZSYmKHRoaXMuZW52ZWxvcGU9dGhpcy5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpKSxuZXcgQyh0aGlzLmVudmVsb3BlKX0sc2V0U1JJRDpmdW5jdGlvbih0KXt0aGlzLlNSSUQ9dH0sc2V0VXNlckRhdGE6ZnVuY3Rpb24odCl7dGhpcy51c2VyRGF0YT10fSxjb21wYXJlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaXRlcmF0b3IoKSxpPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKSYmaS5oYXNOZXh0KCk7KXt2YXIgcj1uLm5leHQoKSxzPWkubmV4dCgpLG89ci5jb21wYXJlVG8ocyk7aWYoMCE9PW8pcmV0dXJuIG99cmV0dXJuIG4uaGFzTmV4dCgpPzE6aS5oYXNOZXh0KCk/LTE6MH0saGFzaENvZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuaGFzaENvZGUoKX0saXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTnx8dGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX01VTFRJUE9JTlR8fHRoaXMuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkd8fHRoaXMuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9NVUxUSVBPTFlHT059LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW28scyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQn19KSxCLmhhc05vbkVtcHR5RWxlbWVudHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIXRbZV0uaXNFbXB0eSgpKXJldHVybiEwO3JldHVybiExfSxCLmhhc051bGxFbGVtZW50cz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKylpZihudWxsPT09dFtlXSlyZXR1cm4hMDtyZXR1cm4hMX0sQi5zZXJpYWxWZXJzaW9uVUlEPTB4Nzk5ZWE0NjUyMjg1NGMwMCxCLlNPUlRJTkRFWF9QT0lOVD0wLEIuU09SVElOREVYX01VTFRJUE9JTlQ9MSxCLlNPUlRJTkRFWF9MSU5FU1RSSU5HPTIsQi5TT1JUSU5ERVhfTElORUFSUklORz0zLEIuU09SVElOREVYX01VTFRJTElORVNUUklORz00LEIuU09SVElOREVYX1BPTFlHT049NSxCLlNPUlRJTkRFWF9NVUxUSVBPTFlHT049NixCLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT049NyxCLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcj17aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGZpbHRlcjpmdW5jdGlvbih0KXt0Lmdlb21ldHJ5Q2hhbmdlZEFjdGlvbigpfX0sZSh6LnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gen19KSxlKFYucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWfX0pLGUoay5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtyZXR1cm4gdCUyPT09MX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bVl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGt9fSksZShZLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0PjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZfX0pLGUoVS5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtyZXR1cm4gdD4xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltWXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVX19KSxlKFgucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7cmV0dXJuIDE9PT10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltWXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWH19KSxWLk1vZDJCb3VuZGFyeU5vZGVSdWxlPWssVi5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9WSxWLk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPVUsVi5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPVgsVi5NT0QyX0JPVU5EQVJZX1JVTEU9bmV3IGssVi5FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBZLFYuTVVMVElWQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgVSxWLk1PTk9WQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgWCxWLk9HQ19TRlNfQk9VTkRBUllfUlVMRT1WLk1PRDJfQk9VTkRBUllfUlVMRSxlKEgucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIfX0pLEguaXNSaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aDw0PyExOiEhdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX0sSC5wdE5vdEluTGlzdD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2lmKEguaW5kZXhPZihpLGUpPDApcmV0dXJuIGl9cmV0dXJuIG51bGx9LEguc2Nyb2xsPWZ1bmN0aW9uKHQsZSl7dmFyIG49SC5pbmRleE9mKGUsdCk7aWYoMD5uKXJldHVybiBudWxsO3ZhciBpPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtBLmFycmF5Y29weSh0LG4saSwwLHQubGVuZ3RoLW4pLEEuYXJyYXljb3B5KHQsMCxpLHQubGVuZ3RoLW4sbiksQS5hcnJheWNvcHkoaSwwLHQsMCx0Lmxlbmd0aCl9LEguZXF1YWxzPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT09dHx8bnVsbD09PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZVtuXSkpcmV0dXJuITE7cmV0dXJuITB9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtpZihpPT09cilyZXR1cm4hMDtpZihudWxsPT09aXx8bnVsbD09PXIpcmV0dXJuITE7aWYoaS5sZW5ndGghPT1yLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIG49MDtuPGkubGVuZ3RoO24rKylpZigwIT09cy5jb21wYXJlKGlbbl0scltuXSkpcmV0dXJuITE7cmV0dXJuITB9fSxILmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgTixpPTA7aTx0Lmxlbmd0aDtpKyspZS5pbnRlcnNlY3RzKHRbaV0pJiZuLmFkZCh0W2ldLCEwKTtyZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfSxILmhhc1JlcGVhdGVkUG9pbnRzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZS0xXS5lcXVhbHModFtlXSkpcmV0dXJuITA7cmV0dXJuITF9LEgucmVtb3ZlUmVwZWF0ZWRQb2ludHM9ZnVuY3Rpb24odCl7aWYoIUguaGFzUmVwZWF0ZWRQb2ludHModCkpcmV0dXJuIHQ7dmFyIGU9bmV3IE4odCwhMSk7cmV0dXJuIGUudG9Db29yZGluYXRlQXJyYXkoKX0sSC5yZXZlcnNlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aC0xLG49TWF0aC50cnVuYyhlLzIpLGk9MDtuPj1pO2krKyl7dmFyIHI9dFtpXTt0W2ldPXRbZS1pXSx0W2UtaV09cn19LEgucmVtb3ZlTnVsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDtuKyspbnVsbCE9PXRbbl0mJmUrKzt2YXIgaT1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtpZigwPT09ZSlyZXR1cm4gaTtmb3IodmFyIHI9MCxuPTA7bjx0Lmxlbmd0aDtuKyspbnVsbCE9PXRbbl0mJihpW3IrK109dFtuXSk7cmV0dXJuIGl9LEguY29weURlZXA9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKSxuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT1uZXcgZyh0W25dKTtyZXR1cm4gZX1pZig1PT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdLGE9YXJndW1lbnRzWzRdLG49MDthPm47bisrKXNbbytuXT1uZXcgZyhpW3Irbl0pfSxILmlzRXF1YWxSZXZlcnNlZD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dLHI9ZVt0Lmxlbmd0aC1uLTFdO2lmKDAhPT1pLmNvbXBhcmVUbyhyKSlyZXR1cm4hMX1yZXR1cm4hMH0sSC5lbnZlbG9wZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEMsbj0wO248dC5sZW5ndGg7bisrKWUuZXhwYW5kVG9JbmNsdWRlKHRbbl0pO3JldHVybiBlfSxILnRvQ29vcmRpbmF0ZUFycmF5PWZ1bmN0aW9uKHQpe3JldHVybiB0LnRvQXJyYXkoSC5jb29yZEFycmF5VHlwZSl9LEguYXRMZWFzdE5Db29yZGluYXRlc09yTm90aGluZz1mdW5jdGlvbih0LGUpe3JldHVybiBlLmxlbmd0aD49dD9lOltdfSxILmluZGV4T2Y9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKylpZih0LmVxdWFscyhlW25dKSlyZXR1cm4gbjtyZXR1cm4tMX0sSC5pbmNyZWFzaW5nRGlyZWN0aW9uPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8TWF0aC50cnVuYyh0Lmxlbmd0aC8yKTtlKyspe3ZhciBuPXQubGVuZ3RoLTEtZSxpPXRbZV0uY29tcGFyZVRvKHRbbl0pO2lmKDAhPT1pKXJldHVybiBpfXJldHVybiAxfSxILmNvbXBhcmU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoJiZuPGUubGVuZ3RoOyl7dmFyIGk9dFtuXS5jb21wYXJlVG8oZVtuXSk7aWYoMCE9PWkpcmV0dXJuIGk7bisrfXJldHVybiBuPGUubGVuZ3RoPy0xOm48dC5sZW5ndGg/MTowfSxILm1pbkNvb3JkaW5hdGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj0wO248dC5sZW5ndGg7bisrKShudWxsPT09ZXx8ZS5jb21wYXJlVG8odFtuXSk+MCkmJihlPXRbbl0pO3JldHVybiBlfSxILmV4dHJhY3Q9ZnVuY3Rpb24odCxlLG4pe2U9VC5jbGFtcChlLDAsdC5sZW5ndGgpLG49VC5jbGFtcChuLC0xLHQubGVuZ3RoKTt2YXIgaT1uLWUrMTswPm4mJihpPTApLGU+PXQubGVuZ3RoJiYoaT0wKSxlPm4mJihpPTApO3ZhciByPW5ldyBBcnJheShpKS5maWxsKG51bGwpO2lmKDA9PT1pKXJldHVybiByO2Zvcih2YXIgcz0wLG89ZTtuPj1vO28rKylyW3MrK109dFtvXTtyZXR1cm4gcn0sZShXLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO3JldHVybiBILmNvbXBhcmUobixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFd9fSksZShqLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO2lmKG4ubGVuZ3RoPGkubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPmkubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDt2YXIgcj1ILmNvbXBhcmUobixpKSxzPUguaXNFcXVhbFJldmVyc2VkKG4saSk7cmV0dXJuIHM/MDpyfSxPTERjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWU7aWYobi5sZW5ndGg8aS5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+aS5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2Zvcih2YXIgcj1ILmluY3JlYXNpbmdEaXJlY3Rpb24obikscz1ILmluY3JlYXNpbmdEaXJlY3Rpb24oaSksbz1yPjA/MDpuLmxlbmd0aC0xLGE9cz4wPzA6bi5sZW5ndGgtMSx1PTA7dTxuLmxlbmd0aDt1Kyspe3ZhciBsPW5bb10uY29tcGFyZVRvKGlbYV0pO2lmKDAhPT1sKXJldHVybiBsO28rPXIsYSs9c31yZXR1cm4gMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGp9fSksSC5Gb3J3YXJkQ29tcGFyYXRvcj1XLEguQmlkaXJlY3Rpb25hbENvbXBhcmF0b3I9aixILmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLEsucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe30sSy5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7fSxaLnByb3RvdHlwZT1uZXcgSyxRLnByb3RvdHlwZT1uZXcgdixRLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbigpe30sSi5wcm90b3R5cGU9bmV3IFEsSi5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl7dmFyIGk9dGhpcy5hcnJheV9bZV07aWYoaT09PXQpcmV0dXJuITB9cmV0dXJuITF9LEoucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb250YWlucyh0KT8hMToodGhpcy5hcnJheV8ucHVzaCh0KSwhMCl9LEoucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LEoucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgamF2YXNjcmlwdC51dGlsLk9wZXJhdGlvbk5vdFN1cHBvcnRlZH0sSi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LEoucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sSi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxKLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgSnModGhpcyl9O3ZhciBKcz1mdW5jdGlvbih0KXt0aGlzLmhhc2hTZXRfPXQsdGhpcy5wb3NpdGlvbl89MH07SnMucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvc2l0aW9uXz09PXRoaXMuaGFzaFNldF8uc2l6ZSgpKXRocm93IG5ldyB4O3JldHVybiB0aGlzLmhhc2hTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXX0sSnMucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy5oYXNoU2V0Xy5zaXplKCl9LEpzLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRX07dmFyICRzPTAsdG89MTtydC5wcm90b3R5cGU9bmV3IFoscnQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5yb290XztudWxsIT09ZTspe3ZhciBuPXQuY29tcGFyZVRvKGUua2V5KTtpZigwPm4pZT1lLmxlZnQ7ZWxzZXtpZighKG4+MCkpcmV0dXJuIGUudmFsdWU7ZT1lLnJpZ2h0fX1yZXR1cm4gbnVsbH0scnQucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe2lmKG51bGw9PT10aGlzLnJvb3RfKXJldHVybiB0aGlzLnJvb3RfPXtrZXk6dCx2YWx1ZTplLGxlZnQ6bnVsbCxyaWdodDpudWxsLHBhcmVudDpudWxsLGNvbG9yOiRzLGdldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmtleX19LHRoaXMuc2l6ZV89MSxudWxsO3ZhciBuLGkscj10aGlzLnJvb3RfO2RvIGlmKG49cixpPXQuY29tcGFyZVRvKHIua2V5KSwwPmkpcj1yLmxlZnQ7ZWxzZXtpZighKGk+MCkpe3ZhciBzPXIudmFsdWU7cmV0dXJuIHIudmFsdWU9ZSxzfXI9ci5yaWdodH13aGlsZShudWxsIT09cik7dmFyIG89e2tleTp0LGxlZnQ6bnVsbCxyaWdodDpudWxsLHZhbHVlOmUscGFyZW50Om4sY29sb3I6JHMsZ2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5fX07cmV0dXJuIDA+aT9uLmxlZnQ9bzpuLnJpZ2h0PW8sdGhpcy5maXhBZnRlckluc2VydGlvbihvKSx0aGlzLnNpemVfKyssbnVsbH0scnQucHJvdG90eXBlLmZpeEFmdGVySW5zZXJ0aW9uPWZ1bmN0aW9uKHQpe2Zvcih0LmNvbG9yPXRvO251bGwhPXQmJnQhPXRoaXMucm9vdF8mJnQucGFyZW50LmNvbG9yPT10bzspaWYodHQodCk9PW50KHR0KHR0KHQpKSkpe3ZhciBlPWl0KHR0KHR0KHQpKSk7JChlKT09dG8/KGV0KHR0KHQpLCRzKSxldChlLCRzKSxldCh0dCh0dCh0KSksdG8pLHQ9dHQodHQodCkpKToodD09aXQodHQodCkpJiYodD10dCh0KSx0aGlzLnJvdGF0ZUxlZnQodCkpLGV0KHR0KHQpLCRzKSxldCh0dCh0dCh0KSksdG8pLHRoaXMucm90YXRlUmlnaHQodHQodHQodCkpKSl9ZWxzZXt2YXIgZT1udCh0dCh0dCh0KSkpOyQoZSk9PXRvPyhldCh0dCh0KSwkcyksZXQoZSwkcyksZXQodHQodHQodCkpLHRvKSx0PXR0KHR0KHQpKSk6KHQ9PW50KHR0KHQpKSYmKHQ9dHQodCksdGhpcy5yb3RhdGVSaWdodCh0KSksZXQodHQodCksJHMpLGV0KHR0KHR0KHQpKSx0byksdGhpcy5yb3RhdGVMZWZ0KHR0KHR0KHQpKSkpfXRoaXMucm9vdF8uY29sb3I9JHN9LHJ0LnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSSxlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlLnZhbHVlKTtudWxsIT09KGU9cnQuc3VjY2Vzc29yKGUpKTspdC5hZGQoZS52YWx1ZSk7cmV0dXJuIHR9LHJ0LnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe3ZhciB0PW5ldyBKLGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUpO251bGwhPT0oZT1ydC5zdWNjZXNzb3IoZSkpOyl0LmFkZChlKTtyZXR1cm4gdH0scnQucHJvdG90eXBlLnJvdGF0ZUxlZnQ9ZnVuY3Rpb24odCl7aWYobnVsbCE9dCl7dmFyIGU9dC5yaWdodDt0LnJpZ2h0PWUubGVmdCxudWxsIT1lLmxlZnQmJihlLmxlZnQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5sZWZ0PT10P3QucGFyZW50LmxlZnQ9ZTp0LnBhcmVudC5yaWdodD1lLGUubGVmdD10LHQucGFyZW50PWV9fSxydC5wcm90b3R5cGUucm90YXRlUmlnaHQ9ZnVuY3Rpb24odCl7aWYobnVsbCE9dCl7dmFyIGU9dC5sZWZ0O3QubGVmdD1lLnJpZ2h0LG51bGwhPWUucmlnaHQmJihlLnJpZ2h0LnBhcmVudD10KSxlLnBhcmVudD10LnBhcmVudCxudWxsPT10LnBhcmVudD90aGlzLnJvb3RfPWU6dC5wYXJlbnQucmlnaHQ9PXQ/dC5wYXJlbnQucmlnaHQ9ZTp0LnBhcmVudC5sZWZ0PWUsZS5yaWdodD10LHQucGFyZW50PWV9fSxydC5wcm90b3R5cGUuZ2V0Rmlyc3RFbnRyeT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucm9vdF87aWYobnVsbCE9dClmb3IoO251bGwhPXQubGVmdDspdD10LmxlZnQ7cmV0dXJuIHR9LHJ0LnN1Y2Nlc3Nvcj1mdW5jdGlvbih0KXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtpZihudWxsIT09dC5yaWdodCl7Zm9yKHZhciBlPXQucmlnaHQ7bnVsbCE9PWUubGVmdDspZT1lLmxlZnQ7cmV0dXJuIGV9Zm9yKHZhciBlPXQucGFyZW50LG49dDtudWxsIT09ZSYmbj09PWUucmlnaHQ7KW49ZSxlPWUucGFyZW50O3JldHVybiBlfSxydC5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVffSxlKHN0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gc3R9fSksb3QucHJvdG90eXBlPW5ldyBRLGF0LnByb3RvdHlwZT1uZXcgb3QsYXQucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspe3ZhciBpPXRoaXMuYXJyYXlfW2VdO2lmKDA9PT1pLmNvbXBhcmVUbyh0KSlyZXR1cm4hMH1yZXR1cm4hMX0sYXQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtpZih0aGlzLmNvbnRhaW5zKHQpKXJldHVybiExO2Zvcih2YXIgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspe3ZhciBpPXRoaXMuYXJyYXlfW2VdO2lmKDE9PT1pLmNvbXBhcmVUbyh0KSlyZXR1cm4gdGhpcy5hcnJheV8uc3BsaWNlKGUsMCx0KSwhMH1yZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSwhMH0sYXQucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LGF0LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEV9LGF0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sYXQucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sYXQucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sYXQucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBlbyh0aGlzKX07dmFyIGVvPWZ1bmN0aW9uKHQpe3RoaXMudHJlZVNldF89dCx0aGlzLnBvc2l0aW9uXz0wfTtlby5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy50cmVlU2V0Xy5zaXplKCkpdGhyb3cgbmV3IHg7cmV0dXJuIHRoaXMudHJlZVNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdfSxlby5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLnRyZWVTZXRfLnNpemUoKX0sZW8ucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBFfSx1dC5zb3J0PWZ1bmN0aW9uKCl7dmFyIHQsZSxuLGkscj1hcmd1bWVudHNbMF07aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSl9LHZvaWQgci5zb3J0KGkpO2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKW49YXJndW1lbnRzWzFdLGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbi5jb21wYXJlKHQsZSl9LHIuc29ydChpKTtlbHNle2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtlPXIuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSksZS5zb3J0KCk7dmFyIHM9ci5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KGUsci5zbGljZShhcmd1bWVudHNbMl0sci5sZW5ndGgpKTtmb3Ioci5zcGxpY2UoMCxyLmxlbmd0aCksdD0wO3Q8cy5sZW5ndGg7dCsrKXIucHVzaChzW3RdKTtyZXR1cm59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihlPXIuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSksbj1hcmd1bWVudHNbM10saT1mdW5jdGlvbih0LGUpe3JldHVybiBuLmNvbXBhcmUodCxlKX0sZS5zb3J0KGkpLHM9ci5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KGUsci5zbGljZShhcmd1bWVudHNbMl0sci5sZW5ndGgpKSxyLnNwbGljZSgwLHIubGVuZ3RoKSx0PTA7dDxzLmxlbmd0aDt0Kyspci5wdXNoKHNbdF0pO3JldHVybn19fSx1dC5hc0xpc3Q9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49MCxpPXQubGVuZ3RoO2k+bjtuKyspZS5hZGQodFtuXSk7cmV0dXJuIGV9LGUobHQucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsdH19KSxsdC50b0RpbWVuc2lvblN5bWJvbD1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSBsdC5GQUxTRTpyZXR1cm4gbHQuU1lNX0ZBTFNFO2Nhc2UgbHQuVFJVRTpyZXR1cm4gbHQuU1lNX1RSVUU7Y2FzZSBsdC5ET05UQ0FSRTpyZXR1cm4gbHQuU1lNX0RPTlRDQVJFO2Nhc2UgbHQuUDpyZXR1cm4gbHQuU1lNX1A7Y2FzZSBsdC5MOnJldHVybiBsdC5TWU1fTDtjYXNlIGx0LkE6cmV0dXJuIGx0LlNZTV9BfXRocm93IG5ldyBpKFwiVW5rbm93biBkaW1lbnNpb24gdmFsdWU6IFwiK3QpfSxsdC50b0RpbWVuc2lvblZhbHVlPWZ1bmN0aW9uKHQpe3N3aXRjaChPLnRvVXBwZXJDYXNlKHQpKXtjYXNlIGx0LlNZTV9GQUxTRTpyZXR1cm4gbHQuRkFMU0U7Y2FzZSBsdC5TWU1fVFJVRTpyZXR1cm4gbHQuVFJVRTtjYXNlIGx0LlNZTV9ET05UQ0FSRTpyZXR1cm4gbHQuRE9OVENBUkU7Y2FzZSBsdC5TWU1fUDpyZXR1cm4gbHQuUDtjYXNlIGx0LlNZTV9MOnJldHVybiBsdC5MO2Nhc2UgbHQuU1lNX0E6cmV0dXJuIGx0LkF9dGhyb3cgbmV3IGkoXCJVbmtub3duIGRpbWVuc2lvbiBzeW1ib2w6IFwiK3QpfSxsdC5QPTAsbHQuTD0xLGx0LkE9MixsdC5GQUxTRT0tMSxsdC5UUlVFPS0yLGx0LkRPTlRDQVJFPS0zLGx0LlNZTV9GQUxTRT1cIkZcIixsdC5TWU1fVFJVRT1cIlRcIixsdC5TWU1fRE9OVENBUkU9XCIqXCIsbHQuU1lNX1A9XCIwXCIsbHQuU1lNX0w9XCIxXCIsbHQuU1lNX0E9XCIyXCIsZShodC5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGh0fX0pLGUoY3QucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCxlKXt9LGlzRG9uZTpmdW5jdGlvbigpe30saXNHZW9tZXRyeUNoYW5nZWQ6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGN0fX0pLGgoZnQsQiksZShmdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBDLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuZ2VvbWV0cmllc1tlXS5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiB0fSxnZXRHZW9tZXRyeU46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cmllc1t0XX0sZ2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTn0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCksZT0tMSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKylmb3IodmFyIGk9dGhpcy5nZW9tZXRyaWVzW25dLmdldENvb3JkaW5hdGVzKCkscj0wO3I8aS5sZW5ndGg7cisrKWUrKyx0W2VdPWlbcl07cmV0dXJuIHR9LGdldEFyZWE6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmdlb21ldHJpZXNbZV0uZ2V0QXJlYSgpO3JldHVybiB0fSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7dmFyIG49dDtpZih0aGlzLmdlb21ldHJpZXMubGVuZ3RoIT09bi5nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGk9MDtpPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7aSsrKWlmKCF0aGlzLmdlb21ldHJpZXNbaV0uZXF1YWxzRXhhY3Qobi5nZW9tZXRyaWVzW2ldLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBCLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDt0KyspdGhpcy5nZW9tZXRyaWVzW3RdLm5vcm1hbGl6ZSgpO3V0LnNvcnQodGhpcy5nZW9tZXRyaWVzKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2VvbWV0cmllc1swXS5nZXRDb29yZGluYXRlKCl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWx0LkZBTFNFLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLmdlb21ldHJpZXNbZV0uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSk7cmV0dXJuIHR9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe2Zvcih2YXIgdD1sdC5GQUxTRSxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5nZW9tZXRyaWVzW2VdLmdldERpbWVuc2lvbigpKTtyZXR1cm4gdH0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5nZW9tZXRyaWVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmdlb21ldHJpZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9LGdldE51bUdlb21ldHJpZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW9tZXRyaWVzLmxlbmd0aH0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksbj0wO248dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZVtuXT10aGlzLmdlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9LGNvbXBhcmVUb1NhbWVDbGFzczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgYXQodXQuYXNMaXN0KHRoaXMuZ2VvbWV0cmllcykpLG49bmV3IGF0KHV0LmFzTGlzdCh0Lmdlb21ldHJpZXMpKTtyZXR1cm4gdGhpcy5jb21wYXJlKGUsbil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1pLG89dGhpcy5nZXROdW1HZW9tZXRyaWVzKCksYT1zLmdldE51bUdlb21ldHJpZXMoKSx1PTA7bz51JiZhPnU7KXt2YXIgbD10aGlzLmdldEdlb21ldHJ5Tih1KSxoPXMuZ2V0R2VvbWV0cnlOKHUpLGM9bC5jb21wYXJlVG9TYW1lQ2xhc3MoaCxyKTtpZigwIT09YylyZXR1cm4gYzt1Kyt9cmV0dXJuIG8+dT8xOmE+dT8tMTowfX0sYXBwbHk6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx6KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseSh0KTtlbHNlIGlmKFIoYXJndW1lbnRzWzBdLGN0KSl7dmFyIG49YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLmdlb21ldHJpZXMubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aCYmKHRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseShuKSwhbi5pc0RvbmUoKSk7ZSsrKTtuLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpLmZpbHRlcih0aGlzKTtmb3IodmFyIGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseShpKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgcj1hcmd1bWVudHNbMF07ci5maWx0ZXIodGhpcyk7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLmdlb21ldHJpZXNbZV0uYXBwbHkocil9fSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSxudWxsfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7dC5nZW9tZXRyaWVzPW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdC5nZW9tZXRyaWVzW2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jbG9uZSgpO3JldHVybiB0fSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIkdlb21ldHJ5Q29sbGVjdGlvblwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBmdCh0LHRoaXMuZmFjdG9yeSl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLmdlb21ldHJpZXNbdF0uaXNFbXB0eSgpKXJldHVybiExO3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmdH19KSxmdC5zZXJpYWxWZXJzaW9uVUlEPS0weDRmMDdiY2IxZjg1N2Q4MDAsaChndCxmdCksZShndC5wcm90b3R5cGUse2dldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkd9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KT9mdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSk6ITF9cmV0dXJuIGZ0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT9sdC5GQUxTRTowfSxpc0Nsb3NlZDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiExO2Zvcih2YXIgdD0wO3Q8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuZ2VvbWV0cmllc1t0XS5pc0Nsb3NlZCgpKXJldHVybiExO3JldHVybiEwfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMX0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksbj0wO248dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZVt0LTEtbl09dGhpcy5nZW9tZXRyaWVzW25dLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe1xucmV0dXJuIG5ldyBkdCh0aGlzKS5nZXRCb3VuZGFyeSgpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIk11bHRpTGluZVN0cmluZ1wifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBndCh0LHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3N0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ3R9fSksZ3Quc2VyaWFsVmVyc2lvblVJRD0weDcxNTVkMmFiNGFmYTgwMDAsZShkdC5wcm90b3R5cGUse2JvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7dmFyIGU9dGhpcy5jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyh0KTtyZXR1cm4gMT09PWUubGVuZ3RoP3RoaXMuZ2VvbUZhY3QuY3JlYXRlUG9pbnQoZVswXSk6dGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhlKX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW9tIGluc3RhbmNlb2YgU3Q/dGhpcy5ib3VuZGFyeUxpbmVTdHJpbmcodGhpcy5nZW9tKTp0aGlzLmdlb20gaW5zdGFuY2VvZiBndD90aGlzLmJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nKHRoaXMuZ2VvbSk6dGhpcy5nZW9tLmdldEJvdW5kYXJ5KCl9LGJvdW5kYXJ5TGluZVN0cmluZzpmdW5jdGlvbih0KXtpZih0aGlzLmdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpO2lmKHQuaXNDbG9zZWQoKSl7dmFyIGU9dGhpcy5iblJ1bGUuaXNJbkJvdW5kYXJ5KDIpO3JldHVybiBlP3QuZ2V0U3RhcnRQb2ludCgpOnRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfXJldHVybiB0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoW3QuZ2V0U3RhcnRQb2ludCgpLHQuZ2V0RW5kUG9pbnQoKV0pfSxnZXRFbXB0eU11bHRpUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9LGNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBJO3RoaXMuZW5kcG9pbnRNYXA9bmV3IHJ0O2Zvcih2YXIgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10LmdldEdlb21ldHJ5TihuKTswIT09aS5nZXROdW1Qb2ludHMoKSYmKHRoaXMuYWRkRW5kcG9pbnQoaS5nZXRDb29yZGluYXRlTigwKSksdGhpcy5hZGRFbmRwb2ludChpLmdldENvb3JkaW5hdGVOKGkuZ2V0TnVtUG9pbnRzKCktMSkpKX1mb3IodmFyIHI9dGhpcy5lbmRwb2ludE1hcC5lbnRyeVNldCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXMuZ2V0VmFsdWUoKSxhPW8uY291bnQ7dGhpcy5iblJ1bGUuaXNJbkJvdW5kYXJ5KGEpJiZlLmFkZChzLmdldEtleSgpKX1yZXR1cm4gSC50b0Nvb3JkaW5hdGVBcnJheShlKX0sYWRkRW5kcG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lbmRwb2ludE1hcC5nZXQodCk7bnVsbD09PWUmJihlPW5ldyBwdCx0aGlzLmVuZHBvaW50TWFwLnB1dCh0LGUpKSxlLmNvdW50Kyt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGR0fX0pLGR0LmdldEJvdW5kYXJ5PWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBkdCh0KTtyZXR1cm4gZS5nZXRCb3VuZGFyeSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1uZXcgZHQobixpKTtyZXR1cm4gZS5nZXRCb3VuZGFyeSgpfX0sZShwdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHB0fX0pLGUoTnQucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOdH19KSxOdC5jaGFycz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgQXJyYXkoZSkuZmlsbChudWxsKSxpPTA7ZT5pO2krKyluW2ldPXQ7cmV0dXJuIG5ldyBTdHJpbmcobil9LE50LmdldFN0YWNrVHJhY2U9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IHh0LG49bmV3IHZ0KGUpO3JldHVybiB0LnByaW50U3RhY2tUcmFjZShuKSxlLnRvU3RyaW5nKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1cIlwiLG89bmV3IG10KE50LmdldFN0YWNrVHJhY2UoaSkpLGE9bmV3IEl0KG8pLHU9MDtyPnU7dSsrKXRyeXtzKz1hLnJlYWRMaW5lKCkrTnQuTkVXTElORX1jYXRjaChsKXtpZighKGwgaW5zdGFuY2VvZiBFdCkpdGhyb3cgbDtmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9ZmluYWxseXt9cmV0dXJuIHN9fSxOdC5zcGxpdD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLmxlbmd0aCxpPW5ldyBJLHI9XCJcIit0LHM9ci5pbmRleE9mKGUpO3M+PTA7KXt2YXIgbz1yLnN1YnN0cmluZygwLHMpO2kuYWRkKG8pLHI9ci5zdWJzdHJpbmcocytuKSxzPXIuaW5kZXhPZihlKX1yLmxlbmd0aD4wJiZpLmFkZChyKTtmb3IodmFyIGE9bmV3IEFycmF5KGkuc2l6ZSgpKS5maWxsKG51bGwpLHU9MDt1PGEubGVuZ3RoO3UrKylhW3VdPWkuZ2V0KHUpO3JldHVybiBhfSxOdC50b1N0cmluZz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIE50LlNJTVBMRV9PUkRJTkFURV9GT1JNQVQuZm9ybWF0KHQpfX0sTnQuc3BhY2VzPWZ1bmN0aW9uKHQpe3JldHVybiBOdC5jaGFycyhcIiBcIix0KX0sTnQuTkVXTElORT1BLmdldFByb3BlcnR5KFwibGluZS5zZXBhcmF0b3JcIiksTnQuU0lNUExFX09SRElOQVRFX0ZPUk1BVD1uZXcgeXQoXCIwLiNcIiksZShDdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEN0fX0pLEN0LmNvcHlDb29yZD1mdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHI9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxuLmdldERpbWVuc2lvbigpKSxzPTA7cj5zO3MrKyluLnNldE9yZGluYXRlKGkscyx0LmdldE9yZGluYXRlKGUscykpfSxDdC5pc1Jpbmc9ZnVuY3Rpb24odCl7dmFyIGU9dC5zaXplKCk7cmV0dXJuIDA9PT1lPyEwOjM+PWU/ITE6dC5nZXRPcmRpbmF0ZSgwLEQuWCk9PT10LmdldE9yZGluYXRlKGUtMSxELlgpJiZ0LmdldE9yZGluYXRlKDAsRC5ZKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEQuWSl9LEN0LmlzRXF1YWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10LnNpemUoKSxpPWUuc2l6ZSgpO2lmKG4hPT1pKXJldHVybiExO2Zvcih2YXIgcz1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpLG89MDtuPm87bysrKWZvcih2YXIgYT0wO3M+YTthKyspe3ZhciB1PXQuZ2V0T3JkaW5hdGUobyxhKSxsPWUuZ2V0T3JkaW5hdGUobyxhKTtpZighKHQuZ2V0T3JkaW5hdGUobyxhKT09PWUuZ2V0T3JkaW5hdGUobyxhKXx8ci5pc05hTih1KSYmci5pc05hTihsKSkpcmV0dXJuITF9cmV0dXJuITB9LEN0LmV4dGVuZD1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxyPWUuc2l6ZSgpO2lmKEN0LmNvcHkoZSwwLGksMCxyKSxyPjApZm9yKHZhciBzPXI7bj5zO3MrKylDdC5jb3B5KGUsci0xLGkscywxKTtyZXR1cm4gaX0sQ3QucmV2ZXJzZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zaXplKCktMSxuPU1hdGgudHJ1bmMoZS8yKSxpPTA7bj49aTtpKyspQ3Quc3dhcCh0LGksZS1pKX0sQ3Quc3dhcD1mdW5jdGlvbih0LGUsbil7aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKHZhciBpPTA7aTx0LmdldERpbWVuc2lvbigpO2krKyl7dmFyIHI9dC5nZXRPcmRpbmF0ZShlLGkpO3Quc2V0T3JkaW5hdGUoZSxpLHQuZ2V0T3JkaW5hdGUobixpKSksdC5zZXRPcmRpbmF0ZShuLGkscil9fSxDdC5jb3B5PWZ1bmN0aW9uKHQsZSxuLGkscil7Zm9yKHZhciBzPTA7cj5zO3MrKylDdC5jb3B5Q29vcmQodCxlK3MsbixpK3MpfSxDdC50b1N0cmluZz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10LnNpemUoKTtpZigwPT09ZSlyZXR1cm5cIigpXCI7dmFyIG49dC5nZXREaW1lbnNpb24oKSxpPW5ldyBQO2kuYXBwZW5kKFwiKFwiKTtmb3IodmFyIHI9MDtlPnI7cisrKXtyPjAmJmkuYXBwZW5kKFwiIFwiKTtmb3IodmFyIHM9MDtuPnM7cysrKXM+MCYmaS5hcHBlbmQoXCIsXCIpLGkuYXBwZW5kKE50LnRvU3RyaW5nKHQuZ2V0T3JkaW5hdGUocixzKSkpfXJldHVybiBpLmFwcGVuZChcIilcIiksaS50b1N0cmluZygpfX0sQ3QuZW5zdXJlVmFsaWRSaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zaXplKCk7aWYoMD09PW4pcmV0dXJuIGU7aWYoMz49bilyZXR1cm4gQ3QuY3JlYXRlQ2xvc2VkUmluZyh0LGUsNCk7dmFyIGk9ZS5nZXRPcmRpbmF0ZSgwLEQuWCk9PT1lLmdldE9yZGluYXRlKG4tMSxELlgpJiZlLmdldE9yZGluYXRlKDAsRC5ZKT09PWUuZ2V0T3JkaW5hdGUobi0xLEQuWSk7cmV0dXJuIGk/ZTpDdC5jcmVhdGVDbG9zZWRSaW5nKHQsZSxuKzEpfSxDdC5jcmVhdGVDbG9zZWRSaW5nPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLHI9ZS5zaXplKCk7Q3QuY29weShlLDAsaSwwLHIpO2Zvcih2YXIgcz1yO24+cztzKyspQ3QuY29weShlLDAsaSxzLDEpO3JldHVybiBpfSxoKFN0LEIpLGUoU3QucHJvdG90eXBlLHtjb21wdXRlRW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9uZXcgQzp0aGlzLnBvaW50cy5leHBhbmRFbnZlbG9wZShuZXcgQyl9LGlzUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCkmJnRoaXMuaXNTaW1wbGUoKX0sZ2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX0xJTkVTVFJJTkd9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnRzLnRvQ29vcmRpbmF0ZUFycmF5KCl9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10O2lmKHRoaXMucG9pbnRzLnNpemUoKSE9PW4ucG9pbnRzLnNpemUoKSlyZXR1cm4hMTtmb3IodmFyIGk9MDtpPHRoaXMucG9pbnRzLnNpemUoKTtpKyspaWYoIXRoaXMuZXF1YWwodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSxuLnBvaW50cy5nZXRDb29yZGluYXRlKGkpLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBCLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8TWF0aC50cnVuYyh0aGlzLnBvaW50cy5zaXplKCkvMik7dCsrKXt2YXIgZT10aGlzLnBvaW50cy5zaXplKCktMS10O2lmKCF0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpLmVxdWFscyh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpKSlyZXR1cm4gdGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5jb21wYXJlVG8odGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSk+MCYmQ3QucmV2ZXJzZSh0aGlzLnBvaW50cyksbnVsbH19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKDApfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/bHQuRkFMU0U6MH0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/ITE6dGhpcy5nZXRDb29yZGluYXRlTigwKS5lcXVhbHMyRCh0aGlzLmdldENvb3JkaW5hdGVOKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSkpfSxnZXRFbmRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2V0UG9pbnROKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSl9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gaGUuY29tcHV0ZUxlbmd0aCh0aGlzLnBvaW50cyl9LGdldE51bVBvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvaW50cy5zaXplKCl9LHJldmVyc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvaW50cy5jb3B5KCk7Q3QucmV2ZXJzZSh0KTt2YXIgZT10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQpO3JldHVybiBlfSxjb21wYXJlVG9TYW1lQ2xhc3M6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQsbj0wLGk9MDtuPHRoaXMucG9pbnRzLnNpemUoKSYmaTxlLnBvaW50cy5zaXplKCk7KXt2YXIgcj10aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKG4pLmNvbXBhcmVUbyhlLnBvaW50cy5nZXRDb29yZGluYXRlKGkpKTtpZigwIT09cilyZXR1cm4gcjtuKyssaSsrfXJldHVybiBuPHRoaXMucG9pbnRzLnNpemUoKT8xOmk8ZS5wb2ludHMuc2l6ZSgpPy0xOjB9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxlPXM7cmV0dXJuIG8uY29tcGFyZSh0aGlzLnBvaW50cyxlLnBvaW50cyl9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5wb2ludHMuc2l6ZSgpO2UrKyl0LmZpbHRlcih0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpKTtlbHNlIGlmKFIoYXJndW1lbnRzWzBdLGN0KSl7dmFyIG49YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLnBvaW50cy5zaXplKCkpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTx0aGlzLnBvaW50cy5zaXplKCkmJihuLmZpbHRlcih0aGlzLnBvaW50cyxlKSwhbi5pc0RvbmUoKSk7ZSsrKTtuLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpLmZpbHRlcih0aGlzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgcj1hcmd1bWVudHNbMF07ci5maWx0ZXIodGhpcyl9fSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiBuZXcgZHQodGhpcykuZ2V0Qm91bmRhcnkoKX0saXNFcXVpdmFsZW50Q2xhc3M6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBTdH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1CLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0LnBvaW50cz10aGlzLnBvaW50cy5jbG9uZSgpLHR9LGdldENvb3JkaW5hdGVOOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIkxpbmVTdHJpbmdcIn0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgU3QodGhpcy5wb2ludHMuY29weSgpLHRoaXMuZmFjdG9yeSl9LGdldENvb3JkaW5hdGVTZXF1ZW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvaW50c30saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5wb2ludHMuc2l6ZSgpfSxpbml0OmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksMT09PXQuc2l6ZSgpKXRocm93IG5ldyBpKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVTdHJpbmcgKGZvdW5kIFwiK3Quc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDIpXCIpO3RoaXMucG9pbnRzPXR9LGlzQ29vcmRpbmF0ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMucG9pbnRzLnNpemUoKTtlKyspaWYodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKS5lcXVhbHModCkpcmV0dXJuITA7cmV0dXJuITF9LGdldFN0YXJ0UG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50TigwKX0sZ2V0UG9pbnROOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTdH19KSxTdC5zZXJpYWxWZXJzaW9uVUlEPTB4MmIyYjUxYmE0MzVjOGUwMCxlKHd0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd3R9fSksaChMdCxCKSxlKEx0LnByb3RvdHlwZSx7Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbmV3IEM7dmFyIHQ9bmV3IEM7cmV0dXJuIHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY29vcmRpbmF0ZXMuZ2V0WCgwKSx0aGlzLmNvb3JkaW5hdGVzLmdldFkoMCkpLHR9LGdldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9QT0lOVH0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/W106W3RoaXMuZ2V0Q29vcmRpbmF0ZSgpXX0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpP3RoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKT8hMDp0aGlzLmlzRW1wdHkoKSE9PXQuaXNFbXB0eSgpPyExOnRoaXMuZXF1YWwodC5nZXRDb29yZGluYXRlKCksdGhpcy5nZXRDb29yZGluYXRlKCksZSk6ITF9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLmNvb3JkaW5hdGVzLnNpemUoKT90aGlzLmNvb3JkaW5hdGVzLmdldENvb3JkaW5hdGUoMCk6bnVsbH0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAwfSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoxfSxyZXZlcnNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29weSgpfSxnZXRYOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJnZXRYIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueH0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQ7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyhlLmdldENvb3JkaW5hdGUoKSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW47cmV0dXJuIGkuY29tcGFyZSh0aGlzLmNvb3JkaW5hdGVzLGUuY29vcmRpbmF0ZXMpfX0sYXBwbHk6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx6KSl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGN0KSl7dmFyIGU9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO2UuZmlsdGVyKHRoaXMuY29vcmRpbmF0ZXMsMCksZS5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0saHQpKXt2YXIgbj1hcmd1bWVudHNbMF07bi5maWx0ZXIodGhpcyl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxxKSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuY29vcmRpbmF0ZXM9dGhpcy5jb29yZGluYXRlcy5jbG9uZSgpLHR9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiUG9pbnRcIn0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgTHQodGhpcy5jb29yZGluYXRlcy5jb3B5KCksdGhpcy5mYWN0b3J5KX0sZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXN9LGdldFk6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFkgY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS55fSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmNvb3JkaW5hdGVzLnNpemUoKX0saW5pdDpmdW5jdGlvbih0KXtudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLGYuaXNUcnVlKHQuc2l6ZSgpPD0xKSx0aGlzLmNvb3JkaW5hdGVzPXR9LGlzU2ltcGxlOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3d0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTHR9fSksTHQuc2VyaWFsVmVyc2lvblVJRD0weDQ0MDc3YmFkMTYxY2JjMDAsZShSdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJ0fX0pLGgoVHQsQiksZShUdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfUE9MWUdPTn0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm5bXTtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCksZT0tMSxuPXRoaXMuc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKSxpPTA7aTxuLmxlbmd0aDtpKyspZSsrLHRbZV09bltpXTtmb3IodmFyIHI9MDtyPHRoaXMuaG9sZXMubGVuZ3RoO3IrKylmb3IodmFyIHM9dGhpcy5ob2xlc1tyXS5nZXRDb29yZGluYXRlcygpLG89MDtvPHMubGVuZ3RoO28rKyllKyssdFtlXT1zW29dO3JldHVybiB0fSxnZXRBcmVhOmZ1bmN0aW9uKCl7dmFyIHQ9MDt0Kz1NYXRoLmFicyhoZS5zaWduZWRBcmVhKHRoaXMuc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0LT1NYXRoLmFicyhoZS5zaWduZWRBcmVhKHRoaXMuaG9sZXNbZV0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpKTtyZXR1cm4gdH0saXNSZWN0YW5nbGU6ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSlyZXR1cm4hMTtpZihudWxsPT09dGhpcy5zaGVsbClyZXR1cm4hMTtpZig1IT09dGhpcy5zaGVsbC5nZXROdW1Qb2ludHMoKSlyZXR1cm4hMTtmb3IodmFyIHQ9dGhpcy5zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxlPXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG49MDs1Pm47bisrKXt2YXIgaT10LmdldFgobik7aWYoaSE9PWUuZ2V0TWluWCgpJiZpIT09ZS5nZXRNYXhYKCkpcmV0dXJuITE7dmFyIHI9dC5nZXRZKG4pO2lmKHIhPT1lLmdldE1pblkoKSYmciE9PWUuZ2V0TWF4WSgpKXJldHVybiExfWZvcih2YXIgcz10LmdldFgoMCksbz10LmdldFkoMCksbj0xOzQ+PW47bisrKXt2YXIgaT10LmdldFgobikscj10LmdldFkobiksYT1pIT09cyx1PXIhPT1vO2lmKGE9PT11KXJldHVybiExO3M9aSxvPXJ9cmV0dXJuITB9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10LGk9dGhpcy5zaGVsbCxyPW4uc2hlbGw7aWYoIWkuZXF1YWxzRXhhY3QocixlKSlyZXR1cm4hMTtpZih0aGlzLmhvbGVzLmxlbmd0aCE9PW4uaG9sZXMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgcz0wO3M8dGhpcy5ob2xlcy5sZW5ndGg7cysrKWlmKCF0aGlzLmhvbGVzW3NdLmVxdWFsc0V4YWN0KG4uaG9sZXNbc10sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMubm9ybWFsaXplKHRoaXMuc2hlbGwsITApO2Zvcih2YXIgdD0wO3Q8dGhpcy5ob2xlcy5sZW5ndGg7dCsrKXRoaXMubm9ybWFsaXplKHRoaXMuaG9sZXNbdF0sITEpO3V0LnNvcnQodGhpcy5ob2xlcyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKGUuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBpPW5ldyBBcnJheShlLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpLmZpbGwobnVsbCk7QS5hcnJheWNvcHkoZS5nZXRDb29yZGluYXRlcygpLDAsaSwwLGkubGVuZ3RoKTt2YXIgcj1ILm1pbkNvb3JkaW5hdGUoZS5nZXRDb29yZGluYXRlcygpKTtILnNjcm9sbChpLHIpLEEuYXJyYXljb3B5KGksMCxlLmdldENvb3JkaW5hdGVzKCksMCxpLmxlbmd0aCksZS5nZXRDb29yZGluYXRlcygpW2kubGVuZ3RoXT1pWzBdLGhlLmlzQ0NXKGUuZ2V0Q29vcmRpbmF0ZXMoKSk9PT1uJiZILnJldmVyc2UoZS5nZXRDb29yZGluYXRlcygpKX19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbC5nZXRDb29yZGluYXRlKCl9LGdldE51bUludGVyaW9yUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhvbGVzLmxlbmd0aH0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDJ9LGdldExlbmd0aDpmdW5jdGlvbigpe3ZhciB0PTA7dCs9dGhpcy5zaGVsbC5nZXRMZW5ndGgoKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmhvbGVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5zaGVsbC5nZXROdW1Qb2ludHMoKSxlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5ob2xlc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH0scmV2ZXJzZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY29weSgpO3Quc2hlbGw9dGhpcy5zaGVsbC5jb3B5KCkucmV2ZXJzZSgpLHQuaG9sZXM9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQuaG9sZXNbZV09dGhpcy5ob2xlc1tlXS5jb3B5KCkucmV2ZXJzZSgpO3JldHVybiB0fSxjb252ZXhIdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkuY29udmV4SHVsbCgpfSxjb21wYXJlVG9TYW1lQ2xhc3M6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5zaGVsbCxuPXQuc2hlbGw7cmV0dXJuIGUuY29tcGFyZVRvU2FtZUNsYXNzKG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1pLGU9dGhpcy5zaGVsbCxuPXMuc2hlbGwsbz1lLmNvbXBhcmVUb1NhbWVDbGFzcyhuLHIpO2lmKDAhPT1vKXJldHVybiBvO2Zvcih2YXIgYT10aGlzLmdldE51bUludGVyaW9yUmluZygpLHU9cy5nZXROdW1JbnRlcmlvclJpbmcoKSxsPTA7YT5sJiZ1Pmw7KXt2YXIgaD10aGlzLmdldEludGVyaW9yUmluZ04obCksYz1zLmdldEludGVyaW9yUmluZ04obCksZj1oLmNvbXBhcmVUb1NhbWVDbGFzcyhjLHIpO2lmKDAhPT1mKXJldHVybiBmO2wrK31yZXR1cm4gYT5sPzE6dT5sPy0xOjB9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zaGVsbC5hcHBseSh0KTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0aGlzLmhvbGVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5zaGVsbC5hcHBseShuKSwhbi5pc0RvbmUoKSlmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoJiYodGhpcy5ob2xlc1tlXS5hcHBseShuKSwhbi5pc0RvbmUoKSk7ZSsrKTtuLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpLmZpbHRlcih0aGlzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgcj1hcmd1bWVudHNbMF07ci5maWx0ZXIodGhpcyksdGhpcy5zaGVsbC5hcHBseShyKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0aGlzLmhvbGVzW2VdLmFwcGx5KHIpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7dmFyIHQ9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKzEpLmZpbGwobnVsbCk7dFswXT10aGlzLnNoZWxsO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXRbZSsxXT10aGlzLmhvbGVzW2VdO3JldHVybiB0Lmxlbmd0aDw9MT90aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHRbMF0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpOnRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1CLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO3Quc2hlbGw9dGhpcy5zaGVsbC5jbG9uZSgpLHQuaG9sZXM9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQuaG9sZXNbZV09dGhpcy5ob2xlc1tlXS5jbG9uZSgpO3JldHVybiB0fSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIlBvbHlnb25cIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLnNoZWxsLmNvcHkoKSxlPW5ldyBBcnJheSh0aGlzLmhvbGVzLmxlbmd0aCkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10aGlzLmhvbGVzW25dLmNvcHkoKTtyZXR1cm4gbmV3IFR0KHQsZSx0aGlzLmZhY3RvcnkpfSxnZXRFeHRlcmlvclJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbH0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsLmlzRW1wdHkoKX0sZ2V0SW50ZXJpb3JSaW5nTjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ob2xlc1t0XX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bUnRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUdH19KSxUdC5zZXJpYWxWZXJzaW9uVUlEPS0weDMwN2ZmZWZkOGRjOTcyMDAsaChQdCxmdCksZShQdC5wcm90b3R5cGUse2dldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9NVUxUSVBPSU5UfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KT9mdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSk6ITF9cmV0dXJuIGZ0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmdlb21ldHJpZXNbdF0uZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiBmdC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGx0LkZBTFNFfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIk11bHRpUG9pbnRcIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKSxlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLmdlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgUHQodCx0aGlzLmZhY3RvcnkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt3dF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFB0fX0pLFB0LnNlcmlhbFZlcnNpb25VSUQ9LTB4NmZiMWVkNDE2MmUwZmMwMCxoKGJ0LFN0KSxlKGJ0LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX0xJTkVBUlJJTkd9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGx0LkZBTFNFfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8hMDpTdC5wcm90b3R5cGUuaXNDbG9zZWQuY2FsbCh0aGlzKX0scmV2ZXJzZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucG9pbnRzLmNvcHkoKTtDdC5yZXZlcnNlKHQpO3ZhciBlPXRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodCk7cmV0dXJuIGV9LHZhbGlkYXRlQ29uc3RydWN0aW9uOmZ1bmN0aW9uKCl7aWYoIXRoaXMuaXNFbXB0eSgpJiYhU3QucHJvdG90eXBlLmlzQ2xvc2VkLmNhbGwodGhpcykpdGhyb3cgbmV3IGkoXCJQb2ludHMgb2YgTGluZWFyUmluZyBkbyBub3QgZm9ybSBhIGNsb3NlZCBsaW5lc3RyaW5nXCIpO2lmKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPj0xJiZ0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKTxidC5NSU5JTVVNX1ZBTElEX1NJWkUpdGhyb3cgbmV3IGkoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZWFyUmluZyAoZm91bmQgXCIrdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gNClcIil9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTGluZWFyUmluZ1wifSxjb3B5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBidCh0aGlzLnBvaW50cy5jb3B5KCksdGhpcy5mYWN0b3J5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYnR9fSksYnQuTUlOSU1VTV9WQUxJRF9TSVpFPTQsYnQuc2VyaWFsVmVyc2lvblVJRD0tMHgzYjIyOWUyNjIzNjdhNjAwLGgoT3QsZnQpLGUoT3QucHJvdG90eXBlLHtnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTVVMVElQT0xZR09OfSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCk/ZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpOiExfXJldHVybiBmdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMn0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksbj0wO248dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZVtuXT10aGlzLmdlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2Zvcih2YXIgdD1uZXcgSSxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKylmb3IodmFyIG49dGhpcy5nZW9tZXRyaWVzW2VdLGk9bi5nZXRCb3VuZGFyeSgpLHI9MDtyPGkuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl0LmFkZChpLmdldEdlb21ldHJ5TihyKSk7dmFyIHM9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcodC50b0FycmF5KHMpKX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJNdWx0aVBvbHlnb25cIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKSxlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLmdlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgT3QodCx0aGlzLmZhY3RvcnkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE90fX0pLE90LnNlcmlhbFZlcnNpb25VSUQ9LTB4N2E1YWExMzY5MTcxOTgwLGUoX3QucHJvdG90eXBlLHtzZXRDb3B5VXNlckRhdGE6ZnVuY3Rpb24odCl7dGhpcy5pc1VzZXJEYXRhQ29waWVkPXR9LGVkaXQ6ZnVuY3Rpb24odCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDt2YXIgbj10aGlzLmVkaXRJbnRlcm5hbCh0LGUpO3JldHVybiB0aGlzLmlzVXNlckRhdGFDb3BpZWQmJm4uc2V0VXNlckRhdGEodC5nZXRVc2VyRGF0YSgpKSxufSxlZGl0SW50ZXJuYWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXRoaXMuZmFjdG9yeSYmKHRoaXMuZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdCBpbnN0YW5jZW9mIGZ0P3RoaXMuZWRpdEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpOnQgaW5zdGFuY2VvZiBUdD90aGlzLmVkaXRQb2x5Z29uKHQsZSk6dCBpbnN0YW5jZW9mIEx0P2UuZWRpdCh0LHRoaXMuZmFjdG9yeSk6dCBpbnN0YW5jZW9mIFN0P2UuZWRpdCh0LHRoaXMuZmFjdG9yeSk6KGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbnN1cHBvcnRlZCBHZW9tZXRyeSBjbGFzczogXCIrdC5nZXRDbGFzcygpLmdldE5hbWUoKSksbnVsbCl9LGVkaXRHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KSxpPW5ldyBJLHI9MDtyPG4uZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIHM9dGhpcy5lZGl0KG4uZ2V0R2VvbWV0cnlOKHIpLGUpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8aS5hZGQocyl9cmV0dXJuIG4uZ2V0Q2xhc3MoKT09PVB0P3RoaXMuZmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGkudG9BcnJheShbXSkpOm4uZ2V0Q2xhc3MoKT09PWd0P3RoaXMuZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoaS50b0FycmF5KFtdKSk6bi5nZXRDbGFzcygpPT09T3Q/dGhpcy5mYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihpLnRvQXJyYXkoW10pKTp0aGlzLmZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGkudG9BcnJheShbXSkpfSxlZGl0UG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPWUuZWRpdCh0LHRoaXMuZmFjdG9yeSk7aWYobnVsbD09PW4mJihuPXRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKG51bGwpKSxuLmlzRW1wdHkoKSlyZXR1cm4gbjt2YXIgaT10aGlzLmVkaXQobi5nZXRFeHRlcmlvclJpbmcoKSxlKTtpZihudWxsPT09aXx8aS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCk7Zm9yKHZhciByPW5ldyBJLHM9MDtzPG4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXt2YXIgbz10aGlzLmVkaXQobi5nZXRJbnRlcmlvclJpbmdOKHMpLGUpO251bGw9PT1vfHxvLmlzRW1wdHkoKXx8ci5hZGQobyl9cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKGksci50b0FycmF5KFtdKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF90fX0pLF90Lkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uPU10LGUoRHQucHJvdG90eXBlLHtlZGl0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRHR9fSksZShBdC5wcm90b3R5cGUse2VkaXQ6ZnVuY3Rpb24odCxlKXtpZih0IGluc3RhbmNlb2YgYnQpcmV0dXJuIGUuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCksdCkpO2lmKHQgaW5zdGFuY2VvZiBTdClyZXR1cm4gZS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZWRpdENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSk7aWYodCBpbnN0YW5jZW9mIEx0KXt2YXIgbj10aGlzLmVkaXRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCksdCk7cmV0dXJuIG4ubGVuZ3RoPjA/ZS5jcmVhdGVQb2ludChuWzBdKTplLmNyZWF0ZVBvaW50KCl9cmV0dXJuIHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQXR9fSksZShGdC5wcm90b3R5cGUse2VkaXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIGJ0P2UuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIFN0P2UuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIEx0P2UuY3JlYXRlUG9pbnQodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRnR9fSksX3QuTm9PcEdlb21ldHJ5T3BlcmF0aW9uPUR0LF90LkNvb3JkaW5hdGVPcGVyYXRpb249QXQsX3QuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uPUZ0LGUoR3QucHJvdG90eXBlLHtzZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUsbil7c3dpdGNoKGUpe2Nhc2UgRC5YOnRoaXMuY29vcmRpbmF0ZXNbdF0ueD1uO2JyZWFrO2Nhc2UgRC5ZOnRoaXMuY29vcmRpbmF0ZXNbdF0ueT1uO2JyZWFrO2Nhc2UgRC5aOnRoaXMuY29vcmRpbmF0ZXNbdF0uej1uO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IGkoXCJpbnZhbGlkIG9yZGluYXRlSW5kZXhcIil9fSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RofSxnZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUpe3N3aXRjaChlKXtjYXNlIEQuWDpyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS54O2Nhc2UgRC5ZOnJldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLnk7Y2FzZSBELlo6cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0uen1yZXR1cm4gci5OYU59LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07bi54PXRoaXMuY29vcmRpbmF0ZXNbZV0ueCxuLnk9dGhpcy5jb29yZGluYXRlc1tlXS55LG4uej10aGlzLmNvb3JkaW5hdGVzW2VdLnp9fSxnZXRDb29yZGluYXRlQ29weTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodGhpcy5jb29yZGluYXRlc1t0XSl9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpbWVuc2lvbn0sZ2V0WDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS54fSxjbG9uZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCksZT0wO2U8dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXRbZV09dGhpcy5jb29yZGluYXRlc1tlXS5jbG9uZSgpO3JldHVybiBuZXcgR3QodCx0aGlzLmRpbWVuc2lvbil9LGV4cGFuZEVudmVsb3BlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0fSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKSxlPTA7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdFtlXT10aGlzLmNvb3JkaW5hdGVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IEd0KHQsdGhpcy5kaW1lbnNpb24pfSx0b1N0cmluZzpmdW5jdGlvbigpe2lmKHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoPjApe3ZhciB0PW5ldyBQKDE3KnRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoKTt0LmFwcGVuZChcIihcIiksdC5hcHBlbmQodGhpcy5jb29yZGluYXRlc1swXSk7Zm9yKHZhciBlPTE7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5hcHBlbmQoXCIsIFwiKSx0LmFwcGVuZCh0aGlzLmNvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdC5hcHBlbmQoXCIpXCIpLHQudG9TdHJpbmcoKX1yZXR1cm5cIigpXCJ9LGdldFk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0ueX0sdG9Db29yZGluYXRlQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRCx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR3R9fSksR3Quc2VyaWFsVmVyc2lvblVJRD0tMHhjYjQ0YTc3OGRiMThlMDAsZShxdC5wcm90b3R5cGUse3JlYWRSZXNvbHZlOmZ1bmN0aW9uKCl7cmV0dXJuIHF0Lmluc3RhbmNlKCl9LGNyZWF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBHdCh0KX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgR3QoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gaT4zJiYoaT0zKSwyPmk/bmV3IEd0KG4pOm5ldyBHdChuLGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcXR9fSkscXQuaW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gcXQuaW5zdGFuY2VPYmplY3R9LHF0LnNlcmlhbFZlcnNpb25VSUQ9LTB4MzhlNDlmYTZjZjZmMmUwMCxxdC5pbnN0YW5jZU9iamVjdD1uZXcgcXQ7dmFyIG5vLGlvPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxybz16dCh7XCJkZWxldGVcIjprdCxoYXM6WHQsZ2V0Oll0LHNldDpIdCxrZXlzOmp0LHZhbHVlczpLdCxlbnRyaWVzOlp0LGZvckVhY2g6JHQsY2xlYXI6V3R9KSxzbz1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwJiZNYXAucHJvdG90eXBlLnZhbHVlcz9NYXA6cm87dGUucHJvdG90eXBlPW5ldyBLLHRlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubWFwXy5nZXQodCl8fG51bGx9LHRlLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5tYXBfLnNldCh0LGUpLGV9LHRlLnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEksZT10aGlzLm1hcF8udmFsdWVzKCksbj1lLm5leHQoKTshbi5kb25lOyl0LmFkZChuLnZhbHVlKSxuPWUubmV4dCgpO3JldHVybiB0fSx0ZS5wcm90b3R5cGUuZW50cnlTZXQ9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSjtyZXR1cm4gdGhpcy5tYXBfLmVudHJpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFkZChlKX0pLHR9LHRlLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwXy5zaXplKCl9LGUoZWUucHJvdG90eXBlLHtlcXVhbHM6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgZWUpKXJldHVybiExO3ZhciBlPXQ7cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZS5tb2RlbFR5cGUmJnRoaXMuc2NhbGU9PT1lLnNjYWxlfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPXRoaXMuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCksaT1lLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpO3JldHVybiBuZXcgYihuKS5jb21wYXJlVG8obmV3IGIoaSkpfSxnZXRTY2FsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNjYWxlfSxpc0Zsb2F0aW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkd8fHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkdfU0lOR0xFfSxnZXRUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kZWxUeXBlfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PVwiVU5LTk9XTlwiO3JldHVybiB0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HP3Q9XCJGbG9hdGluZ1wiOnRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkdfU0lOR0xFP3Q9XCJGbG9hdGluZy1TaW5nbGVcIjp0aGlzLm1vZGVsVHlwZT09PWVlLkZJWEVEJiYodD1cIkZpeGVkIChTY2FsZT1cIit0aGlzLmdldFNjYWxlKCkrXCIpXCIpLHR9LG1ha2VQcmVjaXNlOmZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHIuaXNOYU4odCkpcmV0dXJuIHQ7aWYodGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR19TSU5HTEUpe3ZhciBlPXQ7cmV0dXJuIGV9cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZWUuRklYRUQ/TWF0aC5yb3VuZCh0KnRoaXMuc2NhbGUpL3RoaXMuc2NhbGU6dH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HKXJldHVybiBudWxsO24ueD10aGlzLm1ha2VQcmVjaXNlKG4ueCksbi55PXRoaXMubWFrZVByZWNpc2Uobi55KX19LGdldE1heGltdW1TaWduaWZpY2FudERpZ2l0czpmdW5jdGlvbigpe3ZhciB0PTE2O3JldHVybiB0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HP3Q9MTY6dGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR19TSU5HTEU/dD02OnRoaXMubW9kZWxUeXBlPT09ZWUuRklYRUQmJih0PTErTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5sb2codGhpcy5nZXRTY2FsZSgpKS9NYXRoLmxvZygxMCkpKSksdH0sc2V0U2NhbGU6ZnVuY3Rpb24odCl7dGhpcy5zY2FsZT1NYXRoLmFicyh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdSxzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZWV9fSksZWUubW9zdFByZWNpc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSk+PTA/dDplfSxlKG5lLnByb3RvdHlwZSx7cmVhZFJlc29sdmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmUubmFtZVRvVHlwZU1hcC5nZXQodGhpcy5uYW1lKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbmV9fSksbmUuc2VyaWFsVmVyc2lvblVJRD0tNTUyODYwMjYzMTczMTU5ZTQsbmUubmFtZVRvVHlwZU1hcD1uZXcgdGUsZWUuVHlwZT1uZSxlZS5zZXJpYWxWZXJzaW9uVUlEPTB4NmJlZTY0MDRlOWEyNWMwMCxlZS5GSVhFRD1uZXcgbmUoXCJGSVhFRFwiKSxlZS5GTE9BVElORz1uZXcgbmUoXCJGTE9BVElOR1wiKSxlZS5GTE9BVElOR19TSU5HTEU9bmV3IG5lKFwiRkxPQVRJTkcgU0lOR0xFXCIpLGVlLm1heGltdW1QcmVjaXNlVmFsdWU9OTAwNzE5OTI1NDc0MDk5MixlKGllLnByb3RvdHlwZSx7dG9HZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdC5pc051bGwoKT90aGlzLmNyZWF0ZVBvaW50KG51bGwpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCkmJnQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVQb2ludChuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSkpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCl8fHQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpXSk6dGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhbbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKV0pLG51bGwpfSxjcmVhdGVMaW5lU3RyaW5nOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBTdChlLHRoaXMpfX19LGNyZWF0ZU11bHRpTGluZVN0cmluZzpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgZ3QobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgZ3QodCx0aGlzKX19LGJ1aWxkR2VvbWV0cnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj0hMSxpPSExLHI9dC5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldENsYXNzKCk7bnVsbD09PWUmJihlPW8pLG8hPT1lJiYobj0hMCkscy5pc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZCgpJiYoaT0hMCl9aWYobnVsbD09PWUpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7aWYobnx8aSlyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KHQpKTt2YXIgYT10Lml0ZXJhdG9yKCkubmV4dCgpLHU9dC5zaXplKCk+MTtpZih1KXtpZihhIGluc3RhbmNlb2YgVHQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2x5Z29uKGllLnRvUG9seWdvbkFycmF5KHQpKTtpZihhIGluc3RhbmNlb2YgU3QpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGllLnRvTGluZVN0cmluZ0FycmF5KHQpKTtpZihhIGluc3RhbmNlb2YgTHQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChpZS50b1BvaW50QXJyYXkodCkpO2Yuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbmhhbmRsZWQgY2xhc3M6IFwiK2EuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfXJldHVybiBhfSxjcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX0sY3JlYXRlUG9pbnQ6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2ludCh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFt0XSk6bnVsbCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IEx0KGUsdGhpcyl9fX0sZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnl9LGNyZWF0ZVBvbHlnb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IFR0KG51bGwsbnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyh0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKGUpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXt2YXIgbj1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbihuLG51bGwpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBUdChpLHIsdGhpcyl9fSxnZXRTUklEOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuU1JJRH0sY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBmdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBmdCh0LHRoaXMpfX0sY3JlYXRlR2VvbWV0cnk6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IF90KHRoaXMpO3JldHVybiBlLmVkaXQodCx7ZWRpdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkuY3JlYXRlKHQpfX19KX0sZ2V0UHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbH0sY3JlYXRlTGluZWFyUmluZzpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgYnQoZSx0aGlzKX19fSxjcmVhdGVNdWx0aVBvbHlnb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IE90KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IE90KHQsdGhpcyl9fSxjcmVhdGVNdWx0aVBvaW50OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBQdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBQdCh0LHRoaXMpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG51bGwhPT1lP3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShlKTpudWxsKX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIG49YXJndW1lbnRzWzBdO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobmV3IEFycmF5KDApLmZpbGwobnVsbCkpO2Zvcih2YXIgaT1uZXcgQXJyYXkobi5zaXplKCkpLmZpbGwobnVsbCkscj0wO3I8bi5zaXplKCk7cisrKXt2YXIgcz10aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoMSxuLmdldERpbWVuc2lvbigpKTtDdC5jb3B5KG4scixzLDAsMSksaVtyXT10aGlzLmNyZWF0ZVBvaW50KHMpfXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoaSl9fX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGllfX0pLGllLnRvTXVsdGlQb2x5Z29uQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvR2VvbWV0cnlBcnJheT1mdW5jdGlvbih0KXtpZihudWxsPT09dClyZXR1cm4gbnVsbDt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9ZnVuY3Rpb24oKXtyZXR1cm4gcXQuaW5zdGFuY2UoKX0saWUudG9NdWx0aUxpbmVTdHJpbmdBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9MaW5lU3RyaW5nQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvTXVsdGlQb2ludEFycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b0xpbmVhclJpbmdBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9Qb2ludEFycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b1BvbHlnb25BcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZD1mdW5jdGlvbih0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9LGllLnNlcmlhbFZlcnNpb25VSUQ9LTB4NWVhNzVmMjA1MWVlYjQwMDt2YXIgb289e3R5cGVTdHI6L15cXHMqKFxcdyspXFxzKlxcKFxccyooLiopXFxzKlxcKVxccyokLyxlbXB0eVR5cGVTdHI6L15cXHMqKFxcdyspXFxzKkVNUFRZXFxzKiQvLHNwYWNlczovXFxzKy8scGFyZW5Db21tYTovXFwpXFxzKixcXHMqXFwoLyxkb3VibGVQYXJlbkNvbW1hOi9cXClcXHMqXFwpXFxzKixcXHMqXFwoXFxzKlxcKC8sdHJpbVBhcmVuczovXlxccypcXCg/KC4qPylcXCk/XFxzKiQvfTtlKHJlLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZSxuLGk7dD10LnJlcGxhY2UoL1tcXG5cXHJdL2csXCIgXCIpO3ZhciByPW9vLnR5cGVTdHIuZXhlYyh0KTtpZigtMSE9PXQuc2VhcmNoKFwiRU1QVFlcIikmJihyPW9vLmVtcHR5VHlwZVN0ci5leGVjKHQpLHJbMl09dm9pZCAwKSxyJiYobj1yWzFdLnRvTG93ZXJDYXNlKCksaT1yWzJdLHVvW25dJiYoZT11b1tuXS5hcHBseSh0aGlzLFtpXSkpKSx2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBXS1QgXCIrdCk7cmV0dXJuIGV9LHdyaXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmV4dHJhY3RHZW9tZXRyeSh0KTtcbn0sZXh0cmFjdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0R2VvbWV0cnlUeXBlKCkudG9Mb3dlckNhc2UoKTtpZighYW9bZV0pcmV0dXJuIG51bGw7dmFyIG4saT1lLnRvVXBwZXJDYXNlKCk7cmV0dXJuIG49dC5pc0VtcHR5KCk/aStcIiBFTVBUWVwiOmkrXCIoXCIrYW9bZV0uYXBwbHkodGhpcyxbdF0pK1wiKVwifX0pO3ZhciBhbz17Y29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdC54K1wiIFwiK3QueX0scG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIGFvLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuY29vcmRpbmF0ZXMuY29vcmRpbmF0ZXNbMF0pfSxtdWx0aXBvaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLnBvaW50LmFwcGx5KHRoaXMsW3QuZ2VvbWV0cmllc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbGluZXN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5wb2ludHMuY29vcmRpbmF0ZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKGFvLmNvb3JkaW5hdGUuYXBwbHkodGhpcyxbdC5wb2ludHMuY29vcmRpbmF0ZXNbbl1dKSk7cmV0dXJuIGUuam9pbihcIixcIil9LGxpbmVhcnJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQucG9pbnRzLmNvb3JkaW5hdGVzLmxlbmd0aDtpPm47KytuKWUucHVzaChhby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3QucG9pbnRzLmNvb3JkaW5hdGVzW25dXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxtdWx0aWxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQuZ2VvbWV0cmllcy5sZW5ndGg7aT5uOysrbillLnB1c2goXCIoXCIrYW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFt0Lmdlb21ldHJpZXNbbl1dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LHBvbHlnb246ZnVuY3Rpb24odCl7dmFyIGU9W107ZS5wdXNoKFwiKFwiK2FvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbdC5zaGVsbF0pK1wiKVwiKTtmb3IodmFyIG49MCxpPXQuaG9sZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbdC5ob2xlc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbXVsdGlwb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLnBvbHlnb24uYXBwbHkodGhpcyxbdC5nZW9tZXRyaWVzW25dXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxnZW9tZXRyeWNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQuZ2VvbWV0cmllcy5sZW5ndGg7aT5uOysrbillLnB1c2godGhpcy5leHRyYWN0R2VvbWV0cnkodC5nZW9tZXRyaWVzW25dKSk7cmV0dXJuIGUuam9pbihcIixcIil9fSx1bz17cG9pbnQ6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoKTt2YXIgZT10LnRyaW0oKS5zcGxpdChvby5zcGFjZXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChuZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSkpfSxtdWx0aXBvaW50OmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChcIixcIiksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS5yZXBsYWNlKG9vLnRyaW1QYXJlbnMsXCIkMVwiKSxpLnB1c2godW8ucG9pbnQuYXBwbHkodGhpcyxbZV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChpKX0sbGluZXN0cmluZzpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQoXCIsXCIpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0udHJpbSgpLnNwbGl0KG9vLnNwYWNlcyksaS5wdXNoKG5ldyBnKE51bWJlci5wYXJzZUZsb2F0KGVbMF0pLE51bWJlci5wYXJzZUZsb2F0KGVbMV0pKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoaSl9LGxpbmVhcnJpbmc6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZygpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3M+cjsrK3IpZT1uW3JdLnRyaW0oKS5zcGxpdChvby5zcGFjZXMpLGkucHVzaChuZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGkpfSxtdWx0aWxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQob28ucGFyZW5Db21tYSksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS5yZXBsYWNlKG9vLnRyaW1QYXJlbnMsXCIkMVwiKSxpLnB1c2godW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFtlXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoaSl9LHBvbHlnb246ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbigpO2Zvcih2YXIgZSxuLGkscixzPXQudHJpbSgpLnNwbGl0KG9vLnBhcmVuQ29tbWEpLG89W10sYT0wLHU9cy5sZW5ndGg7dT5hOysrYSllPXNbYV0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksbj11by5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW2VdKSxpPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobi5wb2ludHMpLDA9PT1hP3I9aTpvLnB1c2goaSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24ocixvKX0sbXVsdGlwb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbigpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KG9vLmRvdWJsZVBhcmVuQ29tbWEpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksaS5wdXNoKHVvLnBvbHlnb24uYXBwbHkodGhpcyxbZV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGkpfSxnZW9tZXRyeWNvbGxlY3Rpb246ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7dD10LnJlcGxhY2UoLyxcXHMqKFtBLVphLXpdKS9nLFwifCQxXCIpO2Zvcih2YXIgZT10LnRyaW0oKS5zcGxpdChcInxcIiksbj1bXSxpPTAscj1lLmxlbmd0aDtyPmk7KytpKW4ucHVzaCh0aGlzLnJlYWQoZVtpXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9fTtlKHNlLnByb3RvdHlwZSx7d3JpdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfX0pLGUoc2Use3RvTGluZVN0cmluZzpmdW5jdGlvbih0LGUpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtyZXR1cm5cIkxJTkVTVFJJTkcgKCBcIit0LngrXCIgXCIrdC55K1wiLCBcIitlLngrXCIgXCIrZS55K1wiIClcIn19KSxlKG9lLnByb3RvdHlwZSx7Z2V0SW5kZXhBbG9uZ1NlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5pbnRMaW5lSW5kZXhbdF1bZV19LGdldFRvcG9sb2d5U3VtbWFyeTpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3JldHVybiB0aGlzLmlzRW5kUG9pbnQoKSYmdC5hcHBlbmQoXCIgZW5kcG9pbnRcIiksdGhpcy5faXNQcm9wZXImJnQuYXBwZW5kKFwiIHByb3BlclwiKSx0aGlzLmlzQ29sbGluZWFyKCkmJnQuYXBwZW5kKFwiIGNvbGxpbmVhclwiKSx0LnRvU3RyaW5nKCl9LGNvbXB1dGVJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dGhpcy5pbnB1dExpbmVzWzBdWzBdPXQsdGhpcy5pbnB1dExpbmVzWzBdWzFdPWUsdGhpcy5pbnB1dExpbmVzWzFdWzBdPW4sdGhpcy5pbnB1dExpbmVzWzFdWzFdPWksdGhpcy5yZXN1bHQ9dGhpcy5jb21wdXRlSW50ZXJzZWN0KHQsZSxuLGkpfSxnZXRJbnRlcnNlY3Rpb25OdW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHR9LGNvbXB1dGVJbnRMaW5lSW5kZXg6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCludWxsPT09dGhpcy5pbnRMaW5lSW5kZXgmJih0aGlzLmludExpbmVJbmRleD1BcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5KDIpfSksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDApLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgxKSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwwKSxuPXRoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMSk7ZT5uPyh0aGlzLmludExpbmVJbmRleFt0XVswXT0wLHRoaXMuaW50TGluZUluZGV4W3RdWzFdPTEpOih0aGlzLmludExpbmVJbmRleFt0XVswXT0xLHRoaXMuaW50TGluZUluZGV4W3RdWzFdPTApfX0saXNQcm9wZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5faXNQcm9wZXJ9LHNldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKHQpe3RoaXMucHJlY2lzaW9uTW9kZWw9dH0saXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMCk/ITA6ISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5yZXN1bHQ7ZSsrKWlmKCF0aGlzLmludFB0W2VdLmVxdWFsczJEKHRoaXMuaW5wdXRMaW5lc1t0XVswXSkmJiF0aGlzLmludFB0W2VdLmVxdWFsczJEKHRoaXMuaW5wdXRMaW5lc1t0XVsxXSkpcmV0dXJuITA7cmV0dXJuITF9fSxnZXRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW50UHRbdF19LGlzRW5kUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmIXRoaXMuX2lzUHJvcGVyfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHQhPT1vZS5OT19JTlRFUlNFQ1RJT059LGdldEVkZ2VEaXN0YW5jZTpmdW5jdGlvbih0LGUpe3ZhciBuPW9lLmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5pbnRQdFtlXSx0aGlzLmlucHV0TGluZXNbdF1bMF0sdGhpcy5pbnB1dExpbmVzW3RdWzFdKTtyZXR1cm4gbn0saXNDb2xsaW5lYXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHQ9PT1vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcodGhpcy5pbnB1dExpbmVzWzBdWzBdLHRoaXMuaW5wdXRMaW5lc1swXVsxXSkrXCIgLSBcIitzZS50b0xpbmVTdHJpbmcodGhpcy5pbnB1dExpbmVzWzFdWzBdLHRoaXMuaW5wdXRMaW5lc1sxXVsxXSkrdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKX0sZ2V0RW5kcG9pbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5pbnB1dExpbmVzW3RdW2VdfSxpc0ludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMucmVzdWx0O2UrKylpZih0aGlzLmludFB0W2VdLmVxdWFsczJEKHQpKXJldHVybiEwO3JldHVybiExfSxnZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5pbnRQdFt0aGlzLmludExpbmVJbmRleFt0XVtlXV19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfX0pLG9lLmNvbXB1dGVFZGdlRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPU1hdGguYWJzKG4ueC1lLngpLHI9TWF0aC5hYnMobi55LWUueSkscz0tMTtpZih0LmVxdWFscyhlKSlzPTA7ZWxzZSBpZih0LmVxdWFscyhuKSlzPWk+cj9pOnI7ZWxzZXt2YXIgbz1NYXRoLmFicyh0LngtZS54KSxhPU1hdGguYWJzKHQueS1lLnkpO3M9aT5yP286YSwwIT09c3x8dC5lcXVhbHMoZSl8fChzPU1hdGgubWF4KG8sYSkpfXJldHVybiBmLmlzVHJ1ZSghKDA9PT1zJiYhdC5lcXVhbHMoZSkpLFwiQmFkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHN9LG9lLm5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9TWF0aC5zcXJ0KGkqaStyKnIpO3JldHVybiBmLmlzVHJ1ZSghKDA9PT1zJiYhdC5lcXVhbHMoZSkpLFwiSW52YWxpZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxzfSxvZS5ET05UX0lOVEVSU0VDVD0wLG9lLkRPX0lOVEVSU0VDVD0xLG9lLkNPTExJTkVBUj0yLG9lLk5PX0lOVEVSU0VDVElPTj0wLG9lLlBPSU5UX0lOVEVSU0VDVElPTj0xLG9lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT049MixoKGFlLG9lKSxlKGFlLnByb3RvdHlwZSx7aXNJblNlZ21lbnRFbnZlbG9wZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEModGhpcy5pbnB1dExpbmVzWzBdWzBdLHRoaXMuaW5wdXRMaW5lc1swXVsxXSksbj1uZXcgQyh0aGlzLmlucHV0TGluZXNbMV1bMF0sdGhpcy5pbnB1dExpbmVzWzFdWzFdKTtyZXR1cm4gZS5jb250YWlucyh0KSYmbi5jb250YWlucyh0KX0sY29tcHV0ZUludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDMhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBvZS5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLl9pc1Byb3Blcj0hMSxDLmludGVyc2VjdHMoZSxuLHQpJiYwPT09aGUub3JpZW50YXRpb25JbmRleChlLG4sdCkmJjA9PT1oZS5vcmllbnRhdGlvbkluZGV4KG4sZSx0KT8odGhpcy5faXNQcm9wZXI9ITAsKHQuZXF1YWxzKGUpfHx0LmVxdWFscyhuKSkmJih0aGlzLl9pc1Byb3Blcj0hMSksdGhpcy5yZXN1bHQ9b2UuUE9JTlRfSU5URVJTRUNUSU9OLG51bGwpOnZvaWQodGhpcy5yZXN1bHQ9b2UuTk9fSU5URVJTRUNUSU9OKX0sbm9ybWFsaXplVG9NaW5pbXVtOmZ1bmN0aW9uKHQsZSxuLGkscil7ci54PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueCxlLngsbi54LGkueCksci55PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueSxlLnksbi55LGkueSksdC54LT1yLngsdC55LT1yLnksZS54LT1yLngsZS55LT1yLnksbi54LT1yLngsbi55LT1yLnksaS54LT1yLngsaS55LT1yLnl9LHNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1udWxsO3RyeXtyPUYuaW50ZXJzZWN0aW9uKHQsZSxuLGkpfWNhdGNoKHMpe2lmKCEocyBpbnN0YW5jZW9mIHcpKXRocm93IHM7cj1hZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4saSl9ZmluYWxseXt9cmV0dXJuIHJ9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLmludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uKHQsZSxuLGkpO3JldHVybiB0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKHIpfHwocj1uZXcgZyhhZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4saSkpKSxudWxsIT09dGhpcy5wcmVjaXNpb25Nb2RlbCYmdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShyKSxyfSxzbWFsbGVzdEluQWJzVmFsdWU6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPU1hdGguYWJzKHIpO3JldHVybiBNYXRoLmFicyhlKTxzJiYocj1lLHM9TWF0aC5hYnMoZSkpLE1hdGguYWJzKG4pPHMmJihyPW4scz1NYXRoLmFicyhuKSksTWF0aC5hYnMoaSk8cyYmKHI9aSkscn0sY2hlY2tERDpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPU0uaW50ZXJzZWN0aW9uKHQsZSxuLGkpLG89dGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhzKTtBLm91dC5wcmludGxuKFwiREQgaW4gZW52ID0gXCIrbytcIiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFwiK3MpLHIuZGlzdGFuY2Uocyk+MWUtNCYmQS5vdXQucHJpbnRsbihcIkRpc3RhbmNlID0gXCIrci5kaXN0YW5jZShzKSl9LGludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBnKHQpLHM9bmV3IGcoZSksbz1uZXcgZyhuKSxhPW5ldyBnKGkpLHU9bmV3IGc7dGhpcy5ub3JtYWxpemVUb0VudkNlbnRyZShyLHMsbyxhLHUpO3ZhciBsPXRoaXMuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpO3JldHVybiBsLngrPXUueCxsLnkrPXUueSxsfSxjb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPUMuaW50ZXJzZWN0cyh0LGUsbikscz1DLmludGVyc2VjdHModCxlLGkpLG89Qy5pbnRlcnNlY3RzKG4saSx0KSxhPUMuaW50ZXJzZWN0cyhuLGksZSk7cmV0dXJuIHImJnM/KHRoaXMuaW50UHRbMF09bix0aGlzLmludFB0WzFdPWksb2UuQ09MTElORUFSX0lOVEVSU0VDVElPTik6byYmYT8odGhpcy5pbnRQdFswXT10LHRoaXMuaW50UHRbMV09ZSxvZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTpyJiZvPyh0aGlzLmludFB0WzBdPW4sdGhpcy5pbnRQdFsxXT10LCFuLmVxdWFscyh0KXx8c3x8YT9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6ciYmYT8odGhpcy5pbnRQdFswXT1uLHRoaXMuaW50UHRbMV09ZSwhbi5lcXVhbHMoZSl8fHN8fG8/b2UuQ09MTElORUFSX0lOVEVSU0VDVElPTjpvZS5QT0lOVF9JTlRFUlNFQ1RJT04pOnMmJm8/KHRoaXMuaW50UHRbMF09aSx0aGlzLmludFB0WzFdPXQsIWkuZXF1YWxzKHQpfHxyfHxhP29lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT046b2UuUE9JTlRfSU5URVJTRUNUSU9OKTpzJiZhPyh0aGlzLmludFB0WzBdPWksdGhpcy5pbnRQdFsxXT1lLCFpLmVxdWFscyhlKXx8cnx8bz9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6b2UuTk9fSU5URVJTRUNUSU9OfSxub3JtYWxpemVUb0VudkNlbnRyZTpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPXQueDxlLng/dC54OmUueCxvPXQueTxlLnk/dC55OmUueSxhPXQueD5lLng/dC54OmUueCx1PXQueT5lLnk/dC55OmUueSxsPW4ueDxpLng/bi54OmkueCxoPW4ueTxpLnk/bi55OmkueSxjPW4ueD5pLng/bi54OmkueCxmPW4ueT5pLnk/bi55OmkueSxnPXM+bD9zOmwsZD1jPmE/YTpjLHA9bz5oP286aCx2PWY+dT91OmYsbT0oZytkKS8yLHk9KHArdikvMjtyLng9bSxyLnk9eSx0LngtPXIueCx0LnktPXIueSxlLngtPXIueCxlLnktPXIueSxuLngtPXIueCxuLnktPXIueSxpLngtPXIueCxpLnktPXIueX0sY29tcHV0ZUludGVyc2VjdDpmdW5jdGlvbih0LGUsbixpKXtpZih0aGlzLl9pc1Byb3Blcj0hMSwhQy5pbnRlcnNlY3RzKHQsZSxuLGkpKXJldHVybiBvZS5OT19JTlRFUlNFQ1RJT047dmFyIHI9aGUub3JpZW50YXRpb25JbmRleCh0LGUsbikscz1oZS5vcmllbnRhdGlvbkluZGV4KHQsZSxpKTtpZihyPjAmJnM+MHx8MD5yJiYwPnMpcmV0dXJuIG9lLk5PX0lOVEVSU0VDVElPTjt2YXIgbz1oZS5vcmllbnRhdGlvbkluZGV4KG4saSx0KSxhPWhlLm9yaWVudGF0aW9uSW5kZXgobixpLGUpO2lmKG8+MCYmYT4wfHwwPm8mJjA+YSlyZXR1cm4gb2UuTk9fSU5URVJTRUNUSU9OO3ZhciB1PTA9PT1yJiYwPT09cyYmMD09PW8mJjA9PT1hO3JldHVybiB1P3RoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixpKTooMD09PXJ8fDA9PT1zfHwwPT09b3x8MD09PWE/KHRoaXMuX2lzUHJvcGVyPSExLHQuZXF1YWxzMkQobil8fHQuZXF1YWxzMkQoaSk/dGhpcy5pbnRQdFswXT10OmUuZXF1YWxzMkQobil8fGUuZXF1YWxzMkQoaSk/dGhpcy5pbnRQdFswXT1lOjA9PT1yP3RoaXMuaW50UHRbMF09bmV3IGcobik6MD09PXM/dGhpcy5pbnRQdFswXT1uZXcgZyhpKTowPT09bz90aGlzLmludFB0WzBdPW5ldyBnKHQpOjA9PT1hJiYodGhpcy5pbnRQdFswXT1uZXcgZyhlKSkpOih0aGlzLl9pc1Byb3Blcj0hMCx0aGlzLmludFB0WzBdPXRoaXMuaW50ZXJzZWN0aW9uKHQsZSxuLGkpKSxvZS5QT0lOVF9JTlRFUlNFQ1RJT04pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhZX19KSxhZS5uZWFyZXN0RW5kcG9pbnQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPWhlLmRpc3RhbmNlUG9pbnRMaW5lKHQsbixpKSxvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsbixpKTtyZXR1cm4gcz5vJiYocz1vLHI9ZSksbz1oZS5kaXN0YW5jZVBvaW50TGluZShuLHQsZSkscz5vJiYocz1vLHI9biksbz1oZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSkscz5vJiYocz1vLHI9aSkscn0sZSh1ZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVlfX0pLHVlLm9yaWVudGF0aW9uSW5kZXg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9bi54LWUueCxvPW4ueS1lLnk7cmV0dXJuIHVlLnNpZ25PZkRldDJ4MihpLHIscyxvKX0sdWUuc2lnbk9mRGV0MngyPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW51bGwscz1udWxsLG89bnVsbCxhPTA7aWYocj0xLDA9PT10fHwwPT09aSlyZXR1cm4gMD09PWV8fDA9PT1uPzA6ZT4wP24+MD8tcjpyOm4+MD9yOi1yO2lmKDA9PT1lfHwwPT09bilyZXR1cm4gaT4wP3Q+MD9yOi1yOnQ+MD8tcjpyO2lmKGU+MD9pPjA/aT49ZXx8KHI9LXIscz10LHQ9bixuPXMscz1lLGU9aSxpPXMpOi1pPj1lPyhyPS1yLG49LW4saT0taSk6KHM9dCx0PS1uLG49cyxzPWUsZT0taSxpPXMpOmk+MD9pPj0tZT8ocj0tcix0PS10LGU9LWUpOihzPS10LHQ9bixuPXMscz0tZSxlPWksaT1zKTplPj1pPyh0PS10LGU9LWUsbj0tbixpPS1pKToocj0tcixzPS10LHQ9LW4sbj1zLHM9LWUsZT0taSxpPXMpLHQ+MCl7aWYoIShuPjApKXJldHVybiByO2lmKCEobj49dCkpcmV0dXJuIHJ9ZWxzZXtpZihuPjApcmV0dXJuLXI7aWYoISh0Pj1uKSlyZXR1cm4tcjtyPS1yLHQ9LXQsbj0tbn1mb3IoOzspe2lmKGErPTEsbz1NYXRoLmZsb29yKG4vdCksbi09byp0LGktPW8qZSwwPmkpcmV0dXJuLXI7aWYoaT5lKXJldHVybiByO2lmKHQ+bituKXtpZihpK2k+ZSlyZXR1cm4gcn1lbHNle2lmKGU+aStpKXJldHVybi1yO249dC1uLGk9ZS1pLHI9LXJ9aWYoMD09PWkpcmV0dXJuIDA9PT1uPzA6LXI7aWYoMD09PW4pcmV0dXJuIHI7aWYobz1NYXRoLmZsb29yKHQvbiksdC09bypuLGUtPW8qaSwwPmUpcmV0dXJuIHI7aWYoZT5pKXJldHVybi1yO2lmKG4+dCt0KXtpZihlK2U+aSlyZXR1cm4tcn1lbHNle2lmKGk+ZStlKXJldHVybiByO3Q9bi10LGU9aS1lLHI9LXJ9aWYoMD09PWUpcmV0dXJuIDA9PT10PzA6cjtpZigwPT09dClyZXR1cm4tcn19LGUobGUucHJvdG90eXBlLHtjb3VudFNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtpZih0Lng8dGhpcy5wLngmJmUueDx0aGlzLnAueClyZXR1cm4gbnVsbDtpZih0aGlzLnAueD09PWUueCYmdGhpcy5wLnk9PT1lLnkpcmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2lmKHQueT09PXRoaXMucC55JiZlLnk9PT10aGlzLnAueSl7dmFyIG49dC54LGk9ZS54O3JldHVybiBuPmkmJihuPWUueCxpPXQueCksdGhpcy5wLng+PW4mJnRoaXMucC54PD1pJiYodGhpcy5pc1BvaW50T25TZWdtZW50PSEwKSxudWxsfWlmKHQueT50aGlzLnAueSYmZS55PD10aGlzLnAueXx8ZS55PnRoaXMucC55JiZ0Lnk8PXRoaXMucC55KXt2YXIgcj10LngtdGhpcy5wLngscz10LnktdGhpcy5wLnksbz1lLngtdGhpcy5wLngsYT1lLnktdGhpcy5wLnksdT11ZS5zaWduT2ZEZXQyeDIocixzLG8sYSk7aWYoMD09PXUpcmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCxudWxsO3M+YSYmKHU9LXUpLHU+MCYmdGhpcy5jcm9zc2luZ0NvdW50Kyt9fSxpc1BvaW50SW5Qb2x5Z29uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKSE9PUwuRVhURVJJT1J9LGdldExvY2F0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD9MLkJPVU5EQVJZOnRoaXMuY3Jvc3NpbmdDb3VudCUyPT09MT9MLklOVEVSSU9SOkwuRVhURVJJT1J9LGlzT25TZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbGV9fSksbGUubG9jYXRlUG9pbnRJblJpbmc9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJlIoYXJndW1lbnRzWzFdLEQpKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlKHQpLGk9bmV3IGcscj1uZXcgZyxzPTE7czxlLnNpemUoKTtzKyspaWYoZS5nZXRDb29yZGluYXRlKHMsaSksZS5nZXRDb29yZGluYXRlKHMtMSxyKSxuLmNvdW50U2VnbWVudChpLHIpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpO3JldHVybiBuLmdldExvY2F0aW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLG49bmV3IGxlKG8pLHM9MTtzPGEubGVuZ3RoO3MrKyl7dmFyIGk9YVtzXSxyPWFbcy0xXTtpZihuLmNvdW50U2VnbWVudChpLHIpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpfXJldHVybiBuLmdldExvY2F0aW9uKCl9fSxlKGhlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaGV9fSksaGUub3JpZW50YXRpb25JbmRleD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE0ub3JpZW50YXRpb25JbmRleCh0LGUsbil9LGhlLnNpZ25lZEFyZWE9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5sZW5ndGg8MylyZXR1cm4gMDtmb3IodmFyIGU9MCxuPXRbMF0ueCxpPTE7aTx0Lmxlbmd0aC0xO2krKyl7dmFyIHI9dFtpXS54LW4scz10W2krMV0ueSxvPXRbaS0xXS55O2UrPXIqKG8tcyl9cmV0dXJuIGUvMn1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YS5zaXplKCk7aWYoMz51KXJldHVybiAwO3ZhciBsPW5ldyBnLGg9bmV3IGcsYz1uZXcgZzthLmdldENvb3JkaW5hdGUoMCxoKSxhLmdldENvb3JkaW5hdGUoMSxjKTt2YXIgbj1oLng7Yy54LT1uO2Zvcih2YXIgZT0wLGk9MTt1LTE+aTtpKyspbC55PWgueSxoLng9Yy54LGgueT1jLnksYS5nZXRDb29yZGluYXRlKGkrMSxjKSxjLngtPW4sZSs9aC54KihsLnktYy55KTtyZXR1cm4gZS8yfX0saGUuZGlzdGFuY2VMaW5lTGluZT1mdW5jdGlvbih0LGUsbixpKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpO2lmKG4uZXF1YWxzKGkpKXJldHVybiBoZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSk7dmFyIHI9ITE7aWYoQy5pbnRlcnNlY3RzKHQsZSxuLGkpKXt2YXIgcz0oZS54LXQueCkqKGkueS1uLnkpLShlLnktdC55KSooaS54LW4ueCk7aWYoMD09PXMpcj0hMDtlbHNle3ZhciBvPSh0Lnktbi55KSooaS54LW4ueCktKHQueC1uLngpKihpLnktbi55KSxhPSh0Lnktbi55KSooZS54LXQueCktKHQueC1uLngpKihlLnktdC55KSx1PWEvcyxsPW8vczsoMD5sfHxsPjF8fDA+dXx8dT4xKSYmKHI9ITApfX1lbHNlIHI9ITA7cmV0dXJuIHI/VC5taW4oaGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpLGhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsbixpKSxoZS5kaXN0YW5jZVBvaW50TGluZShuLHQsZSksaGUuZGlzdGFuY2VQb2ludExpbmUoaSx0LGUpKTowfSxoZS5pc1BvaW50SW5SaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSkhPT1MLkVYVEVSSU9SfSxoZS5jb21wdXRlTGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc2l6ZSgpO2lmKDE+PWUpcmV0dXJuIDA7dmFyIG49MCxpPW5ldyBnO3QuZ2V0Q29vcmRpbmF0ZSgwLGkpO2Zvcih2YXIgcj1pLngscz1pLnksbz0xO2U+bztvKyspe3QuZ2V0Q29vcmRpbmF0ZShvLGkpO3ZhciBhPWkueCx1PWkueSxsPWEtcixoPXUtcztuKz1NYXRoLnNxcnQobCpsK2gqaCkscj1hLHM9dX1yZXR1cm4gbn0saGUuaXNDQ1c9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGgtMTtpZigzPmUpdGhyb3cgbmV3IGkoXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtmb3IodmFyIG49dFswXSxyPTAscz0xO2U+PXM7cysrKXt2YXIgbz10W3NdO28ueT5uLnkmJihuPW8scj1zKX12YXIgYT1yO2RvIGEtPTEsMD5hJiYoYT1lKTt3aGlsZSh0W2FdLmVxdWFsczJEKG4pJiZhIT09cik7dmFyIHU9cjtkbyB1PSh1KzEpJWU7d2hpbGUodFt1XS5lcXVhbHMyRChuKSYmdSE9PXIpO3ZhciBsPXRbYV0saD10W3VdO2lmKGwuZXF1YWxzMkQobil8fGguZXF1YWxzMkQobil8fGwuZXF1YWxzMkQoaCkpcmV0dXJuITE7dmFyIGM9aGUuY29tcHV0ZU9yaWVudGF0aW9uKGwsbixoKSxmPSExO3JldHVybiBmPTA9PT1jP2wueD5oLng6Yz4wfSxoZS5sb2NhdGVQb2ludEluUmluZz1mdW5jdGlvbih0LGUpe3JldHVybiBsZS5sb2NhdGVQb2ludEluUmluZyh0LGUpfSxoZS5kaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXI9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxyPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL2k7cmV0dXJuIE1hdGguYWJzKHIpKk1hdGguc3FydChpKX0saGUuY29tcHV0ZU9yaWVudGF0aW9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGUub3JpZW50YXRpb25JbmRleCh0LGUsbil9LGhlLmRpc3RhbmNlUG9pbnRMaW5lPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IGkoXCJMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4XCIpO2Zvcih2YXIgbj10LmRpc3RhbmNlKGVbMF0pLHI9MDtyPGUubGVuZ3RoLTE7cisrKXt2YXIgcz1oZS5kaXN0YW5jZVBvaW50TGluZSh0LGVbcl0sZVtyKzFdKTtuPnMmJihuPXMpfXJldHVybiBufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl07aWYoYS54PT09dS54JiZhLnk9PT11LnkpcmV0dXJuIG8uZGlzdGFuY2UoYSk7dmFyIGw9KHUueC1hLngpKih1LngtYS54KSsodS55LWEueSkqKHUueS1hLnkpLGg9KChvLngtYS54KSoodS54LWEueCkrKG8ueS1hLnkpKih1LnktYS55KSkvbDtpZigwPj1oKXJldHVybiBvLmRpc3RhbmNlKGEpO2lmKGg+PTEpcmV0dXJuIG8uZGlzdGFuY2UodSk7dmFyIGM9KChhLnktby55KSoodS54LWEueCktKGEueC1vLngpKih1LnktYS55KSkvbDtyZXR1cm4gTWF0aC5hYnMoYykqTWF0aC5zcXJ0KGwpfX0saGUuaXNPbkxpbmU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IGFlLGk9MTtpPGUubGVuZ3RoO2krKyl7dmFyIHI9ZVtpLTFdLHM9ZVtpXTtpZihuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxyLHMpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITB9cmV0dXJuITF9LGhlLkNMT0NLV0lTRT0tMSxoZS5SSUdIVD1oZS5DTE9DS1dJU0UsaGUuQ09VTlRFUkNMT0NLV0lTRT0xLGhlLkxFRlQ9aGUuQ09VTlRFUkNMT0NLV0lTRSxoZS5DT0xMSU5FQVI9MCxoZS5TVFJBSUdIVD1oZS5DT0xMSU5FQVIsZShjZS5wcm90b3R5cGUse21pblg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC54LHRoaXMucDEueCl9LG9yaWVudGF0aW9uSW5kZXg6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1oZS5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAwKSxuPWhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDEpO3JldHVybiBlPj0wJiZuPj0wP01hdGgubWF4KGUsbik6MD49ZSYmMD49bj9NYXRoLm1heChlLG4pOjB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF07cmV0dXJuIGhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLGkpfX0sdG9HZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdC5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLnAwLHRoaXMucDFdKX0saXNWZXJ0aWNhbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLng9PT10aGlzLnAxLnh9LGVxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBjZSkpcmV0dXJuITE7dmFyIGU9dDtyZXR1cm4gdGhpcy5wMC5lcXVhbHMoZS5wMCkmJnRoaXMucDEuZXF1YWxzKGUucDEpfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFlO3JldHVybiBlLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSksZS5oYXNJbnRlcnNlY3Rpb24oKT9lLmdldEludGVyc2VjdGlvbigwKTpudWxsfSxwcm9qZWN0OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5lcXVhbHModGhpcy5wMCl8fHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiBuZXcgZyh0KTt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCksbj1uZXcgZztyZXR1cm4gbi54PXRoaXMucDAueCtlKih0aGlzLnAxLngtdGhpcy5wMC54KSxuLnk9dGhpcy5wMC55K2UqKHRoaXMucDEueS10aGlzLnAwLnkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKGkucDApLHM9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKGkucDEpO2lmKHI+PTEmJnM+PTEpcmV0dXJuIG51bGw7aWYoMD49ciYmMD49cylyZXR1cm4gbnVsbDt2YXIgbz10aGlzLnByb2plY3QoaS5wMCk7MD5yJiYobz10aGlzLnAwKSxyPjEmJihvPXRoaXMucDEpO3ZhciBhPXRoaXMucHJvamVjdChpLnAxKTtyZXR1cm4gMD5zJiYoYT10aGlzLnAwKSxzPjEmJihhPXRoaXMucDEpLG5ldyBjZShvLGEpfX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7dGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCk8MCYmdGhpcy5yZXZlcnNlKCl9LGFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55LXRoaXMucDAueSx0aGlzLnAxLngtdGhpcy5wMC54KX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQ/dGhpcy5wMDp0aGlzLnAxfSxkaXN0YW5jZVBlcnBlbmRpY3VsYXI6ZnVuY3Rpb24odCl7cmV0dXJuIGhlLmRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhcih0LHRoaXMucDAsdGhpcy5wMSl9LG1pblk6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC55LHRoaXMucDEueSl9LG1pZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIGNlLm1pZFBvaW50KHRoaXMucDAsdGhpcy5wMSl9LHByb2plY3Rpb25GYWN0b3I6ZnVuY3Rpb24odCl7aWYodC5lcXVhbHModGhpcy5wMCkpcmV0dXJuIDA7aWYodC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIDE7dmFyIGU9dGhpcy5wMS54LXRoaXMucDAueCxuPXRoaXMucDEueS10aGlzLnAwLnksaT1lKmUrbipuO2lmKDA+PWkpcmV0dXJuIHIuTmFOO3ZhciBzPSgodC54LXRoaXMucDAueCkqZSsodC55LXRoaXMucDAueSkqbikvaTtyZXR1cm4gc30sY2xvc2VzdFBvaW50czpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyc2VjdGlvbih0KTtpZihudWxsIT09ZSlyZXR1cm5bZSxlXTt2YXIgbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxpPXIuTUFYX1ZBTFVFLHM9bnVsbCxvPXRoaXMuY2xvc2VzdFBvaW50KHQucDApO2k9by5kaXN0YW5jZSh0LnAwKSxuWzBdPW8sblsxXT10LnAwO3ZhciBhPXRoaXMuY2xvc2VzdFBvaW50KHQucDEpO3M9YS5kaXN0YW5jZSh0LnAxKSxpPnMmJihpPXMsblswXT1hLG5bMV09dC5wMSk7dmFyIHU9dC5jbG9zZXN0UG9pbnQodGhpcy5wMCk7cz11LmRpc3RhbmNlKHRoaXMucDApLGk+cyYmKGk9cyxuWzBdPXRoaXMucDAsblsxXT11KTt2YXIgbD10LmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtyZXR1cm4gcz1sLmRpc3RhbmNlKHRoaXMucDEpLGk+cyYmKGk9cyxuWzBdPXRoaXMucDEsblsxXT1sKSxufSxjbG9zZXN0UG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO2lmKGU+MCYmMT5lKXJldHVybiB0aGlzLnByb2plY3QodCk7dmFyIG49dGhpcy5wMC5kaXN0YW5jZSh0KSxpPXRoaXMucDEuZGlzdGFuY2UodCk7cmV0dXJuIGk+bj90aGlzLnAwOnRoaXMucDF9LG1heFg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC54LHRoaXMucDEueCl9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLmRpc3RhbmNlKHRoaXMucDEpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPXRoaXMucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnRoaXMucDEuY29tcGFyZVRvKGUucDEpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wMDt0aGlzLnAwPXRoaXMucDEsdGhpcy5wMT10fSxlcXVhbHNUb3BvOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnAwLmVxdWFscyh0LnAwKSYmdGhpcy5wMS5lcXVhbHModC5wMSl8fHRoaXMucDAuZXF1YWxzKHQucDEpJiZ0aGlzLnAxLmVxdWFscyh0LnAwKX0sbGluZUludGVyc2VjdGlvbjpmdW5jdGlvbih0KXt0cnl7dmFyIGU9Ri5pbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSk7cmV0dXJuIGV9Y2F0Y2gobil7aWYoIShuIGluc3RhbmNlb2YgdykpdGhyb3cgbn1maW5hbGx5e31yZXR1cm4gbnVsbH0sbWF4WTpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLnksdGhpcy5wMS55KX0scG9pbnRBbG9uZ09mZnNldDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxpPXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxyPXRoaXMucDEueC10aGlzLnAwLngscz10aGlzLnAxLnktdGhpcy5wMC55LG89TWF0aC5zcXJ0KHIqcitzKnMpLGE9MCx1PTA7aWYoMCE9PWUpe2lmKDA+PW8pdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkNhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudFwiKTthPWUqci9vLHU9ZSpzL299dmFyIGw9bi11LGg9aSthLGM9bmV3IGcobCxoKTtyZXR1cm4gY30sc2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29vcmRpbmF0ZXModC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wMC54PWUueCx0aGlzLnAwLnk9ZS55LHRoaXMucDEueD1uLngsdGhpcy5wMS55PW4ueX19LHNlZ21lbnRGcmFjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7cmV0dXJuIDA+ZT9lPTA6KGU+MXx8ci5pc05hTihlKSkmJihlPTEpLGV9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJMSU5FU1RSSU5HKCBcIit0aGlzLnAwLngrXCIgXCIrdGhpcy5wMC55K1wiLCBcIit0aGlzLnAxLngrXCIgXCIrdGhpcy5wMS55K1wiKVwifSxpc0hvcml6b250YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMC55PT09dGhpcy5wMS55fSxkaXN0YW5jZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gaGUuZGlzdGFuY2VMaW5lTGluZSh0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUoZSx0aGlzLnAwLHRoaXMucDEpfX0scG9pbnRBbG9uZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZztyZXR1cm4gZS54PXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxlLnk9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGV9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9amF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7dF49MzEqamF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSk7dmFyIGU9TWF0aC50cnVuYyh0KV5NYXRoLnRydW5jKHQ+PjMyKSxuPWphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO25ePTMxKmphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLnkpO3ZhciBpPU1hdGgudHJ1bmMobileTWF0aC50cnVuYyhuPj4zMik7cmV0dXJuIGVeaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY2V9fSksY2UubWlkUG9pbnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IGcoKHQueCtlLngpLzIsKHQueStlLnkpLzIpfSxjZS5zZXJpYWxWZXJzaW9uVUlEPTB4MmQyMTcyMTM1ZjQxMWMwMCxlKGZlLnByb3RvdHlwZSx7aXNJbnRlcnNlY3RzOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNEaXNqb2ludCgpfSxpc0NvdmVyczpmdW5jdGlvbigpe3ZhciB0PWZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSk7cmV0dXJuIHQmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LGlzQ292ZXJlZEJ5OmZ1bmN0aW9uKCl7dmFyIHQ9ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldKTtyZXR1cm4gdCYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09PT1sdC5GQUxTRX0sc2V0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPU1hdGgudHJ1bmMoZS8zKSxpPWUlMzt0aGlzLm1hdHJpeFtuXVtpXT1sdC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5tYXRyaXhbcl1bc109b319LGlzQ29udGFpbnM6ZnVuY3Rpb24oKXtyZXR1cm4gZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0sc2V0QXRMZWFzdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj1NYXRoLnRydW5jKGUvMyksaT1lJTM7dGhpcy5zZXRBdExlYXN0KG4saSxsdC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMubWF0cml4W3JdW3NdPG8mJih0aGlzLm1hdHJpeFtyXVtzXT1vKX19LHNldEF0TGVhc3RJZlZhbGlkOmZ1bmN0aW9uKHQsZSxuKXt0Pj0wJiZlPj0wJiZ0aGlzLnNldEF0TGVhc3QodCxlLG4pfSxpc1dpdGhpbjpmdW5jdGlvbigpe3JldHVybiBmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZ0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFfSxpc1RvdWNoZXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lP3RoaXMuaXNUb3VjaGVzKGUsdCk6dD09PWx0LkEmJmU9PT1sdC5BfHx0PT09bHQuTCYmZT09PWx0Lkx8fHQ9PT1sdC5MJiZlPT09bHQuQXx8dD09PWx0LlAmJmU9PT1sdC5BfHx0PT09bHQuUCYmZT09PWx0Lkw/dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmKGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSkpOiExfSxpc092ZXJsYXBzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1sdC5QJiZlPT09bHQuUHx8dD09PWx0LkEmJmU9PT1sdC5BP2ZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSk6dD09PWx0LkwmJmU9PT1sdC5MPzE9PT10aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdKTohMX0saXNFcXVhbHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCE9PWU/ITE6ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IFAoXCIxMjM0NTY3ODlcIiksZT0wOzM+ZTtlKyspZm9yKHZhciBuPTA7Mz5uO24rKyl0LnNldENoYXJBdCgzKmUrbixsdC50b0RpbWVuc2lvblN5bWJvbCh0aGlzLm1hdHJpeFtlXVtuXSkpO3JldHVybiB0LnRvU3RyaW5nKCl9LHNldEFsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDszPmU7ZSsrKWZvcih2YXIgbj0wOzM+bjtuKyspdGhpcy5tYXRyaXhbZV1bbl09dH0sZ2V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubWF0cml4W3RdW2VdfSx0cmFuc3Bvc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1hdHJpeFsxXVswXTtyZXR1cm4gdGhpcy5tYXRyaXhbMV1bMF09dGhpcy5tYXRyaXhbMF1bMV0sdGhpcy5tYXRyaXhbMF1bMV09dCx0PXRoaXMubWF0cml4WzJdWzBdLHRoaXMubWF0cml4WzJdWzBdPXRoaXMubWF0cml4WzBdWzJdLHRoaXMubWF0cml4WzBdWzJdPXQsdD10aGlzLm1hdHJpeFsyXVsxXSx0aGlzLm1hdHJpeFsyXVsxXT10aGlzLm1hdHJpeFsxXVsyXSx0aGlzLm1hdHJpeFsxXVsyXT10LHRoaXN9LG1hdGNoZXM6ZnVuY3Rpb24odCl7aWYoOSE9PXQubGVuZ3RoKXRocm93IG5ldyBpKFwiU2hvdWxkIGJlIGxlbmd0aCA5OiBcIit0KTtmb3IodmFyIGU9MDszPmU7ZSsrKWZvcih2YXIgbj0wOzM+bjtuKyspaWYoIWZlLm1hdGNoZXModGhpcy5tYXRyaXhbZV1bbl0sdC5jaGFyQXQoMyplK24pKSlyZXR1cm4hMTtyZXR1cm4hMH0sYWRkOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wOzM+ZTtlKyspZm9yKHZhciBuPTA7Mz5uO24rKyl0aGlzLnNldEF0TGVhc3QoZSxuLHQuZ2V0KGUsbikpfSxpc0Rpc2pvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LGlzQ3Jvc3NlczpmdW5jdGlvbih0LGUpe3JldHVybiB0PT09bHQuUCYmZT09PWx0Lkx8fHQ9PT1sdC5QJiZlPT09bHQuQXx8dD09PWx0LkwmJmU9PT1sdC5BP2ZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSk6dD09PWx0LkwmJmU9PT1sdC5QfHx0PT09bHQuQSYmZT09PWx0LlB8fHQ9PT1sdC5BJiZlPT09bHQuTD9mZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl0pOnQ9PT1sdC5MJiZlPT09bHQuTD8wPT09dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl06ITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmZX19KSxmZS5tYXRjaGVzPWZ1bmN0aW9uKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGU9PT1sdC5TWU1fRE9OVENBUkU/ITA6ZT09PWx0LlNZTV9UUlVFJiYodD49MHx8dD09PWx0LlRSVUUpPyEwOmU9PT1sdC5TWU1fRkFMU0UmJnQ9PT1sdC5GQUxTRT8hMDplPT09bHQuU1lNX1AmJnQ9PT1sdC5QPyEwOmU9PT1sdC5TWU1fTCYmdD09PWx0Lkw/ITA6ZT09PWx0LlNZTV9BJiZ0PT09bHQuQX1pZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1uZXcgZmUobik7cmV0dXJuIHIubWF0Y2hlcyhpKX19LGZlLmlzVHJ1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdD49MHx8dD09PWx0LlRSVUV9O3ZhciBsbz1PYmplY3QuZnJlZXplKHtDb29yZGluYXRlOmcsQ29vcmRpbmF0ZUxpc3Q6TixFbnZlbG9wZTpDLExpbmVTZWdtZW50OmNlLEdlb21ldHJ5RmFjdG9yeTppZSxHZW9tZXRyeTpCLFBvaW50Okx0LExpbmVTdHJpbmc6U3QsTGluZWFyUmluZzpidCxQb2x5Z29uOlR0LEdlb21ldHJ5Q29sbGVjdGlvbjpmdCxNdWx0aVBvaW50OlB0LE11bHRpTGluZVN0cmluZzpndCxNdWx0aVBvbHlnb246T3QsRGltZW5zaW9uOmx0LEludGVyc2VjdGlvbk1hdHJpeDpmZX0pO2UoZ2UucHJvdG90eXBlLHthZGRQb2ludDpmdW5jdGlvbih0KXt0aGlzLnB0Q291bnQrPTEsdGhpcy5wdENlbnRTdW0ueCs9dC54LHRoaXMucHRDZW50U3VtLnkrPXQueX0sc2V0QmFzZVBvaW50OmZ1bmN0aW9uKHQpe251bGw9PT10aGlzLmFyZWFCYXNlUHQmJih0aGlzLmFyZWFCYXNlUHQ9dCl9LGFkZExpbmVTZWdtZW50czpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aC0xO24rKyl7dmFyIGk9dFtuXS5kaXN0YW5jZSh0W24rMV0pO2lmKDAhPT1pKXtlKz1pO3ZhciByPSh0W25dLngrdFtuKzFdLngpLzI7dGhpcy5saW5lQ2VudFN1bS54Kz1pKnI7dmFyIHM9KHRbbl0ueSt0W24rMV0ueSkvMjt0aGlzLmxpbmVDZW50U3VtLnkrPWkqc319dGhpcy50b3RhbExlbmd0aCs9ZSwwPT09ZSYmdC5sZW5ndGg+MCYmdGhpcy5hZGRQb2ludCh0WzBdKX0sYWRkSG9sZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9aGUuaXNDQ1codCksbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLmFyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9LGdldENlbnRyb2lkOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGc7aWYoTWF0aC5hYnModGhpcy5hcmVhc3VtMik+MCl0Lng9dGhpcy5jZzMueC8zL3RoaXMuYXJlYXN1bTIsdC55PXRoaXMuY2czLnkvMy90aGlzLmFyZWFzdW0yO2Vsc2UgaWYodGhpcy50b3RhbExlbmd0aD4wKXQueD10aGlzLmxpbmVDZW50U3VtLngvdGhpcy50b3RhbExlbmd0aCx0Lnk9dGhpcy5saW5lQ2VudFN1bS55L3RoaXMudG90YWxMZW5ndGg7ZWxzZXtpZighKHRoaXMucHRDb3VudD4wKSlyZXR1cm4gbnVsbDt0Lng9dGhpcy5wdENlbnRTdW0ueC90aGlzLnB0Q291bnQsdC55PXRoaXMucHRDZW50U3VtLnkvdGhpcy5wdENvdW50fXJldHVybiB0fSxhZGRTaGVsbDpmdW5jdGlvbih0KXt0Lmxlbmd0aD4wJiZ0aGlzLnNldEJhc2VQb2ludCh0WzBdKTtmb3IodmFyIGU9IWhlLmlzQ0NXKHQpLG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfSxhZGRUcmlhbmdsZTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1pPzE6LTE7Z2UuY2VudHJvaWQzKHQsZSxuLHRoaXMudHJpYW5nbGVDZW50Myk7dmFyIHM9Z2UuYXJlYTIodCxlLG4pO3RoaXMuY2czLngrPXIqcyp0aGlzLnRyaWFuZ2xlQ2VudDMueCx0aGlzLmNnMy55Kz1yKnMqdGhpcy50cmlhbmdsZUNlbnQzLnksdGhpcy5hcmVhc3VtMis9cipzfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hZGRTaGVsbCh0LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspdGhpcy5hZGRIb2xlKHQuZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIG49YXJndW1lbnRzWzBdO2lmKG4uaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKG4gaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KG4uZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiBTdCl0aGlzLmFkZExpbmVTZWdtZW50cyhuLmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYobiBpbnN0YW5jZW9mIFR0KXt2YXIgaT1uO3RoaXMuYWRkKGkpfWVsc2UgaWYobiBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgcj1uLGU9MDtlPHIuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl0aGlzLmFkZChyLmdldEdlb21ldHJ5TihlKSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBnZX19KSxnZS5hcmVhMj1mdW5jdGlvbih0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0obi54LXQueCkqKGUueS10LnkpfSxnZS5jZW50cm9pZDM9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIGkueD10LngrZS54K24ueCxpLnk9dC55K2UueStuLnksbnVsbH0sZ2UuZ2V0Q2VudHJvaWQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGdlKHQpO3JldHVybiBlLmdldENlbnRyb2lkKCl9LGRlLnByb3RvdHlwZT1uZXcgRXJyb3IsZGUucHJvdG90eXBlLm5hbWU9XCJFbXB0eVN0YWNrRXhjZXB0aW9uXCIscGUucHJvdG90eXBlPW5ldyB5LHBlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksITB9LHBlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYoMD50fHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjtyZXR1cm4gdGhpcy5hcnJheV9bdF19LHBlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLHR9LHBlLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMuYXJyYXlfLmxlbmd0aCl0aHJvdyBuZXcgZGU7cmV0dXJuIHRoaXMuYXJyYXlfLnBvcCgpfSxwZS5wcm90b3R5cGUucGVlaz1mdW5jdGlvbigpe2lmKDA9PT10aGlzLmFycmF5Xy5sZW5ndGgpdGhyb3cgbmV3IGRlO3JldHVybiB0aGlzLmFycmF5X1t0aGlzLmFycmF5Xy5sZW5ndGgtMV19LHBlLnByb3RvdHlwZS5lbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxwZS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVtcHR5KCl9LHBlLnByb3RvdHlwZS5zZWFyY2g9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLmluZGV4T2YodCl9LHBlLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0scGUucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sZSh2ZS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0aGlzLnRyZWVTZXQuY29udGFpbnModCl8fCh0aGlzLmxpc3QuYWRkKHQpLHRoaXMudHJlZVNldC5hZGQodCkpfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSh0aGlzLmxpc3Quc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmxpc3QudG9BcnJheSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bel19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZlfX0pLHZlLmZpbHRlckNvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgdmUsbj0wO248dC5sZW5ndGg7bisrKWUuZmlsdGVyKHRbbl0pO3JldHVybiBlLmdldENvb3JkaW5hdGVzKCl9LGUobWUucHJvdG90eXBlLHtwcmVTb3J0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49MTtuPHQubGVuZ3RoO24rKykodFtuXS55PHRbMF0ueXx8dFtuXS55PT09dFswXS55JiZ0W25dLng8dFswXS54KSYmKGU9dFswXSx0WzBdPXRbbl0sdFtuXT1lKTtyZXR1cm4gdXQuc29ydCh0LDEsdC5sZW5ndGgsbmV3IHllKHRbMF0pKSx0fSxjb21wdXRlT2N0UmluZzpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVPY3RQdHModCksbj1uZXcgTjtyZXR1cm4gbi5hZGQoZSwhMSksbi5zaXplKCk8Mz9udWxsOihuLmNsb3NlUmluZygpLG4udG9Db29yZGluYXRlQXJyYXkoKSl9LGxpbmVPclBvbHlnb246ZnVuY3Rpb24odCl7aWYodD10aGlzLmNsZWFuUmluZyh0KSwzPT09dC5sZW5ndGgpcmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbdFswXSx0WzFdXSk7dmFyIGU9dGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpO3JldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZVBvbHlnb24oZSxudWxsKX0sY2xlYW5SaW5nOmZ1bmN0aW9uKHQpe2YuZXF1YWxzKHRbMF0sdFt0Lmxlbmd0aC0xXSk7Zm9yKHZhciBlPW5ldyBJLG49bnVsbCxpPTA7aTw9dC5sZW5ndGgtMjtpKyspe3ZhciByPXRbaV0scz10W2krMV07ci5lcXVhbHMocyl8fG51bGwhPT1uJiZ0aGlzLmlzQmV0d2VlbihuLHIscyl8fChlLmFkZChyKSxuPXIpfWUuYWRkKHRbdC5sZW5ndGgtMV0pO3ZhciBvPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gZS50b0FycmF5KG8pfSxpc0JldHdlZW46ZnVuY3Rpb24odCxlLG4pe2lmKDAhPT1oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLG4pKXJldHVybiExO2lmKHQueCE9PW4ueCl7aWYodC54PD1lLngmJmUueDw9bi54KXJldHVybiEwO2lmKG4ueDw9ZS54JiZlLng8PXQueClyZXR1cm4hMH1pZih0LnkhPT1uLnkpe2lmKHQueTw9ZS55JiZlLnk8PW4ueSlyZXR1cm4hMDtpZihuLnk8PWUueSYmZS55PD10LnkpcmV0dXJuITB9cmV0dXJuITF9LHJlZHVjZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVPY3RSaW5nKHQpO2lmKG51bGw9PT1lKXJldHVybiB0O2Zvcih2YXIgbj1uZXcgYXQsaT0wO2k8ZS5sZW5ndGg7aSsrKW4uYWRkKGVbaV0pO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKWhlLmlzUG9pbnRJblJpbmcodFtpXSxlKXx8bi5hZGQodFtpXSk7dmFyIHI9SC50b0Nvb3JkaW5hdGVBcnJheShuKTtyZXR1cm4gci5sZW5ndGg8Mz90aGlzLnBhZEFycmF5MyhyKTpyfSxnZXRDb252ZXhIdWxsOmZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuaW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKTtpZigxPT09dGhpcy5pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy5pbnB1dFB0c1swXSk7aWYoMj09PXRoaXMuaW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5pbnB1dFB0cyk7dmFyIHQ9dGhpcy5pbnB1dFB0czt0aGlzLmlucHV0UHRzLmxlbmd0aD41MCYmKHQ9dGhpcy5yZWR1Y2UodGhpcy5pbnB1dFB0cykpO3ZhciBlPXRoaXMucHJlU29ydCh0KSxuPXRoaXMuZ3JhaGFtU2NhbihlKSxpPXRoaXMudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHRoaXMubGluZU9yUG9seWdvbihpKX0scGFkQXJyYXkzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspbjx0Lmxlbmd0aD9lW25dPXRbbl06ZVtuXT10WzBdO3JldHVybiBlfSxjb21wdXRlT2N0UHRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkoOCkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10WzBdO2Zvcih2YXIgaT0xO2k8dC5sZW5ndGg7aSsrKXRbaV0ueDxlWzBdLngmJihlWzBdPXRbaV0pLHRbaV0ueC10W2ldLnk8ZVsxXS54LWVbMV0ueSYmKGVbMV09dFtpXSksdFtpXS55PmVbMl0ueSYmKGVbMl09dFtpXSksdFtpXS54K3RbaV0ueT5lWzNdLngrZVszXS55JiYoZVszXT10W2ldKSx0W2ldLng+ZVs0XS54JiYoZVs0XT10W2ldKSx0W2ldLngtdFtpXS55PmVbNV0ueC1lWzVdLnkmJihlWzVdPXRbaV0pLHRbaV0ueTxlWzZdLnkmJihlWzZdPXRbaV0pLHRbaV0ueCt0W2ldLnk8ZVs3XS54K2VbN10ueSYmKGVbN109dFtpXSk7cmV0dXJuIGV9LHRvQ29vcmRpbmF0ZUFycmF5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wO248dC5zaXplKCk7bisrKXt2YXIgaT10LmdldChuKTtlW25dPWl9cmV0dXJuIGV9LGdyYWhhbVNjYW46ZnVuY3Rpb24odCl7dmFyIGU9bnVsbCxuPW5ldyBwZTtlPW4ucHVzaCh0WzBdKSxlPW4ucHVzaCh0WzFdKSxlPW4ucHVzaCh0WzJdKTtmb3IodmFyIGk9MztpPHQubGVuZ3RoO2krKyl7Zm9yKGU9bi5wb3AoKTshbi5lbXB0eSgpJiZoZS5jb21wdXRlT3JpZW50YXRpb24obi5wZWVrKCksZSx0W2ldKT4wOyllPW4ucG9wKCk7ZT1uLnB1c2goZSksZT1uLnB1c2godFtpXSl9cmV0dXJuIGU9bi5wdXNoKHRbMF0pLG59LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1lfX0pLG1lLmV4dHJhY3RDb29yZGluYXRlcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgdmU7cmV0dXJuIHQuYXBwbHkoZSksZS5nZXRDb29yZGluYXRlcygpO1xufSxlKHllLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO3JldHVybiB5ZS5wb2xhckNvbXBhcmUodGhpcy5vcmlnaW4sbixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHllfX0pLHllLnBvbGFyQ29tcGFyZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS54LXQueCxyPWUueS10Lnkscz1uLngtdC54LG89bi55LXQueSxhPWhlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsbik7aWYoYT09PWhlLkNPVU5URVJDTE9DS1dJU0UpcmV0dXJuIDE7aWYoYT09PWhlLkNMT0NLV0lTRSlyZXR1cm4tMTt2YXIgdT1pKmkrcipyLGw9cypzK28qbztyZXR1cm4gbD51Py0xOnU+bD8xOjB9LG1lLlJhZGlhbENvbXBhcmF0b3I9eWUsZSh4ZS5wcm90b3R5cGUse3RyYW5zZm9ybVBvaW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfSx0cmFuc2Zvcm1Qb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49ITAsaT10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSx0KTtudWxsIT09aSYmaSBpbnN0YW5jZW9mIGJ0JiYhaS5pc0VtcHR5KCl8fChuPSExKTtmb3IodmFyIHI9bmV3IEkscz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe3ZhciBvPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEludGVyaW9yUmluZ04ocyksdCk7bnVsbD09PW98fG8uaXNFbXB0eSgpfHwobyBpbnN0YW5jZW9mIGJ0fHwobj0hMSksci5hZGQobykpfWlmKG4pcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKGksci50b0FycmF5KFtdKSk7dmFyIGE9bmV3IEk7cmV0dXJuIG51bGwhPT1pJiZhLmFkZChpKSxhLmFkZEFsbChyKSx0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShhKX0sY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KX0sZ2V0SW5wdXRHZW9tZXRyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlucHV0R2VvbX0sdHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9dGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQuZ2V0R2VvbWV0cnlOKGkpLHQpO251bGwhPT1yJiYoci5pc0VtcHR5KCl8fG4uYWRkKHIpKX1yZXR1cm4gdGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9LHRyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29weSh0KX0sdHJhbnNmb3JtTGluZVN0cmluZzpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfSx0cmFuc2Zvcm1NdWx0aVBvaW50OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9dGhpcy50cmFuc2Zvcm1Qb2ludCh0LmdldEdlb21ldHJ5TihpKSx0KTtudWxsIT09ciYmKHIuaXNFbXB0eSgpfHxuLmFkZChyKSl9cmV0dXJuIHRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfSx0cmFuc2Zvcm1NdWx0aVBvbHlnb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj10aGlzLnRyYW5zZm9ybVBvbHlnb24odC5nZXRHZW9tZXRyeU4oaSksdCk7bnVsbCE9PXImJihyLmlzRW1wdHkoKXx8bi5hZGQocikpfXJldHVybiB0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX0sY29weTpmdW5jdGlvbih0KXtyZXR1cm4gdC5jb3B5KCl9LHRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPXRoaXMudHJhbnNmb3JtKHQuZ2V0R2VvbWV0cnlOKGkpKTtudWxsIT09ciYmKHRoaXMucHJ1bmVFbXB0eUdlb21ldHJ5JiZyLmlzRW1wdHkoKXx8bi5hZGQocikpfXJldHVybiB0aGlzLnByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT90aGlzLmZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheShuKSk6dGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9LHRyYW5zZm9ybTpmdW5jdGlvbih0KXtpZih0aGlzLmlucHV0R2VvbT10LHRoaXMuZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0IGluc3RhbmNlb2YgTHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgUHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBidClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFN0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgZ3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFR0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgT3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGZ0KXJldHVybiB0aGlzLnRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LG51bGwpO3Rocm93IG5ldyBpKFwiVW5rbm93biBHZW9tZXRyeSBzdWJ0eXBlOiBcIit0LmdldENsYXNzKCkuZ2V0TmFtZSgpKX0sdHJhbnNmb3JtTGluZWFyUmluZzpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KTtpZihudWxsPT09bilyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobnVsbCk7dmFyIGk9bi5zaXplKCk7cmV0dXJuIGk+MCYmND5pJiYhdGhpcy5wcmVzZXJ2ZVR5cGU/dGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobik6dGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHhlfX0pLGUoRWUucHJvdG90eXBlLHtzbmFwVmVydGljZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5faXNDbG9zZWQ/dC5zaXplKCktMTp0LnNpemUoKSxpPTA7bj5pO2krKyl7dmFyIHI9dC5nZXQoaSkscz10aGlzLmZpbmRTbmFwRm9yVmVydGV4KHIsZSk7bnVsbCE9PXMmJih0LnNldChpLG5ldyBnKHMpKSwwPT09aSYmdGhpcy5faXNDbG9zZWQmJnQuc2V0KHQuc2l6ZSgpLTEsbmV3IGcocykpKX19LGZpbmRTbmFwRm9yVmVydGV4OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe2lmKHQuZXF1YWxzMkQoZVtuXSkpcmV0dXJuIG51bGw7aWYodC5kaXN0YW5jZShlW25dKTx0aGlzLnNuYXBUb2xlcmFuY2UpcmV0dXJuIGVbbl19cmV0dXJuIG51bGx9LHNuYXBUbzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTih0aGlzLnNyY1B0cyk7dGhpcy5zbmFwVmVydGljZXMoZSx0KSx0aGlzLnNuYXBTZWdtZW50cyhlLHQpO3ZhciBuPWUudG9Db29yZGluYXRlQXJyYXkoKTtyZXR1cm4gbn0sc25hcFNlZ21lbnRzOmZ1bmN0aW9uKHQsZSl7aWYoMD09PWUubGVuZ3RoKXJldHVybiBudWxsO3ZhciBuPWUubGVuZ3RoO2VbMF0uZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkmJihuPWUubGVuZ3RoLTEpO2Zvcih2YXIgaT0wO24+aTtpKyspe3ZhciByPWVbaV0scz10aGlzLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAocix0KTtzPj0wJiZ0LmFkZChzKzEsbmV3IGcociksITEpfX0sZmluZFNlZ21lbnRJbmRleFRvU25hcDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1yLk1BWF9WQUxVRSxpPS0xLHM9MDtzPGUuc2l6ZSgpLTE7cysrKXtpZih0aGlzLnNlZy5wMD1lLmdldChzKSx0aGlzLnNlZy5wMT1lLmdldChzKzEpLHRoaXMuc2VnLnAwLmVxdWFsczJEKHQpfHx0aGlzLnNlZy5wMS5lcXVhbHMyRCh0KSl7aWYodGhpcy5hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyljb250aW51ZTtyZXR1cm4tMX12YXIgbz10aGlzLnNlZy5kaXN0YW5jZSh0KTtvPHRoaXMuc25hcFRvbGVyYW5jZSYmbj5vJiYobj1vLGk9cyl9cmV0dXJuIGl9LHNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe3RoaXMuYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRWV9fSksRWUuaXNDbG9zZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoPD0xPyExOnRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSl9LGUoSWUucHJvdG90eXBlLHtzbmFwVG86ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KSxpPW5ldyBOZShlLG4pO3JldHVybiBpLnRyYW5zZm9ybSh0aGlzLnNyY0dlb20pfSxzbmFwVG9TZWxmOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModGhpcy5zcmNHZW9tKSxpPW5ldyBOZSh0LG4sITApLHI9aS50cmFuc2Zvcm0odGhpcy5zcmNHZW9tKSxzPXI7cmV0dXJuIGUmJlIocyxSdCkmJihzPXIuYnVmZmVyKDApKSxzfSxjb21wdXRlU25hcFRvbGVyYW5jZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCh0KSxuPWUvMTA7cmV0dXJuIG59LGV4dHJhY3RUYXJnZXRDb29yZGluYXRlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IGF0LG49dC5nZXRDb29yZGluYXRlcygpLGk9MDtpPG4ubGVuZ3RoO2krKyllLmFkZChuW2ldKTtyZXR1cm4gZS50b0FycmF5KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKX0sY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1yLk1BWF9WQUxVRSxuPTA7bjx0Lmxlbmd0aC0xO24rKyl7dmFyIGk9dFtuXS5kaXN0YW5jZSh0W24rMV0pO2U+aSYmKGU9aSl9cmV0dXJuIGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEllfX0pLEllLnNuYXA9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHI9bmV3IEllKHQpO2lbMF09ci5zbmFwVG8oZSxuKTt2YXIgcz1uZXcgSWUoZSk7cmV0dXJuIGlbMV09cy5zbmFwVG8oaVswXSxuKSxpfSxJZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2U9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9SWUuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UodCksbj10LmdldFByZWNpc2lvbk1vZGVsKCk7aWYobi5nZXRUeXBlKCk9PT1lZS5GSVhFRCl7dmFyIGk9MS9uLmdldFNjYWxlKCkqMi8xLjQxNTtpPmUmJihlPWkpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV07cmV0dXJuIE1hdGgubWluKEllLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShyKSxJZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UocykpfX0sSWUuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2U9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCksbj1NYXRoLm1pbihlLmdldEhlaWdodCgpLGUuZ2V0V2lkdGgoKSksaT1uKkllLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUjtyZXR1cm4gaX0sSWUuc25hcFRvU2VsZj1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEllKHQpO3JldHVybiBpLnNuYXBUb1NlbGYoZSxuKX0sSWUuU05BUF9QUkVDSVNJT05fRkFDVE9SPTFlLTksaChOZSx4ZSksZShOZS5wcm90b3R5cGUse3NuYXBMaW5lOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEVlKHQsdGhpcy5zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbi5zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0aGlzLmlzU2VsZlNuYXApLG4uc25hcFRvKGUpfSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxpPXRoaXMuc25hcExpbmUobix0aGlzLnNuYXBQdHMpO3JldHVybiB0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTmV9fSksZShDZS5wcm90b3R5cGUse2dldENvbW1vbjpmdW5jdGlvbigpe3JldHVybiByLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5jb21tb25CaXRzKX0sYWRkOmZ1bmN0aW9uKHQpe3ZhciBlPXIuZG91YmxlVG9Mb25nQml0cyh0KTtpZih0aGlzLmlzRmlyc3QpcmV0dXJuIHRoaXMuY29tbW9uQml0cz1lLHRoaXMuY29tbW9uU2lnbkV4cD1DZS5zaWduRXhwQml0cyh0aGlzLmNvbW1vbkJpdHMpLHRoaXMuaXNGaXJzdD0hMSxudWxsO3ZhciBuPUNlLnNpZ25FeHBCaXRzKGUpO3JldHVybiBuIT09dGhpcy5jb21tb25TaWduRXhwPyh0aGlzLmNvbW1vbkJpdHM9MCxudWxsKToodGhpcy5jb21tb25NYW50aXNzYUJpdHNDb3VudD1DZS5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHRoaXMuY29tbW9uQml0cyxlKSx2b2lkKHRoaXMuY29tbW9uQml0cz1DZS56ZXJvTG93ZXJCaXRzKHRoaXMuY29tbW9uQml0cyw2NC0oMTIrdGhpcy5jb21tb25NYW50aXNzYUJpdHNDb3VudCkpKSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXIubG9uZ0JpdHNUb0RvdWJsZSh0KSxuPUxvbmcudG9CaW5hcnlTdHJpbmcodCksaT1cIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIituLHM9aS5zdWJzdHJpbmcoaS5sZW5ndGgtNjQpLG89cy5zdWJzdHJpbmcoMCwxKStcIiAgXCIrcy5zdWJzdHJpbmcoMSwxMikrXCIoZXhwKSBcIitzLnN1YnN0cmluZygxMikrXCIgWyBcIitlK1wiIF1cIjtyZXR1cm4gb319LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENlfX0pLENlLmdldEJpdD1mdW5jdGlvbih0LGUpe3ZhciBuPTE8PGU7cmV0dXJuIDAhPT0odCZuKT8xOjB9LENlLnNpZ25FeHBCaXRzPWZ1bmN0aW9uKHQpe3JldHVybiB0Pj41Mn0sQ2UuemVyb0xvd2VyQml0cz1mdW5jdGlvbih0LGUpe3ZhciBuPSgxPDxlKS0xLGk9fm4scj10Jmk7cmV0dXJuIHJ9LENlLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxpPTUyO2k+PTA7aS0tKXtpZihDZS5nZXRCaXQodCxpKSE9PUNlLmdldEJpdChlLGkpKXJldHVybiBuO24rK31yZXR1cm4gNTJ9LGUoU2UucHJvdG90eXBlLHthZGRDb21tb25CaXRzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBMZSh0aGlzLmNvbW1vbkNvb3JkKTt0LmFwcGx5KGUpLHQuZ2VvbWV0cnlDaGFuZ2VkKCl9LHJlbW92ZUNvbW1vbkJpdHM6ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMuY29tbW9uQ29vcmQueCYmMD09PXRoaXMuY29tbW9uQ29vcmQueSlyZXR1cm4gdDt2YXIgZT1uZXcgZyh0aGlzLmNvbW1vbkNvb3JkKTtlLng9LWUueCxlLnk9LWUueTt2YXIgbj1uZXcgTGUoZSk7cmV0dXJuIHQuYXBwbHkobiksdC5nZW9tZXRyeUNoYW5nZWQoKSx0fSxnZXRDb21tb25Db29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tbW9uQ29vcmR9LGFkZDpmdW5jdGlvbih0KXt0LmFwcGx5KHRoaXMuY2NGaWx0ZXIpLHRoaXMuY29tbW9uQ29vcmQ9dGhpcy5jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFNlfX0pLGUod2UucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dGhpcy5jb21tb25CaXRzWC5hZGQodC54KSx0aGlzLmNvbW1vbkJpdHNZLmFkZCh0LnkpfSxnZXRDb21tb25Db29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKHRoaXMuY29tbW9uQml0c1guZ2V0Q29tbW9uKCksdGhpcy5jb21tb25CaXRzWS5nZXRDb21tb24oKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3pdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3ZX19KSxlKExlLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRPcmRpbmF0ZShlLDApK3RoaXMudHJhbnMueCxpPXQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLnRyYW5zLnk7dC5zZXRPcmRpbmF0ZShlLDAsbiksdC5zZXRPcmRpbmF0ZShlLDEsaSl9LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiExfSxpc0dlb21ldHJ5Q2hhbmdlZDpmdW5jdGlvbigpe3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltjdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExlfX0pLFNlLkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXI9d2UsU2UuVHJhbnNsYXRlcj1MZSxlKFJlLnByb3RvdHlwZSx7bmV4dDpmdW5jdGlvbigpe2lmKHRoaXMuYXRTdGFydClyZXR1cm4gdGhpcy5hdFN0YXJ0PSExLFJlLmlzQXRvbWljKHRoaXMucGFyZW50KSYmdGhpcy5pbmRleCsrLHRoaXMucGFyZW50O2lmKG51bGwhPT10aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcil7aWYodGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiB0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCk7dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1pZih0aGlzLmluZGV4Pj10aGlzLm1heCl0aHJvdyBuZXcgeDt2YXIgdD10aGlzLnBhcmVudC5nZXRHZW9tZXRyeU4odGhpcy5pbmRleCsrKTtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ0Pyh0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1uZXcgUmUodCksdGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpKTp0fSxyZW1vdmU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSl9LGhhc05leHQ6ZnVuY3Rpb24oKXtpZih0aGlzLmF0U3RhcnQpcmV0dXJuITA7aWYobnVsbCE9PXRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuITA7dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1yZXR1cm4hKHRoaXMuaW5kZXg+PXRoaXMubWF4KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJlfX0pLFJlLmlzQXRvbWljPWZ1bmN0aW9uKHQpe3JldHVybiEodCBpbnN0YW5jZW9mIGZ0KX0sZShUZS5wcm90b3R5cGUse2xvY2F0ZUludGVybmFsOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFR0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoZS5pc0VtcHR5KCkpcmV0dXJuIEwuRVhURVJJT1I7dmFyIG49ZS5nZXRFeHRlcmlvclJpbmcoKSxpPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LG4pO2lmKGk9PT1MLkVYVEVSSU9SKXJldHVybiBMLkVYVEVSSU9SO2lmKGk9PT1MLkJPVU5EQVJZKXJldHVybiBMLkJPVU5EQVJZO2Zvcih2YXIgcj0wO3I8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtyKyspe3ZhciBzPWUuZ2V0SW50ZXJpb3JSaW5nTihyKSxvPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LHMpO2lmKG89PT1MLklOVEVSSU9SKXJldHVybiBMLkVYVEVSSU9SO2lmKG89PT1MLkJPVU5EQVJZKXJldHVybiBMLkJPVU5EQVJZfXJldHVybiBMLklOVEVSSU9SfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBTdCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdO2lmKCF1LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGEpKXJldHVybiBMLkVYVEVSSU9SO3ZhciBsPXUuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdS5pc0Nsb3NlZCgpfHwhYS5lcXVhbHMobFswXSkmJiFhLmVxdWFscyhsW2wubGVuZ3RoLTFdKT9oZS5pc09uTGluZShhLGwpP0wuSU5URVJJT1I6TC5FWFRFUklPUjpMLkJPVU5EQVJZfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBMdCl7dmFyIGg9YXJndW1lbnRzWzBdLGM9YXJndW1lbnRzWzFdLGY9Yy5nZXRDb29yZGluYXRlKCk7cmV0dXJuIGYuZXF1YWxzMkQoaCk/TC5JTlRFUklPUjpMLkVYVEVSSU9SfX0sbG9jYXRlSW5Qb2x5Z29uUmluZzpmdW5jdGlvbih0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP2hlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTpMLkVYVEVSSU9SfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRlKHQsZSkhPT1MLkVYVEVSSU9SfSx1cGRhdGVMb2NhdGlvbkluZm86ZnVuY3Rpb24odCl7dD09PUwuSU5URVJJT1ImJih0aGlzLmlzSW49ITApLHQ9PT1MLkJPVU5EQVJZJiZ0aGlzLm51bUJvdW5kYXJpZXMrK30sY29tcHV0ZUxvY2F0aW9uOmZ1bmN0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIEx0JiZ0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsZSkpLGUgaW5zdGFuY2VvZiBTdCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsZSkpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFR0KXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgZ3QpZm9yKHZhciBuPWUsaT0wO2k8bi5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj1uLmdldEdlb21ldHJ5TihpKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQscikpfWVsc2UgaWYoZSBpbnN0YW5jZW9mIE90KWZvcih2YXIgcz1lLGk9MDtpPHMuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIG89cy5nZXRHZW9tZXRyeU4oaSk7dGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbCh0LG8pKX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBmdClmb3IodmFyIGE9bmV3IFJlKGUpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCk7dSE9PWUmJnRoaXMuY29tcHV0ZUxvY2F0aW9uKHQsdSl9fSxsb2NhdGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/TC5FWFRFUklPUjplIGluc3RhbmNlb2YgU3Q/dGhpcy5sb2NhdGVJbnRlcm5hbCh0LGUpOmUgaW5zdGFuY2VvZiBUdD90aGlzLmxvY2F0ZUludGVybmFsKHQsZSk6KHRoaXMuaXNJbj0hMSx0aGlzLm51bUJvdW5kYXJpZXM9MCx0aGlzLmNvbXB1dGVMb2NhdGlvbih0LGUpLHRoaXMuYm91bmRhcnlSdWxlLmlzSW5Cb3VuZGFyeSh0aGlzLm51bUJvdW5kYXJpZXMpP0wuQk9VTkRBUlk6dGhpcy5udW1Cb3VuZGFyaWVzPjB8fHRoaXMuaXNJbj9MLklOVEVSSU9SOkwuRVhURVJJT1IpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUZX19KSxlKFBlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUGV9fSksUGUub2N0YW50PWZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO3ZhciBuPU1hdGguYWJzKHQpLHI9TWF0aC5hYnMoZSk7cmV0dXJuIHQ+PTA/ZT49MD9uPj1yPzA6MTpuPj1yPzc6NjplPj0wP24+PXI/MzoyOm4+PXI/NDo1fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1vLngtcy54LHU9by55LXMueTtpZigwPT09YSYmMD09PXUpdGhyb3cgbmV3IGkoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIitzKTtyZXR1cm4gUGUub2N0YW50KGEsdSl9fSxlKGJlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt9LHNpemU6ZnVuY3Rpb24oKXt9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7fSxpc0Nsb3NlZDpmdW5jdGlvbigpe30sc2V0RGF0YTpmdW5jdGlvbih0KXt9LGdldERhdGE6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJlfX0pLGUoT2UucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHRzW3RdfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX0sZ2V0U2VnbWVudE9jdGFudDpmdW5jdGlvbih0KXtyZXR1cm4gdD09PXRoaXMucHRzLmxlbmd0aC0xPy0xOlBlLm9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLnB0cykpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltiZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9lfX0pLGUoX2UucHJvdG90eXBlLHtnZXRCb3VuZHM6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9lfX0pLGUoTWUucHJvdG90eXBlLHtnZXRJdGVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm91bmRzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltfZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTWV9fSksZShEZS5wcm90b3R5cGUse3BvbGw6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLml0ZW1zLmdldCgxKTtyZXR1cm4gdGhpcy5pdGVtcy5zZXQoMSx0aGlzLml0ZW1zLmdldCh0aGlzLl9zaXplKSksdGhpcy5fc2l6ZS09MSx0aGlzLnJlb3JkZXIoMSksdH0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaXplfSxyZW9yZGVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49dGhpcy5pdGVtcy5nZXQodCk7Mip0PD10aGlzLl9zaXplJiYoZT0yKnQsZSE9PXRoaXMuX3NpemUmJnRoaXMuaXRlbXMuZ2V0KGUrMSkuY29tcGFyZVRvKHRoaXMuaXRlbXMuZ2V0KGUpKTwwJiZlKyssdGhpcy5pdGVtcy5nZXQoZSkuY29tcGFyZVRvKG4pPDApO3Q9ZSl0aGlzLml0ZW1zLnNldCh0LHRoaXMuaXRlbXMuZ2V0KGUpKTt0aGlzLml0ZW1zLnNldCh0LG4pfSxjbGVhcjpmdW5jdGlvbigpe3RoaXMuX3NpemU9MCx0aGlzLml0ZW1zLmNsZWFyKCl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuX3NpemV9LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZChudWxsKSx0aGlzLl9zaXplKz0xO3ZhciBlPXRoaXMuX3NpemU7Zm9yKHRoaXMuaXRlbXMuc2V0KDAsdCk7dC5jb21wYXJlVG8odGhpcy5pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk8MDtlLz0yKXRoaXMuaXRlbXMuc2V0KGUsdGhpcy5pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk7dGhpcy5pdGVtcy5zZXQoZSx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRGV9fSksZShBZS5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFlfX0pLGUoRmUucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlKXt9LHJlbW92ZTpmdW5jdGlvbih0LGUpe30scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGZX19KSxlKEdlLnByb3RvdHlwZSx7Z2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkQm91bmRhYmxlcy5zaXplKCl9LGdldENoaWxkQm91bmRhYmxlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkQm91bmRhYmxlc30sYWRkQ2hpbGRCb3VuZGFibGU6ZnVuY3Rpb24odCl7Zi5pc1RydWUobnVsbD09PXRoaXMuYm91bmRzKSx0aGlzLmNoaWxkQm91bmRhYmxlcy5hZGQodCl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuYm91bmRzJiYodGhpcy5ib3VuZHM9dGhpcy5jb21wdXRlQm91bmRzKCkpLHRoaXMuYm91bmRzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltfZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR2V9fSksR2Uuc2VyaWFsVmVyc2lvblVJRD0weDVhMWU1NWVjNDEzNjk4MDA7dmFyIGhvPXtyZXZlcnNlT3JkZXI6ZnVuY3Rpb24oKXtyZXR1cm57Y29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiBlLmNvbXBhcmVUbyh0KX19fSxtaW46ZnVuY3Rpb24odCl7cmV0dXJuIGhvLnNvcnQodCksdC5nZXQoMCl9LHNvcnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRvQXJyYXkoKTtlP3V0LnNvcnQobixlKTp1dC5zb3J0KG4pO2Zvcih2YXIgaT10Lml0ZXJhdG9yKCkscj0wLHM9bi5sZW5ndGg7cz5yO3IrKylpLm5leHQoKSxpLnNldChuW3JdKX0sc2luZ2xldG9uTGlzdDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgSTtyZXR1cm4gZS5hZGQodCksZX19O2UocWUucHJvdG90eXBlLHtleHBhbmRUb1F1ZXVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49cWUuaXNDb21wb3NpdGUodGhpcy5ib3VuZGFibGUxKSxyPXFlLmlzQ29tcG9zaXRlKHRoaXMuYm91bmRhYmxlMik7aWYobiYmcilyZXR1cm4gcWUuYXJlYSh0aGlzLmJvdW5kYWJsZTEpPnFlLmFyZWEodGhpcy5ib3VuZGFibGUyKT8odGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMix0LGUpLG51bGwpOih0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTIsdGhpcy5ib3VuZGFibGUxLHQsZSksbnVsbCk7aWYobilyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMix0LGUpLG51bGw7aWYocilyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUyLHRoaXMuYm91bmRhYmxlMSx0LGUpLG51bGw7dGhyb3cgbmV3IGkoXCJuZWl0aGVyIGJvdW5kYWJsZSBpcyBjb21wb3NpdGVcIil9LGlzTGVhdmVzOmZ1bmN0aW9uKCl7cmV0dXJuIShxZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTEpfHxxZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTIpKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlPGUuX2Rpc3RhbmNlPy0xOnRoaXMuX2Rpc3RhbmNlPmUuX2Rpc3RhbmNlPzE6MH0sZXhwYW5kOmZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj10LmdldENoaWxkQm91bmRhYmxlcygpLHM9ci5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksYT1uZXcgcWUobyxlLHRoaXMuaXRlbURpc3RhbmNlKTthLmdldERpc3RhbmNlKCk8aSYmbi5hZGQoYSl9fSxnZXRCb3VuZGFibGU6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10P3RoaXMuYm91bmRhYmxlMTp0aGlzLmJvdW5kYWJsZTJ9LGdldERpc3RhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfSxkaXN0YW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTGVhdmVzKCk/dGhpcy5pdGVtRGlzdGFuY2UuZGlzdGFuY2UodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMik6dGhpcy5ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuYm91bmRhYmxlMi5nZXRCb3VuZHMoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxZX19KSxxZS5hcmVhPWZ1bmN0aW9uKHQpe3JldHVybiB0LmdldEJvdW5kcygpLmdldEFyZWEoKX0scWUuaXNDb21wb3NpdGU9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBHZX0sZShCZS5wcm90b3R5cGUse2dldE5vZGVDYXBhY2l0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVDYXBhY2l0eX0sbGFzdE5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0KHQuc2l6ZSgpLTEpfSxzaXplOmZ1bmN0aW9uIHFvKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLnNpemUodGhpcy5yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0scW89MCxlPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24gaW5zdGFuY2VvZiBHZT9xbys9dGhpcy5zaXplKG4pOm4gaW5zdGFuY2VvZiBNZSYmKHFvKz0xKX1yZXR1cm4gcW99fSxyZW1vdmVJdGVtOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW51bGwsaT10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyIGluc3RhbmNlb2YgTWUmJnIuZ2V0SXRlbSgpPT09ZSYmKG49cil9cmV0dXJuIG51bGwhPT1uPyh0LmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShuKSwhMCk6ITF9LGl0ZW1zVHJlZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLmJ1aWxkKCk7dmFyIHQ9dGhpcy5pdGVtc1RyZWUodGhpcy5yb290KTtyZXR1cm4gbnVsbD09PXQ/bmV3IEk6dH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPW5ldyBJLGk9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYociBpbnN0YW5jZW9mIEdlKXt2YXIgcz10aGlzLml0ZW1zVHJlZShyKTtudWxsIT09cyYmbi5hZGQocyl9ZWxzZSByIGluc3RhbmNlb2YgTWU/bi5hZGQoci5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbi5zaXplKCk8PTA/bnVsbDpufX0saW5zZXJ0OmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUoIXRoaXMuYnVpbHQsXCJDYW5ub3QgaW5zZXJ0IGl0ZW1zIGludG8gYW4gU1RSIHBhY2tlZCBSLXRyZWUgYWZ0ZXIgaXQgaGFzIGJlZW4gYnVpbHQuXCIpLHRoaXMuaXRlbUJvdW5kYWJsZXMuYWRkKG5ldyBNZSh0LGUpKX0sYm91bmRhYmxlc0F0TGV2ZWw6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEk7cmV0dXJuIHRoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCx0aGlzLnJvb3QsZSksZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO2lmKGYuaXNUcnVlKG4+LTIpLGkuZ2V0TGV2ZWwoKT09PW4pcmV0dXJuIHIuYWRkKGkpLG51bGw7Zm9yKHZhciBzPWkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpO28gaW5zdGFuY2VvZiBHZT90aGlzLmJvdW5kYWJsZXNBdExldmVsKG4sbyxyKTooZi5pc1RydWUobyBpbnN0YW5jZW9mIE1lKSwtMT09PW4mJnIuYWRkKG8pKX1yZXR1cm4gbnVsbH19LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmJ1aWxkKCk7dmFyIGU9bmV3IEk7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2U6KHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLnJvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnkodCx0aGlzLnJvb3QsZSksZSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtpZih0aGlzLmJ1aWxkKCksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMucm9vdC5nZXRCb3VuZHMoKSxuKSYmdGhpcy5xdWVyeShuLHRoaXMucm9vdCxpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLEFlKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2UpZm9yKHZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCksdT0wO3U8YS5zaXplKCk7dSsrKXt2YXIgbD1hLmdldCh1KTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMobC5nZXRCb3VuZHMoKSxyKSYmKGwgaW5zdGFuY2VvZiBHZT90aGlzLnF1ZXJ5KHIsbCxvKTpsIGluc3RhbmNlb2YgTWU/by52aXNpdEl0ZW0obC5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2UpZm9yKHZhciBoPWFyZ3VtZW50c1swXSxjPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxhPWMuZ2V0Q2hpbGRCb3VuZGFibGVzKCksdT0wO3U8YS5zaXplKCk7dSsrKXt2YXIgbD1hLmdldCh1KTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMobC5nZXRCb3VuZHMoKSxoKSYmKGwgaW5zdGFuY2VvZiBHZT90aGlzLnF1ZXJ5KGgsbCxnKTpsIGluc3RhbmNlb2YgTWU/Zy5hZGQobC5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fSxidWlsZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1aWx0P251bGw6KHRoaXMucm9vdD10aGlzLml0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKT90aGlzLmNyZWF0ZU5vZGUoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHModGhpcy5pdGVtQm91bmRhYmxlcywtMSksdGhpcy5pdGVtQm91bmRhYmxlcz1udWxsLHZvaWQodGhpcy5idWlsdD0hMCkpfSxnZXRSb290OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLnJvb3R9LHJlbW92ZTpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5yb290LmdldEJvdW5kcygpLHQpP3RoaXMucmVtb3ZlKHQsdGhpcy5yb290LGUpOiExfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl0scz10aGlzLnJlbW92ZUl0ZW0oaSxyKTtpZihzKXJldHVybiEwO2Zvcih2YXIgbz1udWxsLGE9aS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCk7aWYodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHUuZ2V0Qm91bmRzKCksbikmJnUgaW5zdGFuY2VvZiBHZSYmKHM9dGhpcy5yZW1vdmUobix1LHIpKSl7bz11O2JyZWFrfX1yZXR1cm4gbnVsbCE9PW8mJm8uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXNFbXB0eSgpJiZpLmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShvKSxzfX0sY3JlYXRlSGlnaGVyTGV2ZWxzOmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUoIXQuaXNFbXB0eSgpKTt2YXIgbj10aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKzEpO3JldHVybiAxPT09bi5zaXplKCk/bi5nZXQoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHMobixlKzEpfSxkZXB0aDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5kZXB0aCh0aGlzLnJvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTAsbj10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpIGluc3RhbmNlb2YgR2Upe3ZhciByPXRoaXMuZGVwdGgoaSk7cj5lJiYoZT1yKX19cmV0dXJuIGUrMX19LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO3ZhciBuPW5ldyBJO24uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSk7dmFyIGk9bmV3IEkodCk7aG8uc29ydChpLHRoaXMuZ2V0Q29tcGFyYXRvcigpKTtmb3IodmFyIHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7dGhpcy5sYXN0Tm9kZShuKS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5zaXplKCk9PT10aGlzLmdldE5vZGVDYXBhY2l0eSgpJiZuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpLHRoaXMubGFzdE5vZGUobikuYWRkQ2hpbGRCb3VuZGFibGUocyl9cmV0dXJuIG59LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWlsdD90aGlzLnJvb3QuaXNFbXB0eSgpOnRoaXMuaXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQmV9fSksQmUuY29tcGFyZURvdWJsZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lPzE6ZT50Py0xOjB9LEJlLkludGVyc2VjdHNPcD16ZSxCZS5zZXJpYWxWZXJzaW9uVUlEPS0weDM1ZWY2NGM4MmQ0YzU0MDAsQmUuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwLGUoVmUucHJvdG90eXBlLHtkaXN0YW5jZTpmdW5jdGlvbih0LGUpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVmV9fSksaChrZSxCZSksZShrZS5wcm90b3R5cGUse2NyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSh0Lmxlbmd0aD4wKTtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5sZW5ndGg7aSsrKW4uYWRkQWxsKHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHRbaV0sZSkpO3JldHVybiBufSxjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgWWUodCl9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/QmUucHJvdG90eXBlLnNpemUuY2FsbCh0aGlzKTpCZS5wcm90b3R5cGUuc2l6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGluc2VydDpmdW5jdGlvbigpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBCZS5wcm90b3R5cGUuaW5zZXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuaXNOdWxsKCk/bnVsbDp2b2lkIEJlLnByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLHQsZSl9LGdldEludGVyc2VjdHNPcDpmdW5jdGlvbigpe3JldHVybiBrZS5pbnRlcnNlY3RzT3B9LHZlcnRpY2FsU2xpY2VzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL2UpKSxpPW5ldyBBcnJheShlKS5maWxsKG51bGwpLHI9dC5pdGVyYXRvcigpLHM9MDtlPnM7cysrKXtpW3NdPW5ldyBJO2Zvcih2YXIgbz0wO3IuaGFzTmV4dCgpJiZuPm87KXt2YXIgYT1yLm5leHQoKTtpW3NdLmFkZChhKSxvKyt9fXJldHVybiBpfSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIEJlLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLGUsbil9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihSKGFyZ3VtZW50c1syXSxBZSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEdlKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07QmUucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcyxpLHIscyl9ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2Upe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXTtCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLG8sYSx1KX19LGdldENvbXBhcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4ga2UueUNvbXBhcmF0b3J9LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZTpmdW5jdGlvbih0LGUpe3JldHVybiBCZS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlcy5jYWxsKHRoaXMsdCxlKX0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gQmUucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gQmUucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGRlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP0JlLnByb3RvdHlwZS5kZXB0aC5jYWxsKHRoaXMpOkJlLnByb3RvdHlwZS5kZXB0aC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO3ZhciBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL3RoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkpKSxpPW5ldyBJKHQpO2hvLnNvcnQoaSxrZS54Q29tcGFyYXRvcik7dmFyIHI9dGhpcy52ZXJ0aWNhbFNsaWNlcyhpLE1hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGguc3FydChuKSkpKTtyZXR1cm4gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKHIsZSl9LG5lYXJlc3ROZWlnaGJvdXI6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sVmUpKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgcWUodGhpcy5nZXRSb290KCksdGhpcy5nZXRSb290KCksdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFlKXt2YXIgbj1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihuLHIuUE9TSVRJVkVfSU5GSU5JVFkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGtlJiZSKGFyZ3VtZW50c1sxXSxWZSkpe3ZhciBpPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxlPW5ldyBxZSh0aGlzLmdldFJvb3QoKSxpLmdldFJvb3QoKSxzKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcWUmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWEsbD1udWxsLGg9bmV3IERlO2ZvcihoLmFkZChvKTshaC5pc0VtcHR5KCkmJnU+MDspe3ZhciBjPWgucG9sbCgpLGY9Yy5nZXREaXN0YW5jZSgpO2lmKGY+PXUpYnJlYWs7Yy5pc0xlYXZlcygpPyh1PWYsbD1jKTpjLmV4cGFuZFRvUXVldWUoaCx1KX1yZXR1cm5bbC5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLGwuZ2V0Qm91bmRhYmxlKDEpLmdldEl0ZW0oKV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBnPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXSx2PW5ldyBNZShnLGQpLGU9bmV3IHFlKHRoaXMuZ2V0Um9vdCgpLHYscCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKVswXX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0ZlLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrZX19KSxrZS5jZW50cmVYPWZ1bmN0aW9uKHQpe3JldHVybiBrZS5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpfSxrZS5hdmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4odCtlKS8yfSxrZS5jZW50cmVZPWZ1bmN0aW9uKHQpe3JldHVybiBrZS5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpfSxoKFllLEdlKSxlKFllLnByb3RvdHlwZSx7Y29tcHV0ZUJvdW5kczpmdW5jdGlvbigpe2Zvcih2YXIgdD1udWxsLGU9dGhpcy5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bnVsbD09PXQ/dD1uZXcgQyhuLmdldEJvdW5kcygpKTp0LmV4cGFuZFRvSW5jbHVkZShuLmdldEJvdW5kcygpKX1yZXR1cm4gdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWWV9fSksa2UuU1RSdHJlZU5vZGU9WWUsa2Uuc2VyaWFsVmVyc2lvblVJRD0weDM5OTIwZjdkNWYyNjFlMCxrZS54Q29tcGFyYXRvcj17aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gQmUuY29tcGFyZURvdWJsZXMoa2UuY2VudHJlWCh0LmdldEJvdW5kcygpKSxrZS5jZW50cmVYKGUuZ2V0Qm91bmRzKCkpKX19LGtlLnlDb21wYXJhdG9yPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sY29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiBCZS5jb21wYXJlRG91YmxlcyhrZS5jZW50cmVZKHQuZ2V0Qm91bmRzKCkpLGtlLmNlbnRyZVkoZS5nZXRCb3VuZHMoKSkpfX0sa2UuaW50ZXJzZWN0c09wPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltJbnRlcnNlY3RzT3BdfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0cyhlKX19LGtlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMCxlKFVlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVWV9fSksVWUucmVsYXRpdmVTaWduPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU+dD8tMTp0PmU/MTowfSxVZS5jb21wYXJlPWZ1bmN0aW9uKHQsZSxuKXtpZihlLmVxdWFsczJEKG4pKXJldHVybiAwO3ZhciBpPVVlLnJlbGF0aXZlU2lnbihlLngsbi54KSxyPVVlLnJlbGF0aXZlU2lnbihlLnksbi55KTtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiBVZS5jb21wYXJlVmFsdWUoaSxyKTtjYXNlIDE6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZShyLGkpO2Nhc2UgMjpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKHIsLWkpO2Nhc2UgMzpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1pLHIpO2Nhc2UgNDpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1pLC1yKTtjYXNlIDU6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZSgtciwtaSk7Y2FzZSA2OnJldHVybiBVZS5jb21wYXJlVmFsdWUoLXIsaSk7Y2FzZSA3OnJldHVybiBVZS5jb21wYXJlVmFsdWUoaSwtcil9cmV0dXJuIGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJpbnZhbGlkIG9jdGFudCB2YWx1ZVwiKSwwfSxVZS5jb21wYXJlVmFsdWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD50Py0xOnQ+MD8xOjA+ZT8tMTplPjA/MTowfSxlKFhlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkfSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDxlLnNlZ21lbnRJbmRleD8tMTp0aGlzLnNlZ21lbnRJbmRleD5lLnNlZ21lbnRJbmRleD8xOnRoaXMuY29vcmQuZXF1YWxzMkQoZS5jb29yZCk/MDpVZS5jb21wYXJlKHRoaXMuc2VnbWVudE9jdGFudCx0aGlzLmNvb3JkLGUuY29vcmQpfSxpc0VuZFBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiAwIT09dGhpcy5zZWdtZW50SW5kZXh8fHRoaXMuX2lzSW50ZXJpb3I/dGhpcy5zZWdtZW50SW5kZXg9PT10OiEwfSxpc0ludGVyaW9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW50ZXJpb3J9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYZX19KSxlKEhlLnByb3RvdHlwZSx7Z2V0U3BsaXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBOO3RoaXMuYWRkRW5kcG9pbnRzKCk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKSxuPWUubmV4dCgpO2UuaGFzTmV4dCgpOyl7dmFyIGk9ZS5uZXh0KCk7dGhpcy5hZGRFZGdlQ29vcmRpbmF0ZXMobixpLHQpLG49aX1yZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfSxhZGRDb2xsYXBzZWROb2RlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3RoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpLHRoaXMuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpO2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKS5pbnRWYWx1ZSgpO3RoaXMuYWRkKHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKG4pLG4pfX0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxmaW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2Uuc2l6ZSgpLTI7ZSsrKXt2YXIgbj10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlKSxpPSh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlKzEpLHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUrMikpO24uZXF1YWxzMkQoaSkmJnQuYWRkKG5ldyBiKGUrMSkpfX0sYWRkRWRnZUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyLHI9dGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLHM9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHIpO3N8fGktLTtuLmFkZChuZXcgZyh0LmNvb3JkKSwhMSk7Zm9yKHZhciBvPXQuc2VnbWVudEluZGV4KzE7bzw9ZS5zZWdtZW50SW5kZXg7bysrKW4uYWRkKHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKG8pKTtzJiZuLmFkZChuZXcgZyhlLmNvb3JkKSl9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSxhZGRTcGxpdEVkZ2VzOmZ1bmN0aW9uKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCksdGhpcy5hZGRDb2xsYXBzZWROb2RlcygpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCksbj1lLm5leHQoKTtlLmhhc05leHQoKTspe3ZhciBpPWUubmV4dCgpLHI9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixpKTt0LmFkZChyKSxuPWl9fSxmaW5kQ29sbGFwc2VJbmRleDpmdW5jdGlvbih0LGUsbil7aWYoIXQuY29vcmQuZXF1YWxzMkQoZS5jb29yZCkpcmV0dXJuITE7dmFyIGk9ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXg7cmV0dXJuIGUuaXNJbnRlcmlvcigpfHxpLS0sMT09PWk/KG5bMF09dC5zZWdtZW50SW5kZXgrMSwhMCk6ITF9LGZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLml0ZXJhdG9yKCksaT1uLm5leHQoKTtuLmhhc05leHQoKTspe3ZhciByPW4ubmV4dCgpLHM9dGhpcy5maW5kQ29sbGFwc2VJbmRleChpLHIsZSk7cyYmdC5hZGQobmV3IGIoZVswXSkpLGk9cn19LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlfSxhZGRFbmRwb2ludHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVkZ2Uuc2l6ZSgpLTE7dGhpcy5hZGQodGhpcy5lZGdlLmdldENvb3JkaW5hdGUoMCksMCksdGhpcy5hZGQodGhpcy5lZGdlLmdldENvb3JkaW5hdGUodCksdCl9LGNyZWF0ZVNwbGl0RWRnZTpmdW5jdGlvbih0LGUpe3ZhciBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzIsaT10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlLnNlZ21lbnRJbmRleCkscj1lLmlzSW50ZXJpb3IoKXx8IWUuY29vcmQuZXF1YWxzMkQoaSk7cnx8bi0tO3ZhciBzPW5ldyBBcnJheShuKS5maWxsKG51bGwpLG89MDtzW28rK109bmV3IGcodC5jb29yZCk7Zm9yKHZhciBhPXQuc2VnbWVudEluZGV4KzE7YTw9ZS5zZWdtZW50SW5kZXg7YSsrKXNbbysrXT10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShhKTtyZXR1cm4gciYmKHNbb109bmV3IGcoZS5jb29yZCkpLG5ldyBLZShzLHRoaXMuZWRnZS5nZXREYXRhKCkpfSxhZGQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgWGUodGhpcy5lZGdlLHQsZSx0aGlzLmVkZ2UuZ2V0U2VnbWVudE9jdGFudChlKSksaT10aGlzLm5vZGVNYXAuZ2V0KG4pO3JldHVybiBudWxsIT09aT8oZi5pc1RydWUoaS5jb29yZC5lcXVhbHMyRCh0KSxcIkZvdW5kIGVxdWFsIG5vZGVzIHdpdGggZGlmZmVyZW50IGNvb3JkaW5hdGVzXCIpLGkpOih0aGlzLm5vZGVNYXAucHV0KG4sbiksbil9LGNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlcygpLG49dC5nZXQoMCksaT1uLmdldENvb3JkaW5hdGUoMCk7aWYoIWkuZXF1YWxzMkQoZVswXSkpdGhyb3cgbmV3IGwoXCJiYWQgc3BsaXQgZWRnZSBzdGFydCBwb2ludCBhdCBcIitpKTt2YXIgcj10LmdldCh0LnNpemUoKS0xKSxzPXIuZ2V0Q29vcmRpbmF0ZXMoKSxvPXNbcy5sZW5ndGgtMV07aWYoIW8uZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkpdGhyb3cgbmV3IGwoXCJiYWQgc3BsaXQgZWRnZSBlbmQgcG9pbnQgYXQgXCIrbyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhlfX0pLGUoV2UucHJvdG90eXBlLHtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmN1cnJOb2RlPyh0aGlzLmN1cnJOb2RlPXRoaXMubmV4dE5vZGUsdGhpcy5jdXJyU2VnSW5kZXg9dGhpcy5jdXJyTm9kZS5zZWdtZW50SW5kZXgsdGhpcy5yZWFkTmV4dE5vZGUoKSx0aGlzLmN1cnJOb2RlKTpudWxsPT09dGhpcy5uZXh0Tm9kZT9udWxsOnRoaXMubmV4dE5vZGUuc2VnbWVudEluZGV4PT09dGhpcy5jdXJyTm9kZS5zZWdtZW50SW5kZXg/KHRoaXMuY3Vyck5vZGU9dGhpcy5uZXh0Tm9kZSx0aGlzLmN1cnJTZWdJbmRleD10aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleCx0aGlzLnJlYWROZXh0Tm9kZSgpLHRoaXMuY3Vyck5vZGUpOih0aGlzLm5leHROb2RlLnNlZ21lbnRJbmRleD50aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleCxudWxsKX0scmVtb3ZlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfSxoYXNOZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLm5leHROb2RlfSxyZWFkTmV4dE5vZGU6ZnVuY3Rpb24oKXt0aGlzLm5vZGVJdC5oYXNOZXh0KCk/dGhpcy5uZXh0Tm9kZT10aGlzLm5vZGVJdC5uZXh0KCk6dGhpcy5uZXh0Tm9kZT1udWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltwXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV2V9fSksZShqZS5wcm90b3R5cGUse2FkZEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYmVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqZX19KSxlKEtlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHN9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RofSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnB0c1t0XX0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aC0xXSl9LGdldFNlZ21lbnRPY3RhbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLnB0cy5sZW5ndGgtMT8tMTp0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sc2FmZU9jdGFudDpmdW5jdGlvbih0LGUpe3JldHVybiB0LmVxdWFsczJEKGUpPzA6UGUub2N0YW50KHQsZSl9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxhZGRJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPShhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdKSxzPW5ldyBnKG4uZ2V0SW50ZXJzZWN0aW9uKHIpKTt0aGlzLmFkZEludGVyc2VjdGlvbihzLGkpfX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLnB0cykpfSxnZXROb2RlTGlzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVMaXN0fSxhZGRJbnRlcnNlY3Rpb25Ob2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSxpPW4rMTtpZihpPHRoaXMucHRzLmxlbmd0aCl7dmFyIHI9dGhpcy5wdHNbaV07dC5lcXVhbHMyRChyKSYmKG49aSl9dmFyIHM9dGhpcy5ub2RlTGlzdC5hZGQodCxuKTtyZXR1cm4gc30sYWRkSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LmdldEludGVyc2VjdGlvbk51bSgpO2krKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bamVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLZX19KSxLZS5nZXROb2RlZFN1YnN0cmluZ3M9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEk7cmV0dXJuIEtlLmdldE5vZGVkU3Vic3RyaW5ncyh0LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW4uaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO3MuZ2V0Tm9kZUxpc3QoKS5hZGRTcGxpdEVkZ2VzKGkpfX0sZShaZS5wcm90b3R5cGUse292ZXJsYXA6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dC5nZXRMaW5lU2VnbWVudChlLHRoaXMub3ZlcmxhcFNlZzEpLG4uZ2V0TGluZVNlZ21lbnQoaSx0aGlzLm92ZXJsYXBTZWcyKSx0aGlzLm92ZXJsYXAodGhpcy5vdmVybGFwU2VnMSx0aGlzLm92ZXJsYXBTZWcyKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFplfX0pLFxuZShRZS5wcm90b3R5cGUse2dldExpbmVTZWdtZW50OmZ1bmN0aW9uKHQsZSl7ZS5wMD10aGlzLnB0c1t0XSxlLnAxPXRoaXMucHRzW3QrMV19LGNvbXB1dGVTZWxlY3Q6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dGhpcy5wdHNbZV0scz10aGlzLnB0c1tuXTtpZihpLnRlbXBFbnYxLmluaXQocixzKSxuLWU9PT0xKXJldHVybiBpLnNlbGVjdCh0aGlzLGUpLG51bGw7aWYoIXQuaW50ZXJzZWN0cyhpLnRlbXBFbnYxKSlyZXR1cm4gbnVsbDt2YXIgbz1NYXRoLnRydW5jKChlK24pLzIpO28+ZSYmdGhpcy5jb21wdXRlU2VsZWN0KHQsZSxvLGkpLG4+byYmdGhpcy5jb21wdXRlU2VsZWN0KHQsbyxuLGkpfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5lbmQtdGhpcy5zdGFydCsxKS5maWxsKG51bGwpLGU9MCxuPXRoaXMuc3RhcnQ7bjw9dGhpcy5lbmQ7bisrKXRbZSsrXT10aGlzLnB0c1tuXTtyZXR1cm4gdH0sY29tcHV0ZU92ZXJsYXBzOmZ1bmN0aW9uKHQsZSl7dGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0aGlzLnN0YXJ0LHRoaXMuZW5kLHQsdC5zdGFydCx0LmVuZCxlKX0sc2V0SWQ6ZnVuY3Rpb24odCl7dGhpcy5pZD10fSxzZWxlY3Q6ZnVuY3Rpb24odCxlKXt0aGlzLmNvbXB1dGVTZWxlY3QodCx0aGlzLnN0YXJ0LHRoaXMuZW5kLGUpfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmVudil7dmFyIHQ9dGhpcy5wdHNbdGhpcy5zdGFydF0sZT10aGlzLnB0c1t0aGlzLmVuZF07dGhpcy5lbnY9bmV3IEModCxlKX1yZXR1cm4gdGhpcy5lbnZ9LGdldEVuZEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kfSxnZXRTdGFydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnR9LGdldENvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZXh0fSxnZXRJZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkfSxjb21wdXRlT3ZlcmxhcHNJbnRlcm5hbDpmdW5jdGlvbih0LGUsbixpLHIscyl7dmFyIG89dGhpcy5wdHNbdF0sYT10aGlzLnB0c1tlXSx1PW4ucHRzW2ldLGw9bi5wdHNbcl07aWYoZS10PT09MSYmci1pPT09MSlyZXR1cm4gcy5vdmVybGFwKHRoaXMsdCxuLGkpLG51bGw7aWYocy50ZW1wRW52MS5pbml0KG8sYSkscy50ZW1wRW52Mi5pbml0KHUsbCksIXMudGVtcEVudjEuaW50ZXJzZWN0cyhzLnRlbXBFbnYyKSlyZXR1cm4gbnVsbDt2YXIgaD1NYXRoLnRydW5jKCh0K2UpLzIpLGM9TWF0aC50cnVuYygoaStyKS8yKTtoPnQmJihjPmkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwodCxoLG4saSxjLHMpLHI+YyYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0LGgsbixjLHIscykpLGU+aCYmKGM+aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbChoLGUsbixpLGMscykscj5jJiZ0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKGgsZSxuLGMscixzKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFFlfX0pLGUoSmUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBKZX19KSxKZS5pc05vcnRoZXJuPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09SmUuTkV8fHQ9PT1KZS5OV30sSmUuaXNPcHBvc2l0ZT1mdW5jdGlvbih0LGUpe2lmKHQ9PT1lKXJldHVybiExO3ZhciBuPSh0LWUrNCklNDtyZXR1cm4gMj09PW59LEplLmNvbW1vbkhhbGZQbGFuZT1mdW5jdGlvbih0LGUpe2lmKHQ9PT1lKXJldHVybiB0O3ZhciBuPSh0LWUrNCklNDtpZigyPT09bilyZXR1cm4tMTt2YXIgaT1lPnQ/dDplLHI9dD5lP3Q6ZTtyZXR1cm4gMD09PWkmJjM9PT1yPzM6aX0sSmUuaXNJbkhhbGZQbGFuZT1mdW5jdGlvbih0LGUpe3JldHVybiBlPT09SmUuU0U/dD09PUplLlNFfHx0PT09SmUuU1c6dD09PWV8fHQ9PT1lKzF9LEplLnF1YWRyYW50PWZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7cmV0dXJuIHQ+PTA/ZT49MD9KZS5ORTpKZS5TRTplPj0wP0plLk5XOkplLlNXfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgbj1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07aWYoci54PT09bi54JiZyLnk9PT1uLnkpdGhyb3cgbmV3IGkoXCJDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK24pO3JldHVybiByLng+PW4ueD9yLnk+PW4ueT9KZS5ORTpKZS5TRTpyLnk+PW4ueT9KZS5OVzpKZS5TV319LEplLk5FPTAsSmUuTlc9MSxKZS5TVz0yLEplLlNFPTMsZSgkZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRlfX0pLCRlLmdldENoYWluU3RhcnRJbmRpY2VzPWZ1bmN0aW9uKHQpe3ZhciBlPTAsbj1uZXcgSTtuLmFkZChuZXcgYihlKSk7ZG97dmFyIGk9JGUuZmluZENoYWluRW5kKHQsZSk7bi5hZGQobmV3IGIoaSkpLGU9aX13aGlsZShlPHQubGVuZ3RoLTEpO3ZhciByPSRlLnRvSW50QXJyYXkobik7cmV0dXJuIHJ9LCRlLmZpbmRDaGFpbkVuZD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lO248dC5sZW5ndGgtMSYmdFtuXS5lcXVhbHMyRCh0W24rMV0pOyluKys7aWYobj49dC5sZW5ndGgtMSlyZXR1cm4gdC5sZW5ndGgtMTtmb3IodmFyIGk9SmUucXVhZHJhbnQodFtuXSx0W24rMV0pLHI9ZSsxO3I8dC5sZW5ndGg7KXtpZighdFtyLTFdLmVxdWFsczJEKHRbcl0pKXt2YXIgcz1KZS5xdWFkcmFudCh0W3ItMV0sdFtyXSk7aWYocyE9PWkpYnJlYWt9cisrfXJldHVybiByLTF9LCRlLmdldENoYWlucz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuICRlLmdldENoYWlucyh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9bmV3IEkscj0kZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyhlKSxzPTA7czxyLmxlbmd0aC0xO3MrKyl7dmFyIG89bmV3IFFlKGUscltzXSxyW3MrMV0sbik7aS5hZGQobyl9cmV0dXJuIGl9fSwkZS50b0ludEFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX0sZSh0bi5wcm90b3R5cGUse2NvbXB1dGVOb2RlczpmdW5jdGlvbih0KXt9LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdG59fSksZShlbi5wcm90b3R5cGUse3NldFNlZ21lbnRJbnRlcnNlY3RvcjpmdW5jdGlvbih0KXt0aGlzLnNlZ0ludD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt0bl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVufX0pLGgobm4sZW4pLGUobm4ucHJvdG90eXBlLHtnZXRNb25vdG9uZUNoYWluczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vbm9DaGFpbnN9LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe3JldHVybiBLZS5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5ub2RlZFNlZ1N0cmluZ3MpfSxnZXRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluZGV4fSxhZGQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSRlLmdldENoYWlucyh0LmdldENvb3JkaW5hdGVzKCksdCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldElkKHRoaXMuaWRDb3VudGVyKyspLHRoaXMuaW5kZXguaW5zZXJ0KGkuZ2V0RW52ZWxvcGUoKSxpKSx0aGlzLm1vbm9DaGFpbnMuYWRkKGkpfX0sY29tcHV0ZU5vZGVzOmZ1bmN0aW9uKHQpe3RoaXMubm9kZWRTZWdTdHJpbmdzPXQ7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3RoaXMuaW50ZXJzZWN0Q2hhaW5zKCl9LGludGVyc2VjdENoYWluczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgcm4odGhpcy5zZWdJbnQpLGU9dGhpcy5tb25vQ2hhaW5zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPXRoaXMuaW5kZXgucXVlcnkobi5nZXRFbnZlbG9wZSgpKSxyPWkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKHMuZ2V0SWQoKT5uLmdldElkKCkmJihuLmNvbXB1dGVPdmVybGFwcyhzLHQpLHRoaXMubk92ZXJsYXBzKyspLHRoaXMuc2VnSW50LmlzRG9uZSgpKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbm59fSksaChybixaZSksZShybi5wcm90b3R5cGUse292ZXJsYXA6ZnVuY3Rpb24oKXtpZig0IT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gWmUucHJvdG90eXBlLm92ZXJsYXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXSxyPXQuZ2V0Q29udGV4dCgpLHM9bi5nZXRDb250ZXh0KCk7dGhpcy5zaS5wcm9jZXNzSW50ZXJzZWN0aW9ucyhyLGUscyxpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcm59fSksbm4uU2VnbWVudE92ZXJsYXBBY3Rpb249cm4saChzbixsKSxlKHNuLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzbn19KSxzbi5tc2dXaXRoQ29vcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9LGUob24ucHJvdG90eXBlLHtwcm9jZXNzSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXt9LGlzRG9uZTpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb259fSksZShhbi5wcm90b3R5cGUse2dldEludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb259LHNldENoZWNrRW5kU2VnbWVudHNPbmx5OmZ1bmN0aW9uKHQpe3RoaXMuaXNDaGVja0VuZFNlZ21lbnRzT25seT10fSxnZXRJbnRlcnNlY3Rpb25TZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludFNlZ21lbnRzfSxjb3VudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyc2VjdGlvbkNvdW50fSxnZXRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uc30sc2V0RmluZEFsbEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCl7dGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz10fSxzZXRLZWVwSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0KXt0aGlzLmtlZXBJbnRlcnNlY3Rpb25zPXR9LHByb2Nlc3NJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKCF0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zJiZ0aGlzLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiBudWxsO2lmKHQ9PT1uJiZlPT09aSlyZXR1cm4gbnVsbDtpZih0aGlzLmlzQ2hlY2tFbmRTZWdtZW50c09ubHkpe3ZhciByPXRoaXMuaXNFbmRTZWdtZW50KHQsZSl8fHRoaXMuaXNFbmRTZWdtZW50KG4saSk7aWYoIXIpcmV0dXJuIG51bGx9dmFyIHM9dC5nZXRDb29yZGluYXRlcygpW2VdLG89dC5nZXRDb29yZGluYXRlcygpW2UrMV0sYT1uLmdldENvb3JkaW5hdGVzKClbaV0sdT1uLmdldENvb3JkaW5hdGVzKClbaSsxXTt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocyxvLGEsdSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLmludFNlZ21lbnRzPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuaW50U2VnbWVudHNbMF09cyx0aGlzLmludFNlZ21lbnRzWzFdPW8sdGhpcy5pbnRTZWdtZW50c1syXT1hLHRoaXMuaW50U2VnbWVudHNbM109dSx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uPXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApLHRoaXMua2VlcEludGVyc2VjdGlvbnMmJnRoaXMuaW50ZXJzZWN0aW9ucy5hZGQodGhpcy5pbnRlcmlvckludGVyc2VjdGlvbiksdGhpcy5pbnRlcnNlY3Rpb25Db3VudCsrKX0saXNFbmRTZWdtZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIDA9PT1lPyEwOmU+PXQuc2l6ZSgpLTJ9LGhhc0ludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5pbnRlcmlvckludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmluZEFsbEludGVyc2VjdGlvbnM/ITE6bnVsbCE9PXRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb259LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29uXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYW59fSksYW4uY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgYW4odCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGV9LGFuLmNyZWF0ZUFueUludGVyc2VjdGlvbkZpbmRlcj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGFuKHQpfSxhbi5jcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBhbih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX0sZSh1bi5wcm90b3R5cGUse2V4ZWN1dGU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuc2VnSW50P251bGw6dm9pZCB0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9LGdldEludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbnQuZ2V0SW50ZXJzZWN0aW9ucygpfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0ZSgpLHRoaXMuX2lzVmFsaWR9LHNldEZpbmRBbGxJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQpe3RoaXMuZmluZEFsbEludGVyc2VjdGlvbnM9dH0sY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXt0aGlzLl9pc1ZhbGlkPSEwLHRoaXMuc2VnSW50PW5ldyBhbih0aGlzLmxpKSx0aGlzLnNlZ0ludC5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zKTt2YXIgdD1uZXcgbm47cmV0dXJuIHQuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuc2VnSW50KSx0LmNvbXB1dGVOb2Rlcyh0aGlzLnNlZ1N0cmluZ3MpLHRoaXMuc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpPyh0aGlzLl9pc1ZhbGlkPSExLG51bGwpOnZvaWQgMH0sY2hlY2tWYWxpZDpmdW5jdGlvbigpe2lmKHRoaXMuZXhlY3V0ZSgpLCF0aGlzLl9pc1ZhbGlkKXRocm93IG5ldyBzbih0aGlzLmdldEVycm9yTWVzc2FnZSgpLHRoaXMuc2VnSW50LmdldEludGVyaW9ySW50ZXJzZWN0aW9uKCkpfSxnZXRFcnJvck1lc3NhZ2U6ZnVuY3Rpb24oKXtpZih0aGlzLl9pc1ZhbGlkKXJldHVyblwibm8gaW50ZXJzZWN0aW9ucyBmb3VuZFwiO3ZhciB0PXRoaXMuc2VnSW50LmdldEludGVyc2VjdGlvblNlZ21lbnRzKCk7cmV0dXJuXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGJldHdlZW4gXCIrc2UudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSkrXCIgYW5kIFwiK3NlLnRvTGluZVN0cmluZyh0WzJdLHRbM10pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB1bn19KSx1bi5jb21wdXRlSW50ZXJzZWN0aW9ucz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgdW4odCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuaXNWYWxpZCgpLGUuZ2V0SW50ZXJzZWN0aW9ucygpfSxlKGxuLnByb3RvdHlwZSx7Y2hlY2tWYWxpZDpmdW5jdGlvbigpe3RoaXMubnYuY2hlY2tWYWxpZCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsbn19KSxsbi50b1NlZ21lbnRTdHJpbmdzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuYWRkKG5ldyBPZShpLmdldENvb3JkaW5hdGVzKCksaSkpfXJldHVybiBlfSxsbi5jaGVja1ZhbGlkPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBsbih0KTtlLmNoZWNrVmFsaWQoKX0sZShobi5wcm90b3R5cGUse21hcDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10aGlzLm1hcE9wLm1hcCh0LmdldEdlb21ldHJ5TihuKSk7aS5pc0VtcHR5KCl8fGUuYWRkKGkpfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KGUpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaG59fSksaG4ubWFwPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGhuKGUpO3JldHVybiBuLm1hcCh0KX0sZShjbi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNufX0pLGNuLm9wcG9zaXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09Y24uTEVGVD9jbi5SSUdIVDp0PT09Y24uUklHSFQ/Y24uTEVGVDp0fSxjbi5PTj0wLGNuLkxFRlQ9MSxjbi5SSUdIVD0yLGUoZm4ucHJvdG90eXBlLHtzZXRBbGxMb2NhdGlvbnM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10fSxpc051bGw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdIT09TC5OT05FKXJldHVybiExO3JldHVybiEwfSxzZXRBbGxMb2NhdGlvbnNJZk51bGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PUwuTk9ORSYmKHRoaXMubG9jYXRpb25bZV09dCl9LGlzTGluZTpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5sb2NhdGlvbi5sZW5ndGh9LG1lcmdlOmZ1bmN0aW9uKHQpe2lmKHQubG9jYXRpb24ubGVuZ3RoPnRoaXMubG9jYXRpb24ubGVuZ3RoKXt2YXIgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtlW2NuLk9OXT10aGlzLmxvY2F0aW9uW2NuLk9OXSxlW2NuLkxFRlRdPUwuTk9ORSxlW2NuLlJJR0hUXT1MLk5PTkUsdGhpcy5sb2NhdGlvbj1lfWZvcih2YXIgbj0wO248dGhpcy5sb2NhdGlvbi5sZW5ndGg7bisrKXRoaXMubG9jYXRpb25bbl09PT1MLk5PTkUmJm48dC5sb2NhdGlvbi5sZW5ndGgmJih0aGlzLmxvY2F0aW9uW25dPXQubG9jYXRpb25bbl0pfSxnZXRMb2NhdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb2NhdGlvbn0sZmxpcDpmdW5jdGlvbigpe2lmKHRoaXMubG9jYXRpb24ubGVuZ3RoPD0xKXJldHVybiBudWxsO3ZhciB0PXRoaXMubG9jYXRpb25bY24uTEVGVF07dGhpcy5sb2NhdGlvbltjbi5MRUZUXT10aGlzLmxvY2F0aW9uW2NuLlJJR0hUXSx0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXT10fSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChMLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltjbi5MRUZUXSkpLHQuYXBwZW5kKEwudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2NuLk9OXSkpLHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKEwudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXSkpLHQudG9TdHJpbmcoKX0sc2V0TG9jYXRpb25zOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLmxvY2F0aW9uW2NuLk9OXT10LHRoaXMubG9jYXRpb25bY24uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXT1ufSxnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8dGhpcy5sb2NhdGlvbi5sZW5ndGg/dGhpcy5sb2NhdGlvblt0XTpMLk5PTkV9LGlzQXJlYTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xfSxpc0FueU51bGw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdPT09TC5OT05FKXJldHVybiEwO3JldHVybiExfSxzZXRMb2NhdGlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRMb2NhdGlvbihjbi5PTix0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5sb2NhdGlvbltlXT1ufX0saW5pdDpmdW5jdGlvbih0KXt0aGlzLmxvY2F0aW9uPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuc2V0QWxsTG9jYXRpb25zKEwuTk9ORSl9LGlzRXF1YWxPblNpZGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5sb2NhdGlvbltlXT09PXQubG9jYXRpb25bZV19LGFsbFBvc2l0aW9uc0VxdWFsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKWlmKHRoaXMubG9jYXRpb25bZV0hPT10KXJldHVybiExO3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmbn19KSxlKGduLnByb3RvdHlwZSx7Z2V0R2VvbWV0cnlDb3VudDpmdW5jdGlvbigpe3ZhciB0PTA7cmV0dXJuIHRoaXMuZWx0WzBdLmlzTnVsbCgpfHx0KyssdGhpcy5lbHRbMV0uaXNOdWxsKCl8fHQrKyx0fSxzZXRBbGxMb2NhdGlvbnM6ZnVuY3Rpb24odCxlKXt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnMoZSl9LGlzTnVsbDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNOdWxsKCl9LHNldEFsbExvY2F0aW9uc0lmTnVsbDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0KSx0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFtlXS5zZXRBbGxMb2NhdGlvbnNJZk51bGwobil9fSxpc0xpbmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTGluZSgpfSxtZXJnZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDsyPmU7ZSsrKW51bGw9PT10aGlzLmVsdFtlXSYmbnVsbCE9PXQuZWx0W2VdP3RoaXMuZWx0W2VdPW5ldyBmbih0LmVsdFtlXSk6dGhpcy5lbHRbZV0ubWVyZ2UodC5lbHRbZV0pfSxmbGlwOmZ1bmN0aW9uKCl7dGhpcy5lbHRbMF0uZmxpcCgpLHRoaXMuZWx0WzFdLmZsaXAoKX0sZ2V0TG9jYXRpb246ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoY24uT04pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuZWx0W2VdLmdldChuKX19LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7cmV0dXJuIG51bGwhPT10aGlzLmVsdFswXSYmKHQuYXBwZW5kKFwiQTpcIiksdC5hcHBlbmQodGhpcy5lbHRbMF0udG9TdHJpbmcoKSkpLG51bGwhPT10aGlzLmVsdFsxXSYmKHQuYXBwZW5kKFwiIEI6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzFdLnRvU3RyaW5nKCkpKSx0LnRvU3RyaW5nKCl9LGlzQXJlYTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmVsdFswXS5pc0FyZWEoKXx8dGhpcy5lbHRbMV0uaXNBcmVhKCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBcmVhKCl9fSxpc0FueU51bGw6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzQW55TnVsbCgpfSxzZXRMb2NhdGlvbjpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oY24uT04sZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuZWx0W25dLnNldExvY2F0aW9uKGkscil9fSxpc0VxdWFsT25TaWRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZWx0WzBdLmlzRXF1YWxPblNpZGUodC5lbHRbMF0sZSkmJnRoaXMuZWx0WzFdLmlzRXF1YWxPblNpZGUodC5lbHRbMV0sZSl9LGFsbFBvc2l0aW9uc0VxdWFsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZWx0W3RdLmFsbFBvc2l0aW9uc0VxdWFsKGUpfSx0b0xpbmU6ZnVuY3Rpb24odCl7dGhpcy5lbHRbdF0uaXNBcmVhKCkmJih0aGlzLmVsdFt0XT1uZXcgZm4odGhpcy5lbHRbdF0ubG9jYXRpb25bMF0pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ259fSksZ24udG9MaW5lTGFiZWw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBnbihMLk5PTkUpLG49MDsyPm47bisrKWUuc2V0TG9jYXRpb24obix0LmdldExvY2F0aW9uKG4pKTtyZXR1cm4gZX0sZShkbi5wcm90b3R5cGUse2NvbXB1dGVSaW5nOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucmluZylyZXR1cm4gbnVsbDtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMucHRzLnNpemUoKSkuZmlsbChudWxsKSxlPTA7ZTx0aGlzLnB0cy5zaXplKCk7ZSsrKXRbZV09dGhpcy5wdHMuZ2V0KGUpO3RoaXMucmluZz10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpLHRoaXMuX2lzSG9sZT1oZS5pc0NDVyh0aGlzLnJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSl9LGlzSXNvbGF0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfSxjb21wdXRlUG9pbnRzOmZ1bmN0aW9uKHQpe3RoaXMuc3RhcnREZT10O3ZhciBlPXQsbj0hMDtkb3tpZihudWxsPT09ZSl0aHJvdyBuZXcgc24oXCJGb3VuZCBudWxsIERpcmVjdGVkRWRnZVwiKTtpZihlLmdldEVkZ2VSaW5nKCk9PT10aGlzKXRocm93IG5ldyBzbihcIkRpcmVjdGVkIEVkZ2UgdmlzaXRlZCB0d2ljZSBkdXJpbmcgcmluZy1idWlsZGluZyBhdCBcIitlLmdldENvb3JkaW5hdGUoKSk7dGhpcy5lZGdlcy5hZGQoZSk7dmFyIGk9ZS5nZXRMYWJlbCgpO2YuaXNUcnVlKGkuaXNBcmVhKCkpLHRoaXMubWVyZ2VMYWJlbChpKSx0aGlzLmFkZFBvaW50cyhlLmdldEVkZ2UoKSxlLmlzRm9yd2FyZCgpLG4pLG49ITEsdGhpcy5zZXRFZGdlUmluZyhlLHRoaXMpLGU9dGhpcy5nZXROZXh0KGUpfXdoaWxlKGUhPT10aGlzLnN0YXJ0RGUpfSxnZXRMaW5lYXJSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmluZ30sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wdHMuZ2V0KHQpfSxjb21wdXRlTWF4Tm9kZURlZ3JlZTpmdW5jdGlvbigpe3RoaXMubWF4Tm9kZURlZ3JlZT0wO3ZhciB0PXRoaXMuc3RhcnREZTtkb3t2YXIgZT10LmdldE5vZGUoKSxuPWUuZ2V0RWRnZXMoKS5nZXRPdXRnb2luZ0RlZ3JlZSh0aGlzKTtuPnRoaXMubWF4Tm9kZURlZ3JlZSYmKHRoaXMubWF4Tm9kZURlZ3JlZT1uKSx0PXRoaXMuZ2V0TmV4dCh0KX13aGlsZSh0IT09dGhpcy5zdGFydERlKTt0aGlzLm1heE5vZGVEZWdyZWUqPTJ9LGFkZFBvaW50czpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRDb29yZGluYXRlcygpO2lmKGUpe3ZhciByPTE7biYmKHI9MCk7Zm9yKHZhciBzPXI7czxpLmxlbmd0aDtzKyspdGhpcy5wdHMuYWRkKGlbc10pfWVsc2V7dmFyIHI9aS5sZW5ndGgtMjtuJiYocj1pLmxlbmd0aC0xKTtmb3IodmFyIHM9cjtzPj0wO3MtLSl0aGlzLnB0cy5hZGQoaVtzXSl9fSxpc0hvbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNIb2xlfSxzZXRJblJlc3VsdDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3RhcnREZTtkbyB0LmdldEVkZ2UoKS5zZXRJblJlc3VsdCghMCksdD10LmdldE5leHQoKTt3aGlsZSh0IT09dGhpcy5zdGFydERlKX0sY29udGFpbnNQb2ludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldExpbmVhclJpbmcoKSxuPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCFuLmNvbnRhaW5zKHQpKXJldHVybiExO2lmKCFoZS5pc1BvaW50SW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKSlyZXR1cm4hMTtmb3IodmFyIGk9dGhpcy5ob2xlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYoci5jb250YWluc1BvaW50KHQpKXJldHVybiExfXJldHVybiEwfSxhZGRIb2xlOmZ1bmN0aW9uKHQpe3RoaXMuaG9sZXMuYWRkKHQpfSxpc1NoZWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnNoZWxsfSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzfSxnZXRNYXhOb2RlRGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4Tm9kZURlZ3JlZTwwJiZ0aGlzLmNvbXB1dGVNYXhOb2RlRGVncmVlKCksdGhpcy5tYXhOb2RlRGVncmVlfSxnZXRTaGVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsfSxtZXJnZUxhYmVsOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodCwwKSx0aGlzLm1lcmdlTGFiZWwodCwxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1lLmdldExvY2F0aW9uKG4sY24uUklHSFQpO2lmKGk9PT1MLk5PTkUpcmV0dXJuIG51bGw7aWYodGhpcy5sYWJlbC5nZXRMb2NhdGlvbihuKT09PUwuTk9ORSlyZXR1cm4gdGhpcy5sYWJlbC5zZXRMb2NhdGlvbihuLGkpLG51bGx9fSxzZXRTaGVsbDpmdW5jdGlvbih0KXt0aGlzLnNoZWxsPXQsbnVsbCE9PXQmJnQuYWRkSG9sZSh0aGlzKX0sdG9Qb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodGhpcy5ob2xlcy5zaXplKCkpLmZpbGwobnVsbCksbj0wO248dGhpcy5ob2xlcy5zaXplKCk7bisrKWVbbl09dGhpcy5ob2xlcy5nZXQobikuZ2V0TGluZWFyUmluZygpO3ZhciBpPXQuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSxlKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZG59fSksaChwbixkbiksZShwbi5wcm90b3R5cGUse3NldEVkZ2VSaW5nOmZ1bmN0aW9uKHQsZSl7dC5zZXRNaW5FZGdlUmluZyhlKX0sZ2V0TmV4dDpmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXROZXh0TWluKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHBufX0pLGgodm4sZG4pLGUodm4ucHJvdG90eXBlLHtidWlsZE1pbmltYWxSaW5nczpmdW5jdGlvbigpe3ZhciB0PW5ldyBJLGU9dGhpcy5zdGFydERlO2Rve2lmKG51bGw9PT1lLmdldE1pbkVkZ2VSaW5nKCkpe3ZhciBuPW5ldyBwbihlLHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTt0LmFkZChuKX1lPWUuZ2V0TmV4dCgpfXdoaWxlKGUhPT10aGlzLnN0YXJ0RGUpO3JldHVybiB0fSxzZXRFZGdlUmluZzpmdW5jdGlvbih0LGUpe3Quc2V0RWRnZVJpbmcoZSl9LGxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5nczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3RhcnREZTtkb3t2YXIgZT10LmdldE5vZGUoKTtlLmdldEVkZ2VzKCkubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHRoaXMpLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuc3RhcnREZSl9LGdldE5leHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0TmV4dCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2bn19KSxlKG1uLnByb3RvdHlwZSx7c2V0VmlzaXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH0sc2V0SW5SZXN1bHQ6ZnVuY3Rpb24odCl7dGhpcy5faXNJblJlc3VsdD10fSxpc0NvdmVyZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkfSxpc0NvdmVyZWRTZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkU2V0fSxzZXRMYWJlbDpmdW5jdGlvbih0KXt0aGlzLmxhYmVsPXR9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LHNldENvdmVyZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNDb3ZlcmVkPXQsdGhpcy5faXNDb3ZlcmVkU2V0PSEwfSx1cGRhdGVJTTpmdW5jdGlvbih0KXtmLmlzVHJ1ZSh0aGlzLmxhYmVsLmdldEdlb21ldHJ5Q291bnQoKT49MixcImZvdW5kIHBhcnRpYWwgbGFiZWxcIiksdGhpcy5jb21wdXRlSU0odCl9LGlzSW5SZXN1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH0saXNWaXNpdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbW59fSksaCh5bixtbiksZSh5bi5wcm90b3R5cGUse2lzSW5jaWRlbnRFZGdlSW5SZXN1bHQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2lmKGUuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSlyZXR1cm4hMH1yZXR1cm4hMX0saXNJc29sYXRlZDpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZH0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwibm9kZSBcIit0aGlzLmNvb3JkK1wiIGxibDogXCIrdGhpcy5sYWJlbCl9LGNvbXB1dGVJTTpmdW5jdGlvbih0KXt9LGNvbXB1dGVNZXJnZWRMb2NhdGlvbjpmdW5jdGlvbih0LGUpe3ZhciBuPUwuTk9ORTtpZihuPXRoaXMubGFiZWwuZ2V0TG9jYXRpb24oZSksIXQuaXNOdWxsKGUpKXt2YXIgaT10LmdldExvY2F0aW9uKGUpO24hPT1MLkJPVU5EQVJZJiYobj1pKX1yZXR1cm4gbn0sc2V0TGFiZWw6ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbW4ucHJvdG90eXBlLnNldExhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMubGFiZWw/dGhpcy5sYWJlbD1uZXcgZ24odCxlKTp0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LG1lcmdlTGFiZWw6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHluKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQubGFiZWwpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnbilmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49MDsyPm47bisrKXt2YXIgaT10aGlzLmNvbXB1dGVNZXJnZWRMb2NhdGlvbihlLG4pLHI9dGhpcy5sYWJlbC5nZXRMb2NhdGlvbihuKTtyPT09TC5OT05FJiZ0aGlzLmxhYmVsLnNldExvY2F0aW9uKG4saSl9fSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5lZGdlcy5pbnNlcnQodCksdC5zZXROb2RlKHRoaXMpfSxzZXRMYWJlbEJvdW5kYXJ5OmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10aGlzLmxhYmVsKXJldHVybiBudWxsO3ZhciBlPUwuTk9ORTtudWxsIT09dGhpcy5sYWJlbCYmKGU9dGhpcy5sYWJlbC5nZXRMb2NhdGlvbih0KSk7dmFyIG49bnVsbDtzd2l0Y2goZSl7Y2FzZSBMLkJPVU5EQVJZOm49TC5JTlRFUklPUjticmVhaztjYXNlIEwuSU5URVJJT1I6bj1MLkJPVU5EQVJZO2JyZWFrO2RlZmF1bHQ6bj1MLkJPVU5EQVJZfXRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geW59fSksZSh4bi5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9LGFkZE5vZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMubm9kZU1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1lJiYoZT10aGlzLm5vZGVGYWN0LmNyZWF0ZU5vZGUodCksdGhpcy5ub2RlTWFwLnB1dCh0LGUpKSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeW4pe3ZhciBuPWFyZ3VtZW50c1swXSxlPXRoaXMubm9kZU1hcC5nZXQobi5nZXRDb29yZGluYXRlKCkpO3JldHVybiBudWxsPT09ZT8odGhpcy5ub2RlTWFwLnB1dChuLmdldENvb3JkaW5hdGUoKSxuKSxuKTooZS5tZXJnZUxhYmVsKG4pLGUpfX0scHJpbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0sdmFsdWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX0sZ2V0Qm91bmRhcnlOb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk9PT1MLkJPVU5EQVJZJiZlLmFkZChpKX1yZXR1cm4gZX0sYWRkOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZSgpLG49dGhpcy5hZGROb2RlKGUpO24uYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4bn19KSxlKEVuLnByb3RvdHlwZSx7Y29tcGFyZURpcmVjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5keD09PXQuZHgmJnRoaXMuZHk9PT10LmR5PzA6dGhpcy5xdWFkcmFudD50LnF1YWRyYW50PzE6dGhpcy5xdWFkcmFudDx0LnF1YWRyYW50Py0xOmhlLmNvbXB1dGVPcmllbnRhdGlvbih0LnAwLHQucDEsdGhpcy5wMSl9LGdldER5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMH0sc2V0Tm9kZTpmdW5jdGlvbih0KXt0aGlzLm5vZGU9dH0scHJpbnQ6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5hdGFuMih0aGlzLmR5LHRoaXMuZHgpLG49dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxpPW4ubGFzdEluZGV4T2YoXCIuXCIpLHI9bi5zdWJzdHJpbmcoaSsxKTt0LnByaW50KFwiICBcIityK1wiOiBcIit0aGlzLnAwK1wiIC0gXCIrdGhpcy5wMStcIiBcIit0aGlzLnF1YWRyYW50K1wiOlwiK2UrXCIgICBcIit0aGlzLmxhYmVsKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX0sZ2V0RGlyZWN0ZWRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDF9LGdldER4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHh9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlfSxnZXRRdWFkcmFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnF1YWRyYW50fSxnZXROb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1NYXRoLmF0YW4yKHRoaXMuZHksdGhpcy5keCksZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIiksaT1lLnN1YnN0cmluZyhuKzEpO3JldHVyblwiICBcIitpK1wiOiBcIit0aGlzLnAwK1wiIC0gXCIrdGhpcy5wMStcIiBcIit0aGlzLnF1YWRyYW50K1wiOlwiK3QrXCIgICBcIit0aGlzLmxhYmVsfSxjb21wdXRlTGFiZWw6ZnVuY3Rpb24odCl7fSxpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5wMD10LHRoaXMucDE9ZSx0aGlzLmR4PWUueC10LngsdGhpcy5keT1lLnktdC55LHRoaXMucXVhZHJhbnQ9SmUucXVhZHJhbnQodGhpcy5keCx0aGlzLmR5KSxmLmlzVHJ1ZSghKDA9PT10aGlzLmR4JiYwPT09dGhpcy5keSksXCJFZGdlRW5kIHdpdGggaWRlbnRpY2FsIGVuZHBvaW50cyBmb3VuZFwiKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVufX0pLGgoSW4sRW4pLGUoSW4ucHJvdG90eXBlLHtnZXROZXh0TWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dE1pbn0sZ2V0RGVwdGg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGVwdGhbdF19LHNldFZpc2l0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNWaXNpdGVkPXR9LGNvbXB1dGVEaXJlY3RlZExhYmVsOmZ1bmN0aW9uKCl7dGhpcy5sYWJlbD1uZXcgZ24odGhpcy5lZGdlLmdldExhYmVsKCkpLHRoaXMuX2lzRm9yd2FyZHx8dGhpcy5sYWJlbC5mbGlwKCl9LGdldE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0fSxzZXREZXB0aDpmdW5jdGlvbih0LGUpe2lmKC05OTkhPT10aGlzLmRlcHRoW3RdJiZ0aGlzLmRlcHRoW3RdIT09ZSl0aHJvdyBuZXcgc24oXCJhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3RoaXMuZGVwdGhbdF09ZX0saXNJbnRlcmlvckFyZWFFZGdlOmZ1bmN0aW9uIEJvKCl7Zm9yKHZhciBCbz0hMCx0PTA7Mj50O3QrKyl0aGlzLmxhYmVsLmlzQXJlYSh0KSYmdGhpcy5sYWJlbC5nZXRMb2NhdGlvbih0LGNuLkxFRlQpPT09TC5JTlRFUklPUiYmdGhpcy5sYWJlbC5nZXRMb2NhdGlvbih0LGNuLlJJR0hUKT09PUwuSU5URVJJT1J8fChCbz0hMSk7cmV0dXJuIEJvfSxzZXROZXh0TWluOmZ1bmN0aW9uKHQpe3RoaXMubmV4dE1pbj10fSxwcmludDpmdW5jdGlvbih0KXtFbi5wcm90b3R5cGUucHJpbnQuY2FsbCh0aGlzLHQpLHQucHJpbnQoXCIgXCIrdGhpcy5kZXB0aFtjbi5MRUZUXStcIi9cIit0aGlzLmRlcHRoW2NuLlJJR0hUXSksdC5wcmludChcIiAoXCIrdGhpcy5nZXREZXB0aERlbHRhKCkrXCIpXCIpLHRoaXMuX2lzSW5SZXN1bHQmJnQucHJpbnQoXCIgaW5SZXN1bHRcIil9LHNldE1pbkVkZ2VSaW5nOmZ1bmN0aW9uKHQpe3RoaXMubWluRWRnZVJpbmc9dH0saXNMaW5lRWRnZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGFiZWwuaXNMaW5lKDApfHx0aGlzLmxhYmVsLmlzTGluZSgxKSxlPSF0aGlzLmxhYmVsLmlzQXJlYSgwKXx8dGhpcy5sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgwLEwuRVhURVJJT1IpLG49IXRoaXMubGFiZWwuaXNBcmVhKDEpfHx0aGlzLmxhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDEsTC5FWFRFUklPUik7cmV0dXJuIHQmJmUmJm59LHNldEVkZ2VSaW5nOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZVJpbmc9dH0sZ2V0TWluRWRnZVJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW5FZGdlUmluZ30sZ2V0RGVwdGhEZWx0YTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWRnZS5nZXREZXB0aERlbHRhKCk7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZHx8KHQ9LXQpLHR9LHNldEluUmVzdWx0OmZ1bmN0aW9uKHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH0sZ2V0U3ltOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltfSxpc0ZvcndhcmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZX0scHJpbnRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMucHJpbnQodCksdC5wcmludChcIiBcIiksdGhpcy5faXNGb3J3YXJkP3RoaXMuZWRnZS5wcmludCh0KTp0aGlzLmVkZ2UucHJpbnRSZXZlcnNlKHQpfSxzZXRTeW06ZnVuY3Rpb24odCl7dGhpcy5zeW09dH0sc2V0VmlzaXRlZEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5zZXRWaXNpdGVkKHQpLHRoaXMuc3ltLnNldFZpc2l0ZWQodCl9LHNldEVkZ2VEZXB0aHM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEVkZ2UoKS5nZXREZXB0aERlbHRhKCk7dGhpcy5faXNGb3J3YXJkfHwobj0tbik7dmFyIGk9MTt0PT09Y24uTEVGVCYmKGk9LTEpO3ZhciByPWNuLm9wcG9zaXRlKHQpLHM9bippLG89ZStzO3RoaXMuc2V0RGVwdGgodCxlKSx0aGlzLnNldERlcHRoKHIsbyl9LGdldEVkZ2VSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZVJpbmd9LGlzSW5SZXN1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH0sc2V0TmV4dDpmdW5jdGlvbih0KXt0aGlzLm5leHQ9dH0saXNWaXNpdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSW59fSksSW4uZGVwdGhGYWN0b3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PUwuRVhURVJJT1ImJmU9PT1MLklOVEVSSU9SPzE6dD09PUwuSU5URVJJT1ImJmU9PT1MLkVYVEVSSU9SPy0xOjB9LGUoTm4ucHJvdG90eXBlLHtjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgeW4odCxudWxsKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTm59fSksZShDbi5wcm90b3R5cGUse3ByaW50RWRnZXM6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiRWRnZXM6XCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlcy5zaXplKCk7ZSsrKXt0LnByaW50bG4oXCJlZGdlIFwiK2UrXCI6XCIpO3ZhciBuPXRoaXMuZWRnZXMuZ2V0KGUpO24ucHJpbnQodCksbi5laUxpc3QucHJpbnQodCl9fSxmaW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVzLmZpbmQodCl9LGFkZE5vZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHluKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubm9kZXMuYWRkTm9kZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5ub2Rlcy5hZGROb2RlKGUpfX0sZ2V0Tm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXMuaXRlcmF0b3IoKX0sbGlua1Jlc3VsdERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fSxkZWJ1Z1ByaW50bG46ZnVuY3Rpb24odCl7QS5vdXQucHJpbnRsbih0KX0saXNCb3VuZGFyeU5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm5vZGVzLmZpbmQoZSk7aWYobnVsbD09PW4pcmV0dXJuITE7dmFyIGk9bi5nZXRMYWJlbCgpO3JldHVybiBudWxsIT09aSYmaS5nZXRMb2NhdGlvbih0KT09PUwuQk9VTkRBUll9LGxpbmtBbGxEaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5saW5rQWxsRGlyZWN0ZWRFZGdlcygpfX0sbWF0Y2hJblNhbWVEaXJlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIHQuZXF1YWxzKG4pP2hlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsaSk9PT1oZS5DT0xMSU5FQVImJkplLnF1YWRyYW50KHQsZSk9PT1KZS5xdWFkcmFudChuLGkpOiExfSxnZXRFZGdlRW5kczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VFbmRMaXN0fSxkZWJ1Z1ByaW50OmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50KHQpfSxnZXRFZGdlSXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlcy5pdGVyYXRvcigpfSxmaW5kRWRnZUluU2FtZURpcmVjdGlvbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5lZGdlcy5zaXplKCk7bisrKXt2YXIgaT10aGlzLmVkZ2VzLmdldChuKSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxyWzBdLHJbMV0pKXJldHVybiBpO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLHJbci5sZW5ndGgtMV0scltyLmxlbmd0aC0yXSkpcmV0dXJuIGl9cmV0dXJuIG51bGx9LGluc2VydEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5lZGdlcy5hZGQodCl9LGZpbmRFZGdlRW5kOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKG4uZ2V0RWRnZSgpPT09dClyZXR1cm4gbn1yZXR1cm4gbnVsbH0sYWRkRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuZWRnZXMuYWRkKG4pO3ZhciBpPW5ldyBJbihuLCEwKSxyPW5ldyBJbihuLCExKTtpLnNldFN5bShyKSxyLnNldFN5bShpKSx0aGlzLmFkZChpKSx0aGlzLmFkZChyKX19LGFkZDpmdW5jdGlvbih0KXt0aGlzLm5vZGVzLmFkZCh0KSx0aGlzLmVkZ2VFbmRMaXN0LmFkZCh0KX0sZ2V0Tm9kZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlcy52YWx1ZXMoKX0sZmluZEVkZ2U6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHRoaXMuZWRnZXMuc2l6ZSgpO24rKyl7dmFyIGk9dGhpcy5lZGdlcy5nZXQobikscj1pLmdldENvb3JkaW5hdGVzKCk7aWYodC5lcXVhbHMoclswXSkmJmUuZXF1YWxzKHJbMV0pKXJldHVybiBpfXJldHVybiBudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDbn19KSxDbi5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fSxlKFNuLnByb3RvdHlwZSx7c29ydFNoZWxsc0FuZEhvbGVzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc0hvbGUoKT9uLmFkZChyKTplLmFkZChyKX19LGNvbXB1dGVQb2x5Z29uczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkudG9Qb2x5Z29uKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZChyKX1yZXR1cm4gZX0scGxhY2VGcmVlSG9sZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYobnVsbD09PWkuZ2V0U2hlbGwoKSl7dmFyIHI9dGhpcy5maW5kRWRnZVJpbmdDb250YWluaW5nKGksdCk7aWYobnVsbD09PXIpdGhyb3cgbmV3IHNuKFwidW5hYmxlIHRvIGFzc2lnbiBob2xlIHRvIGEgc2hlbGxcIixpLmdldENvb3JkaW5hdGUoMCkpO2kuc2V0U2hlbGwocil9fX0sYnVpbGRNaW5pbWFsRWRnZVJpbmdzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bmV3IEkscj10Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZihzLmdldE1heE5vZGVEZWdyZWUoKT4yKXtzLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO3ZhciBvPXMuYnVpbGRNaW5pbWFsUmluZ3MoKSxhPXRoaXMuZmluZFNoZWxsKG8pO251bGwhPT1hPyh0aGlzLnBsYWNlUG9seWdvbkhvbGVzKGEsbyksZS5hZGQoYSkpOm4uYWRkQWxsKG8pfWVsc2UgaS5hZGQocyl9cmV0dXJuIGl9LGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuc2hlbGxMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZihuLmNvbnRhaW5zUG9pbnQodCkpcmV0dXJuITB9cmV0dXJuITF9LGJ1aWxkTWF4aW1hbEVkZ2VSaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmlzSW5SZXN1bHQoKSYmaS5nZXRMYWJlbCgpLmlzQXJlYSgpJiZudWxsPT09aS5nZXRFZGdlUmluZygpKXt2YXIgcj1uZXcgdm4oaSx0aGlzLmdlb21ldHJ5RmFjdG9yeSk7ZS5hZGQociksci5zZXRJblJlc3VsdCgpfX1yZXR1cm4gZX0scGxhY2VQb2x5Z29uSG9sZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5pc0hvbGUoKSYmaS5zZXRTaGVsbCh0KX19LGdldFBvbHlnb25zOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb21wdXRlUG9seWdvbnModGhpcy5zaGVsbExpc3QpO3JldHVybiB0fSxmaW5kRWRnZVJpbmdDb250YWluaW5nOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0TGluZWFyUmluZygpLGk9bi5nZXRFbnZlbG9wZUludGVybmFsKCkscj1uLmdldENvb3JkaW5hdGVOKDApLHM9bnVsbCxvPW51bGwsYT1lLml0ZXJhdG9yKCk7YS5oYXNOZXh0KCk7KXt2YXIgdT1hLm5leHQoKSxsPXUuZ2V0TGluZWFyUmluZygpLGg9bC5nZXRFbnZlbG9wZUludGVybmFsKCk7bnVsbCE9PXMmJihvPXMuZ2V0TGluZWFyUmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7dmFyIGM9ITE7aC5jb250YWlucyhpKSYmaGUuaXNQb2ludEluUmluZyhyLGwuZ2V0Q29vcmRpbmF0ZXMoKSkmJihjPSEwKSxjJiYobnVsbD09PXN8fG8uY29udGFpbnMoaCkpJiYocz11KX1yZXR1cm4gc30sZmluZFNoZWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49bnVsbCxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuaXNIb2xlKCl8fChuPXIsZSsrKX1yZXR1cm4gZi5pc1RydWUoMT49ZSxcImZvdW5kIHR3byBzaGVsbHMgaW4gTWluaW1hbEVkZ2VSaW5nIGxpc3RcIiksbn0sYWRkOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0LmdldEVkZ2VFbmRzKCksdC5nZXROb2RlcygpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07Q24ubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMobik7dmFyIGk9dGhpcy5idWlsZE1heGltYWxFZGdlUmluZ3MoZSkscj1uZXcgSSxzPXRoaXMuYnVpbGRNaW5pbWFsRWRnZVJpbmdzKGksdGhpcy5zaGVsbExpc3Qscik7dGhpcy5zb3J0U2hlbGxzQW5kSG9sZXMocyx0aGlzLnNoZWxsTGlzdCxyKSx0aGlzLnBsYWNlRnJlZUhvbGVzKHRoaXMuc2hlbGxMaXN0LHIpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU259fSksZSh3bi5wcm90b3R5cGUse2NvbGxlY3RMaW5lczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuY29sbGVjdExpbmVFZGdlKG4sdCx0aGlzLmxpbmVFZGdlc0xpc3QpLHRoaXMuY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKG4sdCx0aGlzLmxpbmVFZGdlc0xpc3QpfX0sbGFiZWxJc29sYXRlZExpbmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5vcC5nZXRBcmdHZW9tZXRyeShlKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9LGJ1aWxkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCksdGhpcy5jb2xsZWN0TGluZXModCksdGhpcy5idWlsZExpbmVzKHQpLHRoaXMucmVzdWx0TGluZUxpc3R9LGNvbGxlY3RMaW5lRWRnZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRMYWJlbCgpLHI9dC5nZXRFZGdlKCk7dC5pc0xpbmVFZGdlKCkmJih0LmlzVmlzaXRlZCgpfHwhaWkuaXNSZXN1bHRPZk9wKGksZSl8fHIuaXNDb3ZlcmVkKCl8fChuLmFkZChyKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpfSxmaW5kQ292ZXJlZExpbmVFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm9wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl9Zm9yKHZhciBuPXRoaXMub3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0RWRnZSgpO2lmKGkuaXNMaW5lRWRnZSgpJiYhci5pc0NvdmVyZWRTZXQoKSl7dmFyIHM9dGhpcy5vcC5pc0NvdmVyZWRCeUEoaS5nZXRDb29yZGluYXRlKCkpO3Iuc2V0Q292ZXJlZChzKX19fSxsYWJlbElzb2xhdGVkTGluZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpO24uaXNJc29sYXRlZCgpJiYoaS5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTGluZShuLDApOnRoaXMubGFiZWxJc29sYXRlZExpbmUobiwxKSl9fSxidWlsZExpbmVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmxpbmVFZGdlc0xpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9KG4uZ2V0TGFiZWwoKSx0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4uZ2V0Q29vcmRpbmF0ZXMoKSkpO3RoaXMucmVzdWx0TGluZUxpc3QuYWRkKGkpLG4uc2V0SW5SZXN1bHQoITApfX0sY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldExhYmVsKCk7cmV0dXJuIHQuaXNMaW5lRWRnZSgpP251bGw6dC5pc1Zpc2l0ZWQoKT9udWxsOnQuaXNJbnRlcmlvckFyZWFFZGdlKCk/bnVsbDp0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCk/bnVsbDooZi5pc1RydWUoISh0LmlzSW5SZXN1bHQoKXx8dC5nZXRTeW0oKS5pc0luUmVzdWx0KCkpfHwhdC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKSx2b2lkKGlpLmlzUmVzdWx0T2ZPcChpLGUpJiZlPT09aWkuSU5URVJTRUNUSU9OJiYobi5hZGQodC5nZXRFZGdlKCkpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3bn19KSxlKExuLnByb3RvdHlwZSx7ZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKCF0aGlzLm9wLmlzQ292ZXJlZEJ5TEEoZSkpe3ZhciBuPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGUpO3RoaXMucmVzdWx0UG9pbnRMaXN0LmFkZChuKX19LGV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMub3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZighKG4uaXNJblJlc3VsdCgpfHxuLmlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKXx8MCE9PW4uZ2V0RWRnZXMoKS5nZXREZWdyZWUoKSYmdCE9PWlpLklOVEVSU0VDVElPTikpe3ZhciBpPW4uZ2V0TGFiZWwoKTtpaS5pc1Jlc3VsdE9mT3AoaSx0KSYmdGhpcy5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQobil9fX0sYnVpbGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2Rlcyh0KSx0aGlzLnJlc3VsdFBvaW50TGlzdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTG59fSksZShSbi5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJufX0pLGUoVG4ucHJvdG90eXBlLHtsb2NhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIFRuLmxvY2F0ZSh0LHRoaXMuZ2VvbSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1JuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVG59fSksVG4uaXNQb2ludEluUmluZz1mdW5jdGlvbih0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP2hlLmlzUG9pbnRJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOiExfSxUbi5jb250YWluc1BvaW50SW5Qb2x5Z29uPWZ1bmN0aW9uKHQsZSl7aWYoZS5pc0VtcHR5KCkpcmV0dXJuITE7dmFyIG49ZS5nZXRFeHRlcmlvclJpbmcoKTtpZighVG4uaXNQb2ludEluUmluZyh0LG4pKXJldHVybiExO2Zvcih2YXIgaT0wO2k8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtpKyspe3ZhciByPWUuZ2V0SW50ZXJpb3JSaW5nTihpKTtpZihUbi5pc1BvaW50SW5SaW5nKHQscikpcmV0dXJuITF9cmV0dXJuITB9LFRuLmNvbnRhaW5zUG9pbnQ9ZnVuY3Rpb24odCxlKXtpZihlIGluc3RhbmNlb2YgVHQpcmV0dXJuIFRuLmNvbnRhaW5zUG9pbnRJblBvbHlnb24odCxlKTtpZihlIGluc3RhbmNlb2YgZnQpZm9yKHZhciBuPW5ldyBSZShlKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkhPT1lJiZUbi5jb250YWluc1BvaW50KHQsaSkpcmV0dXJuITB9cmV0dXJuITF9LFRuLmxvY2F0ZT1mdW5jdGlvbih0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9MLkVYVEVSSU9SOlRuLmNvbnRhaW5zUG9pbnQodCxlKT9MLklOVEVSSU9SOkwuRVhURVJJT1J9LGUoUG4ucHJvdG90eXBlLHtnZXROZXh0Q1c6ZnVuY3Rpb24odCl7dGhpcy5nZXRFZGdlcygpO3ZhciBlPXRoaXMuZWRnZUxpc3QuaW5kZXhPZih0KSxuPWUtMTtyZXR1cm4gMD09PWUmJihuPXRoaXMuZWRnZUxpc3Quc2l6ZSgpLTEpLHRoaXMuZWRnZUxpc3QuZ2V0KG4pfSxwcm9wYWdhdGVTaWRlTGFiZWxzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1MLk5PTkUsbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKTtyLmlzQXJlYSh0KSYmci5nZXRMb2NhdGlvbih0LGNuLkxFRlQpIT09TC5OT05FJiYoZT1yLmdldExvY2F0aW9uKHQsY24uTEVGVCkpfWlmKGU9PT1MLk5PTkUpcmV0dXJuIG51bGw7Zm9yKHZhciBzPWUsbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKTtpZihyLmdldExvY2F0aW9uKHQsY24uT04pPT09TC5OT05FJiZyLnNldExvY2F0aW9uKHQsY24uT04scyksci5pc0FyZWEodCkpe3ZhciBvPXIuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSxhPXIuZ2V0TG9jYXRpb24odCxjbi5SSUdIVCk7aWYoYSE9PUwuTk9ORSl7aWYoYSE9PXMpdGhyb3cgbmV3IHNuKFwic2lkZSBsb2NhdGlvbiBjb25mbGljdFwiLGkuZ2V0Q29vcmRpbmF0ZSgpKTtvPT09TC5OT05FJiZmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZSAoYXQgXCIraS5nZXRDb29yZGluYXRlKCkrXCIpXCIpLHM9b31lbHNlIGYuaXNUcnVlKHIuZ2V0TG9jYXRpb24odCxjbi5MRUZUKT09PUwuTk9ORSxcImZvdW5kIHNpbmdsZSBudWxsIHNpZGVcIiksci5zZXRMb2NhdGlvbih0LGNuLlJJR0hULHMpLHIuc2V0TG9jYXRpb24odCxjbi5MRUZULHMpfX19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLml0ZXJhdG9yKCk7aWYoIXQuaGFzTmV4dCgpKXJldHVybiBudWxsO3ZhciBlPXQubmV4dCgpO3JldHVybiBlLmdldENvb3JkaW5hdGUoKX0scHJpbnQ6ZnVuY3Rpb24odCl7QS5vdXQucHJpbnRsbihcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KX19LGlzQXJlYUxhYmVsc0NvbnNpc3RlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModC5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMuY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCgwKTtcbn0sY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEVkZ2VzKCk7aWYoZS5zaXplKCk8PTApcmV0dXJuITA7dmFyIG49ZS5zaXplKCktMSxpPWUuZ2V0KG4pLmdldExhYmVsKCkscj1pLmdldExvY2F0aW9uKHQsY24uTEVGVCk7Zi5pc1RydWUociE9PUwuTk9ORSxcIkZvdW5kIHVubGFiZWxsZWQgYXJlYSBlZGdlXCIpO2Zvcih2YXIgcz1yLG89dGhpcy5pdGVyYXRvcigpO28uaGFzTmV4dCgpOyl7dmFyIGE9by5uZXh0KCksdT1hLmdldExhYmVsKCk7Zi5pc1RydWUodS5pc0FyZWEodCksXCJGb3VuZCBub24tYXJlYSBlZGdlXCIpO3ZhciBsPXUuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSxoPXUuZ2V0TG9jYXRpb24odCxjbi5SSUdIVCk7aWYobD09PWgpcmV0dXJuITE7aWYoaCE9PXMpcmV0dXJuITE7cz1sfXJldHVybiEwfSxmaW5kSW5kZXg6ZnVuY3Rpb24odCl7dGhpcy5pdGVyYXRvcigpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlTGlzdC5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmVkZ2VMaXN0LmdldChlKTtpZihuPT09dClyZXR1cm4gZX1yZXR1cm4tMX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFZGdlcygpLml0ZXJhdG9yKCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmVkZ2VMaXN0JiYodGhpcy5lZGdlTGlzdD1uZXcgSSh0aGlzLmVkZ2VNYXAudmFsdWVzKCkpKSx0aGlzLmVkZ2VMaXN0fSxnZXRMb2NhdGlvbjpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMucHRJbkFyZWFMb2NhdGlvblt0XT09PUwuTk9ORSYmKHRoaXMucHRJbkFyZWFMb2NhdGlvblt0XT1Ubi5sb2NhdGUoZSxuW3RdLmdldEdlb21ldHJ5KCkpKSx0aGlzLnB0SW5BcmVhTG9jYXRpb25bdF19LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7dC5hcHBlbmQoXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSksdC5hcHBlbmQoXCJcXG5cIik7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3QuYXBwZW5kKG4pLHQuYXBwZW5kKFwiXFxuXCIpfXJldHVybiB0LnRvU3RyaW5nKCl9LGNvbXB1dGVFZGdlRW5kTGFiZWxzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmNvbXB1dGVMYWJlbCh0KX19LGNvbXB1dGVMYWJlbGxpbmc6ZnVuY3Rpb24odCl7dGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0WzBdLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygxKTtmb3IodmFyIGU9WyExLCExXSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZm9yKHZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpLHM9MDsyPnM7cysrKXIuaXNMaW5lKHMpJiZyLmdldExvY2F0aW9uKHMpPT09TC5CT1VOREFSWSYmKGVbc109ITApO2Zvcih2YXIgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWZvcih2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKSxzPTA7Mj5zO3MrKylpZihyLmlzQW55TnVsbChzKSl7dmFyIG89TC5OT05FO2lmKGVbc10pbz1MLkVYVEVSSU9SO2Vsc2V7dmFyIGE9aS5nZXRDb29yZGluYXRlKCk7bz10aGlzLmdldExvY2F0aW9uKHMsYSx0KX1yLnNldEFsbExvY2F0aW9uc0lmTnVsbChzLG8pfX0sZ2V0RGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZU1hcC5zaXplKCl9LGluc2VydEVkZ2VFbmQ6ZnVuY3Rpb24odCxlKXt0aGlzLmVkZ2VNYXAucHV0KHQsZSksdGhpcy5lZGdlTGlzdD1udWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQbn19KSxoKGJuLFBuKSxlKGJuLnByb3RvdHlwZSx7bGlua1Jlc3VsdERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXt0aGlzLmdldFJlc3VsdEFyZWFFZGdlcygpO2Zvcih2YXIgdD1udWxsLGU9bnVsbCxuPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HLGk9MDtpPHRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKTtpKyspe3ZhciByPXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKSxzPXIuZ2V0U3ltKCk7aWYoci5nZXRMYWJlbCgpLmlzQXJlYSgpKXN3aXRjaChudWxsPT09dCYmci5pc0luUmVzdWx0KCkmJih0PXIpLG4pe2Nhc2UgdGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoIXMuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2U9cyxuPXRoaXMuTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuTElOS0lOR19UT19PVVRHT0lORzppZighci5pc0luUmVzdWx0KCkpY29udGludWU7ZS5zZXROZXh0KHIpLG49dGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkd9fWlmKG49PT10aGlzLkxJTktJTkdfVE9fT1VUR09JTkcpe2lmKG51bGw9PT10KXRocm93IG5ldyBzbihcIm5vIG91dGdvaW5nIGRpckVkZ2UgZm91bmRcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7Zi5pc1RydWUodC5pc0luUmVzdWx0KCksXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksZS5zZXROZXh0KHQpfX0saW5zZXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5pbnNlcnRFZGdlRW5kKGUsZSl9LGdldFJpZ2h0bW9zdEVkZ2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldEVkZ2VzKCksZT10LnNpemUoKTtpZigxPmUpcmV0dXJuIG51bGw7dmFyIG49dC5nZXQoMCk7aWYoMT09PWUpcmV0dXJuIG47dmFyIGk9dC5nZXQoZS0xKSxyPW4uZ2V0UXVhZHJhbnQoKSxzPWkuZ2V0UXVhZHJhbnQoKTtpZihKZS5pc05vcnRoZXJuKHIpJiZKZS5pc05vcnRoZXJuKHMpKXJldHVybiBuO2lmKCFKZS5pc05vcnRoZXJuKHIpJiYhSmUuaXNOb3J0aGVybihzKSlyZXR1cm4gaTtyZXR1cm4gMCE9PW4uZ2V0RHkoKT9uOjAhPT1pLmdldER5KCk/aTooZi5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHR3byBob3Jpem9udGFsIGVkZ2VzIGluY2lkZW50IG9uIG5vZGVcIiksbnVsbCl9LHByaW50OmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4oXCJEaXJlY3RlZEVkZ2VTdGFyOiBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3QucHJpbnQoXCJvdXQgXCIpLG4ucHJpbnQodCksdC5wcmludGxuKCksdC5wcmludChcImluIFwiKSxuLmdldFN5bSgpLnByaW50KHQpLHQucHJpbnRsbigpfX0sZ2V0UmVzdWx0QXJlYUVkZ2VzOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0KXJldHVybiB0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdDt0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdD1uZXcgSTtmb3IodmFyIHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7KGUuaXNJblJlc3VsdCgpfHxlLmdldFN5bSgpLmlzSW5SZXN1bHQoKSkmJnRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmFkZChlKX1yZXR1cm4gdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3R9LHVwZGF0ZUxhYmVsbGluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7aS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0LmdldExvY2F0aW9uKDApKSxpLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQuZ2V0TG9jYXRpb24oMSkpfX0sbGlua0FsbERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXt0aGlzLmdldEVkZ2VzKCk7Zm9yKHZhciB0PW51bGwsZT1udWxsLG49dGhpcy5lZGdlTGlzdC5zaXplKCktMTtuPj0wO24tLSl7dmFyIGk9dGhpcy5lZGdlTGlzdC5nZXQobikscj1pLmdldFN5bSgpO251bGw9PT1lJiYoZT1yKSxudWxsIT09dCYmci5zZXROZXh0KHQpLHQ9aX1lLnNldE5leHQodCl9LGNvbXB1dGVEZXB0aHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5maW5kSW5kZXgodCksbj0odC5nZXRMYWJlbCgpLHQuZ2V0RGVwdGgoY24uTEVGVCkpLGk9dC5nZXREZXB0aChjbi5SSUdIVCkscj10aGlzLmNvbXB1dGVEZXB0aHMoZSsxLHRoaXMuZWRnZUxpc3Quc2l6ZSgpLG4pLHM9dGhpcy5jb21wdXRlRGVwdGhzKDAsZSxyKTtpZihzIT09aSl0aHJvdyBuZXcgc24oXCJkZXB0aCBtaXNtYXRjaCBhdCBcIit0LmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXSxsPXUsaD1vO2E+aDtoKyspe3ZhciBjPXRoaXMuZWRnZUxpc3QuZ2V0KGgpO2MuZ2V0TGFiZWwoKTtjLnNldEVkZ2VEZXB0aHMoY24uUklHSFQsbCksbD1jLmdldERlcHRoKGNuLkxFRlQpfXJldHVybiBsfX0sbWVyZ2VTeW1MYWJlbHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7bi5tZXJnZShlLmdldFN5bSgpLmdldExhYmVsKCkpfX0sbGlua01pbmltYWxEaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49bnVsbCxpPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HLHI9dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpLTE7cj49MDtyLS0pe3ZhciBzPXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmdldChyKSxvPXMuZ2V0U3ltKCk7c3dpdGNoKG51bGw9PT1lJiZzLmdldEVkZ2VSaW5nKCk9PT10JiYoZT1zKSxpKXtjYXNlIHRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKG8uZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bj1vLGk9dGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HOmlmKHMuZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bi5zZXROZXh0TWluKHMpLGk9dGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkd9fWk9PT10aGlzLkxJTktJTkdfVE9fT1VUR09JTkcmJihmLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgZm9yIGZpcnN0IG91dGdvaW5nIGRpckVkZ2VcIiksZi5pc1RydWUoZS5nZXRFZGdlUmluZygpPT09dCxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxuLnNldE5leHRNaW4oZSkpfSxnZXRPdXRnb2luZ0RlZ3JlZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9MCxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uaXNJblJlc3VsdCgpJiZ0Kyt9cmV0dXJuIHR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0sdD0wLGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5nZXRFZGdlUmluZygpPT09aSYmdCsrfXJldHVybiB0fX0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sZmluZENvdmVyZWRMaW5lRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9TC5OT05FLGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldFN5bSgpO2lmKCFuLmlzTGluZUVkZ2UoKSl7aWYobi5pc0luUmVzdWx0KCkpe3Q9TC5JTlRFUklPUjticmVha31pZihpLmlzSW5SZXN1bHQoKSl7dD1MLkVYVEVSSU9SO2JyZWFrfX19aWYodD09PUwuTk9ORSlyZXR1cm4gbnVsbDtmb3IodmFyIHI9dCxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRTeW0oKTtuLmlzTGluZUVkZ2UoKT9uLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKHI9PT1MLklOVEVSSU9SKToobi5pc0luUmVzdWx0KCkmJihyPUwuRVhURVJJT1IpLGkuaXNJblJlc3VsdCgpJiYocj1MLklOVEVSSU9SKSl9fSxjb21wdXRlTGFiZWxsaW5nOmZ1bmN0aW9uKHQpe1BuLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nLmNhbGwodGhpcyx0KSx0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0RWRnZSgpLHI9aS5nZXRMYWJlbCgpLHM9MDsyPnM7cysrKXt2YXIgbz1yLmdldExvY2F0aW9uKHMpO28hPT1MLklOVEVSSU9SJiZvIT09TC5CT1VOREFSWXx8dGhpcy5sYWJlbC5zZXRMb2NhdGlvbihzLEwuSU5URVJJT1IpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYm59fSksaChPbixObiksZShPbi5wcm90b3R5cGUse2NyZWF0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB5bih0LG5ldyBibil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9ufX0pLGUoX24ucHJvdG90eXBlLHtjb21wdXRlSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUpe3RoaXMubWNlLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5jaGFpbkluZGV4LHQubWNlLHQuY2hhaW5JbmRleCxlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX259fSksZShNbi5wcm90b3R5cGUse2lzRGVsZXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXZlbnRUeXBlPT09TW4uREVMRVRFfSxzZXREZWxldGVFdmVudEluZGV4OmZ1bmN0aW9uKHQpe3RoaXMuZGVsZXRlRXZlbnRJbmRleD10fSxnZXRPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vYmp9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLnhWYWx1ZTxlLnhWYWx1ZT8tMTp0aGlzLnhWYWx1ZT5lLnhWYWx1ZT8xOnRoaXMuZXZlbnRUeXBlPGUuZXZlbnRUeXBlPy0xOnRoaXMuZXZlbnRUeXBlPmUuZXZlbnRUeXBlPzE6MH0sZ2V0SW5zZXJ0RXZlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnNlcnRFdmVudH0saXNJbnNlcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudFR5cGU9PT1Nbi5JTlNFUlR9LGlzU2FtZUxhYmVsOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dGhpcy5sYWJlbD8hMTp0aGlzLmxhYmVsPT09dC5sYWJlbH0sZ2V0RGVsZXRlRXZlbnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGV0ZUV2ZW50SW5kZXh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNbn19KSxNbi5JTlNFUlQ9MSxNbi5ERUxFVEU9MixlKERuLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRG59fSksZShBbi5wcm90b3R5cGUse2lzVHJpdmlhbEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmMT09PXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkpe2lmKEFuLmlzQWRqYWNlbnRTZWdtZW50cyhlLGkpKXJldHVybiEwO2lmKHQuaXNDbG9zZWQoKSl7dmFyIHI9dC5nZXROdW1Qb2ludHMoKS0xO2lmKDA9PT1lJiZpPT09cnx8MD09PWkmJmU9PT1yKXJldHVybiEwfX1yZXR1cm4hMX0sZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH0sc2V0SXNEb25lSWZQcm9wZXJJbnQ6ZnVuY3Rpb24odCl7dGhpcy5pc0RvbmVXaGVuUHJvcGVySW50PXR9LGhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzUHJvcGVySW50ZXJpb3J9LGlzQm91bmRhcnlQb2ludEludGVybmFsOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRDb29yZGluYXRlKCk7aWYodC5pc0ludGVyc2VjdGlvbihyKSlyZXR1cm4hMH1yZXR1cm4hMX0saGFzUHJvcGVySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzUHJvcGVyfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNEb25lfSxpc0JvdW5kYXJ5UG9pbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PWU/ITE6dGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMF0pPyEwOiEhdGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMV0pfSxzZXRCb3VuZGFyeU5vZGVzOmZ1bmN0aW9uKHQsZSl7dGhpcy5iZHlOb2Rlcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmJkeU5vZGVzWzBdPXQsdGhpcy5iZHlOb2Rlc1sxXT1lfSxhZGRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQ9PT1uJiZlPT09aSlyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7dmFyIHI9dC5nZXRDb29yZGluYXRlcygpW2VdLHM9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbaV0sYT1uLmdldENvb3JkaW5hdGVzKClbaSsxXTt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocixzLG8sYSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMucmVjb3JkSXNvbGF0ZWQmJih0LnNldElzb2xhdGVkKCExKSxuLnNldElzb2xhdGVkKCExKSksdGhpcy5udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4saSl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsIXRoaXMuaW5jbHVkZVByb3BlciYmdGhpcy5saS5pc1Byb3BlcigpfHwodC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5saSxpLDEpKSx0aGlzLmxpLmlzUHJvcGVyKCkmJih0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50PXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApLmNvcHkoKSx0aGlzLmhhc1Byb3Blcj0hMCx0aGlzLmlzRG9uZVdoZW5Qcm9wZXJJbnQmJih0aGlzLl9pc0RvbmU9ITApLHRoaXMuaXNCb3VuZGFyeVBvaW50KHRoaXMubGksdGhpcy5iZHlOb2Rlcyl8fCh0aGlzLmhhc1Byb3BlckludGVyaW9yPSEwKSkpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQW59fSksQW4uaXNBZGphY2VudFNlZ21lbnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfSxoKEZuLERuKSxlKEZuLnByb3RvdHlwZSx7cHJlcGFyZUV2ZW50czpmdW5jdGlvbigpe2hvLnNvcnQodGhpcy5ldmVudHMpO2Zvcih2YXIgdD0wO3Q8dGhpcy5ldmVudHMuc2l6ZSgpO3QrKyl7dmFyIGU9dGhpcy5ldmVudHMuZ2V0KHQpO2UuaXNEZWxldGUoKSYmZS5nZXRJbnNlcnRFdmVudCgpLnNldERlbGV0ZUV2ZW50SW5kZXgodCl9fSxjb21wdXRlSW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5uT3ZlcmxhcHM9MCx0aGlzLnByZXBhcmVFdmVudHMoKTtmb3IodmFyIGU9MDtlPHRoaXMuZXZlbnRzLnNpemUoKTtlKyspe3ZhciBuPXRoaXMuZXZlbnRzLmdldChlKTtpZihuLmlzSW5zZXJ0KCkmJnRoaXMucHJvY2Vzc092ZXJsYXBzKGUsbi5nZXREZWxldGVFdmVudEluZGV4KCksbix0KSx0LmlzRG9uZSgpKWJyZWFrfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQW4mJlIoYXJndW1lbnRzWzBdLHkpJiZSKGFyZ3VtZW50c1sxXSx5KSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMuYWRkRWRnZXMoaSxpKSx0aGlzLmFkZEVkZ2VzKHIsciksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhzKX1lbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZSKGFyZ3VtZW50c1swXSx5KSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBbil7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YXJndW1lbnRzWzJdO3U/dGhpcy5hZGRFZGdlcyhvLG51bGwpOnRoaXMuYWRkRWRnZXMobyksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhhKX19LGFkZEVkZ2U6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRNb25vdG9uZUNoYWluRWRnZSgpLGk9bi5nZXRTdGFydEluZGV4ZXMoKSxyPTA7cjxpLmxlbmd0aC0xO3IrKyl7dmFyIHM9bmV3IF9uKG4sciksbz1uZXcgTW4oZSxuLmdldE1pblgocikscyk7dGhpcy5ldmVudHMuYWRkKG8pLHRoaXMuZXZlbnRzLmFkZChuZXcgTW4obi5nZXRNYXhYKHIpLG8pKX19LHByb2Nlc3NPdmVybGFwczpmdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHI9bi5nZXRPYmplY3QoKSxzPXQ7ZT5zO3MrKyl7dmFyIG89dGhpcy5ldmVudHMuZ2V0KHMpO2lmKG8uaXNJbnNlcnQoKSl7dmFyIGE9by5nZXRPYmplY3QoKTtuLmlzU2FtZUxhYmVsKG8pfHwoci5jb21wdXRlSW50ZXJzZWN0aW9ucyhhLGkpLHRoaXMubk92ZXJsYXBzKyspfX19LGFkZEVkZ2VzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuYWRkRWRnZShuLG4pfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxlPWkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuYWRkRWRnZShuLHIpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRm59fSksZShHbi5wcm90b3R5cGUse2dldE1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbn0saW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe3JldHVybiEodGhpcy5taW4+ZXx8dGhpcy5tYXg8dCl9LGdldE1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBnKHRoaXMubWluLDApLG5ldyBnKHRoaXMubWF4LDApKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR259fSksZShxbi5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZSxyPShuLm1pbituLm1heCkvMixzPShpLm1pbitpLm1heCkvMjtyZXR1cm4gcz5yPy0xOnI+cz8xOjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxbn19KSxHbi5Ob2RlQ29tcGFyYXRvcj1xbixoKEJuLEduKSxlKEJuLnByb3RvdHlwZSx7cXVlcnk6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmludGVyc2VjdHModCxlKT92b2lkIG4udmlzaXRJdGVtKHRoaXMuaXRlbSk6bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQm59fSksaCh6bixHbiksZSh6bi5wcm90b3R5cGUse2J1aWxkRXh0ZW50OmZ1bmN0aW9uKHQsZSl7dGhpcy5taW49TWF0aC5taW4odC5taW4sZS5taW4pLHRoaXMubWF4PU1hdGgubWF4KHQubWF4LGUubWF4KX0scXVlcnk6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmludGVyc2VjdHModCxlKT8obnVsbCE9PXRoaXMubm9kZTEmJnRoaXMubm9kZTEucXVlcnkodCxlLG4pLHZvaWQobnVsbCE9PXRoaXMubm9kZTImJnRoaXMubm9kZTIucXVlcnkodCxlLG4pKSk6bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gem59fSksZShWbi5wcm90b3R5cGUse2J1aWxkVHJlZTpmdW5jdGlvbigpe2hvLnNvcnQodGhpcy5sZWF2ZXMsbmV3IEludGVydmFsUlRyZWVOb2RlLk5vZGVDb21wYXJhdG9yKTtmb3IodmFyIHQ9dGhpcy5sZWF2ZXMsZT1udWxsLG49bmV3IEk7Oyl7aWYodGhpcy5idWlsZExldmVsKHQsbiksMT09PW4uc2l6ZSgpKXJldHVybiBuLmdldCgwKTtlPXQsdD1uLG49ZX19LGluc2VydDpmdW5jdGlvbih0LGUsbil7aWYobnVsbCE9PXRoaXMucm9vdCl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiSW5kZXggY2Fubm90IGJlIGFkZGVkIHRvIG9uY2UgaXQgaGFzIGJlZW4gcXVlcmllZFwiKTt0aGlzLmxlYXZlcy5hZGQobmV3IEJuKHQsZSxuKSl9LHF1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXt0aGlzLmluaXQoKSx0aGlzLnJvb3QucXVlcnkodCxlLG4pfSxidWlsZFJvb3Q6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD9udWxsOnZvaWQodGhpcy5yb290PXRoaXMuYnVpbGRUcmVlKCkpfSxwcmludE5vZGU6ZnVuY3Rpb24odCl7QS5vdXQucHJpbnRsbihzZS50b0xpbmVTdHJpbmcobmV3IGcodC5taW4sdGhpcy5sZXZlbCksbmV3IGcodC5tYXgsdGhpcy5sZXZlbCkpKX0saW5pdDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P251bGw6dm9pZCB0aGlzLmJ1aWxkUm9vdCgpfSxidWlsZExldmVsOmZ1bmN0aW9uKHQsZSl7dGhpcy5sZXZlbCsrLGUuY2xlYXIoKTtmb3IodmFyIG49MDtuPHQuc2l6ZSgpO24rPTIpe3ZhciBpPXQuZ2V0KG4pLHI9bisxPHQuc2l6ZSgpP3QuZ2V0KG4pOm51bGw7aWYobnVsbD09PXIpZS5hZGQoaSk7ZWxzZXt2YXIgcz1uZXcgem4odC5nZXQobiksdC5nZXQobisxKSk7ZS5hZGQocyl9fX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVm59fSksZShrbi5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXtpZih0aGlzLmlzRm9yY2VkVG9MaW5lU3RyaW5nJiZ0IGluc3RhbmNlb2YgYnQpe3ZhciBlPXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7cmV0dXJuIHRoaXMubGluZXMuYWRkKGUpLG51bGx9dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLmxpbmVzLmFkZCh0KX0sc2V0Rm9yY2VUb0xpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZz10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga259fSksa24uZ2V0R2VvbWV0cnk9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGtuLmdldExpbmVzKHQpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBlLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGtuLmdldExpbmVzKGUsbikpfX0sa24uZ2V0TGluZXM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBrbi5nZXRMaW5lcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sdikmJlIoYXJndW1lbnRzWzFdLHYpKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7a24uZ2V0TGluZXMocixuKX1yZXR1cm4gbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1uZXcgSTtyZXR1cm4gcy5hcHBseShuZXcga24oYSxvKSksYX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlIoYXJndW1lbnRzWzFdLHYpKXt2YXIgdT1hcmd1bWVudHNbMF0sbD1hcmd1bWVudHNbMV07cmV0dXJuIHUgaW5zdGFuY2VvZiBTdD9sLmFkZCh1KTp1LmFwcGx5KG5ldyBrbihsKSksbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlIoYXJndW1lbnRzWzBdLHYpJiZSKGFyZ3VtZW50c1sxXSx2KSl7Zm9yKHZhciBoPWFyZ3VtZW50c1swXSxjPWFyZ3VtZW50c1sxXSxmPWFyZ3VtZW50c1syXSxpPWguaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2tuLmdldExpbmVzKHIsYyxmKX1yZXR1cm4gY31pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZSKGFyZ3VtZW50c1sxXSx2KSl7dmFyIGc9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdO3JldHVybiBnLmFwcGx5KG5ldyBrbihkLHApKSxkfX19LGUoWW4ucHJvdG90eXBlLHt2aXNpdEl0ZW06ZnVuY3Rpb24odCl7dGhpcy5pdGVtcy5hZGQodCl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWW59fSksZShVbi5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgbGUodCksbj1uZXcgWG4oZSk7cmV0dXJuIHRoaXMuaW5kZXgucXVlcnkodC55LHQueSxuKSxlLmdldExvY2F0aW9uKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1JuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVW59fSksZShYbi5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt2YXIgZT10O3RoaXMuY291bnRlci5jb3VudFNlZ21lbnQoZS5nZXRDb29yZGluYXRlKDApLGUuZ2V0Q29vcmRpbmF0ZSgxKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWG59fSksZShIbi5wcm90b3R5cGUse2luaXQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWtuLmdldExpbmVzKHQpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldENvb3JkaW5hdGVzKCk7dGhpcy5hZGRMaW5lKHIpfX0sYWRkTGluZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPHQubGVuZ3RoO2UrKyl7dmFyIG49bmV3IGNlKHRbZS0xXSx0W2VdKSxpPU1hdGgubWluKG4ucDAueSxuLnAxLnkpLHI9TWF0aC5tYXgobi5wMC55LG4ucDEueSk7dGhpcy5pbmRleC5pbnNlcnQoaSxyLG4pfX0scXVlcnk6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFluO3JldHVybiB0aGlzLmluZGV4LnF1ZXJ5KHQsZSxuKSxuLmdldEl0ZW1zKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLmluZGV4LnF1ZXJ5KGkscixzKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhufX0pLFVuLlNlZ21lbnRWaXNpdG9yPVhuLFVuLkludGVydmFsSW5kZXhlZEdlb21ldHJ5PUhuLGUoV24ucHJvdG90eXBlLHtnZXRTZWdtZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXh9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZH0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpLHQucHJpbnRsbihcIiBkaXN0ID0gXCIrdGhpcy5kaXN0KX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZShlLnNlZ21lbnRJbmRleCxlLmRpc3QpfSxpc0VuZFBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dGhpcy5zZWdtZW50SW5kZXgmJjA9PT10aGlzLmRpc3Q/ITA6dGhpcy5zZWdtZW50SW5kZXg9PT10fSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkK1wiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgrXCIgZGlzdCA9IFwiK3RoaXMuZGlzdH0sZ2V0RGlzdGFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXN0fSxjb21wYXJlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PHQ/LTE6dGhpcy5zZWdtZW50SW5kZXg+dD8xOnRoaXMuZGlzdDxlPy0xOnRoaXMuZGlzdD5lPzE6MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdufX0pLGUoam4ucHJvdG90eXBlLHtwcmludDpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KX19LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSxhZGRTcGxpdEVkZ2VzOmZ1bmN0aW9uKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKSxuPWUubmV4dCgpO2UuaGFzTmV4dCgpOyl7dmFyIGk9ZS5uZXh0KCkscj10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLGkpO3QuYWRkKHIpLG49aX19LGFkZEVuZHBvaW50czpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWRnZS5wdHMubGVuZ3RoLTE7dGhpcy5hZGQodGhpcy5lZGdlLnB0c1swXSwwLDApLHRoaXMuYWRkKHRoaXMuZWRnZS5wdHNbdF0sdCwwKX0sY3JlYXRlU3BsaXRFZGdlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMixpPXRoaXMuZWRnZS5wdHNbZS5zZWdtZW50SW5kZXhdLHI9ZS5kaXN0PjB8fCFlLmNvb3JkLmVxdWFsczJEKGkpO3J8fG4tLTt2YXIgcz1uZXcgQXJyYXkobikuZmlsbChudWxsKSxvPTA7c1tvKytdPW5ldyBnKHQuY29vcmQpO2Zvcih2YXIgYT10LnNlZ21lbnRJbmRleCsxO2E8PWUuc2VnbWVudEluZGV4O2ErKylzW28rK109dGhpcy5lZGdlLnB0c1thXTtyZXR1cm4gciYmKHNbb109ZS5jb29yZCksbmV3IEpuKHMsbmV3IGduKHRoaXMuZWRnZS5sYWJlbCkpfSxhZGQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBXbih0LGUsbikscj10aGlzLm5vZGVNYXAuZ2V0KGkpO3JldHVybiBudWxsIT09cj9yOih0aGlzLm5vZGVNYXAucHV0KGksaSksaSl9LGlzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZihuLmNvb3JkLmVxdWFscyh0KSlyZXR1cm4hMH1yZXR1cm4hMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gam59fSksZShLbi5wcm90b3R5cGUse2dldENoYWluU3RhcnRJbmRpY2VzOmZ1bmN0aW9uKHQpe3ZhciBlPTAsbj1uZXcgSTtuLmFkZChuZXcgYihlKSk7ZG97dmFyIGk9dGhpcy5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChuZXcgYihpKSksZT1pfXdoaWxlKGU8dC5sZW5ndGgtMSk7dmFyIHI9S24udG9JbnRBcnJheShuKTtyZXR1cm4gcn0sZmluZENoYWluRW5kOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPUplLnF1YWRyYW50KHRbZV0sdFtlKzFdKSxpPWUrMTtpPHQubGVuZ3RoOyl7dmFyIHI9SmUucXVhZHJhbnQodFtpLTFdLHRbaV0pO2lmKHIhPT1uKWJyZWFrO2krK31yZXR1cm4gaS0xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLbn19KSxLbi50b0ludEFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX0sZShabi5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzfSxnZXRNYXhYOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBlPm4/ZTpufSxnZXRNaW5YOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBuPmU/ZTpufSxjb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluOmZ1bmN0aW9uKCl7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5zdGFydEluZGV4W3RdLHRoaXMuc3RhcnRJbmRleFt0KzFdLGUsZS5zdGFydEluZGV4W25dLGUuc3RhcnRJbmRleFtuKzFdLGkpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXSx1PWFyZ3VtZW50c1s0XSxsPWFyZ3VtZW50c1s1XSxoPXRoaXMucHRzW3JdLGM9dGhpcy5wdHNbc10sZj1vLnB0c1thXSxnPW8ucHRzW3VdO2lmKHMtcj09PTEmJnUtYT09PTEpcmV0dXJuIGwuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmUscixvLmUsYSksbnVsbDtpZih0aGlzLmVudjEuaW5pdChoLGMpLHRoaXMuZW52Mi5pbml0KGYsZyksIXRoaXMuZW52MS5pbnRlcnNlY3RzKHRoaXMuZW52MikpcmV0dXJuIG51bGw7dmFyIGQ9TWF0aC50cnVuYygocitzKS8yKSxwPU1hdGgudHJ1bmMoKGErdSkvMik7ZD5yJiYocD5hJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4ocixkLG8sYSxwLGwpLHU+cCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHIsZCxvLHAsdSxsKSkscz5kJiYocD5hJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oZCxzLG8sYSxwLGwpLHU+cCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKGQscyxvLHAsdSxsKSl9fSxnZXRTdGFydEluZGV4ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydEluZGV4fSxjb21wdXRlSW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5zdGFydEluZGV4Lmxlbmd0aC0xO24rKylmb3IodmFyIGk9MDtpPHQuc3RhcnRJbmRleC5sZW5ndGgtMTtpKyspdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG4sdCxpLGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBabn19KSxlKFFuLnByb3RvdHlwZSx7Z2V0RGVwdGg6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5kZXB0aFt0XVtlXX0sc2V0RGVwdGg6ZnVuY3Rpb24odCxlLG4pe3RoaXMuZGVwdGhbdF1bZV09bn0saXNOdWxsOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD0wOzI+dDt0KyspZm9yKHZhciBlPTA7Mz5lO2UrKylpZih0aGlzLmRlcHRoW3RdW2VdIT09UW4uTlVMTF9WQUxVRSlyZXR1cm4hMTtyZXR1cm4hMH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRlcHRoW25dWzFdPT09UW4uTlVMTF9WQUxVRX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmRlcHRoW2ldW3JdPT09UW4uTlVMTF9WQUxVRX19LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wOzI+dDt0KyspaWYoIXRoaXMuaXNOdWxsKHQpKXt2YXIgZT10aGlzLmRlcHRoW3RdWzFdO3RoaXMuZGVwdGhbdF1bMl08ZSYmKGU9dGhpcy5kZXB0aFt0XVsyXSksMD5lJiYoZT0wKTtmb3IodmFyIG49MTszPm47bisrKXt2YXIgaT0wO3RoaXMuZGVwdGhbdF1bbl0+ZSYmKGk9MSksdGhpcy5kZXB0aFt0XVtuXT1pfX19LGdldERlbHRhOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRlcHRoW3RdW2NuLlJJR0hUXS10aGlzLmRlcHRoW3RdW2NuLkxFRlRdfSxnZXRMb2NhdGlvbjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmRlcHRoW3RdW2VdPD0wP0wuRVhURVJJT1I6TC5JTlRFUklPUn0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkE6IFwiK3RoaXMuZGVwdGhbMF1bMV0rXCIsXCIrdGhpcy5kZXB0aFswXVsyXStcIiBCOiBcIit0aGlzLmRlcHRoWzFdWzFdK1wiLFwiK3RoaXMuZGVwdGhbMV1bMl19LGFkZDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wOzI+ZTtlKyspZm9yKHZhciBuPTE7Mz5uO24rKyl7dmFyIGk9dC5nZXRMb2NhdGlvbihlLG4pO2khPT1MLkVYVEVSSU9SJiZpIT09TC5JTlRFUklPUnx8KHRoaXMuaXNOdWxsKGUsbik/dGhpcy5kZXB0aFtlXVtuXT1Rbi5kZXB0aEF0TG9jYXRpb24oaSk6dGhpcy5kZXB0aFtlXVtuXSs9UW4uZGVwdGhBdExvY2F0aW9uKGkpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07bz09PUwuSU5URVJJT1ImJnRoaXMuZGVwdGhbcl1bc10rK319LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFFufX0pLFFuLmRlcHRoQXRMb2NhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gdD09PUwuRVhURVJJT1I/MDp0PT09TC5JTlRFUklPUj8xOlFuLk5VTExfVkFMVUV9LFFuLk5VTExfVkFMVUU9LTEsaChKbixtbiksZShKbi5wcm90b3R5cGUse2dldERlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVwdGh9LGdldENvbGxhcHNlZEVkZ2U6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTt0WzBdPXRoaXMucHRzWzBdLHRbMV09dGhpcy5wdHNbMV07dmFyIGU9bmV3IEpuKHQsZ24udG9MaW5lTGFiZWwodGhpcy5sYWJlbCkpO3JldHVybiBlfSxpc0lzb2xhdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSXNvbGF0ZWR9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzfSxzZXRJc29sYXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc0lzb2xhdGVkPXR9LHNldE5hbWU6ZnVuY3Rpb24odCl7dGhpcy5uYW1lPXR9LGVxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBKbikpcmV0dXJuITE7dmFyIGU9dDtpZih0aGlzLnB0cy5sZW5ndGghPT1lLnB0cy5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBuPSEwLGk9ITAscj10aGlzLnB0cy5sZW5ndGgscz0wO3M8dGhpcy5wdHMubGVuZ3RoO3MrKylpZih0aGlzLnB0c1tzXS5lcXVhbHMyRChlLnB0c1tzXSl8fChuPSExKSx0aGlzLnB0c1tzXS5lcXVhbHMyRChlLnB0c1stLXJdKXx8KGk9ITEpLCFuJiYhaSlyZXR1cm4hMTtyZXR1cm4hMH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnB0cy5sZW5ndGg+MD90aGlzLnB0c1swXTpudWxsO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMucHRzW3RdfX0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5uYW1lK1wiOiBcIiksdC5wcmludChcIkxJTkVTVFJJTkcgKFwiKTtmb3IodmFyIGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7dC5wcmludChcIikgIFwiK3RoaXMubGFiZWwrXCIgXCIrdGhpcy5kZXB0aERlbHRhKX0sY29tcHV0ZUlNOmZ1bmN0aW9uKHQpe0puLnVwZGF0ZUlNKHRoaXMubGFiZWwsdCl9LGlzQ29sbGFwc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWwuaXNBcmVhKCk/MyE9PXRoaXMucHRzLmxlbmd0aD8hMTohIXRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1syXSk6ITF9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGgtMV0pfSxnZXRNYXhpbXVtU2VnbWVudEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aC0xfSxnZXREZXB0aERlbHRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVwdGhEZWx0YX0sZ2V0TnVtUG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aH0scHJpbnRSZXZlcnNlOmZ1bmN0aW9uKHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMubmFtZStcIjogXCIpO2Zvcih2YXIgZT10aGlzLnB0cy5sZW5ndGgtMTtlPj0wO2UtLSl0LnByaW50KHRoaXMucHRzW2VdK1wiIFwiKTt0LnByaW50bG4oXCJcIil9LGdldE1vbm90b25lQ2hhaW5FZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLm1jZSYmKHRoaXMubWNlPW5ldyBabih0aGlzKSksdGhpcy5tY2V9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZW52KXt0aGlzLmVudj1uZXcgQztmb3IodmFyIHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspdGhpcy5lbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMucHRzW3RdKX1yZXR1cm4gdGhpcy5lbnZ9LGFkZEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uZXcgZyh0LmdldEludGVyc2VjdGlvbihpKSkscz1lLG89dC5nZXRFZGdlRGlzdGFuY2UobixpKSxhPXMrMTtpZihhPHRoaXMucHRzLmxlbmd0aCl7dmFyIHU9dGhpcy5wdHNbYV07ci5lcXVhbHMyRCh1KSYmKHM9YSxvPTApfXRoaXMuZWlMaXN0LmFkZChyLHMsbyl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7dC5hcHBlbmQoXCJlZGdlIFwiK3RoaXMubmFtZStcIjogXCIpLHQuYXBwZW5kKFwiTElORVNUUklORyAoXCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQuYXBwZW5kKFwiLFwiKSx0LmFwcGVuZCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3JldHVybiB0LmFwcGVuZChcIikgIFwiK3RoaXMubGFiZWwrXCIgXCIrdGhpcy5kZXB0aERlbHRhKSx0LnRvU3RyaW5nKCl9LGlzUG9pbnR3aXNlRXF1YWw6ZnVuY3Rpb24odCl7aWYodGhpcy5wdHMubGVuZ3RoIT09dC5wdHMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKylpZighdGhpcy5wdHNbZV0uZXF1YWxzMkQodC5wdHNbZV0pKXJldHVybiExO3JldHVybiEwfSxzZXREZXB0aERlbHRhOmZ1bmN0aW9uKHQpe3RoaXMuZGVwdGhEZWx0YT10fSxnZXRFZGdlSW50ZXJzZWN0aW9uTGlzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVpTGlzdH0sYWRkSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LmdldEludGVyc2VjdGlvbk51bSgpO2krKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSm59fSksSm4udXBkYXRlSU09ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbW4ucHJvdG90eXBlLnVwZGF0ZUlNLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsY24uT04pLHQuZ2V0TG9jYXRpb24oMSxjbi5PTiksMSksdC5pc0FyZWEoKSYmKGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGNuLkxFRlQpLHQuZ2V0TG9jYXRpb24oMSxjbi5MRUZUKSwyKSxlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCksdC5nZXRMb2NhdGlvbigxLGNuLlJJR0hUKSwyKSl9LGgoJG4sQ24pLGUoJG4ucHJvdG90eXBlLHtpbnNlcnRCb3VuZGFyeVBvaW50OmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5ub2Rlcy5hZGROb2RlKGUpLGk9bi5nZXRMYWJlbCgpLHI9MSxzPUwuTk9ORTtzPWkuZ2V0TG9jYXRpb24odCxjbi5PTikscz09PUwuQk9VTkRBUlkmJnIrKzt2YXIgbz0kbi5kZXRlcm1pbmVCb3VuZGFyeSh0aGlzLmJvdW5kYXJ5Tm9kZVJ1bGUscik7aS5zZXRMb2NhdGlvbih0LG8pfSxjb21wdXRlU2VsZk5vZGVzOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wdXRlU2VsZk5vZGVzKHQsZSwhMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXSxzPW5ldyBBbihuLCEwLCExKTtzLnNldElzRG9uZUlmUHJvcGVySW50KHIpO3ZhciBvPXRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCksYT10aGlzLnBhcmVudEdlb20gaW5zdGFuY2VvZiBidHx8dGhpcy5wYXJlbnRHZW9tIGluc3RhbmNlb2YgVHR8fHRoaXMucGFyZW50R2VvbSBpbnN0YW5jZW9mIE90LHU9aXx8IWE7cmV0dXJuIG8uY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5lZGdlcyxzLHUpLHRoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzKHRoaXMuYXJnSW5kZXgpLHN9fSxjb21wdXRlU3BsaXRFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5laUxpc3QuYWRkU3BsaXRFZGdlcyh0KX19LGNvbXB1dGVFZGdlSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEFuKGUsbiwhMCk7aS5zZXRCb3VuZGFyeU5vZGVzKHRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLHQuZ2V0Qm91bmRhcnlOb2RlcygpKTt2YXIgcj10aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpO3JldHVybiByLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuZWRnZXMsdC5lZGdlcyxpKSxpfSxnZXRHZW9tZXRyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudEdlb219LGdldEJvdW5kYXJ5Tm9kZVJ1bGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ib3VuZGFyeU5vZGVSdWxlfSxoYXNUb29GZXdQb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzfSxhZGRQb2ludDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTHQpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxlLEwuSU5URVJJT1IpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgbj1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LG4sTC5JTlRFUklPUil9fSxhZGRQb2x5Z29uOmZ1bmN0aW9uKHQpe3RoaXMuYWRkUG9seWdvblJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSxMLkVYVEVSSU9SLEwuSU5URVJJT1IpO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe3ZhciBuPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTt0aGlzLmFkZFBvbHlnb25SaW5nKG4sTC5JTlRFUklPUixMLkVYVEVSSU9SKX19LGFkZEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5pbnNlcnRFZGdlKHQpO3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsZVswXSxMLkJPVU5EQVJZKSx0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSxMLkJPVU5EQVJZKX0sYWRkTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8MilyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuaW52YWxpZFBvaW50PWVbMF0sbnVsbDt2YXIgbj1uZXcgSm4oZSxuZXcgZ24odGhpcy5hcmdJbmRleCxMLklOVEVSSU9SKSk7dGhpcy5saW5lRWRnZU1hcC5wdXQodCxuKSx0aGlzLmluc2VydEVkZ2UobiksZi5pc1RydWUoZS5sZW5ndGg+PTIsXCJmb3VuZCBMaW5lU3RyaW5nIHdpdGggc2luZ2xlIHBvaW50XCIpLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLmFyZ0luZGV4LGVbMF0pLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLmFyZ0luZGV4LGVbZS5sZW5ndGgtMV0pfSxnZXRJbnZhbGlkUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZhbGlkUG9pbnR9LGdldEJvdW5kYXJ5UG9pbnRzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpLG49MCxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2VbbisrXT1yLmdldENvb3JkaW5hdGUoKS5jb3B5KCl9cmV0dXJuIGV9LGdldEJvdW5kYXJ5Tm9kZXM6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuYm91bmRhcnlOb2RlcyYmKHRoaXMuYm91bmRhcnlOb2Rlcz10aGlzLm5vZGVzLmdldEJvdW5kYXJ5Tm9kZXModGhpcy5hcmdJbmRleCkpLHRoaXMuYm91bmRhcnlOb2Rlc30sYWRkU2VsZkludGVyc2VjdGlvbk5vZGU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmlzQm91bmRhcnlOb2RlKHQsZSk/bnVsbDp2b2lkKG49PT1MLkJPVU5EQVJZJiZ0aGlzLnVzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU/dGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHQsZSk6dGhpcy5pbnNlcnRQb2ludCh0LGUsbikpfSxhZGRQb2x5Z29uUmluZzpmdW5jdGlvbih0LGUsbil7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIGk9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGkubGVuZ3RoPDQpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLmludmFsaWRQb2ludD1pWzBdLG51bGw7dmFyIHI9ZSxzPW47aGUuaXNDQ1coaSkmJihyPW4scz1lKTt2YXIgbz1uZXcgSm4oaSxuZXcgZ24odGhpcy5hcmdJbmRleCxMLkJPVU5EQVJZLHIscykpO3RoaXMubGluZUVkZ2VNYXAucHV0KHQsbyksdGhpcy5pbnNlcnRFZGdlKG8pLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxpWzBdLEwuQk9VTkRBUlkpfSxpbnNlcnRQb2ludDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5ub2Rlcy5hZGROb2RlKGUpLHI9aS5nZXRMYWJlbCgpO251bGw9PT1yP2kubGFiZWw9bmV3IGduKHQsbik6ci5zZXRMb2NhdGlvbih0LG4pfSxjcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEZufSxhZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpLHI9bi5laUxpc3QuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO3RoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxzLmNvb3JkLGkpfX0sYWRkOmZ1bmN0aW9uKCl7aWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIENuLnByb3RvdHlwZS5hZGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgT3QmJih0aGlzLnVzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITEpLHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEx0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGd0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBPdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBmdCkpdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19LGFkZENvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX0sbG9jYXRlOmZ1bmN0aW9uKHQpe3JldHVybiBSKHRoaXMucGFyZW50R2VvbSxSdCkmJnRoaXMucGFyZW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk+NTA/KG51bGw9PT10aGlzLmFyZWFQdExvY2F0b3ImJih0aGlzLmFyZWFQdExvY2F0b3I9bmV3IFVuKHRoaXMucGFyZW50R2VvbSkpLHRoaXMuYXJlYVB0TG9jYXRvci5sb2NhdGUodCkpOnRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LHRoaXMucGFyZW50R2VvbSl9LGZpbmRFZGdlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5saW5lRWRnZU1hcC5nZXQodCl9cmV0dXJuIENuLnByb3RvdHlwZS5maW5kRWRnZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRufX0pLCRuLmRldGVybWluZUJvdW5kYXJ5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaXNJbkJvdW5kYXJ5KGUpP0wuQk9VTkRBUlk6TC5JTlRFUklPUn0sZSh0aS5wcm90b3R5cGUse2dldEFyZ0dlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFyZ1t0XS5nZXRHZW9tZXRyeSgpfSxzZXRDb21wdXRhdGlvblByZWNpc2lvbjpmdW5jdGlvbih0KXt0aGlzLnJlc3VsdFByZWNpc2lvbk1vZGVsPXQsdGhpcy5saS5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLnJlc3VsdFByZWNpc2lvbk1vZGVsKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGl9fSksZShlaS5wcm90b3R5cGUse2NvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10LG49ZWkuY29tcGFyZU9yaWVudGVkKHRoaXMucHRzLHRoaXMuX29yaWVudGF0aW9uLGUucHRzLGUuX29yaWVudGF0aW9uKTtyZXR1cm4gbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVpfX0pLGVpLm9yaWVudGF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiAxPT09SC5pbmNyZWFzaW5nRGlyZWN0aW9uKHQpfSxlaS5jb21wYXJlT3JpZW50ZWQ9ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByPWU/MTotMSxzPWk/MTotMSxvPWU/dC5sZW5ndGg6LTEsYT1pP24ubGVuZ3RoOi0xLHU9ZT8wOnQubGVuZ3RoLTEsbD1pPzA6bi5sZW5ndGgtMTs7KXt2YXIgaD10W3VdLmNvbXBhcmVUbyhuW2xdKTtpZigwIT09aClyZXR1cm4gaDt1Kz1yLGwrPXM7dmFyIGM9dT09PW8sZj1sPT09YTtpZihjJiYhZilyZXR1cm4tMTtpZighYyYmZilyZXR1cm4gMTtpZihjJiZmKXJldHVybiAwfX0sZShuaS5wcm90b3R5cGUse3ByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQoXCJNVUxUSUxJTkVTVFJJTkcgKCBcIik7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2VzLnNpemUoKTtlKyspe3ZhciBuPXRoaXMuZWRnZXMuZ2V0KGUpO2U+MCYmdC5wcmludChcIixcIiksdC5wcmludChcIihcIik7Zm9yKHZhciBpPW4uZ2V0Q29vcmRpbmF0ZXMoKSxyPTA7cjxpLmxlbmd0aDtyKyspcj4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KGlbcl0ueCtcIiBcIitpW3JdLnkpO3QucHJpbnRsbihcIilcIil9dC5wcmludChcIikgIFwiKX0sYWRkQWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKX0sZmluZEVkZ2VJbmRleDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMuZWRnZXMuc2l6ZSgpO2UrKylpZih0aGlzLmVkZ2VzLmdldChlKS5lcXVhbHModCkpcmV0dXJuIGU7cmV0dXJuLTF9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXMuaXRlcmF0b3IoKX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sZ2V0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVkZ2VzLmdldCh0KX0sZmluZEVxdWFsRWRnZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZWkodC5nZXRDb29yZGluYXRlcygpKSxuPXRoaXMub2NhTWFwLmdldChlKTtyZXR1cm4gbn0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZXMuYWRkKHQpO3ZhciBlPW5ldyBlaSh0LmdldENvb3JkaW5hdGVzKCkpO3RoaXMub2NhTWFwLnB1dChlLHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBuaX19KSxoKGlpLHRpKSxlKGlpLnByb3RvdHlwZSx7aW5zZXJ0VW5pcXVlRWRnZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe3ZhciBuPWUuZ2V0TGFiZWwoKSxpPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChpPW5ldyBnbih0LmdldExhYmVsKCkpLGkuZmxpcCgpKTt2YXIgcj1lLmdldERlcHRoKCk7ci5pc051bGwoKSYmci5hZGQobiksci5hZGQoaSksbi5tZXJnZShpKX1lbHNlIHRoaXMuZWRnZUxpc3QuYWRkKHQpfSxnZXRHcmFwaDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBofSxjYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRTeW0oKTtlLmlzSW5SZXN1bHQoKSYmbi5pc0luUmVzdWx0KCkmJihlLnNldEluUmVzdWx0KCExKSxuLnNldEluUmVzdWx0KCExKSl9fSxpc0NvdmVyZWRCeUxBOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzQ292ZXJlZCh0LHRoaXMucmVzdWx0TGluZUxpc3QpPyEwOiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLnJlc3VsdFBvbHlMaXN0KX0sY29tcHV0ZUdlb21ldHJ5OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBJO3JldHVybiByLmFkZEFsbCh0KSxyLmFkZEFsbChlKSxyLmFkZEFsbChuKSxyLmlzRW1wdHkoKT9paS5jcmVhdGVFbXB0eVJlc3VsdChpLHRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCksdGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKSx0aGlzLmdlb21GYWN0KTp0aGlzLmdlb21GYWN0LmJ1aWxkR2VvbWV0cnkocil9LG1lcmdlU3ltTGFiZWxzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLm1lcmdlU3ltTGFiZWxzKCl9fSxpc0NvdmVyZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj10aGlzLnB0TG9jYXRvci5sb2NhdGUodCxpKTtpZihyIT09TC5FWFRFUklPUilyZXR1cm4hMH1yZXR1cm4hMX0scmVwbGFjZUNvbGxhcHNlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5lZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5pc0NvbGxhcHNlZCgpJiYoZS5yZW1vdmUoKSx0LmFkZChuLmdldENvbGxhcHNlZEVkZ2UoKSkpfXRoaXMuZWRnZUxpc3QuYWRkQWxsKHQpfSx1cGRhdGVOb2RlTGFiZWxsaW5nOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldEVkZ2VzKCkuZ2V0TGFiZWwoKTtlLmdldExhYmVsKCkubWVyZ2Uobil9fSxnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wdXRlT3ZlcmxheSh0KSx0aGlzLnJlc3VsdEdlb219LGluc2VydFVuaXF1ZUVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2Uobil9fSxjb21wdXRlT3ZlcmxheTpmdW5jdGlvbih0KXt0aGlzLmNvcHlQb2ludHMoMCksdGhpcy5jb3B5UG9pbnRzKDEpLHRoaXMuYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSksdGhpcy5hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCExKSx0aGlzLmFyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5hcmdbMV0sdGhpcy5saSwhMCk7dmFyIGU9bmV3IEk7dGhpcy5hcmdbMF0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5hcmdbMV0uY29tcHV0ZVNwbGl0RWRnZXMoZSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlcyhlKSx0aGlzLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCksdGhpcy5yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKSxsbi5jaGVja1ZhbGlkKHRoaXMuZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5ncmFwaC5hZGRFZGdlcyh0aGlzLmVkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuY29tcHV0ZUxhYmVsbGluZygpLHRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZXMoKSx0aGlzLmZpbmRSZXN1bHRBcmVhRWRnZXModCksXG50aGlzLmNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCk7dmFyIG49bmV3IFNuKHRoaXMuZ2VvbUZhY3QpO24uYWRkKHRoaXMuZ3JhcGgpLHRoaXMucmVzdWx0UG9seUxpc3Q9bi5nZXRQb2x5Z29ucygpO3ZhciBpPW5ldyB3bih0aGlzLHRoaXMuZ2VvbUZhY3QsdGhpcy5wdExvY2F0b3IpO3RoaXMucmVzdWx0TGluZUxpc3Q9aS5idWlsZCh0KTt2YXIgcj1uZXcgTG4odGhpcyx0aGlzLmdlb21GYWN0LHRoaXMucHRMb2NhdG9yKTt0aGlzLnJlc3VsdFBvaW50TGlzdD1yLmJ1aWxkKHQpLHRoaXMucmVzdWx0R2VvbT10aGlzLmNvbXB1dGVHZW9tZXRyeSh0aGlzLnJlc3VsdFBvaW50TGlzdCx0aGlzLnJlc3VsdExpbmVMaXN0LHRoaXMucmVzdWx0UG9seUxpc3QsdCl9LGxhYmVsSW5jb21wbGV0ZU5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9LGNvcHlQb2ludHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT10aGlzLmdyYXBoLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpO2kuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX0sZmluZFJlc3VsdEFyZWFFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKTtpLmlzQXJlYSgpJiYhbi5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmaWkuaXNSZXN1bHRPZk9wKGkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCksaS5nZXRMb2NhdGlvbigxLGNuLlJJR0hUKSx0KSYmbi5zZXRJblJlc3VsdCghMCl9fSxjb21wdXRlTGFiZWxzRnJvbURlcHRoczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKSxpPWUuZ2V0RGVwdGgoKTtpZighaS5pc051bGwoKSl7aS5ub3JtYWxpemUoKTtmb3IodmFyIHI9MDsyPnI7cisrKW4uaXNOdWxsKHIpfHwhbi5pc0FyZWEoKXx8aS5pc051bGwocil8fCgwPT09aS5nZXREZWx0YShyKT9uLnRvTGluZShyKTooZi5pc1RydWUoIWkuaXNOdWxsKHIsY24uTEVGVCksXCJkZXB0aCBvZiBMRUZUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24ocixjbi5MRUZULGkuZ2V0TG9jYXRpb24ocixjbi5MRUZUKSksZi5pc1RydWUoIWkuaXNOdWxsKHIsY24uUklHSFQpLFwiZGVwdGggb2YgUklHSFQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbihyLGNuLlJJR0hULGkuZ2V0TG9jYXRpb24ocixjbi5SSUdIVCkpKSl9fX0sY29tcHV0ZUxhYmVsbGluZzpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuYXJnKX10aGlzLm1lcmdlU3ltTGFiZWxzKCksdGhpcy51cGRhdGVOb2RlTGFiZWxsaW5nKCl9LGxhYmVsSW5jb21wbGV0ZU5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpO24uaXNJc29sYXRlZCgpJiYodCsrLGkuaXNOdWxsKDApP3RoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShuLDApOnRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShuLDEpKSxuLmdldEVkZ2VzKCkudXBkYXRlTGFiZWxsaW5nKGkpfX0saXNDb3ZlcmVkQnlBOmZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLnJlc3VsdFBvbHlMaXN0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaWl9fSksaWkub3ZlcmxheU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgaWkodCxlKSxyPWkuZ2V0UmVzdWx0R2VvbWV0cnkobik7cmV0dXJuIHJ9LGlpLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuSU5URVJTRUNUSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXt2YXIgbj1lO3JldHVybiBobi5tYXAodCx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTWFwT3BdfSxtYXA6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKG4pfX0pfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5JTlRFUlNFQ1RJT04pfSxpaS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLlNZTURJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5TWU1ESUZGRVJFTkNFKX0saWkucmVzdWx0RGltZW5zaW9uPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLmdldERpbWVuc2lvbigpLHI9bi5nZXREaW1lbnNpb24oKSxzPS0xO3N3aXRjaCh0KXtjYXNlIGlpLklOVEVSU0VDVElPTjpzPU1hdGgubWluKGkscik7YnJlYWs7Y2FzZSBpaS5VTklPTjpzPU1hdGgubWF4KGkscik7YnJlYWs7Y2FzZSBpaS5ESUZGRVJFTkNFOnM9aTticmVhaztjYXNlIGlpLlNZTURJRkZFUkVOQ0U6cz1NYXRoLm1heChpLHIpfXJldHVybiBzfSxpaS5jcmVhdGVFbXB0eVJlc3VsdD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1udWxsO3N3aXRjaChpaS5yZXN1bHREaW1lbnNpb24odCxlLG4pKXtjYXNlLTE6cj1pLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7YnJlYWs7Y2FzZSAwOnI9aS5jcmVhdGVQb2ludCgpO2JyZWFrO2Nhc2UgMTpyPWkuY3JlYXRlTGluZVN0cmluZygpO2JyZWFrO2Nhc2UgMjpyPWkuY3JlYXRlUG9seWdvbigpfXJldHVybiByfSxpaS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaXNFbXB0eSgpP2lpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLkRJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTplLmlzRW1wdHkoKT90LmNvcHkoKToodC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuRElGRkVSRU5DRSkpfSxpaS5pc1Jlc3VsdE9mT3A9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRMb2NhdGlvbigwKSxpPXQuZ2V0TG9jYXRpb24oMSk7cmV0dXJuIGlpLmlzUmVzdWx0T2ZPcChuLGksZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTtzd2l0Y2gocj09PUwuQk9VTkRBUlkmJihyPUwuSU5URVJJT1IpLHM9PT1MLkJPVU5EQVJZJiYocz1MLklOVEVSSU9SKSxvKXtjYXNlIGlpLklOVEVSU0VDVElPTjpyZXR1cm4gcj09PUwuSU5URVJJT1ImJnM9PT1MLklOVEVSSU9SO2Nhc2UgaWkuVU5JT046cmV0dXJuIHI9PT1MLklOVEVSSU9SfHxzPT09TC5JTlRFUklPUjtjYXNlIGlpLkRJRkZFUkVOQ0U6cmV0dXJuIHI9PT1MLklOVEVSSU9SJiZzIT09TC5JTlRFUklPUjtjYXNlIGlpLlNZTURJRkZFUkVOQ0U6cmV0dXJuIHI9PT1MLklOVEVSSU9SJiZzIT09TC5JTlRFUklPUnx8ciE9PUwuSU5URVJJT1ImJnM9PT1MLklOVEVSSU9SfXJldHVybiExfX0saWkuSU5URVJTRUNUSU9OPTEsaWkuVU5JT049MixpaS5ESUZGRVJFTkNFPTMsaWkuU1lNRElGRkVSRU5DRT00LGUocmkucHJvdG90eXBlLHtzZWxmU25hcDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgSWUodCksbj1lLnNuYXBUbyh0LHRoaXMuc25hcFRvbGVyYW5jZSk7cmV0dXJuIG59LHJlbW92ZUNvbW1vbkJpdHM6ZnVuY3Rpb24odCl7dGhpcy5jYnI9bmV3IFNlLHRoaXMuY2JyLmFkZCh0WzBdKSx0aGlzLmNici5hZGQodFsxXSk7dmFyIGU9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIGVbMF09dGhpcy5jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzBdLmNvcHkoKSksZVsxXT10aGlzLmNici5yZW1vdmVDb21tb25CaXRzKHRbMV0uY29weSgpKSxlfSxwcmVwYXJlUmVzdWx0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNici5hZGRDb21tb25CaXRzKHQpLHR9LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc25hcCh0aGlzLmdlb20pLG49aWkub3ZlcmxheU9wKGVbMF0sZVsxXSx0KTtyZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KG4pfSxjaGVja1ZhbGlkOmZ1bmN0aW9uKHQpe3QuaXNWYWxpZCgpfHxBLm91dC5wcmludGxuKFwiU25hcHBlZCBnZW9tZXRyeSBpcyBpbnZhbGlkXCIpfSxjb21wdXRlU25hcFRvbGVyYW5jZTpmdW5jdGlvbigpe3RoaXMuc25hcFRvbGVyYW5jZT1JZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodGhpcy5nZW9tWzBdLHRoaXMuZ2VvbVsxXSl9LHNuYXA6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZW1vdmVDb21tb25CaXRzKHQpLG49SWUuc25hcChlWzBdLGVbMV0sdGhpcy5zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcml9fSkscmkub3ZlcmxheU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgcmkodCxlKTtyZXR1cm4gaS5nZXRSZXN1bHRHZW9tZXRyeShuKX0scmkudW5pb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LHJpLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe3JldHVybiByaS5vdmVybGF5T3AodCxlLGlpLklOVEVSU0VDVElPTil9LHJpLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5TWU1ESUZGRVJFTkNFKX0scmkuZGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiByaS5vdmVybGF5T3AodCxlLGlpLkRJRkZFUkVOQ0UpfSxlKHNpLnByb3RvdHlwZSx7Z2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24odCl7dmFyIGU9bnVsbCxuPSExLGk9bnVsbDt0cnl7ZT1paS5vdmVybGF5T3AodGhpcy5nZW9tWzBdLHRoaXMuZ2VvbVsxXSx0KTt2YXIgcj0hMDtyJiYobj0hMCl9Y2F0Y2gocyl7aWYoIShzIGluc3RhbmNlb2YgbCkpdGhyb3cgcztpPXN9ZmluYWxseXt9aWYoIW4pdHJ5e2U9cmkub3ZlcmxheU9wKHRoaXMuZ2VvbVswXSx0aGlzLmdlb21bMV0sdCl9Y2F0Y2gocyl7dGhyb3cgcyBpbnN0YW5jZW9mIGw/aTpzfWZpbmFsbHl7fXJldHVybiBlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzaX19KSxzaS5vdmVybGF5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBzaSh0LGUpO3JldHVybiBpLmdldFJlc3VsdEdlb21ldHJ5KG4pfSxzaS51bmlvbj1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlVOSU9OKX0sc2kuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuSU5URVJTRUNUSU9OKX0sc2kuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlNZTURJRkZFUkVOQ0UpfSxzaS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuRElGRkVSRU5DRSl9LGUob2kucHJvdG90eXBlLHthZGRQb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPW51bGwsbj0wLGk9dGhpcy5ob3Jpem9udGFsQmlzZWN0b3IodCk7aWYoMD09PWkuZ2V0TGVuZ3RoKCkpbj0wLGU9aS5nZXRDb29yZGluYXRlKCk7ZWxzZXt2YXIgcj1zaS5vdmVybGF5T3AoaSx0LGlpLklOVEVSU0VDVElPTikscz10aGlzLndpZGVzdEdlb21ldHJ5KHIpO249cy5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKSxlPW9pLmNlbnRyZShzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9KG51bGw9PT10aGlzLmludGVyaW9yUG9pbnR8fG4+dGhpcy5tYXhXaWR0aCkmJih0aGlzLmludGVyaW9yUG9pbnQ9ZSx0aGlzLm1heFdpZHRoPW4pfSxnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JQb2ludH0sd2lkZXN0R2VvbWV0cnk6ZnVuY3Rpb24gem8oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZ0KXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIHQ7Zm9yKHZhciB6bz10LmdldEdlb21ldHJ5TigwKSxlPTE7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspdC5nZXRHZW9tZXRyeU4oZSkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCk+em8uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCkmJih6bz10LmdldEdlb21ldHJ5TihlKSk7cmV0dXJuIHpvfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiBuIGluc3RhbmNlb2YgZnQ/dGhpcy53aWRlc3RHZW9tZXRyeShuKTpufX0saG9yaXpvbnRhbEJpc2VjdG9yOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG49YWkuZ2V0QmlzZWN0b3JZKHQpO3JldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbbmV3IGcoZS5nZXRNaW5YKCksbiksbmV3IGcoZS5nZXRNYXhYKCksbildKX0sYWRkOmZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpZm9yKHZhciBlPXQsbj0wO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKG4pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb2l9fSksb2kuY2VudHJlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyhvaS5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpLG9pLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSkpfSxvaS5hdmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4odCtlKS8yfSxlKGFpLnByb3RvdHlwZSx7dXBkYXRlSW50ZXJ2YWw6ZnVuY3Rpb24odCl7dDw9dGhpcy5jZW50cmVZP3Q+dGhpcy5sb1kmJih0aGlzLmxvWT10KTp0PnRoaXMuY2VudHJlWSYmdDx0aGlzLmhpWSYmKHRoaXMuaGlZPXQpfSxnZXRCaXNlY3Rvclk6ZnVuY3Rpb24oKXt0aGlzLnByb2Nlc3ModGhpcy5wb2x5LmdldEV4dGVyaW9yUmluZygpKTtmb3IodmFyIHQ9MDt0PHRoaXMucG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTt0KyspdGhpcy5wcm9jZXNzKHRoaXMucG9seS5nZXRJbnRlcmlvclJpbmdOKHQpKTt2YXIgZT1vaS5hdmcodGhpcy5oaVksdGhpcy5sb1kpO3JldHVybiBlfSxwcm9jZXNzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49MDtuPGUuc2l6ZSgpO24rKyl7dmFyIGk9ZS5nZXRZKG4pO3RoaXMudXBkYXRlSW50ZXJ2YWwoaSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhaX19KSxhaS5nZXRCaXNlY3Rvclk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFpKHQpO3JldHVybiBlLmdldEJpc2VjdG9yWSgpfSxvaS5TYWZlQmlzZWN0b3JGaW5kZXI9YWksZSh1aS5wcm90b3R5cGUse2FkZEVuZHBvaW50czpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBTdCl0aGlzLmFkZEVuZHBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgZT10LG49MDtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0aGlzLmFkZEVuZHBvaW50cyhlLmdldEdlb21ldHJ5TihuKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5hZGQoaVswXSksdGhpcy5hZGQoaVtpLmxlbmd0aC0xXSl9fSxnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JQb2ludH0sYWRkSW50ZXJpb3I6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRJbnRlcmlvcih0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgZT10LG49MDtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0aGlzLmFkZEludGVyaW9yKGUuZ2V0R2VvbWV0cnlOKG4pKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpZm9yKHZhciBpPWFyZ3VtZW50c1swXSxuPTE7bjxpLmxlbmd0aC0xO24rKyl0aGlzLmFkZChpW25dKX0sYWRkOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZGlzdGFuY2UodGhpcy5jZW50cm9pZCk7ZTx0aGlzLm1pbkRpc3RhbmNlJiYodGhpcy5pbnRlcmlvclBvaW50PW5ldyBnKHQpLHRoaXMubWluRGlzdGFuY2U9ZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVpfX0pLGUobGkucHJvdG90eXBlLHtnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JQb2ludH0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIEx0KXRoaXMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdClmb3IodmFyIGU9dCxuPTA7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4obikpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF0scj1pLmRpc3RhbmNlKHRoaXMuY2VudHJvaWQpO3I8dGhpcy5taW5EaXN0YW5jZSYmKHRoaXMuaW50ZXJpb3JQb2ludD1uZXcgZyhpKSx0aGlzLm1pbkRpc3RhbmNlPXIpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbGl9fSksZShoaS5wcm90b3R5cGUse3NlbGVjdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3QuZ2V0TGluZVNlZ21lbnQoZSx0aGlzLnNlbGVjdGVkU2VnbWVudCksdGhpcy5zZWxlY3QodGhpcy5zZWxlY3RlZFNlZ21lbnQpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaGl9fSksZShjaS5wcm90b3R5cGUse2hhc0NoaWxkcmVuOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7Mj50O3QrKylpZihudWxsIT09dGhpcy5zdWJub2RlW3RdKXJldHVybiEwO3JldHVybiExfSxpc1BydW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuISh0aGlzLmhhc0NoaWxkcmVuKCl8fHRoaXMuaGFzSXRlbXMoKSl9LGFkZEFsbEl0ZW1zOmZ1bmN0aW9uKHQpe3QuYWRkQWxsKHRoaXMuaXRlbXMpO2Zvcih2YXIgZT0wOzI+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmdGhpcy5zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fSxzaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzI+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHQrPXRoaXMuc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0K3RoaXMuaXRlbXMuc2l6ZSgpfSxhZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZzpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dHx8dGhpcy5pc1NlYXJjaE1hdGNoKHQpPyhlLmFkZEFsbCh0aGlzLml0ZW1zKSxudWxsIT09dGhpcy5zdWJub2RlWzBdJiZ0aGlzLnN1Ym5vZGVbMF0uYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKSx2b2lkKG51bGwhPT10aGlzLnN1Ym5vZGVbMV0mJnRoaXMuc3Vibm9kZVsxXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpKSk6bnVsbH0saGFzSXRlbXM6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pdGVtcy5pc0VtcHR5KCl9LHJlbW92ZTpmdW5jdGlvbih0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuITE7Zm9yKHZhciBuPSExLGk9MDsyPmk7aSsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbaV0mJihuPXRoaXMuc3Vibm9kZVtpXS5yZW1vdmUodCxlKSkpe3RoaXMuc3Vibm9kZVtpXS5pc1BydW5hYmxlKCkmJih0aGlzLnN1Ym5vZGVbaV09bnVsbCk7YnJlYWt9cmV0dXJuIG4/bjpuPXRoaXMuaXRlbXMucmVtb3ZlKGUpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxkZXB0aDpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDsyPmU7ZSsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXS5kZXB0aCgpO24+dCYmKHQ9bil9cmV0dXJuIHQrMX0sbm9kZVNpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7Mj5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLm5vZGVTaXplKCkpO3JldHVybiB0KzF9LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY2l9fSksY2kuZ2V0U3Vibm9kZUluZGV4PWZ1bmN0aW9uKHQsZSl7dmFyIG49LTE7cmV0dXJuIHQubWluPj1lJiYobj0xKSx0Lm1heDw9ZSYmKG49MCksbn0sZShmaS5wcm90b3R5cGUse2V4cGFuZFRvSW5jbHVkZTpmdW5jdGlvbih0KXt0Lm1heD50aGlzLm1heCYmKHRoaXMubWF4PXQubWF4KSx0Lm1pbjx0aGlzLm1pbiYmKHRoaXMubWluPXQubWluKX0sZ2V0V2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXgtdGhpcy5taW59LG92ZXJsYXBzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5vdmVybGFwcyh0Lm1pbix0Lm1heCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4hKHRoaXMubWluPm58fHRoaXMubWF4PGUpfX0sZ2V0TWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWlufSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW1wiK3RoaXMubWluK1wiLCBcIit0aGlzLm1heCtcIl1cIn0sY29udGFpbnM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmaSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvbnRhaW5zKHQubWluLHQubWF4KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIGU+PXRoaXMubWluJiZlPD10aGlzLm1heH19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiBuPj10aGlzLm1pbiYmaTw9dGhpcy5tYXh9fSxpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5taW49dCx0aGlzLm1heD1lLHQ+ZSYmKHRoaXMubWluPWUsdGhpcy5tYXg9dCl9LGdldE1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZml9fSksZ2kuZXhwb25lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGRpKDY0LHQpLTEwMjN9LGdpLnBvd2VyT2YyPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLHQpfSxlKHBpLnByb3RvdHlwZSx7Z2V0SW50ZXJ2YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnZhbH0sZ2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sY29tcHV0ZUtleTpmdW5jdGlvbih0KXtmb3IodGhpcy5sZXZlbD1waS5jb21wdXRlTGV2ZWwodCksdGhpcy5pbnRlcnZhbD1uZXcgZmksdGhpcy5jb21wdXRlSW50ZXJ2YWwodGhpcy5sZXZlbCx0KTshdGhpcy5pbnRlcnZhbC5jb250YWlucyh0KTspdGhpcy5sZXZlbCs9MSx0aGlzLmNvbXB1dGVJbnRlcnZhbCh0aGlzLmxldmVsLHQpfSxjb21wdXRlSW50ZXJ2YWw6ZnVuY3Rpb24odCxlKXt2YXIgbj1naS5wb3dlck9mMih0KTt0aGlzLnB0PU1hdGguZmxvb3IoZS5nZXRNaW4oKS9uKSpuLHRoaXMuaW50ZXJ2YWwuaW5pdCh0aGlzLnB0LHRoaXMucHQrbil9LGdldFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHBpfX0pLHBpLmNvbXB1dGVMZXZlbD1mdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCksbj1naS5leHBvbmVudChlKSsxO3JldHVybiBufSxoKHZpLGNpKSxlKHZpLnByb3RvdHlwZSx7Z2V0SW50ZXJ2YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnZhbH0sZmluZDpmdW5jdGlvbih0KXt2YXIgZT1jaS5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZSk7aWYoLTE9PT1lKXJldHVybiB0aGlzO2lmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXTtyZXR1cm4gbi5maW5kKHQpfXJldHVybiB0aGlzfSxpbnNlcnQ6ZnVuY3Rpb24odCl7Zi5pc1RydWUobnVsbD09PXRoaXMuaW50ZXJ2YWx8fHRoaXMuaW50ZXJ2YWwuY29udGFpbnModC5pbnRlcnZhbCkpO3ZhciBlPWNpLmdldFN1Ym5vZGVJbmRleCh0LmludGVydmFsLHRoaXMuY2VudHJlKTtpZih0LmxldmVsPT09dGhpcy5sZXZlbC0xKXRoaXMuc3Vibm9kZVtlXT10O2Vsc2V7dmFyIG49dGhpcy5jcmVhdGVTdWJub2RlKGUpO24uaW5zZXJ0KHQpLHRoaXMuc3Vibm9kZVtlXT1ufX0saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gdC5vdmVybGFwcyh0aGlzLmludGVydmFsKX0sZ2V0U3Vibm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXRoaXMuc3Vibm9kZVt0XSYmKHRoaXMuc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuc3Vibm9kZVt0XX0sZ2V0Tm9kZTpmdW5jdGlvbih0KXt2YXIgZT1jaS5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZSk7aWYoLTEhPT1lKXt2YXIgbj10aGlzLmdldFN1Ym5vZGUoZSk7cmV0dXJuIG4uZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc30sY3JlYXRlU3Vibm9kZTpmdW5jdGlvbih0KXt2YXIgZT0wLG49MDtzd2l0Y2godCl7Y2FzZSAwOmU9dGhpcy5pbnRlcnZhbC5nZXRNaW4oKSxuPXRoaXMuY2VudHJlO2JyZWFrO2Nhc2UgMTplPXRoaXMuY2VudHJlLG49dGhpcy5pbnRlcnZhbC5nZXRNYXgoKX12YXIgaT1uZXcgZmkoZSxuKSxyPW5ldyB2aShpLHRoaXMubGV2ZWwtMSk7cmV0dXJuIHJ9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZpfX0pLHZpLmNyZWF0ZU5vZGU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHBpKHQpLG49bmV3IHZpKGUuZ2V0SW50ZXJ2YWwoKSxlLmdldExldmVsKCkpO3JldHVybiBufSx2aS5jcmVhdGVFeHBhbmRlZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBmaShlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5pbnRlcnZhbCk7dmFyIGk9dmkuY3JlYXRlTm9kZShuKTtyZXR1cm4gbnVsbCE9PXQmJmkuaW5zZXJ0KHQpLGl9LGUobWkucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtaX19KSxtaS5pc1plcm9XaWR0aD1mdW5jdGlvbih0LGUpe3ZhciBuPWUtdDtpZigwPT09bilyZXR1cm4hMDt2YXIgaT1NYXRoLm1heChNYXRoLmFicyh0KSxNYXRoLmFicyhlKSkscj1uL2kscz1naS5leHBvbmVudChyKTtyZXR1cm4gczw9bWkuTUlOX0JJTkFSWV9FWFBPTkVOVH0sbWkuTUlOX0JJTkFSWV9FWFBPTkVOVD0tNTAsaCh5aSxjaSksZSh5aS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUpe3ZhciBuPWNpLmdldFN1Ym5vZGVJbmRleCh0LHlpLm9yaWdpbik7aWYoLTE9PT1uKXJldHVybiB0aGlzLmFkZChlKSxudWxsO3ZhciBpPXRoaXMuc3Vibm9kZVtuXTtpZihudWxsPT09aXx8IWkuZ2V0SW50ZXJ2YWwoKS5jb250YWlucyh0KSl7dmFyIHI9dmkuY3JlYXRlRXhwYW5kZWQoaSx0KTt0aGlzLnN1Ym5vZGVbbl09cn10aGlzLmluc2VydENvbnRhaW5lZCh0aGlzLnN1Ym5vZGVbbl0sdCxlKX0saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4hMH0saW5zZXJ0Q29udGFpbmVkOmZ1bmN0aW9uKHQsZSxuKXtmLmlzVHJ1ZSh0LmdldEludGVydmFsKCkuY29udGFpbnMoZSkpO3ZhciBpPW1pLmlzWmVyb1dpZHRoKGUuZ2V0TWluKCksZS5nZXRNYXgoKSkscj1udWxsO3I9aT90LmZpbmQoZSk6dC5nZXROb2RlKGUpLHIuYWRkKG4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5aX19KSx5aS5vcmlnaW49MCxlKHhpLnByb3RvdHlwZSx7c2l6ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5zaXplKCk6MH0saW5zZXJ0OmZ1bmN0aW9uKHQsZSl7dGhpcy5jb2xsZWN0U3RhdHModCk7dmFyIG49eGkuZW5zdXJlRXh0ZW50KHQsdGhpcy5taW5FeHRlbnQpO3RoaXMucm9vdC5pbnNlcnQobixlKX0scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnF1ZXJ5KG5ldyBmaSh0LHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZpKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1uZXcgSTtyZXR1cm4gdGhpcy5xdWVyeShlLG4pLG59fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTt0aGlzLnJvb3QuYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcoaSxyKX19LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEk7cmV0dXJuIHRoaXMucm9vdC5hZGRBbGxJdGVtcyh0KSx0Lml0ZXJhdG9yKCl9LHJlbW92ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXhpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTtyZXR1cm4gdGhpcy5yb290LnJlbW92ZShuLGUpfSxjb2xsZWN0U3RhdHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpO2U8dGhpcy5taW5FeHRlbnQmJmU+MCYmKHRoaXMubWluRXh0ZW50PWUpfSxkZXB0aDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5kZXB0aCgpOjB9LG5vZGVTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290Lm5vZGVTaXplKCk6MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geGl9fSkseGkuZW5zdXJlRXh0ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRNaW4oKSxpPXQuZ2V0TWF4KCk7cmV0dXJuIG4hPT1pP3Q6KG49PT1pJiYobi09ZS8yLGk9bitlLzIpLG5ldyBmaShuLGkpKX0sZShFaS5wcm90b3R5cGUse2lzSW5zaWRlOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRWl9fSksZShJaS5wcm90b3R5cGUse3Rlc3RMaW5lU2VnbWVudDpmdW5jdGlvbih0LGUpe3ZhciBuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9ZS5wMCx1PWUucDE7aT1hLngtdC54LHI9YS55LXQueSxzPXUueC10Lngsbz11LnktdC55LChyPjAmJjA+PW98fG8+MCYmMD49cikmJihuPXVlLnNpZ25PZkRldDJ4MihpLHIscyxvKS8oby1yKSxuPjAmJnRoaXMuY3Jvc3NpbmdzKyspfSxidWlsZEluZGV4OmZ1bmN0aW9uKCl7dGhpcy50cmVlPW5ldyB4aTtmb3IodmFyIHQ9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0aGlzLnJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSksZT0kZS5nZXRDaGFpbnModCksbj0wO248ZS5zaXplKCk7bisrKXt2YXIgaT1lLmdldChuKSxyPWkuZ2V0RW52ZWxvcGUoKTt0aGlzLmludGVydmFsLm1pbj1yLmdldE1pblkoKSx0aGlzLmludGVydmFsLm1heD1yLmdldE1heFkoKSx0aGlzLnRyZWUuaW5zZXJ0KHRoaXMuaW50ZXJ2YWwsaSl9fSx0ZXN0TW9ub3RvbmVDaGFpbjpmdW5jdGlvbih0LGUsbil7bi5zZWxlY3QodCxlKX0saXNJbnNpZGU6ZnVuY3Rpb24odCl7dGhpcy5jcm9zc2luZ3M9MDt2YXIgZT1uZXcgQyhyLk5FR0FUSVZFX0lORklOSVRZLHIuUE9TSVRJVkVfSU5GSU5JVFksdC55LHQueSk7dGhpcy5pbnRlcnZhbC5taW49dC55LHRoaXMuaW50ZXJ2YWwubWF4PXQueTtmb3IodmFyIG49dGhpcy50cmVlLnF1ZXJ5KHRoaXMuaW50ZXJ2YWwpLGk9bmV3IE5pKHRoaXMsdCkscz1uLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKTt0aGlzLnRlc3RNb25vdG9uZUNoYWluKGUsaSxvKX1yZXR1cm4gdGhpcy5jcm9zc2luZ3MlMj09PTF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0VpXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSWl9fSksaChOaSxoaSksZShOaS5wcm90b3R5cGUse3NlbGVjdDpmdW5jdGlvbigpe2lmKDEhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBoaS5wcm90b3R5cGUuc2VsZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tY3AudGVzdExpbmVTZWdtZW50KHRoaXMucCx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTml9fSksSWkuTUNTZWxlY3Rlcj1OaSxlKENpLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ2l9fSksQ2kudG9EZWdyZWVzPWZ1bmN0aW9uKHQpe3JldHVybiAxODAqdC9NYXRoLlBJfSxDaS5ub3JtYWxpemU9ZnVuY3Rpb24odCl7Zm9yKDt0Pk1hdGguUEk7KXQtPUNpLlBJX1RJTUVTXzI7Zm9yKDt0PD0tTWF0aC5QSTspdCs9Q2kuUElfVElNRVNfMjtyZXR1cm4gdH0sQ2kuYW5nbGU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmF0YW4yKHQueSx0LngpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1uLngtZS54LHI9bi55LWUueTtyZXR1cm4gTWF0aC5hdGFuMihyLGkpfX0sQ2kuaXNBY3V0ZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC54LWUueCxyPXQueS1lLnkscz1uLngtZS54LG89bi55LWUueSxhPWkqcytyKm87cmV0dXJuIGE+MH0sQ2kuaXNPYnR1c2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9bi54LWUueCxvPW4ueS1lLnksYT1pKnMrcipvO3JldHVybiAwPmF9LENpLmludGVyaW9yQW5nbGU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPUNpLmFuZ2xlKGUsdCkscj1DaS5hbmdsZShlLG4pO3JldHVybiBNYXRoLmFicyhyLWkpfSxDaS5ub3JtYWxpemVQb3NpdGl2ZT1mdW5jdGlvbih0KXtpZigwPnQpe2Zvcig7MD50Oyl0Kz1DaS5QSV9USU1FU18yO3Q+PUNpLlBJX1RJTUVTXzImJih0PTApfWVsc2V7Zm9yKDt0Pj1DaS5QSV9USU1FU18yOyl0LT1DaS5QSV9USU1FU18yOzA+dCYmKHQ9MCl9cmV0dXJuIHR9LENpLmFuZ2xlQmV0d2Vlbj1mdW5jdGlvbih0LGUsbil7dmFyIGk9Q2kuYW5nbGUoZSx0KSxyPUNpLmFuZ2xlKGUsbik7cmV0dXJuIENpLmRpZmYoaSxyKX0sQ2kuZGlmZj1mdW5jdGlvbih0LGUpe3ZhciBuPW51bGw7cmV0dXJuIG49ZT50P2UtdDp0LWUsbj5NYXRoLlBJJiYobj0yKk1hdGguUEktbiksbn0sQ2kudG9SYWRpYW5zPWZ1bmN0aW9uKHQpe3JldHVybiB0Kk1hdGguUEkvMTgwfSxDaS5nZXRUdXJuPWZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5zaW4oZS10KTtyZXR1cm4gbj4wP0NpLkNPVU5URVJDTE9DS1dJU0U6MD5uP0NpLkNMT0NLV0lTRTpDaS5OT05FfSxDaS5hbmdsZUJldHdlZW5PcmllbnRlZD1mdW5jdGlvbih0LGUsbil7dmFyIGk9Q2kuYW5nbGUoZSx0KSxyPUNpLmFuZ2xlKGUsbikscz1yLWk7cmV0dXJuIHM8PS1NYXRoLlBJP3MrQ2kuUElfVElNRVNfMjpzPk1hdGguUEk/cy1DaS5QSV9USU1FU18yOnN9LENpLlBJX1RJTUVTXzI9MipNYXRoLlBJLENpLlBJX09WRVJfMj1NYXRoLlBJLzIsQ2kuUElfT1ZFUl80PU1hdGguUEkvNCxDaS5DT1VOVEVSQ0xPQ0tXSVNFPWhlLkNPVU5URVJDTE9DS1dJU0UsQ2kuQ0xPQ0tXSVNFPWhlLkNMT0NLV0lTRSxDaS5OT05FPWhlLkNPTExJTkVBUixlKFNpLnByb3RvdHlwZSx7YXJlYTpmdW5jdGlvbigpe3JldHVybiBTaS5hcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sc2lnbmVkQXJlYTpmdW5jdGlvbigpe3JldHVybiBTaS5zaWduZWRBcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saW50ZXJwb2xhdGVaOmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBpKFwiU3VwcGxpZWQgcG9pbnQgaXMgbnVsbC5cIik7cmV0dXJuIFNpLmludGVycG9sYXRlWih0LHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sbG9uZ2VzdFNpZGVMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gU2kubG9uZ2VzdFNpZGVMZW5ndGgodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxpc0FjdXRlOmZ1bmN0aW9uKCl7cmV0dXJuIFNpLmlzQWN1dGUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxjaXJjdW1jZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gU2kuY2lyY3VtY2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sYXJlYTNEOmZ1bmN0aW9uKCl7cmV0dXJuIFNpLmFyZWEzRCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGNlbnRyb2lkOmZ1bmN0aW9uKCl7cmV0dXJuIFNpLmNlbnRyb2lkKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saW5DZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gU2kuaW5DZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTaX19KSxTaS5hcmVhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnMoKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMil9LFNpLnNpZ25lZEFyZWE9ZnVuY3Rpb24odCxlLG4pe3JldHVybigobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzJ9LFNpLmRldD1mdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gdCppLWUqbn0sU2kuaW50ZXJwb2xhdGVaPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWUueCxzPWUueSxvPW4ueC1yLGE9aS54LXIsdT1uLnktcyxsPWkueS1zLGg9bypsLWEqdSxjPXQueC1yLGY9dC55LXMsZz0obCpjLWEqZikvaCxkPSgtdSpjK28qZikvaCxwPWUueitnKihuLnotZS56KStkKihpLnotZS56KTtyZXR1cm4gcH0sU2kubG9uZ2VzdFNpZGVMZW5ndGg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZGlzdGFuY2UoZSkscj1lLmRpc3RhbmNlKG4pLHM9bi5kaXN0YW5jZSh0KSxvPWk7cmV0dXJuIHI+byYmKG89cikscz5vJiYobz1zKSxvfSxTaS5pc0FjdXRlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gQ2kuaXNBY3V0ZSh0LGUsbikmJkNpLmlzQWN1dGUoZSxuLHQpPyEhQ2kuaXNBY3V0ZShuLHQsZSk6ITF9LFNpLmNpcmN1bWNlbnRyZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bi54LHI9bi55LHM9dC54LWksbz10LnktcixhPWUueC1pLHU9ZS55LXIsbD0yKlNpLmRldChzLG8sYSx1KSxoPVNpLmRldChvLHMqcytvKm8sdSxhKmErdSp1KSxjPVNpLmRldChzLHMqcytvKm8sYSxhKmErdSp1KSxmPWktaC9sLGQ9citjL2w7cmV0dXJuIG5ldyBnKGYsZCl9LFNpLnBlcnBlbmRpY3VsYXJCaXNlY3Rvcj1mdW5jdGlvbih0LGUpe3ZhciBuPWUueC10LngsaT1lLnktdC55LHI9bmV3IEYodC54K24vMix0LnkraS8yLDEpLHM9bmV3IEYodC54LWkrbi8yLHQueStuK2kvMiwxKTtyZXR1cm4gbmV3IEYocixzKX0sU2kuYW5nbGVCaXNlY3Rvcj1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5kaXN0YW5jZSh0KSxyPWUuZGlzdGFuY2Uobikscz1pLyhpK3IpLG89bi54LXQueCxhPW4ueS10LnksdT1uZXcgZyh0LngrcypvLHQueStzKmEpO3JldHVybiB1fSxTaS5hcmVhM0Q9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9ZS56LXQueixvPW4ueC10LngsYT1uLnktdC55LHU9bi56LXQueixsPXIqdS1zKmEsaD1zKm8taSp1LGM9aSphLXIqbyxmPWwqbCtoKmgrYypjLGc9TWF0aC5zcXJ0KGYpLzI7cmV0dXJuIGd9LFNpLmNlbnRyb2lkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT0odC54K2UueCtuLngpLzMscj0odC55K2UueStuLnkpLzM7cmV0dXJuIG5ldyBnKGkscil9LFNpLmluQ2VudHJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShuKSxzPXQuZGlzdGFuY2UoZSksbz1pK3IrcyxhPShpKnQueCtyKmUueCtzKm4ueCkvbyx1PShpKnQueStyKmUueStzKm4ueSkvbztyZXR1cm4gbmV3IGcoYSx1KX0sZSh3aS5wcm90b3R5cGUse2dldFJhZGl1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLnJhZGl1c30sZ2V0RGlhbWV0ZXI6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMTpyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5jZW50cmUpfXZhciB0PXRoaXMuZXh0cmVtYWxQdHNbMF0sZT10aGlzLmV4dHJlbWFsUHRzWzFdO3JldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX0sZ2V0RXh0cmVtYWxQb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5leHRyZW1hbFB0c30sY29tcHV0ZUNpcmNsZVBvaW50czpmdW5jdGlvbigpe2lmKHRoaXMuaW5wdXQuaXNFbXB0eSgpKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7aWYoMT09PXRoaXMuaW5wdXQuZ2V0TnVtUG9pbnRzKCkpe3ZhciB0PXRoaXMuaW5wdXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1bbmV3IGcodFswXSldLG51bGx9dmFyIGU9dGhpcy5pbnB1dC5jb252ZXhIdWxsKCksbj1lLmdldENvb3JkaW5hdGVzKCksdD1uO2lmKG5bMF0uZXF1YWxzMkQobltuLmxlbmd0aC0xXSkmJih0PW5ldyBBcnJheShuLmxlbmd0aC0xKS5maWxsKG51bGwpLEguY29weURlZXAobiwwLHQsMCxuLmxlbmd0aC0xKSksdC5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9SC5jb3B5RGVlcCh0KSxudWxsO2Zvcih2YXIgaT13aS5sb3dlc3RQb2ludCh0KSxyPXdpLnBvaW50V2l0TWluQW5nbGVXaXRoWCh0LGkpLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89d2kucG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudCh0LGkscik7aWYoQ2kuaXNPYnR1c2UoaSxvLHIpKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPVtuZXcgZyhpKSxuZXcgZyhyKV0sbnVsbDtpZihDaS5pc09idHVzZShvLGkscikpaT1vO2Vsc2V7aWYoIUNpLmlzT2J0dXNlKG8scixpKSlyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1bbmV3IGcoaSksbmV3IGcociksbmV3IGcobyldLG51bGw7cj1vfX1mLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiTG9naWMgZmFpbHVyZSBpbiBNaW5pbXVtIEJvdW5kaW5nIENpcmNsZSBhbGdvcml0aG0hXCIpfSxjb21wdXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmV4dHJlbWFsUHRzP251bGw6KHRoaXMuY29tcHV0ZUNpcmNsZVBvaW50cygpLHRoaXMuY29tcHV0ZUNlbnRyZSgpLHZvaWQobnVsbCE9PXRoaXMuY2VudHJlJiYodGhpcy5yYWRpdXM9dGhpcy5jZW50cmUuZGlzdGFuY2UodGhpcy5leHRyZW1hbFB0c1swXSkpKSl9LGdldEZhcnRoZXN0UG9pbnRzOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuY2VudHJlKX12YXIgdD10aGlzLmV4dHJlbWFsUHRzWzBdLGU9dGhpcy5leHRyZW1hbFB0c1t0aGlzLmV4dHJlbWFsUHRzLmxlbmd0aC0xXTtyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCxlXSl9LGdldENpcmNsZTpmdW5jdGlvbigpe2lmKHRoaXMuY29tcHV0ZSgpLG51bGw9PT10aGlzLmNlbnRyZSlyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbigpO3ZhciB0PXRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuY2VudHJlKTtyZXR1cm4gMD09PXRoaXMucmFkaXVzP3Q6dC5idWZmZXIodGhpcy5yYWRpdXMpfSxnZXRDZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5jZW50cmV9LGNvbXB1dGVDZW50cmU6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDp0aGlzLmNlbnRyZT1udWxsO2JyZWFrO2Nhc2UgMTp0aGlzLmNlbnRyZT10aGlzLmV4dHJlbWFsUHRzWzBdO2JyZWFrO2Nhc2UgMjp0aGlzLmNlbnRyZT1uZXcgZygodGhpcy5leHRyZW1hbFB0c1swXS54K3RoaXMuZXh0cmVtYWxQdHNbMV0ueCkvMiwodGhpcy5leHRyZW1hbFB0c1swXS55K3RoaXMuZXh0cmVtYWxQdHNbMV0ueSkvMik7YnJlYWs7Y2FzZSAzOnRoaXMuY2VudHJlPVNpLmNpcmN1bWNlbnRyZSh0aGlzLmV4dHJlbWFsUHRzWzBdLHRoaXMuZXh0cmVtYWxQdHNbMV0sdGhpcy5leHRyZW1hbFB0c1syXSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3aX19KSx3aS5wb2ludFdpdE1pbkFuZ2xlV2l0aFg9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ci5NQVhfVkFMVUUsaT1udWxsLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89dFtzXTtpZihvIT09ZSl7dmFyIGE9by54LWUueCx1PW8ueS1lLnk7MD51JiYodT0tdSk7dmFyIGw9TWF0aC5zcXJ0KGEqYSt1KnUpLGg9dS9sO24+aCYmKG49aCxpPW8pfX1yZXR1cm4gaX0sd2kubG93ZXN0UG9pbnQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRbMF0sbj0xO248dC5sZW5ndGg7bisrKXRbbl0ueTxlLnkmJihlPXRbbl0pO3JldHVybiBlfSx3aS5wb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50PWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9ci5NQVhfVkFMVUUscz1udWxsLG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIGE9dFtvXTtpZihhIT09ZSYmYSE9PW4pe3ZhciB1PUNpLmFuZ2xlQmV0d2VlbihlLGEsbik7aT51JiYoaT11LHM9YSl9fXJldHVybiBzfSxlKExpLnByb3RvdHlwZSx7Z2V0V2lkdGhDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMubWluV2lkdGhQdH0sZ2V0U3VwcG9ydGluZ1NlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMubWluQmFzZVNlZy5wMCx0aGlzLm1pbkJhc2VTZWcucDFdKX0sZ2V0RGlhbWV0ZXI6ZnVuY3Rpb24oKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSxudWxsPT09dGhpcy5taW5XaWR0aFB0KXJldHVybiB0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhudWxsKTt2YXIgdD10aGlzLm1pbkJhc2VTZWcucHJvamVjdCh0aGlzLm1pbldpZHRoUHQpO3JldHVybiB0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCx0aGlzLm1pbldpZHRoUHRdKX0sY29tcHV0ZVdpZHRoQ29udmV4OmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBUdD90aGlzLmNvbnZleEh1bGxQdHM9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpOnRoaXMuY29udmV4SHVsbFB0cz10LmdldENvb3JkaW5hdGVzKCksMD09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMubWluV2lkdGg9MCx0aGlzLm1pbldpZHRoUHQ9bnVsbCx0aGlzLm1pbkJhc2VTZWc9bnVsbCk6MT09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMubWluV2lkdGg9MCx0aGlzLm1pbldpZHRoUHQ9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMD10aGlzLmNvbnZleEh1bGxQdHNbMF0sdGhpcy5taW5CYXNlU2VnLnAxPXRoaXMuY29udmV4SHVsbFB0c1swXSk6Mj09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGh8fDM9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLm1pbldpZHRoPTAsdGhpcy5taW5XaWR0aFB0PXRoaXMuY29udmV4SHVsbFB0c1swXSx0aGlzLm1pbkJhc2VTZWcucDA9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMT10aGlzLmNvbnZleEh1bGxQdHNbMV0pOnRoaXMuY29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0aGlzLmNvbnZleEh1bGxQdHMpfSxjb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyOmZ1bmN0aW9uKHQpe3RoaXMubWluV2lkdGg9ci5NQVhfVkFMVUU7Zm9yKHZhciBlPTEsbj1uZXcgY2UsaT0wO2k8dC5sZW5ndGgtMTtpKyspbi5wMD10W2ldLG4ucDE9dFtpKzFdLGU9dGhpcy5maW5kTWF4UGVycERpc3RhbmNlKHQsbixlKX0sY29tcHV0ZU1pbmltdW1EaWFtZXRlcjpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLm1pbldpZHRoUHQpcmV0dXJuIG51bGw7aWYodGhpcy5pc0NvbnZleCl0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0aGlzLmlucHV0R2VvbSk7ZWxzZXt2YXIgdD1uZXcgbWUodGhpcy5pbnB1dEdlb20pLmdldENvbnZleEh1bGwoKTt0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0KX19LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLm1pbldpZHRofSxmaW5kTWF4UGVycERpc3RhbmNlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtuXSkscj1pLHM9bixvPXM7cj49aTspaT1yLHM9byxvPUxpLm5leHRJbmRleCh0LHMpLHI9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtvXSk7cmV0dXJuIGk8dGhpcy5taW5XaWR0aCYmKHRoaXMubWluUHRJbmRleD1zLHRoaXMubWluV2lkdGg9aSx0aGlzLm1pbldpZHRoUHQ9dFt0aGlzLm1pblB0SW5kZXhdLHRoaXMubWluQmFzZVNlZz1uZXcgY2UoZSkpLHN9LGdldE1pbmltdW1SZWN0YW5nbGU6ZnVuY3Rpb24oKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSwwPT09dGhpcy5taW5XaWR0aClyZXR1cm4gdGhpcy5taW5CYXNlU2VnLnAwLmVxdWFsczJEKHRoaXMubWluQmFzZVNlZy5wMSk/dGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMubWluQmFzZVNlZy5wMCk6dGhpcy5taW5CYXNlU2VnLnRvR2VvbWV0cnkodGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpKTtmb3IodmFyIHQ9dGhpcy5taW5CYXNlU2VnLnAxLngtdGhpcy5taW5CYXNlU2VnLnAwLngsZT10aGlzLm1pbkJhc2VTZWcucDEueS10aGlzLm1pbkJhc2VTZWcucDAueSxuPXIuTUFYX1ZBTFVFLGk9LXIuTUFYX1ZBTFVFLHM9ci5NQVhfVkFMVUUsbz0tci5NQVhfVkFMVUUsYT0wO2E8dGhpcy5jb252ZXhIdWxsUHRzLmxlbmd0aDthKyspe3ZhciB1PUxpLmNvbXB1dGVDKHQsZSx0aGlzLmNvbnZleEh1bGxQdHNbYV0pO3U+aSYmKGk9dSksbj51JiYobj11KTt2YXIgbD1MaS5jb21wdXRlQygtZSx0LHRoaXMuY29udmV4SHVsbFB0c1thXSk7bD5vJiYobz1sKSxzPmwmJihzPWwpfXZhciBoPUxpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxvKSxjPUxpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxzKSxmPUxpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LGkpLGc9TGkuY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQsbiksZD1mLmxpbmVJbnRlcnNlY3Rpb24oaCkscD1nLmxpbmVJbnRlcnNlY3Rpb24oaCksdj1nLmxpbmVJbnRlcnNlY3Rpb24oYyksbT1mLmxpbmVJbnRlcnNlY3Rpb24oYykseT10aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhbZCxwLHYsbSxkXSk7cmV0dXJuIHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKHksbnVsbCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExpfX0pLExpLm5leHRJbmRleD1mdW5jdGlvbih0LGUpe3JldHVybiBlKyssZT49dC5sZW5ndGgmJihlPTApLGV9LExpLmNvbXB1dGVDPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdCpuLnktZSpuLnh9LExpLmdldE1pbmltdW1EaWFtZXRlcj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IExpKHQpLmdldERpYW1ldGVyKCl9LExpLmdldE1pbmltdW1SZWN0YW5nbGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBMaSh0KS5nZXRNaW5pbXVtUmVjdGFuZ2xlKCl9LExpLmNvbXB1dGVTZWdtZW50Rm9yTGluZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bnVsbCxyPW51bGw7cmV0dXJuIE1hdGguYWJzKGUpPk1hdGguYWJzKHQpPyhpPW5ldyBnKDAsbi9lKSxyPW5ldyBnKDEsbi9lLXQvZSkpOihpPW5ldyBnKG4vdCwwKSxyPW5ldyBnKG4vdC1lL3QsMSkpLG5ldyBjZShpLHIpfTt2YXIgY289T2JqZWN0LmZyZWV6ZSh7Q2VudHJvaWQ6Z2UsQ0dBbGdvcml0aG1zOmhlLENvbnZleEh1bGw6bWUsSW50ZXJpb3JQb2ludEFyZWE6b2ksSW50ZXJpb3JQb2ludExpbmU6dWksSW50ZXJpb3JQb2ludFBvaW50OmxpLFJvYnVzdExpbmVJbnRlcnNlY3RvcjphZSxNQ1BvaW50SW5SaW5nOklpLE1pbmltdW1Cb3VuZGluZ0NpcmNsZTp3aSxNaW5pbXVtRGlhbWV0ZXI6TGl9KTtlKFJpLnByb3RvdHlwZSx7Z2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRpKHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLmlucHV0R2VvbSl9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe2lmKDA+PXQpdGhyb3cgbmV3IGkoXCJUb2xlcmFuY2UgbXVzdCBiZSBwb3NpdGl2ZVwiKTt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJpfX0pLFJpLmRlbnNpZnlQb2ludHM9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1uZXcgY2Uscj1uZXcgTixzPTA7czx0Lmxlbmd0aC0xO3MrKyl7aS5wMD10W3NdLGkucDE9dFtzKzFdLHIuYWRkKGkucDAsITEpO3ZhciBvPWkuZ2V0TGVuZ3RoKCksYT1NYXRoLnRydW5jKG8vZSkrMTtpZihhPjEpZm9yKHZhciB1PW8vYSxsPTE7YT5sO2wrKyl7dmFyIGg9bCp1L28sYz1pLnBvaW50QWxvbmcoaCk7bi5tYWtlUHJlY2lzZShjKSxyLmFkZChjLCExKX19cmV0dXJuIHIuYWRkKHRbdC5sZW5ndGgtMV0sITEpLHIudG9Db29yZGluYXRlQXJyYXkoKX0sUmkuZGVuc2lmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBSaSh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9LGgoVGkseGUpLGUoVGkucHJvdG90eXBlLHt0cmFuc2Zvcm1NdWx0aVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sdHJhbnNmb3JtUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgT3Q/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sdHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCksaT1SaS5kZW5zaWZ5UG9pbnRzKG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSxlLmdldFByZWNpc2lvbk1vZGVsKCkpO3JldHVybiBlIGluc3RhbmNlb2YgU3QmJjE9PT1pLmxlbmd0aCYmKGk9bmV3IEFycmF5KDApLmZpbGwobnVsbCkpLHRoaXMuZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGkpfSxjcmVhdGVWYWxpZEFyZWE6ZnVuY3Rpb24odCl7cmV0dXJuIHQuYnVmZmVyKDApfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUaX19KSxSaS5EZW5zaWZ5VHJhbnNmb3JtZXI9VGk7dmFyIGZvPU9iamVjdC5mcmVlemUoe0RlbnNpZmllcjpSaX0pO2UoUGkucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7ZG97aWYobnVsbD09PWUpcmV0dXJuIG51bGw7aWYoZS5kZXN0KCkuZXF1YWxzMkQodCkpcmV0dXJuIGU7ZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiBudWxsfSxkZXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZ30sb05leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLl9uZXh0fSxpbnNlcnQ6ZnVuY3Rpb24odCl7aWYodGhpcy5vTmV4dCgpPT09dGhpcylyZXR1cm4gdGhpcy5pbnNlcnRBZnRlcih0KSxudWxsO3ZhciBlPXRoaXMuY29tcGFyZVRvKHQpLG49dGhpcztkb3t2YXIgaT1uLm9OZXh0KCkscj1pLmNvbXBhcmVUbyh0KTtpZihyIT09ZXx8aT09PXRoaXMpcmV0dXJuIG4uaW5zZXJ0QWZ0ZXIodCksbnVsbDtuPWl9d2hpbGUobiE9PXRoaXMpO2Yuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX0saW5zZXJ0QWZ0ZXI6ZnVuY3Rpb24odCl7Zi5lcXVhbHModGhpcy5fb3JpZyx0Lm9yaWcoKSk7dmFyIGU9dGhpcy5vTmV4dCgpO3RoaXMuX3N5bS5zZXROZXh0KHQpLHQuc3ltKCkuc2V0TmV4dChlKX0sZGVncmVlOmZ1bmN0aW9uIFZvKCl7dmFyIFZvPTAsdD10aGlzO2RvIFZvKyssdD10Lm9OZXh0KCk7d2hpbGUodCE9PXRoaXMpO3JldHVybiBWb30sZXF1YWxzOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fb3JpZy5lcXVhbHMyRCh0KSYmdGhpcy5fc3ltLl9vcmlnLmVxdWFscyhlKX19LGRlbHRhWTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueS10aGlzLl9vcmlnLnl9LHN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW19LHByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLm5leHQoKS5fc3ltfSxjb21wYXJlQW5ndWxhckRpcmVjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmRlbHRhWCgpLG49dGhpcy5kZWx0YVkoKSxpPXQuZGVsdGFYKCkscj10LmRlbHRhWSgpO2lmKGU9PT1pJiZuPT09cilyZXR1cm4gMDt2YXIgcz1KZS5xdWFkcmFudChlLG4pLG89SmUucXVhZHJhbnQoaSxyKTtyZXR1cm4gcz5vPzE6bz5zPy0xOmhlLmNvbXB1dGVPcmllbnRhdGlvbih0Ll9vcmlnLHQuZGVzdCgpLHRoaXMuZGVzdCgpKX0scHJldk5vZGU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpczsyPT09dC5kZWdyZWUoKTspaWYodD10LnByZXYoKSx0PT09dGhpcylyZXR1cm4gbnVsbDtyZXR1cm4gdH0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10aGlzLmNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKGUpO3JldHVybiBufSxuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25leHR9LHNldFN5bTpmdW5jdGlvbih0KXt0aGlzLl9zeW09dH0sb3JpZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcmlnfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiSEUoXCIrdGhpcy5fb3JpZy54K1wiIFwiK3RoaXMuX29yaWcueStcIiwgXCIrdGhpcy5fc3ltLl9vcmlnLngrXCIgXCIrdGhpcy5fc3ltLl9vcmlnLnkrXCIpXCJ9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5fbmV4dD10fSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuc2V0U3ltKHQpLHQuc2V0U3ltKHRoaXMpLHRoaXMuc2V0TmV4dCh0KSx0LnNldE5leHQodGhpcyl9LGRlbHRhWDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueC10aGlzLl9vcmlnLnh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFBpfX0pLFBpLmluaXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsIT09dC5fc3ltfHxudWxsIT09ZS5fc3ltfHxudWxsIT09dC5fbmV4dHx8bnVsbCE9PWUuX25leHQpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkVkZ2VzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXCIpO3JldHVybiB0LmluaXQoZSksdH0sUGkuY3JlYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFBpKHQpLGk9bmV3IFBpKGUpO3JldHVybiBuLmluaXQoaSksbn0saChiaSxQaSksZShiaS5wcm90b3R5cGUse21hcms6ZnVuY3Rpb24oKXt0aGlzLl9pc01hcmtlZD0hMH0sc2V0TWFyazpmdW5jdGlvbih0KXt0aGlzLl9pc01hcmtlZD10fSxpc01hcmtlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc01hcmtlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYml9fSksYmkuc2V0TWFya0JvdGg9ZnVuY3Rpb24odCxlKXt0LnNldE1hcmsoZSksdC5zeW0oKS5zZXRNYXJrKGUpfSxiaS5pc01hcmtlZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5pc01hcmtlZCgpfSxiaS5zZXRNYXJrPWZ1bmN0aW9uKHQsZSl7dC5zZXRNYXJrKGUpfSxiaS5tYXJrQm90aD1mdW5jdGlvbih0KXt0Lm1hcmsoKSx0LnN5bSgpLm1hcmsoKX0sYmkubWFyaz1mdW5jdGlvbih0KXt0Lm1hcmsoKX0sZShPaS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5jcmVhdGUodCxlKTtudWxsIT09bj9uLmluc2VydChpKTp0aGlzLnZlcnRleE1hcC5wdXQodCxpKTt2YXIgcj10aGlzLnZlcnRleE1hcC5nZXQoZSk7cmV0dXJuIG51bGwhPT1yP3IuaW5zZXJ0KGkuc3ltKCkpOnRoaXMudmVydGV4TWFwLnB1dChlLGkuc3ltKCkpLGl9LGNyZWF0ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY3JlYXRlRWRnZSh0KSxpPXRoaXMuY3JlYXRlRWRnZShlKTtyZXR1cm4gUGkuaW5pdChuLGkpLG59LGNyZWF0ZUVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBQaSh0KX0sYWRkRWRnZTpmdW5jdGlvbih0LGUpe2lmKCFPaS5pc1ZhbGlkRWRnZSh0LGUpKXJldHVybiBudWxsO3ZhciBuPXRoaXMudmVydGV4TWFwLmdldCh0KSxpPW51bGw7aWYobnVsbCE9PW4mJihpPW4uZmluZChlKSksbnVsbCE9PWkpcmV0dXJuIGk7dmFyIHI9dGhpcy5pbnNlcnQodCxlLG4pO3JldHVybiByfSxnZXRWZXJ0ZXhFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleE1hcC52YWx1ZXMoKX0sZmluZEVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnZlcnRleE1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1uP251bGw6bi5maW5kKGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPaX19KSxPaS5pc1ZhbGlkRWRnZT1mdW5jdGlvbih0LGUpe3ZhciBuPWUuY29tcGFyZVRvKHQpO3JldHVybiAwIT09bn0saChfaSxiaSksZShfaS5wcm90b3R5cGUse3NldFN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5faXNTdGFydD0hMDtcbn0saXNTdGFydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1N0YXJ0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBfaX19KSxoKE1pLE9pKSxlKE1pLnByb3RvdHlwZSx7Y3JlYXRlRWRnZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IF9pKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNaX19KSxlKERpLnByb3RvdHlwZSx7YWRkTGluZTpmdW5jdGlvbih0KXt0aGlzLmxpbmVzLmFkZCh0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LnRvQ29vcmRpbmF0ZUFycmF5KCkpKX0sdXBkYXRlUmluZ1N0YXJ0RWRnZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5pc1N0YXJ0KCl8fCh0PXQuc3ltKCksdC5pc1N0YXJ0KCkpP251bGw9PT10aGlzLnJpbmdTdGFydEVkZ2U/KHRoaXMucmluZ1N0YXJ0RWRnZT10LG51bGwpOnZvaWQodC5vcmlnKCkuY29tcGFyZVRvKHRoaXMucmluZ1N0YXJ0RWRnZS5vcmlnKCkpPDAmJih0aGlzLnJpbmdTdGFydEVkZ2U9dCkpOm51bGx9LGdldFJlc3VsdDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yZXN1bHQmJnRoaXMuY29tcHV0ZVJlc3VsdCgpLHRoaXMucmVzdWx0fSxwcm9jZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPXQucHJldk5vZGUoKTtudWxsPT09ZSYmKGU9dCksdGhpcy5zdGFja0VkZ2VzKGUpLHRoaXMuYnVpbGRMaW5lcygpfSxidWlsZFJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IE4sbj10O2ZvcihlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaT09PXQpYnJlYWs7ZS5hZGQoaS5vcmlnKCkuY29weSgpLCExKSxuPWl9ZS5hZGQobi5kZXN0KCkuY29weSgpLCExKSx0aGlzLmFkZExpbmUoZSl9LGJ1aWxkTGluZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTixuPXQ7Zm9yKHRoaXMucmluZ1N0YXJ0RWRnZT1udWxsLGJpLm1hcmtCb3RoKG4pLGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXt0aGlzLnVwZGF0ZVJpbmdTdGFydEVkZ2Uobik7dmFyIGk9bi5uZXh0KCk7aWYoaT09PXQpcmV0dXJuIHRoaXMuYnVpbGRSaW5nKHRoaXMucmluZ1N0YXJ0RWRnZSksbnVsbDtlLmFkZChpLm9yaWcoKS5jb3B5KCksITEpLG49aSxiaS5tYXJrQm90aChuKX1lLmFkZChuLmRlc3QoKS5jb3B5KCksITEpLHRoaXMuc3RhY2tFZGdlcyhuLnN5bSgpKSx0aGlzLmFkZExpbmUoZSl9LHN0YWNrRWRnZXM6ZnVuY3Rpb24odCl7dmFyIGU9dDtkbyBiaS5pc01hcmtlZChlKXx8dGhpcy5ub2RlRWRnZVN0YWNrLmFkZChlKSxlPWUub05leHQoKTt3aGlsZShlIT09dCl9LGNvbXB1dGVSZXN1bHQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXRWZXJ0ZXhFZGdlcygpLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7YmkuaXNNYXJrZWQobil8fHRoaXMucHJvY2VzcyhuKX10aGlzLnJlc3VsdD10aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLmxpbmVzKX0sYnVpbGRMaW5lczpmdW5jdGlvbigpe2Zvcig7IXRoaXMubm9kZUVkZ2VTdGFjay5lbXB0eSgpOyl7dmFyIHQ9dGhpcy5ub2RlRWRnZVN0YWNrLnBvcCgpO2JpLmlzTWFya2VkKHQpfHx0aGlzLmJ1aWxkTGluZSh0KX19LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3QuYXBwbHkoe2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLmFkZCh0KX19KX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmFkZChpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciByPWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5mYWN0b3J5JiYodGhpcy5mYWN0b3J5PXIuZ2V0RmFjdG9yeSgpKTtmb3IodmFyIHM9ci5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxvPSExLG49MTtuPHMuc2l6ZSgpO24rKyl7dmFyIGE9dGhpcy5ncmFwaC5hZGRFZGdlKHMuZ2V0Q29vcmRpbmF0ZShuLTEpLHMuZ2V0Q29vcmRpbmF0ZShuKSk7bnVsbCE9PWEmJihvfHwoYS5zZXRTdGFydCgpLG89ITApKX19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEaX19KSxEaS5kaXNzb2x2ZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRGk7cmV0dXJuIGUuYWRkKHQpLGUuZ2V0UmVzdWx0KCl9O3ZhciBnbz1PYmplY3QuZnJlZXplKHtMaW5lRGlzc29sdmVyOkRpfSkscG89T2JqZWN0LmZyZWV6ZSh7R2VvbWV0cnlHcmFwaDokbn0pO2UoQWkucHJvdG90eXBlLHtoYXNDaGlsZHJlbjpmdW5jdGlvbigpe2Zvcih2YXIgdD0wOzQ+dDt0KyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVt0XSlyZXR1cm4hMDtyZXR1cm4hMX0saXNQcnVuYWJsZTpmdW5jdGlvbigpe3JldHVybiEodGhpcy5oYXNDaGlsZHJlbigpfHx0aGlzLmhhc0l0ZW1zKCkpfSxhZGRBbGxJdGVtczpmdW5jdGlvbih0KXt0LmFkZEFsbCh0aGlzLml0ZW1zKTtmb3IodmFyIGU9MDs0PmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJnRoaXMuc3Vibm9kZVtlXS5hZGRBbGxJdGVtcyh0KTtyZXR1cm4gdH0sZ2V0Tm9kZUNvdW50OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzQ+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHQrPXRoaXMuc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0KzF9LHNpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ND5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrdGhpcy5pdGVtcy5zaXplKCl9LGFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nOmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDtlLmFkZEFsbCh0aGlzLml0ZW1zKTtmb3IodmFyIG49MDs0Pm47bisrKW51bGwhPT10aGlzLnN1Ym5vZGVbbl0mJnRoaXMuc3Vibm9kZVtuXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpfSx2aXNpdEl0ZW1zOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuaXRlbXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZS52aXNpdEl0ZW0obi5uZXh0KCkpfSxoYXNJdGVtczpmdW5jdGlvbigpe3JldHVybiF0aGlzLml0ZW1zLmlzRW1wdHkoKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4hMTtmb3IodmFyIG49ITEsaT0wOzQ+aTtpKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtpXSYmKG49dGhpcy5zdWJub2RlW2ldLnJlbW92ZSh0LGUpKSl7dGhpcy5zdWJub2RlW2ldLmlzUHJ1bmFibGUoKSYmKHRoaXMuc3Vibm9kZVtpXT1udWxsKTticmVha31yZXR1cm4gbj9uOm49dGhpcy5pdGVtcy5yZW1vdmUoZSl9LHZpc2l0OmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDt0aGlzLnZpc2l0SXRlbXModCxlKTtmb3IodmFyIG49MDs0Pm47bisrKW51bGwhPT10aGlzLnN1Ym5vZGVbbl0mJnRoaXMuc3Vibm9kZVtuXS52aXNpdCh0LGUpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxkZXB0aDpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDs0PmU7ZSsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXS5kZXB0aCgpO24+dCYmKHQ9bil9cmV0dXJuIHQrMX0saXNFbXB0eTpmdW5jdGlvbiBrbygpe3ZhciBrbz0hMDt0aGlzLml0ZW1zLmlzRW1wdHkoKXx8KGtvPSExKTtmb3IodmFyIHQ9MDs0PnQ7dCsrKW51bGwhPT10aGlzLnN1Ym5vZGVbdF0mJih0aGlzLnN1Ym5vZGVbdF0uaXNFbXB0eSgpfHwoa289ITEpKTtyZXR1cm4ga299LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFpfX0pLEFpLmdldFN1Ym5vZGVJbmRleD1mdW5jdGlvbih0LGUsbil7dmFyIGk9LTE7cmV0dXJuIHQuZ2V0TWluWCgpPj1lJiYodC5nZXRNaW5ZKCk+PW4mJihpPTMpLHQuZ2V0TWF4WSgpPD1uJiYoaT0xKSksdC5nZXRNYXhYKCk8PWUmJih0LmdldE1pblkoKT49biYmKGk9MiksdC5nZXRNYXhZKCk8PW4mJihpPTApKSxpfSxlKEZpLnByb3RvdHlwZSx7Z2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sY29tcHV0ZUtleTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zm9yKHRoaXMubGV2ZWw9RmkuY29tcHV0ZVF1YWRMZXZlbCh0KSx0aGlzLmVudj1uZXcgQyx0aGlzLmNvbXB1dGVLZXkodGhpcy5sZXZlbCx0KTshdGhpcy5lbnYuY29udGFpbnModCk7KXRoaXMubGV2ZWwrPTEsdGhpcy5jb21wdXRlS2V5KHRoaXMubGV2ZWwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9Z2kucG93ZXJPZjIoZSk7dGhpcy5wdC54PU1hdGguZmxvb3Iobi5nZXRNaW5YKCkvaSkqaSx0aGlzLnB0Lnk9TWF0aC5mbG9vcihuLmdldE1pblkoKS9pKSppLHRoaXMuZW52LmluaXQodGhpcy5wdC54LHRoaXMucHQueCtpLHRoaXMucHQueSx0aGlzLnB0LnkraSl9fSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVudn0sZ2V0Q2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKCh0aGlzLmVudi5nZXRNaW5YKCkrdGhpcy5lbnYuZ2V0TWF4WCgpKS8yLCh0aGlzLmVudi5nZXRNaW5ZKCkrdGhpcy5lbnYuZ2V0TWF4WSgpKS8yKX0sZ2V0UG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRml9fSksRmkuY29tcHV0ZVF1YWRMZXZlbD1mdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpLGk9ZT5uP2U6bixyPWdpLmV4cG9uZW50KGkpKzE7cmV0dXJuIHJ9LGgoR2ksQWkpLGUoR2kucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3ZhciBlPUFpLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuY2VudHJleCx0aGlzLmNlbnRyZXkpO2lmKC0xPT09ZSlyZXR1cm4gdGhpcztpZihudWxsIT09dGhpcy5zdWJub2RlW2VdKXt2YXIgbj10aGlzLnN1Ym5vZGVbZV07cmV0dXJuIG4uZmluZCh0KX1yZXR1cm4gdGhpc30saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lbnYuaW50ZXJzZWN0cyh0KX0sZ2V0U3Vibm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXRoaXMuc3Vibm9kZVt0XSYmKHRoaXMuc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuc3Vibm9kZVt0XX0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbnZ9LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9QWkuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmV4LHRoaXMuY2VudHJleSk7aWYoLTEhPT1lKXt2YXIgbj10aGlzLmdldFN1Ym5vZGUoZSk7cmV0dXJuIG4uZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc30sY3JlYXRlU3Vibm9kZTpmdW5jdGlvbih0KXt2YXIgZT0wLG49MCxpPTAscj0wO3N3aXRjaCh0KXtjYXNlIDA6ZT10aGlzLmVudi5nZXRNaW5YKCksbj10aGlzLmNlbnRyZXgsaT10aGlzLmVudi5nZXRNaW5ZKCkscj10aGlzLmNlbnRyZXk7YnJlYWs7Y2FzZSAxOmU9dGhpcy5jZW50cmV4LG49dGhpcy5lbnYuZ2V0TWF4WCgpLGk9dGhpcy5lbnYuZ2V0TWluWSgpLHI9dGhpcy5jZW50cmV5O2JyZWFrO2Nhc2UgMjplPXRoaXMuZW52LmdldE1pblgoKSxuPXRoaXMuY2VudHJleCxpPXRoaXMuY2VudHJleSxyPXRoaXMuZW52LmdldE1heFkoKTticmVhaztjYXNlIDM6ZT10aGlzLmNlbnRyZXgsbj10aGlzLmVudi5nZXRNYXhYKCksaT10aGlzLmNlbnRyZXkscj10aGlzLmVudi5nZXRNYXhZKCl9dmFyIHM9bmV3IEMoZSxuLGksciksbz1uZXcgR2kocyx0aGlzLmxldmVsLTEpO3JldHVybiBvfSxpbnNlcnROb2RlOmZ1bmN0aW9uKHQpe2YuaXNUcnVlKG51bGw9PT10aGlzLmVudnx8dGhpcy5lbnYuY29udGFpbnModC5lbnYpKTt2YXIgZT1BaS5nZXRTdWJub2RlSW5kZXgodC5lbnYsdGhpcy5jZW50cmV4LHRoaXMuY2VudHJleSk7aWYodC5sZXZlbD09PXRoaXMubGV2ZWwtMSl0aGlzLnN1Ym5vZGVbZV09dDtlbHNle3ZhciBuPXRoaXMuY3JlYXRlU3Vibm9kZShlKTtuLmluc2VydE5vZGUodCksdGhpcy5zdWJub2RlW2VdPW59fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHaX19KSxHaS5jcmVhdGVOb2RlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBGaSh0KSxuPW5ldyBHaShlLmdldEVudmVsb3BlKCksZS5nZXRMZXZlbCgpKTtyZXR1cm4gbn0sR2kuY3JlYXRlRXhwYW5kZWQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgQyhlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5lbnYpO3ZhciBpPUdpLmNyZWF0ZU5vZGUobik7cmV0dXJuIG51bGwhPT10JiZpLmluc2VydE5vZGUodCksaX0saChxaSxBaSksZShxaS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUpe3ZhciBuPUFpLmdldFN1Ym5vZGVJbmRleCh0LHFpLm9yaWdpbi54LHFpLm9yaWdpbi55KTtpZigtMT09PW4pcmV0dXJuIHRoaXMuYWRkKGUpLG51bGw7dmFyIGk9dGhpcy5zdWJub2RlW25dO2lmKG51bGw9PT1pfHwhaS5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKHQpKXt2YXIgcj1HaS5jcmVhdGVFeHBhbmRlZChpLHQpO3RoaXMuc3Vibm9kZVtuXT1yfXRoaXMuaW5zZXJ0Q29udGFpbmVkKHRoaXMuc3Vibm9kZVtuXSx0LGUpfSxpc1NlYXJjaE1hdGNoOmZ1bmN0aW9uKHQpe3JldHVybiEwfSxpbnNlcnRDb250YWluZWQ6ZnVuY3Rpb24odCxlLG4pe2YuaXNUcnVlKHQuZ2V0RW52ZWxvcGUoKS5jb250YWlucyhlKSk7dmFyIGk9bWkuaXNaZXJvV2lkdGgoZS5nZXRNaW5YKCksZS5nZXRNYXhYKCkpLHI9bWkuaXNaZXJvV2lkdGgoZS5nZXRNaW5ZKCksZS5nZXRNYXhZKCkpLHM9bnVsbDtzPWl8fHI/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxzLmFkZChuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcWl9fSkscWkub3JpZ2luPW5ldyBnKDAsMCksZShCaS5wcm90b3R5cGUse3NpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3Quc2l6ZSgpOjB9LGluc2VydDpmdW5jdGlvbih0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO3ZhciBuPUJpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTt0aGlzLnJvb3QuaW5zZXJ0KG4sZSl9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBZbjtyZXR1cm4gdGhpcy5xdWVyeSh0LGUpLGUuZ2V0SXRlbXMoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMucm9vdC52aXNpdChuLGkpfX0scXVlcnlBbGw6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTtyZXR1cm4gdGhpcy5yb290LmFkZEFsbEl0ZW1zKHQpLHR9LHJlbW92ZTpmdW5jdGlvbih0LGUpe3ZhciBuPUJpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTtyZXR1cm4gdGhpcy5yb290LnJlbW92ZShuLGUpfSxjb2xsZWN0U3RhdHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpO2U8dGhpcy5taW5FeHRlbnQmJmU+MCYmKHRoaXMubWluRXh0ZW50PWUpO3ZhciBuPXQuZ2V0SGVpZ2h0KCk7bjx0aGlzLm1pbkV4dGVudCYmbj4wJiYodGhpcy5taW5FeHRlbnQ9bil9LGRlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290LmRlcHRoKCk6MH0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yb290fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltGZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQml9fSksQmkuZW5zdXJlRXh0ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRNaW5YKCksaT10LmdldE1heFgoKSxyPXQuZ2V0TWluWSgpLHM9dC5nZXRNYXhZKCk7cmV0dXJuIG4hPT1pJiZyIT09cz90OihuPT09aSYmKG4tPWUvMixpPW4rZS8yKSxyPT09cyYmKHItPWUvMixzPXIrZS8yKSxuZXcgQyhuLGkscixzKSl9LEJpLnNlcmlhbFZlcnNpb25VSUQ9LTB4Njc4YjYwYzk2N2EyNTQwMDt2YXIgdm89T2JqZWN0LmZyZWV6ZSh7UXVhZHRyZWU6Qml9KSxtbz1PYmplY3QuZnJlZXplKHtTVFJ0cmVlOmtlfSkseW89T2JqZWN0LmZyZWV6ZSh7cXVhZHRyZWU6dm8sc3RydHJlZTptb30pLHhvPVtcIlBvaW50XCIsXCJNdWx0aVBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJNdWx0aUxpbmVTdHJpbmdcIixcIlBvbHlnb25cIixcIk11bHRpUG9seWdvblwiXTtlKHppLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT12b2lkIDA7ZT1cInN0cmluZ1wiPT10eXBlb2YgdD9KU09OLnBhcnNlKHQpOnQ7dmFyIG49ZS50eXBlO2lmKCFFb1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrZS50eXBlKTtyZXR1cm4tMSE9PXhvLmluZGV4T2Yobik/RW9bbl0uYXBwbHkodGhpcyxbZS5jb29yZGluYXRlc10pOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT1uP0VvW25dLmFwcGx5KHRoaXMsW2UuZ2VvbWV0cmllc10pOkVvW25dLmFwcGx5KHRoaXMsW2VdKX0sd3JpdGU6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRHZW9tZXRyeVR5cGUoKTtpZighSW9bZV0pdGhyb3cgbmV3IEVycm9yKFwiR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gSW9bZV0uYXBwbHkodGhpcyxbdF0pfX0pO3ZhciBFbz17RmVhdHVyZTpmdW5jdGlvbih0KXt2YXIgZT17fTtmb3IodmFyIG4gaW4gdCllW25dPXRbbl07aWYodC5nZW9tZXRyeSl7dmFyIGk9dC5nZW9tZXRyeS50eXBlO2lmKCFFb1tpXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrdC50eXBlKTtlLmdlb21ldHJ5PXRoaXMucmVhZCh0Lmdlb21ldHJ5KX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PUVvLmJib3guYXBwbHkodGhpcyxbdC5iYm94XSkpLGV9LEZlYXR1cmVDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXt9O2lmKHQuZmVhdHVyZXMpe2UuZmVhdHVyZXM9W107Zm9yKHZhciBuPTA7bjx0LmZlYXR1cmVzLmxlbmd0aDsrK24pZS5mZWF0dXJlcy5wdXNoKHRoaXMucmVhZCh0LmZlYXR1cmVzW25dKSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD10aGlzLnBhcnNlLmJib3guYXBwbHkodGhpcyxbdC5iYm94XSkpLGV9LGNvb3JkaW5hdGVzOmZ1bmN0aW9uIFlvKHQpe2Zvcih2YXIgWW89W10sZT0wO2U8dC5sZW5ndGg7KytlKXt2YXIgbj10W2VdO1lvLnB1c2gobmV3IGcoblswXSxuWzFdKSl9cmV0dXJuIFlvfSxiYm94OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgZyh0WzBdLHRbMV0pLG5ldyBnKHRbMl0sdFsxXSksbmV3IGcodFsyXSx0WzNdKSxuZXcgZyh0WzBdLHRbM10pLG5ldyBnKHRbMF0sdFsxXSldKX0sUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodFswXSx0WzFdKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSl9LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbillLnB1c2goRW8uUG9pbnQuYXBwbHkodGhpcyxbdFtuXV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT1Fby5jb29yZGluYXRlcy5hcHBseSh0aGlzLFt0XSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZSl9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKWUucHVzaChFby5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsW3Rbbl1dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9RW8uY29vcmRpbmF0ZXMuYXBwbHkodGhpcyxbdFswXV0pLG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhlKSxpPVtdLHI9MTtyPHQubGVuZ3RoOysrcil7dmFyIHM9dFtyXSxvPUVvLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsW3NdKSxhPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobyk7aS5wdXNoKGEpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4saSl9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKXt2YXIgaT10W25dO2UucHVzaChFby5Qb2x5Z29uLmFwcGx5KHRoaXMsW2ldKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBpPXRbbl07ZS5wdXNoKHRoaXMucmVhZChpKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX19LElvPXtjb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVyblt0LngsdC55XX0sUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9SW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFt0LmdldENvb3JkaW5hdGUoKV0pO3JldHVybnt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczplfX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPUlvLlBvaW50LmFwcGx5KHRoaXMsW2ldKTtlLnB1c2goci5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvaW50XCIsY29vcmRpbmF0ZXM6ZX19LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49dC5nZXRDb29yZGluYXRlcygpLGk9MDtpPG4ubGVuZ3RoOysraSl7dmFyIHI9bltpXTtlLnB1c2goSW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFtyXSkpfXJldHVybnt0eXBlOlwiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7KytuKXt2YXIgaT10Lmdlb21ldHJpZXNbbl0scj1Jby5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsW2ldKTtlLnB1c2goci5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aUxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sUG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT1bXSxuPUlvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbdC5zaGVsbF0pO2UucHVzaChuLmNvb3JkaW5hdGVzKTtmb3IodmFyIGk9MDtpPHQuaG9sZXMubGVuZ3RoOysraSl7dmFyIHI9dC5ob2xlc1tpXSxzPUlvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbcl0pO2UucHVzaChzLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIlBvbHlnb25cIixjb29yZGluYXRlczplfX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoOysrbil7dmFyIGk9dC5nZW9tZXRyaWVzW25dLHI9SW8uUG9seWdvbi5hcHBseSh0aGlzLFtpXSk7ZS5wdXNoKHIuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPWkuZ2V0R2VvbWV0cnlUeXBlKCk7ZS5wdXNoKElvW3JdLmFwcGx5KHRoaXMsW2ldKSl9cmV0dXJue3R5cGU6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixnZW9tZXRyaWVzOmV9fX07ZShWaS5wcm90b3R5cGUse3JlYWQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wYXJzZXIucmVhZCh0KTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5nZXRUeXBlKCk9PT1lZS5GSVhFRCYmdGhpcy5yZWR1Y2VQcmVjaXNpb24oZSksZX0scmVkdWNlUHJlY2lzaW9uOmZ1bmN0aW9uKHQpe3ZhciBlLG47aWYodC5jb29yZGluYXRlKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5jb29yZGluYXRlKTtlbHNlIGlmKHQucG9pbnRzKWZvcihlPTAsbj10LnBvaW50cy5sZW5ndGg7bj5lO2UrKyl0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHQucG9pbnRzW2VdKTtlbHNlIGlmKHQuZ2VvbWV0cmllcylmb3IoZT0wLG49dC5nZW9tZXRyaWVzLmxlbmd0aDtuPmU7ZSsrKXRoaXMucmVkdWNlUHJlY2lzaW9uKHQuZ2VvbWV0cmllc1tlXSl9fSksZShraS5wcm90b3R5cGUse3dyaXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX19KSxlKFlpLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnBhcnNlci5yZWFkKHQpO3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsLmdldFR5cGUoKT09PWVlLkZJWEVEJiZ0aGlzLnJlZHVjZVByZWNpc2lvbihlKSxlfSxyZWR1Y2VQcmVjaXNpb246ZnVuY3Rpb24odCl7aWYodC5jb29yZGluYXRlKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5jb29yZGluYXRlKTtlbHNlIGlmKHQucG9pbnRzKWZvcih2YXIgZT0wLG49dC5wb2ludHMuY29vcmRpbmF0ZXMubGVuZ3RoO24+ZTtlKyspdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0LnBvaW50cy5jb29yZGluYXRlc1tlXSk7ZWxzZSBpZih0Lmdlb21ldHJpZXMpZm9yKHZhciBpPTAscj10Lmdlb21ldHJpZXMubGVuZ3RoO3I+aTtpKyspdGhpcy5yZWR1Y2VQcmVjaXNpb24odC5nZW9tZXRyaWVzW2ldKX19KSxlKFhpLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIG9sLmdlb20uUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLkxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTGluZWFyUmluZz90aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5Qb2x5Z29uP3RoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLk11bHRpUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9pbnQodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTXVsdGlMaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21NdWx0aUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTXVsdGlQb2x5Z29uP3RoaXMuY29udmVydEZyb21NdWx0aVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uP3RoaXMuY29udmVydEZyb21Db2xsZWN0aW9uKHQpOnZvaWQgMH0sY29udmVydEZyb21Qb2ludDpmdW5jdGlvbih0KXt2YXIgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBnKGVbMF0sZVsxXSkpfSxjb252ZXJ0RnJvbUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodFswXSx0WzFdKX0pKX0sY29udmVydEZyb21MaW5lYXJSaW5nOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKHRbMF0sdFsxXSl9KSl9LGNvbnZlcnRGcm9tUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRMaW5lYXJSaW5ncygpLG49bnVsbCxpPVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIHM9dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcoZVtyXSk7MD09PXI/bj1zOmkucHVzaChzKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLGkpfSxjb252ZXJ0RnJvbU11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRQb2ludHMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2ludCh0KX0sdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9LGNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0TGluZVN0cmluZ3MoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxjb252ZXJ0RnJvbU11bHRpUG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT10LmdldFBvbHlnb25zKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KX0sdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sY29udmVydEZyb21Db2xsZWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0R2VvbWV0cmllcygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkKHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfSx3cml0ZTpmdW5jdGlvbih0KXtyZXR1cm5cIlBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9pbnQodC5nZXRDb29yZGluYXRlKCkpOlwiTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodCk6XCJMaW5lYXJSaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZWFyUmluZyh0KTpcIlBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQpOlwiTXVsdGlQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9pbnQodCk6XCJNdWx0aUxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCk6XCJNdWx0aVBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvbHlnb24odCk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Db2xsZWN0aW9uKHQpOnZvaWQgMH0sY29udmVydFRvUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBvbC5nZW9tLlBvaW50KFt0LngsdC55XSl9LGNvbnZlcnRUb0xpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludHMuY29vcmRpbmF0ZXMubWFwKFVpKTtyZXR1cm4gbmV3IG9sLmdlb20uTGluZVN0cmluZyhlKX0sY29udmVydFRvTGluZWFyUmluZzpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50cy5jb29yZGluYXRlcy5tYXAoVWkpO3JldHVybiBuZXcgb2wuZ2VvbS5MaW5lYXJSaW5nKGUpfSxjb252ZXJ0VG9Qb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bdC5zaGVsbC5wb2ludHMuY29vcmRpbmF0ZXMubWFwKFVpKV0sbj0wO248dC5ob2xlcy5sZW5ndGg7bisrKWUucHVzaCh0LmhvbGVzW25dLnBvaW50cy5jb29yZGluYXRlcy5tYXAoVWkpKTtyZXR1cm4gbmV3IG9sLmdlb20uUG9seWdvbihlKX0sY29udmVydFRvTXVsdGlQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IG9sLmdlb20uTXVsdGlQb2ludCh0LmdldENvb3JkaW5hdGVzKCkubWFwKFVpKSl9LGNvbnZlcnRUb011bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvTGluZVN0cmluZyh0Lmdlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgb2wuZ2VvbS5NdWx0aUxpbmVTdHJpbmcoZSl9LGNvbnZlcnRUb011bHRpUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvUG9seWdvbih0Lmdlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgb2wuZ2VvbS5NdWx0aVBvbHlnb24oZSl9LGNvbnZlcnRUb0NvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7bisrKXt2YXIgaT10Lmdlb21ldHJpZXNbbl07ZS5wdXNoKHRoaXMud3JpdGUoaSkpfXJldHVybiBuZXcgb2wuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSk7dmFyIE5vPU9iamVjdC5mcmVlemUoe0dlb0pTT05SZWFkZXI6VmksR2VvSlNPTldyaXRlcjpraSxPTDNQYXJzZXI6WGksV0tUUmVhZGVyOllpLFdLVFdyaXRlcjpzZX0pO2UoSGkucHJvdG90eXBlLHtyZXNjYWxlOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMucmVzY2FsZShuLmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9bnVsbCxzPW51bGw7Mj09PWkubGVuZ3RoJiYocj1uZXcgZyhpWzBdKSxzPW5ldyBnKGlbMV0pKTtmb3IodmFyIGU9MDtlPGkubGVuZ3RoO2UrKylpW2VdLng9aVtlXS54L3RoaXMuc2NhbGVGYWN0b3IrdGhpcy5vZmZzZXRYLGlbZV0ueT1pW2VdLnkvdGhpcy5zY2FsZUZhY3Rvcit0aGlzLm9mZnNldFk7Mj09PWkubGVuZ3RoJiZpWzBdLmVxdWFsczJEKGlbMV0pJiZBLm91dC5wcmludGxuKGkpfX0sc2NhbGU6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5hZGQobmV3IEtlKHRoaXMuc2NhbGUoaS5nZXRDb29yZGluYXRlcygpKSxpLmdldERhdGEoKSkpfXJldHVybiBlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgcj1hcmd1bWVudHNbMF0scz1uZXcgQXJyYXkoci5sZW5ndGgpLmZpbGwobnVsbCksbj0wO248ci5sZW5ndGg7bisrKXNbbl09bmV3IGcoTWF0aC5yb3VuZCgocltuXS54LXRoaXMub2Zmc2V0WCkqdGhpcy5zY2FsZUZhY3RvciksTWF0aC5yb3VuZCgocltuXS55LXRoaXMub2Zmc2V0WSkqdGhpcy5zY2FsZUZhY3RvcikscltuXS56KTt2YXIgbz1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHMpO3JldHVybiBvfX0saXNJbnRlZ2VyUHJlY2lzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLnNjYWxlRmFjdG9yfSxnZXROb2RlZFN1YnN0cmluZ3M6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm5vZGVyLmdldE5vZGVkU3Vic3RyaW5ncygpO3JldHVybiB0aGlzLmlzU2NhbGVkJiZ0aGlzLnJlc2NhbGUodCksdH0sY29tcHV0ZU5vZGVzOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5pc1NjYWxlZCYmKGU9dGhpcy5zY2FsZSh0KSksdGhpcy5ub2Rlci5jb21wdXRlTm9kZXMoZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3RuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSGl9fSk7dmFyIENvPU9iamVjdC5mcmVlemUoe01DSW5kZXhOb2RlcjpubixTY2FsZWROb2RlcjpIaSxTZWdtZW50U3RyaW5nOmJlfSk7ZShXaS5wcm90b3R5cGUse2lzU2ltcGxlTXVsdGlQb2ludDpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtmb3IodmFyIGU9bmV3IGF0LG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dC5nZXRHZW9tZXRyeU4obikscj1pLmdldENvb3JkaW5hdGUoKTtpZihlLmNvbnRhaW5zKHIpKXJldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPXIsITE7ZS5hZGQocil9cmV0dXJuITB9LGlzU2ltcGxlUG9seWdvbmFsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1rbi5nZXRMaW5lcyh0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKCF0aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkoaSkpcmV0dXJuITF9cmV0dXJuITB9LGhhc0Nsb3NlZEVuZHBvaW50SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgcnQsbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj0oaS5nZXRNYXhpbXVtU2VnbWVudEluZGV4KCksaS5pc0Nsb3NlZCgpKSxzPWkuZ2V0Q29vcmRpbmF0ZSgwKTt0aGlzLmFkZEVuZHBvaW50KGUscyxyKTt2YXIgbz1pLmdldENvb3JkaW5hdGUoaS5nZXROdW1Qb2ludHMoKS0xKTt0aGlzLmFkZEVuZHBvaW50KGUsbyxyKX1mb3IodmFyIG49ZS52YWx1ZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGE9bi5uZXh0KCk7aWYoYS5pc0Nsb3NlZCYmMiE9PWEuZGVncmVlKXJldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPWEuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfSxnZXROb25TaW1wbGVMb2NhdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9ufSxpc1NpbXBsZUxpbmVhckdlb21ldHJ5OmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO3ZhciBlPW5ldyAkbigwLHQpLG49bmV3IGFlLGk9ZS5jb21wdXRlU2VsZk5vZGVzKG4sITApO3JldHVybiBpLmhhc0ludGVyc2VjdGlvbigpP2kuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMubm9uU2ltcGxlTG9jYXRpb249aS5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKTp0aGlzLmhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uKGUpPyExOiF0aGlzLmlzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcnx8IXRoaXMuaGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSk6ITB9LGhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldE1heGltdW1TZWdtZW50SW5kZXgoKSxyPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYoIXMuaXNFbmRQb2ludChpKSlyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1zLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX0sYWRkRW5kcG9pbnQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0KGUpO251bGw9PT1pJiYoaT1uZXcgamkoZSksdC5wdXQoZSxpKSksaS5hZGRFbmRwb2ludChuKX0sY29tcHV0ZVNpbXBsZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1udWxsLHQuaXNFbXB0eSgpPyEwOnQgaW5zdGFuY2VvZiBTdD90aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCk6dCBpbnN0YW5jZW9mIGd0P3RoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KTp0IGluc3RhbmNlb2YgUHQ/dGhpcy5pc1NpbXBsZU11bHRpUG9pbnQodCk6Uih0LFJ0KT90aGlzLmlzU2ltcGxlUG9seWdvbmFsKHQpOnQgaW5zdGFuY2VvZiBmdD90aGlzLmlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uKHQpOiEwfSxpc1NpbXBsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPW51bGwsdGhpcy5jb21wdXRlU2ltcGxlKHRoaXMuaW5wdXRHZW9tKX0saXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmNvbXB1dGVTaW1wbGUobikpcmV0dXJuITF9cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdpfX0pLGUoamkucHJvdG90eXBlLHthZGRFbmRwb2ludDpmdW5jdGlvbih0KXt0aGlzLmRlZ3JlZSsrLHRoaXMuaXNDbG9zZWR8PXR9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaml9fSksV2kuRW5kcG9pbnRJbmZvPWppLGUoS2kucHJvdG90eXBlLHtnZXRFbmRDYXBTdHlsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZENhcFN0eWxlfSxpc1NpbmdsZVNpZGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzU2luZ2xlU2lkZWR9LHNldFF1YWRyYW50U2VnbWVudHM6ZnVuY3Rpb24odCl7dGhpcy5xdWFkcmFudFNlZ21lbnRzPXQsMD09PXRoaXMucXVhZHJhbnRTZWdtZW50cyYmKHRoaXMuam9pblN0eWxlPUtpLkpPSU5fQkVWRUwpLHRoaXMucXVhZHJhbnRTZWdtZW50czwwJiYodGhpcy5qb2luU3R5bGU9S2kuSk9JTl9NSVRSRSx0aGlzLm1pdHJlTGltaXQ9TWF0aC5hYnModGhpcy5xdWFkcmFudFNlZ21lbnRzKSksMD49dCYmKHRoaXMucXVhZHJhbnRTZWdtZW50cz0xKSx0aGlzLmpvaW5TdHlsZSE9PUtpLkpPSU5fUk9VTkQmJih0aGlzLnF1YWRyYW50U2VnbWVudHM9S2kuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyl9LGdldEpvaW5TdHlsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmpvaW5TdHlsZX0sc2V0Sm9pblN0eWxlOmZ1bmN0aW9uKHQpe3RoaXMuam9pblN0eWxlPXR9LHNldFNpbXBsaWZ5RmFjdG9yOmZ1bmN0aW9uKHQpe3RoaXMuc2ltcGxpZnlGYWN0b3I9MD50PzA6dH0sZ2V0U2ltcGxpZnlGYWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaW1wbGlmeUZhY3Rvcn0sZ2V0UXVhZHJhbnRTZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnF1YWRyYW50U2VnbWVudHN9LHNldEVuZENhcFN0eWxlOmZ1bmN0aW9uKHQpe3RoaXMuZW5kQ2FwU3R5bGU9dH0sZ2V0TWl0cmVMaW1pdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pdHJlTGltaXR9LHNldE1pdHJlTGltaXQ6ZnVuY3Rpb24odCl7dGhpcy5taXRyZUxpbWl0PXR9LHNldFNpbmdsZVNpZGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzU2luZ2xlU2lkZWQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS2l9fSksS2kuYnVmZmVyRGlzdGFuY2VFcnJvcj1mdW5jdGlvbih0KXt2YXIgZT1NYXRoLlBJLzIvdDtyZXR1cm4gMS1NYXRoLmNvcyhlLzIpfSxLaS5DQVBfUk9VTkQ9MSxLaS5DQVBfRkxBVD0yLEtpLkNBUF9TUVVBUkU9MyxLaS5KT0lOX1JPVU5EPTEsS2kuSk9JTl9NSVRSRT0yLEtpLkpPSU5fQkVWRUw9MyxLaS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTPTgsS2kuREVGQVVMVF9NSVRSRV9MSU1JVD01LEtpLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SPS4wMSxlKFppLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbkNvb3JkfSxnZXRSaWdodG1vc3RTaWRlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZSk7cmV0dXJuIDA+biYmKG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZS0xKSksMD5uJiYodGhpcy5taW5Db29yZD1udWxsLHRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpKSxufSxmaW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmLmlzVHJ1ZSh0aGlzLm1pbkluZGV4PjAmJnRoaXMubWluSW5kZXg8dC5sZW5ndGgsXCJyaWdodG1vc3QgcG9pbnQgZXhwZWN0ZWQgdG8gYmUgaW50ZXJpb3IgdmVydGV4IG9mIGVkZ2VcIik7dmFyIGU9dFt0aGlzLm1pbkluZGV4LTFdLG49dFt0aGlzLm1pbkluZGV4KzFdLGk9aGUuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMubWluQ29vcmQsbixlKSxyPSExO2UueTx0aGlzLm1pbkNvb3JkLnkmJm4ueTx0aGlzLm1pbkNvb3JkLnkmJmk9PT1oZS5DT1VOVEVSQ0xPQ0tXSVNFP3I9ITA6ZS55PnRoaXMubWluQ29vcmQueSYmbi55PnRoaXMubWluQ29vcmQueSYmaT09PWhlLkNMT0NLV0lTRSYmKHI9ITApLHImJih0aGlzLm1pbkluZGV4PXRoaXMubWluSW5kZXgtMSl9LGdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldEVkZ2UoKSxpPW4uZ2V0Q29vcmRpbmF0ZXMoKTtpZigwPmV8fGUrMT49aS5sZW5ndGgpcmV0dXJuLTE7aWYoaVtlXS55PT09aVtlKzFdLnkpcmV0dXJuLTE7dmFyIHI9Y24uTEVGVDtyZXR1cm4gaVtlXS55PGlbZSsxXS55JiYocj1jbi5SSUdIVCkscn0sZ2V0RWRnZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWVudGVkRGV9LGNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuPTA7bjxlLmxlbmd0aC0xO24rKykobnVsbD09PXRoaXMubWluQ29vcmR8fGVbbl0ueD50aGlzLm1pbkNvb3JkLngpJiYodGhpcy5taW5EZT10LHRoaXMubWluSW5kZXg9bix0aGlzLm1pbkNvb3JkPWVbbl0pfSxmaW5kUmlnaHRtb3N0RWRnZUF0Tm9kZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWluRGUuZ2V0Tm9kZSgpLGU9dC5nZXRFZGdlcygpO3RoaXMubWluRGU9ZS5nZXRSaWdodG1vc3RFZGdlKCksdGhpcy5taW5EZS5pc0ZvcndhcmQoKXx8KHRoaXMubWluRGU9dGhpcy5taW5EZS5nZXRTeW0oKSx0aGlzLm1pbkluZGV4PXRoaXMubWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpfSxmaW5kRWRnZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5pc0ZvcndhcmQoKSYmdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUobil9Zi5pc1RydWUoMCE9PXRoaXMubWluSW5kZXh8fHRoaXMubWluQ29vcmQuZXF1YWxzKHRoaXMubWluRGUuZ2V0Q29vcmRpbmF0ZSgpKSxcImluY29uc2lzdGVuY3kgaW4gcmlnaHRtb3N0IHByb2Nlc3NpbmdcIiksMD09PXRoaXMubWluSW5kZXg/dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpOnRoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpLHRoaXMub3JpZW50ZWREZT10aGlzLm1pbkRlO3ZhciBpPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZSh0aGlzLm1pbkRlLHRoaXMubWluSW5kZXgpO2k9PT1jbi5MRUZUJiYodGhpcy5vcmllbnRlZERlPXRoaXMubWluRGUuZ2V0U3ltKCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBaaX19KSxRaS5wcm90b3R5cGUuYWRkTGFzdD1mdW5jdGlvbih0KXt0aGlzLmFycmF5Xy5wdXNoKHQpfSxRaS5wcm90b3R5cGUucmVtb3ZlRmlyc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8uc2hpZnQoKX0sUWkucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sZShKaS5wcm90b3R5cGUse2NsZWFyVmlzaXRlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2Uuc2V0VmlzaXRlZCghMSl9fSxnZXRSaWdodG1vc3RDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmlnaHRNb3N0Q29vcmR9LGNvbXB1dGVOb2RlRGVwdGg6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuaXNWaXNpdGVkKCl8fGkuZ2V0U3ltKCkuaXNWaXNpdGVkKCkpe2U9aTticmVha319aWYobnVsbD09PWUpdGhyb3cgbmV3IHNuKFwidW5hYmxlIHRvIGZpbmQgZWRnZSB0byBjb21wdXRlIGRlcHRocyBhdCBcIit0LmdldENvb3JkaW5hdGUoKSk7dC5nZXRFZGdlcygpLmNvbXB1dGVEZXB0aHMoZSk7Zm9yKHZhciBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5zZXRWaXNpdGVkKCEwKSx0aGlzLmNvcHlTeW1EZXB0aHMoaSl9fSxjb21wdXRlRGVwdGg6ZnVuY3Rpb24odCl7dGhpcy5jbGVhclZpc2l0ZWRFZGdlcygpO3ZhciBlPXRoaXMuZmluZGVyLmdldEVkZ2UoKTtlLmdldE5vZGUoKSxlLmdldExhYmVsKCk7ZS5zZXRFZGdlRGVwdGhzKGNuLlJJR0hULHQpLHRoaXMuY29weVN5bURlcHRocyhlKSx0aGlzLmNvbXB1dGVEZXB0aHMoZSl9LGNyZWF0ZTpmdW5jdGlvbih0KXt0aGlzLmFkZFJlYWNoYWJsZSh0KSx0aGlzLmZpbmRlci5maW5kRWRnZSh0aGlzLmRpckVkZ2VMaXN0KSx0aGlzLnJpZ2h0TW9zdENvb3JkPXRoaXMuZmluZGVyLmdldENvb3JkaW5hdGUoKX0sZmluZFJlc3VsdEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RGVwdGgoY24uUklHSFQpPj0xJiZlLmdldERlcHRoKGNuLkxFRlQpPD0wJiYhZS5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmZS5zZXRJblJlc3VsdCghMCl9fSxjb21wdXRlRGVwdGhzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBKLG49bmV3IFFpLGk9dC5nZXROb2RlKCk7Zm9yKG4uYWRkTGFzdChpKSxlLmFkZChpKSx0LnNldFZpc2l0ZWQoITApOyFuLmlzRW1wdHkoKTspe3ZhciByPW4ucmVtb3ZlRmlyc3QoKTtlLmFkZChyKSx0aGlzLmNvbXB1dGVOb2RlRGVwdGgocik7Zm9yKHZhciBzPXIuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksYT1vLmdldFN5bSgpO2lmKCFhLmlzVmlzaXRlZCgpKXt2YXIgdT1hLmdldE5vZGUoKTtlLmNvbnRhaW5zKHUpfHwobi5hZGRMYXN0KHUpLGUuYWRkKHUpKX19fX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMucmlnaHRNb3N0Q29vcmQueDxlLnJpZ2h0TW9zdENvb3JkLng/LTE6dGhpcy5yaWdodE1vc3RDb29yZC54PmUucmlnaHRNb3N0Q29vcmQueD8xOjB9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZW52KXtmb3IodmFyIHQ9bmV3IEMsZT10aGlzLmRpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCkscj0wO3I8aS5sZW5ndGgtMTtyKyspdC5leHBhbmRUb0luY2x1ZGUoaVtyXSk7dGhpcy5lbnY9dH1yZXR1cm4gdGhpcy5lbnZ9LGFkZFJlYWNoYWJsZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgcGU7Zm9yKGUuYWRkKHQpOyFlLmVtcHR5KCk7KXt2YXIgbj1lLnBvcCgpO3RoaXMuYWRkKG4sZSl9fSxjb3B5U3ltRGVwdGhzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0U3ltKCk7ZS5zZXREZXB0aChjbi5MRUZULHQuZ2V0RGVwdGgoY24uUklHSFQpKSxlLnNldERlcHRoKGNuLlJJR0hULHQuZ2V0RGVwdGgoY24uTEVGVCkpfSxhZGQ6ZnVuY3Rpb24odCxlKXt0LnNldFZpc2l0ZWQoITApLHRoaXMubm9kZXMuYWRkKHQpO2Zvcih2YXIgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuZGlyRWRnZUxpc3QuYWRkKGkpO3ZhciByPWkuZ2V0U3ltKCkscz1yLmdldE5vZGUoKTtzLmlzVmlzaXRlZCgpfHxlLnB1c2gocyl9fSxnZXROb2RlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzfSxnZXREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlyRWRnZUxpc3R9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBKaX19KSxlKCRpLnByb3RvdHlwZSx7aXNEZWxldGFibGU6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dGhpcy5pbnB1dExpbmVbdF0scz10aGlzLmlucHV0TGluZVtlXSxvPXRoaXMuaW5wdXRMaW5lW25dO3JldHVybiB0aGlzLmlzQ29uY2F2ZShyLHMsbykmJnRoaXMuaXNTaGFsbG93KHIscyxvLGkpP3RoaXMuaXNTaGFsbG93U2FtcGxlZChyLHMsdCxuLGkpOiExfSxkZWxldGVTaGFsbG93Q29uY2F2aXRpZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MSxlPSh0aGlzLmlucHV0TGluZS5sZW5ndGgtMSx0aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpKSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSksaT0hMTtuPHRoaXMuaW5wdXRMaW5lLmxlbmd0aDspe3ZhciByPSExO3RoaXMuaXNEZWxldGFibGUodCxlLG4sdGhpcy5kaXN0YW5jZVRvbCkmJih0aGlzLmlzRGVsZXRlZFtlXT0kaS5ERUxFVEUscj0hMCxpPSEwKSx0PXI/bjplLGU9dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSl9cmV0dXJuIGl9LGlzU2hhbGxvd0NvbmNhdml0eTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLG4pLHM9cj09PXRoaXMuYW5nbGVPcmllbnRhdGlvbjtpZighcylyZXR1cm4hMTt2YXIgbz1oZS5kaXN0YW5jZVBvaW50TGluZShlLHQsbik7cmV0dXJuIGk+b30saXNTaGFsbG93U2FtcGxlZDpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPU1hdGgudHJ1bmMoKGktbikvJGkuTlVNX1BUU19UT19DSEVDSyk7MD49cyYmKHM9MSk7Zm9yKHZhciBvPW47aT5vO28rPXMpaWYoIXRoaXMuaXNTaGFsbG93KHQsZSx0aGlzLmlucHV0TGluZVtvXSxyKSlyZXR1cm4hMTtyZXR1cm4hMH0saXNDb25jYXZlOmZ1bmN0aW9uIFVvKHQsZSxuKXt2YXIgaT1oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLG4pLFVvPWk9PT10aGlzLmFuZ2xlT3JpZW50YXRpb247cmV0dXJuIFVvfSxzaW1wbGlmeTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sPU1hdGguYWJzKHQpLDA+dCYmKHRoaXMuYW5nbGVPcmllbnRhdGlvbj1oZS5DTE9DS1dJU0UpLHRoaXMuaXNEZWxldGVkPW5ldyBBcnJheSh0aGlzLmlucHV0TGluZS5sZW5ndGgpLmZpbGwobnVsbCk7dmFyIGU9ITE7ZG8gZT10aGlzLmRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpO3doaWxlKGUpO3JldHVybiB0aGlzLmNvbGxhcHNlTGluZSgpfSxmaW5kTmV4dE5vbkRlbGV0ZWRJbmRleDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dCsxO2U8dGhpcy5pbnB1dExpbmUubGVuZ3RoJiZ0aGlzLmlzRGVsZXRlZFtlXT09PSRpLkRFTEVURTspZSsrO3JldHVybiBlfSxpc1NoYWxsb3c6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9aGUuZGlzdGFuY2VQb2ludExpbmUoZSx0LG4pO3JldHVybiBpPnJ9LGNvbGxhcHNlTGluZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgTixlPTA7ZTx0aGlzLmlucHV0TGluZS5sZW5ndGg7ZSsrKXRoaXMuaXNEZWxldGVkW2VdIT09JGkuREVMRVRFJiZ0LmFkZCh0aGlzLmlucHV0TGluZVtlXSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gJGl9fSksJGkuc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgJGkodCk7cmV0dXJuIG4uc2ltcGxpZnkoZSl9LCRpLklOSVQ9MCwkaS5ERUxFVEU9MSwkaS5LRUVQPTEsJGkuTlVNX1BUU19UT19DSEVDSz0xMCxlKHRyLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnB0TGlzdC50b0FycmF5KHRyLkNPT1JESU5BVEVfQVJSQVlfVFlQRSk7cmV0dXJuIHR9LHNldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKHQpe3RoaXMucHJlY2lzaW9uTW9kZWw9dH0sYWRkUHQ6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodCk7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoZSksdGhpcy5pc1JlZHVuZGFudChlKT9udWxsOnZvaWQgdGhpcy5wdExpc3QuYWRkKGUpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7fSxhZGRQdHM6ZnVuY3Rpb24odCxlKXtpZihlKWZvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXRoaXMuYWRkUHQodFtuXSk7ZWxzZSBmb3IodmFyIG49dC5sZW5ndGgtMTtuPj0wO24tLSl0aGlzLmFkZFB0KHRbbl0pfSxpc1JlZHVuZGFudDpmdW5jdGlvbih0KXtpZih0aGlzLnB0TGlzdC5zaXplKCk8MSlyZXR1cm4hMTt2YXIgZT10aGlzLnB0TGlzdC5nZXQodGhpcy5wdExpc3Quc2l6ZSgpLTEpLG49dC5kaXN0YW5jZShlKTtyZXR1cm4gbjx0aGlzLm1pbmltaW1WZXJ0ZXhEaXN0YW5jZX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgaWUsZT10LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gZS50b1N0cmluZygpfSxjbG9zZVJpbmc6ZnVuY3Rpb24oKXtpZih0aGlzLnB0TGlzdC5zaXplKCk8MSlyZXR1cm4gbnVsbDt2YXIgdD1uZXcgZyh0aGlzLnB0TGlzdC5nZXQoMCkpLGU9dGhpcy5wdExpc3QuZ2V0KHRoaXMucHRMaXN0LnNpemUoKS0xKSxuPW51bGw7cmV0dXJuIHRoaXMucHRMaXN0LnNpemUoKT49MiYmKG49dGhpcy5wdExpc3QuZ2V0KHRoaXMucHRMaXN0LnNpemUoKS0yKSksdC5lcXVhbHMoZSk/bnVsbDp2b2lkIHRoaXMucHRMaXN0LmFkZCh0KX0sc2V0TWluaW11bVZlcnRleERpc3RhbmNlOmZ1bmN0aW9uKHQpe3RoaXMubWluaW1pbVZlcnRleERpc3RhbmNlPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRyfX0pLHRyLkNPT1JESU5BVEVfQVJSQVlfVFlQRT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxlKGVyLnByb3RvdHlwZSx7YWRkTmV4dFNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtpZih0aGlzLnMwPXRoaXMuczEsdGhpcy5zMT10aGlzLnMyLHRoaXMuczI9dCx0aGlzLnNlZzAuc2V0Q29vcmRpbmF0ZXModGhpcy5zMCx0aGlzLnMxKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuc2VnMCx0aGlzLnNpZGUsdGhpcy5kaXN0YW5jZSx0aGlzLm9mZnNldDApLHRoaXMuc2VnMS5zZXRDb29yZGluYXRlcyh0aGlzLnMxLHRoaXMuczIpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5zZWcxLHRoaXMuc2lkZSx0aGlzLmRpc3RhbmNlLHRoaXMub2Zmc2V0MSksdGhpcy5zMS5lcXVhbHModGhpcy5zMikpcmV0dXJuIG51bGw7dmFyIG49aGUuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMuczAsdGhpcy5zMSx0aGlzLnMyKSxpPW49PT1oZS5DTE9DS1dJU0UmJnRoaXMuc2lkZT09PWNuLkxFRlR8fG49PT1oZS5DT1VOVEVSQ0xPQ0tXSVNFJiZ0aGlzLnNpZGU9PT1jbi5SSUdIVDswPT09bj90aGlzLmFkZENvbGxpbmVhcihlKTppP3RoaXMuYWRkT3V0c2lkZVR1cm4obixlKTp0aGlzLmFkZEluc2lkZVR1cm4obixlKX0sYWRkTGluZUVuZENhcDpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBjZSh0LGUpLGk9bmV3IGNlO3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixjbi5MRUZULHRoaXMuZGlzdGFuY2UsaSk7dmFyIHI9bmV3IGNlO3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixjbi5SSUdIVCx0aGlzLmRpc3RhbmNlLHIpO3ZhciBzPWUueC10Lngsbz1lLnktdC55LGE9TWF0aC5hdGFuMihvLHMpO3N3aXRjaCh0aGlzLmJ1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKXtjYXNlIEtpLkNBUF9ST1VORDp0aGlzLnNlZ0xpc3QuYWRkUHQoaS5wMSksdGhpcy5hZGRGaWxsZXRBcmMoZSxhK01hdGguUEkvMixhLU1hdGguUEkvMixoZS5DTE9DS1dJU0UsdGhpcy5kaXN0YW5jZSksdGhpcy5zZWdMaXN0LmFkZFB0KHIucDEpO2JyZWFrO2Nhc2UgS2kuQ0FQX0ZMQVQ6dGhpcy5zZWdMaXN0LmFkZFB0KGkucDEpLHRoaXMuc2VnTGlzdC5hZGRQdChyLnAxKTticmVhaztjYXNlIEtpLkNBUF9TUVVBUkU6dmFyIHU9bmV3IGc7dS54PU1hdGguYWJzKHRoaXMuZGlzdGFuY2UpKk1hdGguY29zKGEpLHUueT1NYXRoLmFicyh0aGlzLmRpc3RhbmNlKSpNYXRoLnNpbihhKTt2YXIgbD1uZXcgZyhpLnAxLngrdS54LGkucDEueSt1LnkpLGg9bmV3IGcoci5wMS54K3UueCxyLnAxLnkrdS55KTt0aGlzLnNlZ0xpc3QuYWRkUHQobCksdGhpcy5zZWdMaXN0LmFkZFB0KGgpfX0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNlZ0xpc3QuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdH0sYWRkTWl0cmVKb2luOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPSEwLHM9bnVsbDt0cnl7cz1GLmludGVyc2VjdGlvbihlLnAwLGUucDEsbi5wMCxuLnAxKTt2YXIgbz0wPj1pPzE6cy5kaXN0YW5jZSh0KS9NYXRoLmFicyhpKTtvPnRoaXMuYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSYmKHI9ITEpfWNhdGNoKGEpe2lmKCEoYSBpbnN0YW5jZW9mIHcpKXRocm93IGE7cz1uZXcgZygwLDApLHI9ITF9ZmluYWxseXt9cj90aGlzLnNlZ0xpc3QuYWRkUHQocyk6dGhpcy5hZGRMaW1pdGVkTWl0cmVKb2luKGUsbixpLHRoaXMuYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSl9LGFkZEZpbGxldENvcm5lcjpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPWUueC10Lngsbz1lLnktdC55LGE9TWF0aC5hdGFuMihvLHMpLHU9bi54LXQueCxsPW4ueS10LnksaD1NYXRoLmF0YW4yKGwsdSk7aT09PWhlLkNMT0NLV0lTRT9oPj1hJiYoYSs9MipNYXRoLlBJKTphPj1oJiYoYS09MipNYXRoLlBJKSx0aGlzLnNlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGRGaWxsZXRBcmModCxhLGgsaSxyKSx0aGlzLnNlZ0xpc3QuYWRkUHQobil9LGFkZE91dHNpZGVUdXJuOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMub2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLm9mZnNldDEucDApPHRoaXMuZGlzdGFuY2UqZXIuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1I/KHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLG51bGwpOnZvaWQodGhpcy5idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1LaS5KT0lOX01JVFJFP3RoaXMuYWRkTWl0cmVKb2luKHRoaXMuczEsdGhpcy5vZmZzZXQwLHRoaXMub2Zmc2V0MSx0aGlzLmRpc3RhbmNlKTp0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUtpLkpPSU5fQkVWRUw/dGhpcy5hZGRCZXZlbEpvaW4odGhpcy5vZmZzZXQwLHRoaXMub2Zmc2V0MSk6KGUmJnRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuYWRkRmlsbGV0Q29ybmVyKHRoaXMuczEsdGhpcy5vZmZzZXQwLnAxLHRoaXMub2Zmc2V0MS5wMCx0LHRoaXMuZGlzdGFuY2UpLHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApKSl9LGNyZWF0ZVNxdWFyZTpmdW5jdGlvbih0KXt0aGlzLnNlZ0xpc3QuYWRkUHQobmV3IGcodC54K3RoaXMuZGlzdGFuY2UsdC55K3RoaXMuZGlzdGFuY2UpKSx0aGlzLnNlZ0xpc3QuYWRkUHQobmV3IGcodC54K3RoaXMuZGlzdGFuY2UsdC55LXRoaXMuZGlzdGFuY2UpKSx0aGlzLnNlZ0xpc3QuYWRkUHQobmV3IGcodC54LXRoaXMuZGlzdGFuY2UsdC55LXRoaXMuZGlzdGFuY2UpKSx0aGlzLnNlZ0xpc3QuYWRkUHQobmV3IGcodC54LXRoaXMuZGlzdGFuY2UsdC55K3RoaXMuZGlzdGFuY2UpKSx0aGlzLnNlZ0xpc3QuY2xvc2VSaW5nKCl9LGFkZFNlZ21lbnRzOmZ1bmN0aW9uKHQsZSl7dGhpcy5zZWdMaXN0LmFkZFB0cyh0LGUpfSxhZGRGaXJzdFNlZ21lbnQ6ZnVuY3Rpb24oKXt0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQxLnAwKX0sYWRkTGFzdFNlZ21lbnQ6ZnVuY3Rpb24oKXt0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQxLnAxKX0saW5pdFNpZGVTZWdtZW50czpmdW5jdGlvbih0LGUsbil7dGhpcy5zMT10LHRoaXMuczI9ZSx0aGlzLnNpZGU9bix0aGlzLnNlZzEuc2V0Q29vcmRpbmF0ZXModCxlKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuc2VnMSxuLHRoaXMuZGlzdGFuY2UsdGhpcy5vZmZzZXQxKX0sYWRkTGltaXRlZE1pdHJlSm9pbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLnNlZzAucDEscz1DaS5hbmdsZShyLHRoaXMuc2VnMC5wMCksbz0oQ2kuYW5nbGUocix0aGlzLnNlZzEucDEpLENpLmFuZ2xlQmV0d2Vlbk9yaWVudGVkKHRoaXMuc2VnMC5wMCxyLHRoaXMuc2VnMS5wMSkpLGE9by8yLHU9Q2kubm9ybWFsaXplKHMrYSksbD1DaS5ub3JtYWxpemUodStNYXRoLlBJKSxoPWkqbixjPWgqTWF0aC5hYnMoTWF0aC5zaW4oYSkpLGY9bi1jLGQ9ci54K2gqTWF0aC5jb3MobCkscD1yLnkraCpNYXRoLnNpbihsKSx2PW5ldyBnKGQscCksbT1uZXcgY2Uocix2KSx5PW0ucG9pbnRBbG9uZ09mZnNldCgxLGYpLHg9bS5wb2ludEFsb25nT2Zmc2V0KDEsLWYpO1xudGhpcy5zaWRlPT09Y24uTEVGVD8odGhpcy5zZWdMaXN0LmFkZFB0KHkpLHRoaXMuc2VnTGlzdC5hZGRQdCh4KSk6KHRoaXMuc2VnTGlzdC5hZGRQdCh4KSx0aGlzLnNlZ0xpc3QuYWRkUHQoeSkpfSxjb21wdXRlT2Zmc2V0U2VnbWVudDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1lPT09Y24uTEVGVD8xOi0xLHM9dC5wMS54LXQucDAueCxvPXQucDEueS10LnAwLnksYT1NYXRoLnNxcnQocypzK28qbyksdT1yKm4qcy9hLGw9cipuKm8vYTtpLnAwLng9dC5wMC54LWwsaS5wMC55PXQucDAueSt1LGkucDEueD10LnAxLngtbCxpLnAxLnk9dC5wMS55K3V9LGFkZEZpbGxldEFyYzpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPWk9PT1oZS5DTE9DS1dJU0U/LTE6MSxvPU1hdGguYWJzKGUtbiksYT1NYXRoLnRydW5jKG8vdGhpcy5maWxsZXRBbmdsZVF1YW50dW0rLjUpO2lmKDE+YSlyZXR1cm4gbnVsbDt2YXIgdT1udWxsLGw9bnVsbDt1PTAsbD1vL2E7Zm9yKHZhciBoPXUsYz1uZXcgZztvPmg7KXt2YXIgZj1lK3MqaDtjLng9dC54K3IqTWF0aC5jb3MoZiksYy55PXQueStyKk1hdGguc2luKGYpLHRoaXMuc2VnTGlzdC5hZGRQdChjKSxoKz1sfX0sYWRkSW5zaWRlVHVybjpmdW5jdGlvbih0LGUpe2lmKHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLm9mZnNldDAucDAsdGhpcy5vZmZzZXQwLnAxLHRoaXMub2Zmc2V0MS5wMCx0aGlzLm9mZnNldDEucDEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkpdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtlbHNlIGlmKHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMCx0aGlzLm9mZnNldDAucDEuZGlzdGFuY2UodGhpcy5vZmZzZXQxLnAwKTx0aGlzLmRpc3RhbmNlKmVyLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQwLnAxKTtlbHNle2lmKHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj4wKXt2YXIgbj1uZXcgZygodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MC5wMS54K3RoaXMuczEueCkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MC5wMS55K3RoaXMuczEueSkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5zZWdMaXN0LmFkZFB0KG4pO3ZhciBpPW5ldyBnKCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQxLnAwLngrdGhpcy5zMS54KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQxLnAwLnkrdGhpcy5zMS55KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLnNlZ0xpc3QuYWRkUHQoaSl9ZWxzZSB0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5zMSk7dGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCl9fSxjcmVhdGVDaXJjbGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodC54K3RoaXMuZGlzdGFuY2UsdC55KTt0aGlzLnNlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGRGaWxsZXRBcmModCwwLDIqTWF0aC5QSSwtMSx0aGlzLmRpc3RhbmNlKSx0aGlzLnNlZ0xpc3QuY2xvc2VSaW5nKCl9LGFkZEJldmVsSm9pbjpmdW5jdGlvbih0LGUpe3RoaXMuc2VnTGlzdC5hZGRQdCh0LnAxKSx0aGlzLnNlZ0xpc3QuYWRkUHQoZS5wMCl9LGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZT10LHRoaXMubWF4Q3VydmVTZWdtZW50RXJyb3I9dCooMS1NYXRoLmNvcyh0aGlzLmZpbGxldEFuZ2xlUXVhbnR1bS8yKSksdGhpcy5zZWdMaXN0PW5ldyB0cix0aGlzLnNlZ0xpc3Quc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5wcmVjaXNpb25Nb2RlbCksdGhpcy5zZWdMaXN0LnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KmVyLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil9LGFkZENvbGxpbmVhcjpmdW5jdGlvbih0KXt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5zMCx0aGlzLnMxLHRoaXMuczEsdGhpcy5zMik7dmFyIGU9dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTtlPj0yJiYodGhpcy5idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1LaS5KT0lOX0JFVkVMfHx0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUtpLkpPSU5fTUlUUkU/KHQmJnRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApKTp0aGlzLmFkZEZpbGxldENvcm5lcih0aGlzLnMxLHRoaXMub2Zmc2V0MC5wMSx0aGlzLm9mZnNldDEucDAsaGUuQ0xPQ0tXSVNFLHRoaXMuZGlzdGFuY2UpKX0sY2xvc2VSaW5nOmZ1bmN0aW9uKCl7dGhpcy5zZWdMaXN0LmNsb3NlUmluZygpfSxoYXNOYXJyb3dDb25jYXZlQW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlcn19KSxlci5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj0uMDAxLGVyLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0uMDAxLGVyLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0xZS02LGVyLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SPTgwLGUobnIucHJvdG90eXBlLHtnZXRPZmZzZXRDdXJ2ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMuZGlzdGFuY2U9ZSwwPT09ZSlyZXR1cm4gbnVsbDt2YXIgbj0wPmUsaT1NYXRoLmFicyhlKSxyPXRoaXMuZ2V0U2VnR2VuKGkpO3QubGVuZ3RoPD0xP3RoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxyKTp0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZSh0LG4scik7dmFyIHM9ci5nZXRDb29yZGluYXRlcygpO3JldHVybiBuJiZILnJldmVyc2Uocyksc30sY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5kaXN0YW5jZSk7aWYoZSl7bi5hZGRTZWdtZW50cyh0LCEwKTt2YXIgcj0kaS5zaW1wbGlmeSh0LC1pKSxzPXIubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKHJbc10scltzLTFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPXMtMjtvPj0wO28tLSluLmFkZE5leHRTZWdtZW50KHJbb10sITApfWVsc2V7bi5hZGRTZWdtZW50cyh0LCExKTt2YXIgYT0kaS5zaW1wbGlmeSh0LGkpLHU9YS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoYVswXSxhWzFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPTI7dT49bztvKyspbi5hZGROZXh0U2VnbWVudChhW29dLCEwKX1uLmFkZExhc3RTZWdtZW50KCksbi5jbG9zZVJpbmcoKX0sY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKTtlPT09Y24uUklHSFQmJihpPS1pKTt2YXIgcj0kaS5zaW1wbGlmeSh0LGkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzLTFdLHJbMF0sZSk7Zm9yKHZhciBvPTE7cz49bztvKyspe3ZhciBhPTEhPT1vO24uYWRkTmV4dFNlZ21lbnQocltvXSxhKX1uLmNsb3NlUmluZygpfSxjb21wdXRlTGluZUJ1ZmZlckN1cnZlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKSxpPSRpLnNpbXBsaWZ5KHQsbikscj1pLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhpWzBdLGlbMV0sY24uTEVGVCk7Zm9yKHZhciBzPTI7cj49cztzKyspZS5hZGROZXh0U2VnbWVudChpW3NdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKGlbci0xXSxpW3JdKTt2YXIgbz0kaS5zaW1wbGlmeSh0LC1uKSxhPW8ubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKG9bYV0sb1thLTFdLGNuLkxFRlQpO2Zvcih2YXIgcz1hLTI7cz49MDtzLS0pZS5hZGROZXh0U2VnbWVudChvW3NdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKG9bMV0sb1swXSksZS5jbG9zZVJpbmcoKX0sY29tcHV0ZVBvaW50Q3VydmU6ZnVuY3Rpb24odCxlKXtzd2l0Y2godGhpcy5idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBLaS5DQVBfUk9VTkQ6ZS5jcmVhdGVDaXJjbGUodCk7YnJlYWs7Y2FzZSBLaS5DQVBfU1FVQVJFOmUuY3JlYXRlU3F1YXJlKHQpfX0sZ2V0TGluZUN1cnZlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5kaXN0YW5jZT1lLDA+ZSYmIXRoaXMuYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDtpZigwPT09ZSlyZXR1cm4gbnVsbDt2YXIgbj1NYXRoLmFicyhlKSxpPXRoaXMuZ2V0U2VnR2VuKG4pO2lmKHQubGVuZ3RoPD0xKXRoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxpKTtlbHNlIGlmKHRoaXMuYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSl7dmFyIHI9MD5lO3RoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxyLGkpfWVsc2UgdGhpcy5jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQsaSk7dmFyIHM9aS5nZXRDb29yZGluYXRlcygpO3JldHVybiBzfSxnZXRCdWZmZXJQYXJhbWV0ZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmUGFyYW1zfSxzaW1wbGlmeVRvbGVyYW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gdCp0aGlzLmJ1ZlBhcmFtcy5nZXRTaW1wbGlmeUZhY3RvcigpfSxnZXRSaW5nQ3VydmU6ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuZGlzdGFuY2U9bix0Lmxlbmd0aDw9MilyZXR1cm4gdGhpcy5nZXRMaW5lQ3VydmUodCxuKTtpZigwPT09bilyZXR1cm4gbnIuY29weUNvb3JkaW5hdGVzKHQpO3ZhciBpPXRoaXMuZ2V0U2VnR2VuKG4pO3JldHVybiB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLGkpLGkuZ2V0Q29vcmRpbmF0ZXMoKX0sY29tcHV0ZU9mZnNldEN1cnZlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuZGlzdGFuY2UpO2lmKGUpe3ZhciByPSRpLnNpbXBsaWZ5KHQsLWkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzXSxyW3MtMV0sY24uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IodmFyIG89cy0yO28+PTA7by0tKW4uYWRkTmV4dFNlZ21lbnQocltvXSwhMCl9ZWxzZXt2YXIgYT0kaS5zaW1wbGlmeSh0LGkpLHU9YS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoYVswXSxhWzFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPTI7dT49bztvKyspbi5hZGROZXh0U2VnbWVudChhW29dLCEwKX1uLmFkZExhc3RTZWdtZW50KCl9LGdldFNlZ0dlbjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGVyKHRoaXMucHJlY2lzaW9uTW9kZWwsdGhpcy5idWZQYXJhbXMsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5yfX0pLG5yLmNvcHlDb29yZGluYXRlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfSxlKGlyLnByb3RvdHlwZSx7ZmluZFN0YWJiZWRTZWdtZW50czpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEksbj10aGlzLnN1YmdyYXBocy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldEVudmVsb3BlKCk7dC55PHIuZ2V0TWluWSgpfHx0Lnk+ci5nZXRNYXhZKCl8fHRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LGkuZ2V0RGlyZWN0ZWRFZGdlcygpLGUpfXJldHVybiBlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSW4pZm9yKHZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPWFyZ3VtZW50c1syXSx1PW8uZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCksbj0wO248dS5sZW5ndGgtMTtuKyspe3RoaXMuc2VnLnAwPXVbbl0sdGhpcy5zZWcucDE9dVtuKzFdLHRoaXMuc2VnLnAwLnk+dGhpcy5zZWcucDEueSYmdGhpcy5zZWcucmV2ZXJzZSgpO3ZhciBsPU1hdGgubWF4KHRoaXMuc2VnLnAwLngsdGhpcy5zZWcucDEueCk7aWYoIShsPHMueHx8dGhpcy5zZWcuaXNIb3Jpem9udGFsKCl8fHMueTx0aGlzLnNlZy5wMC55fHxzLnk+dGhpcy5zZWcucDEueXx8aGUuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMuc2VnLnAwLHRoaXMuc2VnLnAxLHMpPT09aGUuUklHSFQpKXt2YXIgaD1vLmdldERlcHRoKGNuLkxFRlQpO3RoaXMuc2VnLnAwLmVxdWFscyh1W25dKXx8KGg9by5nZXREZXB0aChjbi5SSUdIVCkpO3ZhciBjPW5ldyBycih0aGlzLnNlZyxoKTthLmFkZChjKX19ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZSKGFyZ3VtZW50c1sxXSx5KSlmb3IodmFyIGY9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdLG49ZC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIHY9bi5uZXh0KCk7di5pc0ZvcndhcmQoKSYmdGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKGYsdixwKX19LGdldERlcHRoOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0KTtpZigwPT09ZS5zaXplKCkpcmV0dXJuIDA7dmFyIG49aG8ubWluKGUpO3JldHVybiBuLmxlZnREZXB0aH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaXJ9fSksZShyci5wcm90b3R5cGUse2NvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O2lmKHRoaXMudXB3YXJkU2VnLm1pblgoKT49ZS51cHdhcmRTZWcubWF4WCgpKXJldHVybiAxO2lmKHRoaXMudXB3YXJkU2VnLm1heFgoKTw9ZS51cHdhcmRTZWcubWluWCgpKXJldHVybi0xO3ZhciBuPXRoaXMudXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgoZS51cHdhcmRTZWcpO3JldHVybiAwIT09bj9uOihuPS0xKmUudXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy51cHdhcmRTZWcpLDAhPT1uP246dGhpcy51cHdhcmRTZWcuY29tcGFyZVRvKGUudXB3YXJkU2VnKSl9LGNvbXBhcmVYOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dC5wMS5jb21wYXJlVG8oZS5wMSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXB3YXJkU2VnLnRvU3RyaW5nKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBycn19KSxpci5EZXB0aFNlZ21lbnQ9cnIsZShzci5wcm90b3R5cGUse2FkZFBvaW50OmZ1bmN0aW9uKHQpe2lmKHRoaXMuZGlzdGFuY2U8PTApcmV0dXJuIG51bGw7dmFyIGU9dC5nZXRDb29yZGluYXRlcygpLG49dGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLEwuRVhURVJJT1IsTC5JTlRFUklPUil9LGFkZFBvbHlnb246ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kaXN0YW5jZSxuPWNuLkxFRlQ7dGhpcy5kaXN0YW5jZTwwJiYoZT0tdGhpcy5kaXN0YW5jZSxuPWNuLlJJR0hUKTt2YXIgaT10LmdldEV4dGVyaW9yUmluZygpLHI9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyhpLmdldENvb3JkaW5hdGVzKCkpO2lmKHRoaXMuZGlzdGFuY2U8MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkoaSx0aGlzLmRpc3RhbmNlKSlyZXR1cm4gbnVsbDtpZih0aGlzLmRpc3RhbmNlPD0wJiZyLmxlbmd0aDwzKXJldHVybiBudWxsO3RoaXMuYWRkUG9seWdvblJpbmcocixlLG4sTC5FWFRFUklPUixMLklOVEVSSU9SKTtmb3IodmFyIHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXt2YXIgbz10LmdldEludGVyaW9yUmluZ04ocyksYT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKG8uZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5kaXN0YW5jZT4wJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShvLC10aGlzLmRpc3RhbmNlKXx8dGhpcy5hZGRQb2x5Z29uUmluZyhhLGUsY24ub3Bwb3NpdGUobiksTC5JTlRFUklPUixMLkVYVEVSSU9SKX19LGlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5OmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFNpKHRbMF0sdFsxXSx0WzJdKSxpPW4uaW5DZW50cmUoKSxyPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGksbi5wMCxuLnAxKTtyZXR1cm4gcjxNYXRoLmFicyhlKX0sYWRkTGluZVN0cmluZzpmdW5jdGlvbih0KXtpZih0aGlzLmRpc3RhbmNlPD0wJiYhdGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0QnVmZmVyUGFyYW1ldGVycygpLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDt2YXIgZT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbj10aGlzLmN1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLmRpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sTC5FWFRFUklPUixMLklOVEVSSU9SKX0sYWRkQ3VydmU6ZnVuY3Rpb24odCxlLG4pe2lmKG51bGw9PT10fHx0Lmxlbmd0aDwyKXJldHVybiBudWxsO3ZhciBpPW5ldyBLZSh0LG5ldyBnbigwLEwuQk9VTkRBUlksZSxuKSk7dGhpcy5jdXJ2ZUxpc3QuYWRkKGkpfSxnZXRDdXJ2ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGQodGhpcy5pbnB1dEdlb20pLHRoaXMuY3VydmVMaXN0fSxhZGRQb2x5Z29uUmluZzpmdW5jdGlvbih0LGUsbixpLHIpe2lmKDA9PT1lJiZ0Lmxlbmd0aDxidC5NSU5JTVVNX1ZBTElEX1NJWkUpcmV0dXJuIG51bGw7dmFyIHM9aSxvPXI7dC5sZW5ndGg+PWJ0Lk1JTklNVU1fVkFMSURfU0laRSYmaGUuaXNDQ1codCkmJihzPXIsbz1pLG49Y24ub3Bwb3NpdGUobikpO3ZhciBhPXRoaXMuY3VydmVCdWlsZGVyLmdldFJpbmdDdXJ2ZSh0LG4sZSk7dGhpcy5hZGRDdXJ2ZShhLHMsbyl9LGFkZDpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBndCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgT3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fSxpc0Vyb2RlZENvbXBsZXRlbHk6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldENvb3JkaW5hdGVzKCk7aWYobi5sZW5ndGg8NClyZXR1cm4gMD5lO2lmKDQ9PT1uLmxlbmd0aClyZXR1cm4gdGhpcy5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseShuLGUpO3ZhciBpPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHI9TWF0aC5taW4oaS5nZXRIZWlnaHQoKSxpLmdldFdpZHRoKCkpO3JldHVybiAwPmUmJjIqTWF0aC5hYnMoZSk+cn0sYWRkQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzcn19KSxlKG9yLnByb3RvdHlwZSx7aXNUcml2aWFsSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQ9PT1uJiYxPT09dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYob3IuaXNBZGphY2VudFNlZ21lbnRzKGUsaSkpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXt2YXIgcj10LnNpemUoKS0xO2lmKDA9PT1lJiZpPT09cnx8MD09PWkmJmU9PT1yKXJldHVybiEwfX1yZXR1cm4hMX0sZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH0saGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNQcm9wZXJJbnRlcmlvcn0sZ2V0TGluZUludGVyc2VjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGl9LGhhc1Byb3BlckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3Blcn0scHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKzt2YXIgcj10LmdldENvb3JkaW5hdGVzKClbZV0scz10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpXSxhPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpKzFdO3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihyLHMsbyxhKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucysrLHRoaXMuaGFzSW50ZXJpb3I9ITApLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLGkpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksaSwxKSx0aGlzLmxpLmlzUHJvcGVyKCkmJih0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMrKyx0aGlzLmhhc1Byb3Blcj0hMCx0aGlzLmhhc1Byb3BlckludGVyaW9yPSEwKSkpfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0saGFzSW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcmlvcn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb25dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvcn19KSxvci5pc0FkamFjZW50U2VnbWVudHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9LGUoYXIucHJvdG90eXBlLHtzZXRXb3JraW5nUHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw9dH0saW5zZXJ0VW5pcXVlRWRnZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe3ZhciBuPWUuZ2V0TGFiZWwoKSxpPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChpPW5ldyBnbih0LmdldExhYmVsKCkpLGkuZmxpcCgpKSxuLm1lcmdlKGkpO3ZhciByPWFyLmRlcHRoRGVsdGEoaSkscz1lLmdldERlcHRoRGVsdGEoKSxvPXMrcjtlLnNldERlcHRoRGVsdGEobyl9ZWxzZSB0aGlzLmVkZ2VMaXN0LmFkZCh0KSx0LnNldERlcHRoRGVsdGEoYXIuZGVwdGhEZWx0YSh0LmdldExhYmVsKCkpKX0sYnVpbGRTdWJncmFwaHM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKSxzPXIuZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpLG89bmV3IGlyKG4pLGE9by5nZXREZXB0aChzKTtyLmNvbXB1dGVEZXB0aChhKSxyLmZpbmRSZXN1bHRFZGdlcygpLG4uYWRkKHIpLGUuYWRkKHIuZ2V0RGlyZWN0ZWRFZGdlcygpLHIuZ2V0Tm9kZXMoKSl9fSxjcmVhdGVTdWJncmFwaHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5nZXROb2RlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZighaS5pc1Zpc2l0ZWQoKSl7dmFyIHI9bmV3IEppO3IuY3JlYXRlKGkpLGUuYWRkKHIpfX1yZXR1cm4gaG8uc29ydChlLGhvLnJldmVyc2VPcmRlcigpKSxlfSxjcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCk7cmV0dXJuIHR9LGdldE5vZGVyOmZ1bmN0aW9uKHQpe2lmKG51bGwhPT10aGlzLndvcmtpbmdOb2RlcilyZXR1cm4gdGhpcy53b3JraW5nTm9kZXI7dmFyIGU9bmV3IG5uLG49bmV3IGFlO3JldHVybiBuLnNldFByZWNpc2lvbk1vZGVsKHQpLGUuc2V0U2VnbWVudEludGVyc2VjdG9yKG5ldyBvcihuKSksZX0sYnVmZmVyOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw7bnVsbD09PW4mJihuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5nZW9tRmFjdD10LmdldEZhY3RvcnkoKTt2YXIgaT1uZXcgbnIobix0aGlzLmJ1ZlBhcmFtcykscj1uZXcgc3IodCxlLGkpLHM9ci5nZXRDdXJ2ZXMoKTtpZihzLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dGhpcy5jb21wdXRlTm9kZWRFZGdlcyhzLG4pLHRoaXMuZ3JhcGg9bmV3IENuKG5ldyBPbiksdGhpcy5ncmFwaC5hZGRFZGdlcyh0aGlzLmVkZ2VMaXN0LmdldEVkZ2VzKCkpO3ZhciBvPXRoaXMuY3JlYXRlU3ViZ3JhcGhzKHRoaXMuZ3JhcGgpLGE9bmV3IFNuKHRoaXMuZ2VvbUZhY3QpO3RoaXMuYnVpbGRTdWJncmFwaHMobyxhKTt2YXIgdT1hLmdldFBvbHlnb25zKCk7aWYodS5zaXplKCk8PTApcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpO3ZhciBsPXRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh1KTtyZXR1cm4gbH0sY29tcHV0ZU5vZGVkRWRnZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldE5vZGVyKGUpO24uY29tcHV0ZU5vZGVzKHQpO2Zvcih2YXIgaT1uLmdldE5vZGVkU3Vic3RyaW5ncygpLHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldENvb3JkaW5hdGVzKCk7aWYoMiE9PW8ubGVuZ3RofHwhb1swXS5lcXVhbHMyRChvWzFdKSl7dmFyIGE9cy5nZXREYXRhKCksdT1uZXcgSm4ocy5nZXRDb29yZGluYXRlcygpLG5ldyBnbihhKSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKHUpfX19LHNldE5vZGVyOmZ1bmN0aW9uKHQpe3RoaXMud29ya2luZ05vZGVyPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFyfX0pLGFyLmRlcHRoRGVsdGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRMb2NhdGlvbigwLGNuLkxFRlQpLG49dC5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKTtyZXR1cm4gZT09PUwuSU5URVJJT1ImJm49PT1MLkVYVEVSSU9SPzE6ZT09PUwuRVhURVJJT1ImJm49PT1MLklOVEVSSU9SPy0xOjB9LGFyLmNvbnZlcnRTZWdTdHJpbmdzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgaWUsbj1uZXcgSTt0Lmhhc05leHQoKTspe3ZhciBpPXQubmV4dCgpLHI9ZS5jcmVhdGVMaW5lU3RyaW5nKGkuZ2V0Q29vcmRpbmF0ZXMoKSk7bi5hZGQocil9cmV0dXJuIGUuYnVpbGRHZW9tZXRyeShuKX0sZSh1ci5wcm90b3R5cGUse2NoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCk7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhuWzBdLHRoaXMuc2VnU3RyaW5ncyksdGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhuW24ubGVuZ3RoLTFdLHRoaXMuc2VnU3RyaW5ncyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHQ9ci5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOylmb3IodmFyIGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCkscz0xO3M8bi5sZW5ndGgtMTtzKyspaWYobltzXS5lcXVhbHMoaSkpdGhyb3cgbmV3IGwoXCJmb3VuZCBlbmRwdC9pbnRlcmlvciBwdCBpbnRlcnNlY3Rpb24gYXQgaW5kZXggXCIrcytcIiA6cHQgXCIraSl9LGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOylmb3IodmFyIGU9dC5uZXh0KCksbj10aGlzLnNlZ1N0cmluZ3MuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoZSxpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1yLmdldENvb3JkaW5hdGVzKCksYT1zLmdldENvb3JkaW5hdGVzKCksdT0wO3U8by5sZW5ndGgtMTt1KyspZm9yKHZhciBoPTA7aDxhLmxlbmd0aC0xO2grKyl0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHIsdSxzLGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBjPWFyZ3VtZW50c1swXSxmPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxkPWFyZ3VtZW50c1szXTtpZihjPT09ZyYmZj09PWQpcmV0dXJuIG51bGw7dmFyIHA9Yy5nZXRDb29yZGluYXRlcygpW2ZdLHY9Yy5nZXRDb29yZGluYXRlcygpW2YrMV0sbT1nLmdldENvb3JkaW5hdGVzKClbZF0seT1nLmdldENvb3JkaW5hdGVzKClbZCsxXTtpZih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocCx2LG0seSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMubGkuaXNQcm9wZXIoKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLmxpLHAsdil8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5saSxtLHkpKSl0aHJvdyBuZXcgbChcImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYXQgXCIrcCtcIi1cIit2K1wiIGFuZCBcIittK1wiLVwiK3kpfX0sY2hlY2tWYWxpZDpmdW5jdGlvbigpe3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0NvbGxhcHNlcygpfSxjaGVja0NvbGxhcHNlczpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD10aGlzLnNlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO3RoaXMuY2hlY2tDb2xsYXBzZXMoZSl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIG49YXJndW1lbnRzWzBdLGk9bi5nZXRDb29yZGluYXRlcygpLHQ9MDt0PGkubGVuZ3RoLTI7dCsrKXRoaXMuY2hlY2tDb2xsYXBzZShpW3RdLGlbdCsxXSxpW3QrMl0pfSxoYXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LmdldEludGVyc2VjdGlvbk51bSgpO2krKyl7dmFyIHI9dC5nZXRJbnRlcnNlY3Rpb24oaSk7aWYoIXIuZXF1YWxzKGUpJiYhci5lcXVhbHMobikpcmV0dXJuITB9cmV0dXJuITF9LGNoZWNrQ29sbGFwc2U6ZnVuY3Rpb24odCxlLG4pe2lmKHQuZXF1YWxzKG4pKXRocm93IG5ldyBsKFwiZm91bmQgbm9uLW5vZGVkIGNvbGxhcHNlIGF0IFwiK3VyLmZhY3QuY3JlYXRlTGluZVN0cmluZyhbdCxlLG5dKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVyfX0pLHVyLmZhY3Q9bmV3IGllLGUobHIucHJvdG90eXBlLHtpbnRlcnNlY3RzU2NhbGVkOmZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5taW4odC54LGUueCksaT1NYXRoLm1heCh0LngsZS54KSxyPU1hdGgubWluKHQueSxlLnkpLHM9TWF0aC5tYXgodC55LGUueSksbz10aGlzLm1heHg8bnx8dGhpcy5taW54Pml8fHRoaXMubWF4eTxyfHx0aGlzLm1pbnk+cztpZihvKXJldHVybiExO3ZhciBhPXRoaXMuaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpO3JldHVybiBmLmlzVHJ1ZSghKG8mJmEpLFwiRm91bmQgYmFkIGVudmVsb3BlIHRlc3RcIiksYX0saW5pdENvcm5lcnM6ZnVuY3Rpb24odCl7dmFyIGU9LjU7dGhpcy5taW54PXQueC1lLHRoaXMubWF4eD10LngrZSx0aGlzLm1pbnk9dC55LWUsdGhpcy5tYXh5PXQueStlLHRoaXMuY29ybmVyWzBdPW5ldyBnKHRoaXMubWF4eCx0aGlzLm1heHkpLHRoaXMuY29ybmVyWzFdPW5ldyBnKHRoaXMubWlueCx0aGlzLm1heHkpLHRoaXMuY29ybmVyWzJdPW5ldyBnKHRoaXMubWlueCx0aGlzLm1pbnkpLHRoaXMuY29ybmVyWzNdPW5ldyBnKHRoaXMubWF4eCx0aGlzLm1pbnkpfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIDE9PT10aGlzLnNjYWxlRmFjdG9yP3RoaXMuaW50ZXJzZWN0c1NjYWxlZCh0LGUpOih0aGlzLmNvcHlTY2FsZWQodCx0aGlzLnAwU2NhbGVkKSx0aGlzLmNvcHlTY2FsZWQoZSx0aGlzLnAxU2NhbGVkKSx0aGlzLmludGVyc2VjdHNTY2FsZWQodGhpcy5wMFNjYWxlZCx0aGlzLnAxU2NhbGVkKSl9LHNjYWxlOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqdGhpcy5zY2FsZUZhY3Rvcil9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcmlnaW5hbFB0fSxjb3B5U2NhbGVkOmZ1bmN0aW9uKHQsZSl7ZS54PXRoaXMuc2NhbGUodC54KSxlLnk9dGhpcy5zY2FsZSh0LnkpfSxnZXRTYWZlRW52ZWxvcGU6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5zYWZlRW52KXt2YXIgdD1sci5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SL3RoaXMuc2NhbGVGYWN0b3I7dGhpcy5zYWZlRW52PW5ldyBDKHRoaXMub3JpZ2luYWxQdC54LXQsdGhpcy5vcmlnaW5hbFB0LngrdCx0aGlzLm9yaWdpbmFsUHQueS10LHRoaXMub3JpZ2luYWxQdC55K3QpfXJldHVybiB0aGlzLnNhZmVFbnZ9LGludGVyc2VjdHNQaXhlbENsb3N1cmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclswXSx0aGlzLmNvcm5lclsxXSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKT8hMDoodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclsxXSx0aGlzLmNvcm5lclsyXSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKT8hMDoodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclsyXSx0aGlzLmNvcm5lclszXSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKT8hMDoodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclszXSx0aGlzLmNvcm5lclswXSksISF0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpKSkpfSxpbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ITEsaT0hMTtyZXR1cm4gdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclswXSx0aGlzLmNvcm5lclsxXSksdGhpcy5saS5pc1Byb3BlcigpPyEwOih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzFdLHRoaXMuY29ybmVyWzJdKSx0aGlzLmxpLmlzUHJvcGVyKCk/ITA6KHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJihuPSEwKSx0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzJdLHRoaXMuY29ybmVyWzNdKSx0aGlzLmxpLmlzUHJvcGVyKCk/ITA6KHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJihpPSEwKSx0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzNdLHRoaXMuY29ybmVyWzBdKSx0aGlzLmxpLmlzUHJvcGVyKCk/ITA6biYmaT8hMDp0LmVxdWFscyh0aGlzLnB0KT8hMDohIWUuZXF1YWxzKHRoaXMucHQpKSkpfSxhZGRTbmFwcGVkTm9kZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0Q29vcmRpbmF0ZShlKSxpPXQuZ2V0Q29vcmRpbmF0ZShlKzEpO3JldHVybiB0aGlzLmludGVyc2VjdHMobixpKT8odC5hZGRJbnRlcnNlY3Rpb24odGhpcy5nZXRDb29yZGluYXRlKCksZSksITApOiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBscn19KSxsci5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SPS43NSxlKGhyLnByb3RvdHlwZSx7c25hcDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc25hcCh0LG51bGwsLTEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1hcmd1bWVudHNbMl0scj1lLmdldFNhZmVFbnZlbG9wZSgpLHM9bmV3IGNyKGUsbixpKTtyZXR1cm4gdGhpcy5pbmRleC5xdWVyeShyLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LHZpc2l0SXRlbTpmdW5jdGlvbih0KXt2YXIgZT10O2Uuc2VsZWN0KHIscyl9fSkscy5pc05vZGVBZGRlZCgpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHJ9fSksaChjcixoaSksZShjci5wcm90b3R5cGUse2lzTm9kZUFkZGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzTm9kZUFkZGVkfSxzZWxlY3Q6ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaGkucHJvdG90eXBlLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRDb250ZXh0KCk7cmV0dXJuIG51bGwhPT10aGlzLnBhcmVudEVkZ2UmJm49PT10aGlzLnBhcmVudEVkZ2UmJmU9PT10aGlzLmhvdFBpeGVsVmVydGV4SW5kZXg/bnVsbDp2b2lkKHRoaXMuX2lzTm9kZUFkZGVkPXRoaXMuaG90UGl4ZWwuYWRkU25hcHBlZE5vZGUobixlKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNyfX0pLGhyLkhvdFBpeGVsU25hcEFjdGlvbj1jcixlKGZyLnByb3RvdHlwZSx7cHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO3ZhciByPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW2ldLGE9bi5nZXRDb29yZGluYXRlcygpW2krMV07aWYodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMubGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKXtmb3IodmFyIHU9MDt1PHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7dSsrKXRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zLmFkZCh0aGlzLmxpLmdldEludGVyc2VjdGlvbih1KSk7dC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5saSxpLDEpfX0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGdldEludGVyaW9ySW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb25dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmcn19KSxlKGdyLnByb3RvdHlwZSx7Y2hlY2tDb3JyZWN0bmVzczpmdW5jdGlvbih0KXt2YXIgZT1LZS5nZXROb2RlZFN1YnN0cmluZ3ModCksbj1uZXcgdXIoZSk7dHJ5e24uY2hlY2tWYWxpZCgpfWNhdGNoKGkpe2lmKCEoaSBpbnN0YW5jZW9mIFMpKXRocm93IGk7aS5wcmludFN0YWNrVHJhY2UoKX1maW5hbGx5e319LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe3JldHVybiBLZS5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5ub2RlZFNlZ1N0cmluZ3MpfSxzbmFwUm91bmQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyhuKSx0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyh0KX0sZmluZEludGVyaW9ySW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBmcihlKTtyZXR1cm4gdGhpcy5ub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IobiksdGhpcy5ub2Rlci5jb21wdXRlTm9kZXModCksbi5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKX0sY29tcHV0ZVZlcnRleFNuYXBzOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuY29tcHV0ZVZlcnRleFNuYXBzKG4pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLZSlmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9aS5nZXRDb29yZGluYXRlcygpLHM9MDtzPHIubGVuZ3RoO3MrKyl7dmFyIG89bmV3IGxyKHJbc10sdGhpcy5zY2FsZUZhY3Rvcix0aGlzLmxpKSxhPXRoaXMucG9pbnRTbmFwcGVyLnNuYXAobyxpLHMpO2EmJmkuYWRkSW50ZXJzZWN0aW9uKHJbc10scyl9fSxjb21wdXRlTm9kZXM6ZnVuY3Rpb24odCl7dGhpcy5ub2RlZFNlZ1N0cmluZ3M9dCx0aGlzLm5vZGVyPW5ldyBubix0aGlzLnBvaW50U25hcHBlcj1uZXcgaHIodGhpcy5ub2Rlci5nZXRJbmRleCgpKSx0aGlzLnNuYXBSb3VuZCh0LHRoaXMubGkpfSxjb21wdXRlSW50ZXJzZWN0aW9uU25hcHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bmV3IGxyKG4sdGhpcy5zY2FsZUZhY3Rvcix0aGlzLmxpKTt0aGlzLnBvaW50U25hcHBlci5zbmFwKGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdG5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBncn19KSxlKGRyLnByb3RvdHlwZSx7YnVmZmVyRml4ZWRQcmVjaXNpb246ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEhpKG5ldyBncihuZXcgZWUoMSkpLHQuZ2V0U2NhbGUoKSksbj1uZXcgYXIodGhpcy5idWZQYXJhbXMpO24uc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsKHQpLG4uc2V0Tm9kZXIoZSksdGhpcy5yZXN1bHRHZW9tZXRyeT1uLmJ1ZmZlcih0aGlzLmFyZ0dlb20sdGhpcy5kaXN0YW5jZSl9LGJ1ZmZlclJlZHVjZWRQcmVjaXNpb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWRyLk1BWF9QUkVDSVNJT05fRElHSVRTO3Q+PTA7dC0tKXt0cnl7dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKHQpfWNhdGNoKGUpe2lmKCEoZSBpbnN0YW5jZW9mIHNuKSl0aHJvdyBlO3RoaXMuc2F2ZUV4Y2VwdGlvbj1lfWZpbmFsbHl7fWlmKG51bGwhPT10aGlzLnJlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsfXRocm93IHRoaXMuc2F2ZUV4Y2VwdGlvbn1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9ZHIucHJlY2lzaW9uU2NhbGVGYWN0b3IodGhpcy5hcmdHZW9tLHRoaXMuZGlzdGFuY2Usbikscj1uZXcgZWUoaSk7dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbihyKX19LGNvbXB1dGVHZW9tZXRyeTpmdW5jdGlvbigpe2lmKHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKSxudWxsIT09dGhpcy5yZXN1bHRHZW9tZXRyeSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLmFyZ0dlb20uZ2V0RmFjdG9yeSgpLmdldFByZWNpc2lvbk1vZGVsKCk7dC5nZXRUeXBlKCk9PT1lZS5GSVhFRD90aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpOnRoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbigpfSxzZXRRdWFkcmFudFNlZ21lbnRzOmZ1bmN0aW9uKHQpe3RoaXMuYnVmUGFyYW1zLnNldFF1YWRyYW50U2VnbWVudHModCl9LGJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uOmZ1bmN0aW9uKCl7dHJ5e3ZhciB0PW5ldyBhcih0aGlzLmJ1ZlBhcmFtcyk7dGhpcy5yZXN1bHRHZW9tZXRyeT10LmJ1ZmZlcih0aGlzLmFyZ0dlb20sdGhpcy5kaXN0YW5jZSl9Y2F0Y2goZSl7aWYoIShlIGluc3RhbmNlb2YgbCkpdGhyb3cgZTt0aGlzLnNhdmVFeGNlcHRpb249ZX1maW5hbGx5e319LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRpc3RhbmNlPXQsdGhpcy5jb21wdXRlR2VvbWV0cnkoKSx0aGlzLnJlc3VsdEdlb21ldHJ5fSxzZXRFbmRDYXBTdHlsZTpmdW5jdGlvbih0KXt0aGlzLmJ1ZlBhcmFtcy5zZXRFbmRDYXBTdHlsZSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZHJ9fSksZHIuYnVmZmVyT3A9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGRyKHQpLGk9bi5nZXRSZXN1bHRHZW9tZXRyeShlKTtyZXR1cm4gaX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPW5ldyBkcihyKTthLnNldFF1YWRyYW50U2VnbWVudHMobyk7dmFyIGk9YS5nZXRSZXN1bHRHZW9tZXRyeShzKTtyZXR1cm4gaX1pZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEtpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB1PWFyZ3VtZW50c1swXSxsPWFyZ3VtZW50c1sxXSxoPWFyZ3VtZW50c1syXSxhPW5ldyBkcih1LGgpLGk9YS5nZXRSZXN1bHRHZW9tZXRyeShsKTtyZXR1cm4gaX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGM9YXJndW1lbnRzWzBdLGY9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLGQ9YXJndW1lbnRzWzNdLGE9bmV3IGRyKGMpO2Euc2V0UXVhZHJhbnRTZWdtZW50cyhnKSxhLnNldEVuZENhcFN0eWxlKGQpO3ZhciBpPWEuZ2V0UmVzdWx0R2VvbWV0cnkoZik7cmV0dXJuIGl9fSxkci5wcmVjaXNpb25TY2FsZUZhY3Rvcj1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkscj1ULm1heChNYXRoLmFicyhpLmdldE1heFgoKSksTWF0aC5hYnMoaS5nZXRNYXhZKCkpLE1hdGguYWJzKGkuZ2V0TWluWCgpKSxNYXRoLmFicyhpLmdldE1pblkoKSkpLHM9ZT4wP2U6MCxvPXIrMipzLGE9TWF0aC50cnVuYyhNYXRoLmxvZyhvKS9NYXRoLmxvZygxMCkrMSksdT1uLWEsbD1NYXRoLnBvdygxMCx1KTtyZXR1cm4gbH0sZHIuQ0FQX1JPVU5EPUtpLkNBUF9ST1VORCxkci5DQVBfQlVUVD1LaS5DQVBfRkxBVCxkci5DQVBfRkxBVD1LaS5DQVBfRkxBVCxkci5DQVBfU1FVQVJFPUtpLkNBUF9TUVVBUkUsZHIuTUFYX1BSRUNJU0lPTl9ESUdJVFM9MTI7dmFyIFNvPU9iamVjdC5mcmVlemUoe0J1ZmZlck9wOmRyLEJ1ZmZlclBhcmFtZXRlcnM6S2l9KTtlKHByLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBUdCYmdGhpcy5jb21wcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2h0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHJ9fSkscHIuZ2V0UG9seWdvbnM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBwci5nZXRQb2x5Z29ucyh0LG5ldyBJKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBlIGluc3RhbmNlb2YgVHQ/bi5hZGQoZSk6ZSBpbnN0YW5jZW9mIGZ0JiZlLmFwcGx5KG5ldyBwcihuKSksbn19LGUodnIucHJvdG90eXBlLHtpc0luc2lkZUFyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbmRleD09PXZyLklOU0lERV9BUkVBfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGdldEdlb21ldHJ5Q29tcG9uZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcG9uZW50fSxnZXRTZWdtZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbmRleH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdnJ9fSksdnIuSU5TSURFX0FSRUE9LTEsZShtci5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgTHQmJnRoaXMucHRzLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtcn19KSxtci5nZXRQb2ludHM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0IGluc3RhbmNlb2YgTHQ/aG8uc2luZ2xldG9uTGlzdCh0KTptci5nZXRQb2ludHModCxuZXcgSSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gZSBpbnN0YW5jZW9mIEx0P24uYWRkKGUpOmUgaW5zdGFuY2VvZiBmdCYmZS5hcHBseShuZXcgbXIobikpLG59fSxlKHlyLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpeyh0IGluc3RhbmNlb2YgTHR8fHQgaW5zdGFuY2VvZiBTdHx8dCBpbnN0YW5jZW9mIFR0KSYmdGhpcy5sb2NhdGlvbnMuYWRkKG5ldyB2cih0LDAsdC5nZXRDb29yZGluYXRlKCkpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5cn19KSx5ci5nZXRMb2NhdGlvbnM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEk7cmV0dXJuIHQuYXBwbHkobmV3IHlyKGUpKSxlfSxlKHhyLnByb3RvdHlwZSx7Y29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2U6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgwLHQpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPTEtZSxyPXByLmdldFBvbHlnb25zKHRoaXMuZ2VvbVtlXSk7aWYoci5zaXplKCk+MCl7dmFyIHM9eXIuZ2V0TG9jYXRpb25zKHRoaXMuZ2VvbVtpXSk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShzLHIsbiksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uW2ldPW5bMF0sdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uW2VdPW5bMV0sbnVsbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZSKGFyZ3VtZW50c1swXSx5KSYmUihhcmd1bWVudHNbMV0seSkpe2Zvcih2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl0sbD0wO2w8by5zaXplKCk7bCsrKWZvcih2YXIgaD1vLmdldChsKSxjPTA7YzxhLnNpemUoKTtjKyspaWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShoLGEuZ2V0KGMpLHUpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHZyJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFR0KXt2YXIgZj1hcmd1bWVudHNbMF0sZz1hcmd1bWVudHNbMV0sZD1hcmd1bWVudHNbMl0scD1mLmdldENvb3JkaW5hdGUoKTtpZihMLkVYVEVSSU9SIT09dGhpcy5wdExvY2F0b3IubG9jYXRlKHAsZykpcmV0dXJuIHRoaXMubWluRGlzdGFuY2U9MCxkWzBdPWYsZFsxXT1uZXcgdnIoZyxwKSxudWxsfX0sY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKHIsbyxuKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX0sY29tcHV0ZUZhY2V0RGlzdGFuY2U6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxlPWtuLmdldExpbmVzKHRoaXMuZ2VvbVswXSksbj1rbi5nZXRMaW5lcyh0aGlzLmdlb21bMV0pLGk9bXIuZ2V0UG9pbnRzKHRoaXMuZ2VvbVswXSkscj1tci5nZXRQb2ludHModGhpcy5nZW9tWzFdKTtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyhlLG4sdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhlLHIsdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhuLGksdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCEwKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMoaSxyLHQpLHZvaWQgdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSkpKX0sbmVhcmVzdExvY2F0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbn0sdXBkYXRlTWluRGlzdGFuY2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXRbMF0/bnVsbDp2b2lkKGU/KHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblswXT10WzFdLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzBdKToodGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMF0sdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMV0pKX0sbmVhcmVzdFBvaW50czpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7dmFyIHQ9W3RoaXMubWluRGlzdGFuY2VMb2NhdGlvblswXS5nZXRDb29yZGluYXRlKCksdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzFdLmdldENvb3JkaW5hdGUoKV07cmV0dXJuIHR9LGNvbXB1dGVNaW5EaXN0YW5jZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihudWxsIT09dGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uKXJldHVybiBudWxsO2lmKHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVGYWNldERpc3RhbmNlKCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMubWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Zm9yKHZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKSxyPWUuZ2V0Q29vcmRpbmF0ZSgpLHM9MDtzPGkubGVuZ3RoLTE7cysrKXt2YXIgbz1oZS5kaXN0YW5jZVBvaW50TGluZShyLGlbc10saVtzKzFdKTtpZihvPHRoaXMubWluRGlzdGFuY2Upe3RoaXMubWluRGlzdGFuY2U9bzt2YXIgYT1uZXcgY2UoaVtzXSxpW3MrMV0pLHU9YS5jbG9zZXN0UG9pbnQocik7blswXT1uZXcgdnIodCxzLHUpLG5bMV09bmV3IHZyKGUsMCxyKX1pZih0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgU3Qpe3ZhciBsPWFyZ3VtZW50c1swXSxoPWFyZ3VtZW50c1sxXSxjPWFyZ3VtZW50c1syXTtpZihsLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShoLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtmb3IodmFyIGk9bC5nZXRDb29yZGluYXRlcygpLGY9aC5nZXRDb29yZGluYXRlcygpLHM9MDtzPGkubGVuZ3RoLTE7cysrKWZvcih2YXIgZz0wO2c8Zi5sZW5ndGgtMTtnKyspe3ZhciBvPWhlLmRpc3RhbmNlTGluZUxpbmUoaVtzXSxpW3MrMV0sZltnXSxmW2crMV0pO2lmKG88dGhpcy5taW5EaXN0YW5jZSl7dGhpcy5taW5EaXN0YW5jZT1vO3ZhciBkPW5ldyBjZShpW3NdLGlbcysxXSkscD1uZXcgY2UoZltnXSxmW2crMV0pLHY9ZC5jbG9zZXN0UG9pbnRzKHApO2NbMF09bmV3IHZyKGwscyx2WzBdKSxjWzFdPW5ldyB2cihoLGcsdlsxXSl9aWYodGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fSxjb21wdXRlTWluRGlzdGFuY2VQb2ludHM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpLGE9ci5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2Uoby5nZXRDb29yZGluYXRlKCkpO2lmKGE8dGhpcy5taW5EaXN0YW5jZSYmKHRoaXMubWluRGlzdGFuY2U9YSxuWzBdPW5ldyB2cihyLDAsci5nZXRDb29yZGluYXRlKCkpLG5bMV09bmV3IHZyKG8sMCxvLmdldENvb3JkaW5hdGUoKSkpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fSxkaXN0YW5jZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmdlb21bMF18fG51bGw9PT10aGlzLmdlb21bMV0pdGhyb3cgbmV3IGkoXCJudWxsIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuZ2VvbVswXS5pc0VtcHR5KCl8fHRoaXMuZ2VvbVsxXS5pc0VtcHR5KCk/MDoodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSx0aGlzLm1pbkRpc3RhbmNlKX0sY29tcHV0ZU1pbkRpc3RhbmNlTGluZXM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKHIsbyxuKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geHJ9fSkseHIuZGlzdGFuY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgeHIodCxlKTtyZXR1cm4gbi5kaXN0YW5jZSgpfSx4ci5pc1dpdGhpbkRpc3RhbmNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgeHIodCxlLG4pO3JldHVybiBpLmRpc3RhbmNlKCk8PW59LHhyLm5lYXJlc3RQb2ludHM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgeHIodCxlKTtyZXR1cm4gbi5uZWFyZXN0UG9pbnRzKCl9O3ZhciB3bz1PYmplY3QuZnJlZXplKHtEaXN0YW5jZU9wOnhyfSk7ZShFci5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuY29vcmRpbmF0ZXMpe2Zvcih2YXIgdD0wLGU9MCxuPW5ldyBOLGk9dGhpcy5kaXJlY3RlZEVkZ2VzLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmdldEVkZ2VEaXJlY3Rpb24oKT90Kys6ZSsrLG4uYWRkKHIuZ2V0RWRnZSgpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLCExLHIuZ2V0RWRnZURpcmVjdGlvbigpKX10aGlzLmNvb3JkaW5hdGVzPW4udG9Db29yZGluYXRlQXJyYXkoKSxlPnQmJkgucmV2ZXJzZSh0aGlzLmNvb3JkaW5hdGVzKX1yZXR1cm4gdGhpcy5jb29yZGluYXRlc30sdG9MaW5lU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSl9LGFkZDpmdW5jdGlvbih0KXt0aGlzLmRpcmVjdGVkRWRnZXMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFcn19KSxlKElyLnByb3RvdHlwZSx7c2V0VmlzaXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH0saXNNYXJrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxzZXRNYXJrZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNNYXJrZWQ9dH0sZ2V0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGlzVmlzaXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9LHNldENvbnRleHQ6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElyfX0pLElyLmdldENvbXBvbmVudFdpdGhWaXNpdGVkU3RhdGU9ZnVuY3Rpb24odCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dmFyIG49dC5uZXh0KCk7aWYobi5pc1Zpc2l0ZWQoKT09PWUpcmV0dXJuIG59cmV0dXJuIG51bGx9LElyLnNldFZpc2l0ZWQ9ZnVuY3Rpb24odCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dmFyIG49dC5uZXh0KCk7bi5zZXRWaXNpdGVkKGUpfX0sSXIuc2V0TWFya2VkPWZ1bmN0aW9uKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3ZhciBuPXQubmV4dCgpO24uc2V0TWFya2VkKGUpfX0saChOcixJciksZShOci5wcm90b3R5cGUse2lzUmVtb3ZlZDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5wYXJlbnRFZGdlfSxjb21wYXJlRGlyZWN0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnF1YWRyYW50PnQucXVhZHJhbnQ/MTp0aGlzLnF1YWRyYW50PHQucXVhZHJhbnQ/LTE6aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQucDAsdC5wMSx0aGlzLnAxKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZyb20uZ2V0Q29vcmRpbmF0ZSgpfSxwcmludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIiksaT1lLnN1YnN0cmluZyhuKzEpO3QucHJpbnQoXCIgIFwiK2krXCI6IFwiK3RoaXMucDArXCIgLSBcIit0aGlzLnAxK1wiIFwiK3RoaXMucXVhZHJhbnQrXCI6XCIrdGhpcy5hbmdsZSl9LGdldERpcmVjdGlvblB0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDF9LGdldEFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYW5nbGV9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9LGdldEZyb21Ob2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZnJvbX0sZ2V0U3ltOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltfSxzZXRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMucGFyZW50RWRnZT10fSxyZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLnN5bT1udWxsLHRoaXMucGFyZW50RWRnZT1udWxsfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50RWRnZX0sZ2V0UXVhZHJhbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5xdWFkcmFudH0sc2V0U3ltOmZ1bmN0aW9uKHQpe3RoaXMuc3ltPXR9LGdldFRvTm9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvfSxnZXRFZGdlRGlyZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZURpcmVjdGlvbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5yfX0pLE5yLnRvRWRnZXM9ZnVuY3Rpb24odCl7XG5mb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuYWRkKG4ubmV4dCgpLnBhcmVudEVkZ2UpO3JldHVybiBlfSxoKENyLE5yKSxlKENyLnByb3RvdHlwZSx7Z2V0TmV4dDpmdW5jdGlvbigpe3JldHVybiAyIT09dGhpcy5nZXRUb05vZGUoKS5nZXREZWdyZWUoKT9udWxsOnRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKT09PXRoaXMuZ2V0U3ltKCk/dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpOihmLmlzVHJ1ZSh0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk9PT10aGlzLmdldFN5bSgpKSx0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDcn19KSxoKFNyLElyKSxlKFNyLnByb3RvdHlwZSx7aXNSZW1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmRpckVkZ2V9LHNldERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24odCxlKXt0aGlzLmRpckVkZ2U9W3QsZV0sdC5zZXRFZGdlKHRoaXMpLGUuc2V0RWRnZSh0aGlzKSx0LnNldFN5bShlKSxlLnNldFN5bSh0KSx0LmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZSh0KSxlLmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZShlKX0sZ2V0RGlyRWRnZTpmdW5jdGlvbigpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRpckVkZ2VbdF19aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMcil7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PWU/dGhpcy5kaXJFZGdlWzBdOnRoaXMuZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09ZT90aGlzLmRpckVkZ2VbMV06bnVsbH19LHJlbW92ZTpmdW5jdGlvbigpe3RoaXMuZGlyRWRnZT1udWxsfSxnZXRPcHBvc2l0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLmRpckVkZ2VbMF0uZ2V0VG9Ob2RlKCk6dGhpcy5kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuZGlyRWRnZVsxXS5nZXRUb05vZGUoKTpudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTcn19KSxlKHdyLnByb3RvdHlwZSx7Z2V0TmV4dEVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlKzEpKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dmFyIGU9dC5uZXh0KCk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMub3V0RWRnZXMuaXRlcmF0b3IoKX0sc29ydEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5zb3J0ZWR8fChoby5zb3J0KHRoaXMub3V0RWRnZXMpLHRoaXMuc29ydGVkPSEwKX0scmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMub3V0RWRnZXMucmVtb3ZlKHQpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMub3V0RWRnZXN9LGdldE5leHRDV0VkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlLTEpKX0sZ2V0SW5kZXg6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFNyKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IodmFyIGU9MDtlPHRoaXMub3V0RWRnZXMuc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5vdXRFZGdlcy5nZXQoZSk7aWYobi5nZXRFZGdlKCk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTnIpe3ZhciBpPWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2Zvcih2YXIgZT0wO2U8dGhpcy5vdXRFZGdlcy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLm91dEVkZ2VzLmdldChlKTtpZihuPT09aSlyZXR1cm4gZX1yZXR1cm4tMX1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciByPWFyZ3VtZW50c1swXSxzPXIldGhpcy5vdXRFZGdlcy5zaXplKCk7cmV0dXJuIDA+cyYmKHMrPXRoaXMub3V0RWRnZXMuc2l6ZSgpKSxzfX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMub3V0RWRnZXMuYWRkKHQpLHRoaXMuc29ydGVkPSExfSxnZXREZWdyZWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vdXRFZGdlcy5zaXplKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdyfX0pLGgoTHIsSXIpLGUoTHIucHJvdG90eXBlLHtpc1JlbW92ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMucHR9LGFkZE91dEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5kZVN0YXIuYWRkKHQpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGdldE91dEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVTdGFyfSxyZW1vdmU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnB0PW51bGw7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZGVTdGFyLnJlbW92ZSh0KX19LGdldEluZGV4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRlU3Rhci5nZXRJbmRleCh0KX0sZ2V0RGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVTdGFyLmdldERlZ3JlZSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMcn19KSxMci5nZXRFZGdlc0JldHdlZW49ZnVuY3Rpb24odCxlKXt2YXIgbj1Oci50b0VkZ2VzKHQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKSxpPW5ldyBKKG4pLHI9TnIudG9FZGdlcyhlLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSk7cmV0dXJuIGkucmV0YWluQWxsKHIpLGl9LGgoUnIsU3IpLGUoUnIucHJvdG90eXBlLHtnZXRMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUnJ9fSksZShUci5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSxyZW1vdmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5yZW1vdmUodCl9LHZhbHVlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9LGFkZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUcn19KSxlKFByLnByb3RvdHlwZSx7ZmluZE5vZGVzT2ZEZWdyZWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuZ2V0RGVncmVlKCk9PT10JiZlLmFkZChpKX1yZXR1cm4gZX0sZGlyRWRnZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlyRWRnZXMuaXRlcmF0b3IoKX0sZWRnZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXMuaXRlcmF0b3IoKX0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTcil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDEpKSx0aGlzLmVkZ2VzLnJlbW92ZSh0KSx0LnJlbW92ZSgpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOcil7dmFyIGU9YXJndW1lbnRzWzBdLG49ZS5nZXRTeW0oKTtudWxsIT09biYmbi5zZXRTeW0obnVsbCksZS5nZXRGcm9tTm9kZSgpLnJlbW92ZShlKSxlLnJlbW92ZSgpLHRoaXMuZGlyRWRnZXMucmVtb3ZlKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMcil7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLHM9ci5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksbj1vLmdldFN5bSgpO251bGwhPT1uJiZ0aGlzLnJlbW92ZShuKSx0aGlzLmRpckVkZ2VzLnJlbW92ZShvKTt2YXIgYT1vLmdldEVkZ2UoKTtudWxsIT09YSYmdGhpcy5lZGdlcy5yZW1vdmUoYSl9dGhpcy5ub2RlTWFwLnJlbW92ZShpLmdldENvb3JkaW5hdGUoKSksaS5yZW1vdmUoKX19LGZpbmROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZmluZCh0KX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sbm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC5pdGVyYXRvcigpfSxjb250YWluczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Ipe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lZGdlcy5jb250YWlucyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE5yKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZGlyRWRnZXMuY29udGFpbnMoZSl9fSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIExyKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlTWFwLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Ipe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmVkZ2VzLmFkZChlKSx0aGlzLmFkZChlLmdldERpckVkZ2UoMCkpLHRoaXMuYWRkKGUuZ2V0RGlyRWRnZSgxKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE5yKXt2YXIgbj1hcmd1bWVudHNbMF07dGhpcy5kaXJFZGdlcy5hZGQobil9fSxnZXROb2RlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFByfX0pLGgoYnIsUHIpLGUoYnIucHJvdG90eXBlLHthZGRFZGdlOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDt2YXIgbj1lWzBdLGk9ZVtlLmxlbmd0aC0xXSxyPXRoaXMuZ2V0Tm9kZShuKSxzPXRoaXMuZ2V0Tm9kZShpKSxvPW5ldyBDcihyLHMsZVsxXSwhMCksYT1uZXcgQ3IocyxyLGVbZS5sZW5ndGgtMl0sITEpLHU9bmV3IFJyKHQpO3Uuc2V0RGlyZWN0ZWRFZGdlcyhvLGEpLHRoaXMuYWRkKHUpfSxnZXROb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgTHIodCksdGhpcy5hZGQoZSkpLGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJyfX0pLGUoT3IucHJvdG90eXBlLHtidWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuaXNNYXJrZWQoKXx8KGYuaXNUcnVlKDI9PT1lLmdldERlZ3JlZSgpKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fSxidWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7MiE9PWUuZ2V0RGVncmVlKCkmJih0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fSxidWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXM6ZnVuY3Rpb24oKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKX0sZ2V0TWVyZ2VkTGluZVN0cmluZ3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZXJnZSgpLHRoaXMubWVyZ2VkTGluZVN0cmluZ3N9LGJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZ2V0RWRnZSgpLmlzTWFya2VkKCl8fHRoaXMuZWRnZVN0cmluZ3MuYWRkKHRoaXMuYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKG4pKX19LG1lcmdlOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMubWVyZ2VkTGluZVN0cmluZ3MpcmV0dXJuIG51bGw7SXIuc2V0TWFya2VkKHRoaXMuZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpLElyLnNldE1hcmtlZCh0aGlzLmdyYXBoLmVkZ2VJdGVyYXRvcigpLCExKSx0aGlzLmVkZ2VTdHJpbmdzPW5ldyBJLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCksdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wcygpLHRoaXMubWVyZ2VkTGluZVN0cmluZ3M9bmV3IEk7Zm9yKHZhciB0PXRoaXMuZWRnZVN0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO3RoaXMubWVyZ2VkTGluZVN0cmluZ3MuYWRkKGUudG9MaW5lU3RyaW5nKCkpfX0sYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFcih0aGlzLmZhY3RvcnkpLG49dDtkbyBlLmFkZChuKSxuLmdldEVkZ2UoKS5zZXRNYXJrZWQoITApLG49bi5nZXROZXh0KCk7d2hpbGUobnVsbCE9PW4mJm4hPT10KTtyZXR1cm4gZX0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07dC5hcHBseSh7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgU3QmJnRoaXMuYWRkKHQpfX0pfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlZExpbmVTdHJpbmdzPW51bGw7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuYWRkKGkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciByPWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5mYWN0b3J5JiYodGhpcy5mYWN0b3J5PXIuZ2V0RmFjdG9yeSgpKSx0aGlzLmdyYXBoLmFkZEVkZ2Uocil9fSxidWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wczpmdW5jdGlvbigpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0ZvclVucHJvY2Vzc2VkTm9kZXMoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT3J9fSk7dmFyIExvPU9iamVjdC5mcmVlemUoe0xpbmVNZXJnZXI6T3J9KSxSbz1PYmplY3QuZnJlZXplKHtPdmVybGF5T3A6aWl9KTtoKF9yLE5yKSxlKF9yLnByb3RvdHlwZSx7Z2V0TmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHR9LGlzSW5SaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmVkZ2VSaW5nfSxzZXRSaW5nOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZVJpbmc9dH0sc2V0TGFiZWw6ZnVuY3Rpb24odCl7dGhpcy5sYWJlbD10fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxzZXROZXh0OmZ1bmN0aW9uKHQpe3RoaXMubmV4dD10fSxnZXRSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZVJpbmd9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9yfX0pLGgoTXIsU3IpLGUoTXIucHJvdG90eXBlLHtnZXRMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTXJ9fSksZShEci5wcm90b3R5cGUse2lzSW5jbHVkZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZH0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5yaW5nUHRzKXtmb3IodmFyIHQ9bmV3IE4sZT10aGlzLmRlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldEVkZ2UoKTtEci5hZGRFZGdlKGkuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksbi5nZXRFZGdlRGlyZWN0aW9uKCksdCl9dGhpcy5yaW5nUHRzPXQudG9Db29yZGluYXRlQXJyYXkoKX1yZXR1cm4gdGhpcy5yaW5nUHRzfSxpc0luY2x1ZGVkU2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWRTZXR9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMucmluZ1B0cy5sZW5ndGg8PTM/ITE6KHRoaXMuZ2V0UmluZygpLHRoaXMucmluZy5pc1ZhbGlkKCkpfSxidWlsZDpmdW5jdGlvbih0KXt2YXIgZT10O2RvIHRoaXMuYWRkKGUpLGUuc2V0UmluZyh0aGlzKSxlPWUuZ2V0TmV4dCgpLGYuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGYuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpO3doaWxlKGUhPT10KX0saXNPdXRlckhvbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNIb2xlPyF0aGlzLmhhc1NoZWxsKCk6ITF9LGdldFBvbHlnb246ZnVuY3Rpb24oKXt2YXIgdD1udWxsO2lmKG51bGwhPT10aGlzLmhvbGVzKXt0PW5ldyBBcnJheSh0aGlzLmhvbGVzLnNpemUoKSkuZmlsbChudWxsKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuaG9sZXMuZ2V0KGUpfXZhciBuPXRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHRoaXMucmluZyx0KTtyZXR1cm4gbn0saXNIb2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX0saXNQcm9jZXNzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNQcm9jZXNzZWR9LGFkZEhvbGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXt2YXIgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuaG9sZXMmJih0aGlzLmhvbGVzPW5ldyBJKSx0aGlzLmhvbGVzLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRHIpe3ZhciBlPWFyZ3VtZW50c1swXTtlLnNldFNoZWxsKHRoaXMpO3ZhciBuPWUuZ2V0UmluZygpO251bGw9PT10aGlzLmhvbGVzJiYodGhpcy5ob2xlcz1uZXcgSSksdGhpcy5ob2xlcy5hZGQobil9fSxzZXRJbmNsdWRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc0luY2x1ZGVkPXQsdGhpcy5faXNJbmNsdWRlZFNldD0hMH0sZ2V0T3V0ZXJIb2xlOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IodmFyIHQ9MDt0PHRoaXMuZGVMaXN0LnNpemUoKTt0Kyspe3ZhciBlPXRoaXMuZGVMaXN0LmdldCh0KSxuPWUuZ2V0U3ltKCkuZ2V0UmluZygpO2lmKG4uaXNPdXRlckhvbGUoKSlyZXR1cm4gbn1yZXR1cm4gbnVsbH0sY29tcHV0ZUhvbGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldFJpbmcoKTt0aGlzLl9pc0hvbGU9aGUuaXNDQ1codC5nZXRDb29yZGluYXRlcygpKX0saGFzU2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuc2hlbGx9LGlzT3V0ZXJTaGVsbDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5nZXRPdXRlckhvbGUoKX0sZ2V0TGluZVN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5yaW5nUHRzKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLmdldENvb3JkaW5hdGVzKCkpKX0sZ2V0U2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0hvbGUoKT90aGlzLnNoZWxsOnRoaXN9LGFkZDpmdW5jdGlvbih0KXt0aGlzLmRlTGlzdC5hZGQodCl9LGdldFJpbmc6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5yaW5nKXJldHVybiB0aGlzLnJpbmc7dGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMucmluZ1B0cy5sZW5ndGg8MyYmQS5vdXQucHJpbnRsbih0aGlzLnJpbmdQdHMpO3RyeXt0aGlzLnJpbmc9dGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodGhpcy5yaW5nUHRzKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0O0Eub3V0LnByaW50bG4odGhpcy5yaW5nUHRzKX1maW5hbGx5e31yZXR1cm4gdGhpcy5yaW5nfSx1cGRhdGVJbmNsdWRlZDpmdW5jdGlvbigpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKHZhciB0PTA7dDx0aGlzLmRlTGlzdC5zaXplKCk7dCsrKXt2YXIgZT10aGlzLmRlTGlzdC5nZXQodCksbj1lLmdldFN5bSgpLmdldFJpbmcoKS5nZXRTaGVsbCgpO2lmKG51bGwhPT1uJiZuLmlzSW5jbHVkZWRTZXQoKSlyZXR1cm4gdGhpcy5zZXRJbmNsdWRlZCghbi5pc0luY2x1ZGVkKCkpLG51bGx9fSxzZXRTaGVsbDpmdW5jdGlvbih0KXt0aGlzLnNoZWxsPXR9LHNldFByb2Nlc3NlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Byb2Nlc3NlZD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEcn19KSxEci5maW5kRGlyRWRnZXNJblJpbmc9ZnVuY3Rpb24odCl7dmFyIGU9dCxuPW5ldyBJO2RvIG4uYWRkKGUpLGU9ZS5nZXROZXh0KCksZi5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZi5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIik7d2hpbGUoZSE9PXQpO3JldHVybiBufSxEci5hZGRFZGdlPWZ1bmN0aW9uKHQsZSxuKXtpZihlKWZvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKW4uYWRkKHRbaV0sITEpO2Vsc2UgZm9yKHZhciBpPXQubGVuZ3RoLTE7aT49MDtpLS0pbi5hZGQodFtpXSwhMSl9LERyLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmc9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRSaW5nKCksaT1uLmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscz1udWxsLG89bnVsbCxhPWUuaXRlcmF0b3IoKTthLmhhc05leHQoKTspe3ZhciB1PWEubmV4dCgpLGw9dS5nZXRSaW5nKCksaD1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighaC5lcXVhbHMoaSkmJmguY29udGFpbnMoaSkpe3I9SC5wdE5vdEluTGlzdChuLmdldENvb3JkaW5hdGVzKCksbC5nZXRDb29yZGluYXRlcygpKTt2YXIgYz0hMTtoZS5pc1BvaW50SW5SaW5nKHIsbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09c3x8by5jb250YWlucyhoKSkmJihzPXUsbz1zLmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpfX1yZXR1cm4gc30sZShBci5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtyZXR1cm4gbi5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKS5jb21wYXJlVG8oaS5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBcn19KSxEci5FbnZlbG9wZUNvbXBhcmF0b3I9QXIsaChGcixQciksZShGci5wcm90b3R5cGUse2ZpbmRFZGdlUmluZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRHIodGhpcy5mYWN0b3J5KTtyZXR1cm4gZS5idWlsZCh0KSxlfSxjb21wdXRlRGVwdGhQYXJpdHk6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IoOzspe3ZhciB0PW51bGw7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlRGVwdGhQYXJpdHkodCl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfX0sY29tcHV0ZU5leHRDV0VkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtGci5jb21wdXRlTmV4dENXRWRnZXMoZSl9fSxhZGRFZGdlOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiBudWxsO3ZhciBuPWVbMF0saT1lW2UubGVuZ3RoLTFdLHI9dGhpcy5nZXROb2RlKG4pLHM9dGhpcy5nZXROb2RlKGkpLG89bmV3IF9yKHIscyxlWzFdLCEwKSxhPW5ldyBfcihzLHIsZVtlLmxlbmd0aC0yXSwhMSksdT1uZXcgTXIodCk7dS5zZXREaXJlY3RlZEVkZ2VzKG8sYSksdGhpcy5hZGQodSl9LGRlbGV0ZUN1dEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxGci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLmRpckVkZ2VzKTtmb3IodmFyIHQ9bmV3IEksZT10aGlzLmRpckVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZighbi5pc01hcmtlZCgpKXt2YXIgaT1uLmdldFN5bSgpO2lmKG4uZ2V0TGFiZWwoKT09PWkuZ2V0TGFiZWwoKSl7bi5zZXRNYXJrZWQoITApLGkuc2V0TWFya2VkKCEwKTt2YXIgcj1uLmdldEVkZ2UoKTt0LmFkZChyLmdldExpbmUoKSl9fX1yZXR1cm4gdH0sZ2V0RWRnZVJpbmdzOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxGci5sYWJlbCh0aGlzLmRpckVkZ2VzLC0xKTt2YXIgdD1Gci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLmRpckVkZ2VzKTt0aGlzLmNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzKHQpO2Zvcih2YXIgZT1uZXcgSSxuPXRoaXMuZGlyRWRnZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKCFpLmlzTWFya2VkKCkmJiFpLmlzSW5SaW5nKCkpe3ZhciByPXRoaXMuZmluZEVkZ2VSaW5nKGkpO2UuYWRkKHIpfX1yZXR1cm4gZX0sZ2V0Tm9kZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmZpbmROb2RlKHQpO3JldHVybiBudWxsPT09ZSYmKGU9bmV3IExyKHQpLHRoaXMuYWRkKGUpKSxlfSxjb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCkscj1Gci5maW5kSW50ZXJzZWN0aW9uTm9kZXMobixpKTtpZihudWxsIT09cilmb3IodmFyIHM9ci5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCk7RnIuY29tcHV0ZU5leHRDQ1dFZGdlcyhvLGkpfX19LGRlbGV0ZURhbmdsZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5maW5kTm9kZXNPZkRlZ3JlZSgxKSxlPW5ldyBKLG49bmV3IHBlLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyluLnB1c2goaS5uZXh0KCkpO2Zvcig7IW4uaXNFbXB0eSgpOyl7dmFyIHI9bi5wb3AoKTtGci5kZWxldGVBbGxFZGdlcyhyKTtmb3IodmFyIHM9ci5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCksaT1zLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgbz1pLm5leHQoKTtvLnNldE1hcmtlZCghMCk7dmFyIGE9by5nZXRTeW0oKTtudWxsIT09YSYmYS5zZXRNYXJrZWQoITApO3ZhciB1PW8uZ2V0RWRnZSgpO2UuYWRkKHUuZ2V0TGluZSgpKTt2YXIgbD1vLmdldFRvTm9kZSgpOzE9PT1Gci5nZXREZWdyZWVOb25EZWxldGVkKGwpJiZuLnB1c2gobCl9fXJldHVybiBlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGcn19KSxGci5maW5kTGFiZWxlZEVkZ2VSaW5ncz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0xLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYoIShyLmlzTWFya2VkKCl8fHIuZ2V0TGFiZWwoKT49MCkpe2UuYWRkKHIpO3ZhciBzPURyLmZpbmREaXJFZGdlc0luUmluZyhyKTtGci5sYWJlbChzLG4pLG4rK319cmV0dXJuIGV9LEZyLmdldERlZ3JlZU5vbkRlbGV0ZWQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLG49MCxpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuaXNNYXJrZWQoKXx8bisrfXJldHVybiBufSxGci5kZWxldGVBbGxFZGdlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldE1hcmtlZCghMCk7dmFyIHI9aS5nZXRTeW0oKTtudWxsIT09ciYmci5zZXRNYXJrZWQoITApfX0sRnIubGFiZWw9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5zZXRMYWJlbChlKX19LEZyLmNvbXB1dGVOZXh0Q1dFZGdlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRPdXRFZGdlcygpLG49bnVsbCxpPW51bGwscj1lLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKCFzLmlzTWFya2VkKCkpe2lmKG51bGw9PT1uJiYobj1zKSxudWxsIT09aSl7dmFyIG89aS5nZXRTeW0oKTtvLnNldE5leHQocyl9aT1zfX1pZihudWxsIT09aSl7dmFyIG89aS5nZXRTeW0oKTtvLnNldE5leHQobil9fSxGci5jb21wdXRlTmV4dENDV0VkZ2VzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0T3V0RWRnZXMoKSxpPW51bGwscj1udWxsLHM9bi5nZXRFZGdlcygpLG89cy5zaXplKCktMTtvPj0wO28tLSl7dmFyIGE9cy5nZXQobyksdT1hLmdldFN5bSgpLGw9bnVsbDthLmdldExhYmVsKCk9PT1lJiYobD1hKTt2YXIgaD1udWxsO3UuZ2V0TGFiZWwoKT09PWUmJihoPXUpLG51bGw9PT1sJiZudWxsPT09aHx8KG51bGwhPT1oJiYocj1oKSxudWxsIT09bCYmKG51bGwhPT1yJiYoci5zZXROZXh0KGwpLHI9bnVsbCksbnVsbD09PWkmJihpPWwpKSl9bnVsbCE9PXImJihmLmlzVHJ1ZShudWxsIT09aSksci5zZXROZXh0KGkpKX0sRnIuZ2V0RGVncmVlPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLGk9MCxyPW4uaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO3MuZ2V0TGFiZWwoKT09PWUmJmkrK31yZXR1cm4gaX0sRnIuZmluZEludGVyc2VjdGlvbk5vZGVzPWZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPW51bGw7ZG97dmFyIHI9bi5nZXRGcm9tTm9kZSgpO0ZyLmdldERlZ3JlZShyLGUpPjEmJihudWxsPT09aSYmKGk9bmV3IEkpLGkuYWRkKHIpKSxuPW4uZ2V0TmV4dCgpLGYuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGYuaXNUcnVlKG49PT10fHwhbi5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKG4hPT10KTtyZXR1cm4gaX0sZShHci5wcm90b3R5cGUse2dldEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmdlb21GYWN0b3J5JiYodGhpcy5nZW9tRmFjdG9yeT1uZXcgaWUpLHRoaXMucG9seWdvbml6ZSgpLHRoaXMuZXh0cmFjdE9ubHlQb2x5Z29uYWw/dGhpcy5nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMucG9seUxpc3QpOnRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheSh0aGlzLnBvbHlMaXN0KSl9LGdldEludmFsaWRSaW5nTGluZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5pbnZhbGlkUmluZ0xpbmVzfSxmaW5kVmFsaWRSaW5nczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuaXNWYWxpZCgpP2UuYWRkKHIpOm4uYWRkKHIuZ2V0TGluZVN0cmluZygpKX19LHBvbHlnb25pemU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5wb2x5TGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLnBvbHlMaXN0PW5ldyBJLG51bGw9PT10aGlzLmdyYXBoKXJldHVybiBudWxsO3RoaXMuZGFuZ2xlcz10aGlzLmdyYXBoLmRlbGV0ZURhbmdsZXMoKSx0aGlzLmN1dEVkZ2VzPXRoaXMuZ3JhcGguZGVsZXRlQ3V0RWRnZXMoKTt2YXIgdD10aGlzLmdyYXBoLmdldEVkZ2VSaW5ncygpLGU9bmV3IEk7dGhpcy5pbnZhbGlkUmluZ0xpbmVzPW5ldyBJLHRoaXMuaXNDaGVja2luZ1JpbmdzVmFsaWQ/dGhpcy5maW5kVmFsaWRSaW5ncyh0LGUsdGhpcy5pbnZhbGlkUmluZ0xpbmVzKTplPXQsdGhpcy5maW5kU2hlbGxzQW5kSG9sZXMoZSksR3IuYXNzaWduSG9sZXNUb1NoZWxscyh0aGlzLmhvbGVMaXN0LHRoaXMuc2hlbGxMaXN0KSxoby5zb3J0KHRoaXMuc2hlbGxMaXN0LG5ldyBEci5FbnZlbG9wZUNvbXBhcmF0b3IpO3ZhciBuPSEwO3RoaXMuZXh0cmFjdE9ubHlQb2x5Z29uYWwmJihHci5maW5kRGlzam9pbnRTaGVsbHModGhpcy5zaGVsbExpc3QpLG49ITEpLHRoaXMucG9seUxpc3Q9R3IuZXh0cmFjdFBvbHlnb25zKHRoaXMuc2hlbGxMaXN0LG4pfSxnZXREYW5nbGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuZGFuZ2xlc30sZ2V0Q3V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5jdXRFZGdlc30sZ2V0UG9seWdvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5wb2x5TGlzdH0sYWRkOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuYWRkKG4pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIGk9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUZhY3Rvcnk9aS5nZXRGYWN0b3J5KCksbnVsbD09PXRoaXMuZ3JhcGgmJih0aGlzLmdyYXBoPW5ldyBGcih0aGlzLmdlb21GYWN0b3J5KSksdGhpcy5ncmFwaC5hZGRFZGdlKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgcj1hcmd1bWVudHNbMF07ci5hcHBseSh0aGlzLmxpbmVTdHJpbmdBZGRlcil9fSxzZXRDaGVja1JpbmdzVmFsaWQ6ZnVuY3Rpb24odCl7dGhpcy5pc0NoZWNraW5nUmluZ3NWYWxpZD10fSxmaW5kU2hlbGxzQW5kSG9sZXM6ZnVuY3Rpb24odCl7dGhpcy5ob2xlTGlzdD1uZXcgSSx0aGlzLnNoZWxsTGlzdD1uZXcgSTtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5jb21wdXRlSG9sZSgpLG4uaXNIb2xlKCk/dGhpcy5ob2xlTGlzdC5hZGQobik6dGhpcy5zaGVsbExpc3QuYWRkKG4pfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR3J9fSksR3IuZmluZE91dGVyU2hlbGxzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0T3V0ZXJIb2xlKCk7bnVsbD09PWl8fGkuaXNQcm9jZXNzZWQoKXx8KG4uc2V0SW5jbHVkZWQoITApLGkuc2V0UHJvY2Vzc2VkKCEwKSl9fSxHci5leHRyYWN0UG9seWdvbnM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTsoZXx8ci5pc0luY2x1ZGVkKCkpJiZuLmFkZChyLmdldFBvbHlnb24oKSl9cmV0dXJuIG59LEdyLmFzc2lnbkhvbGVzVG9TaGVsbHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7R3IuYXNzaWduSG9sZVRvU2hlbGwoaSxlKX19LEdyLmFzc2lnbkhvbGVUb1NoZWxsPWZ1bmN0aW9uKHQsZSl7dmFyIG49RHIuZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpO251bGwhPT1uJiZuLmFkZEhvbGUodCl9LEdyLmZpbmREaXNqb2ludFNoZWxscz1mdW5jdGlvbih0KXtHci5maW5kT3V0ZXJTaGVsbHModCk7dmFyIGU9bnVsbDtkb3tlPSExO2Zvcih2YXIgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmlzSW5jbHVkZWRTZXQoKXx8KGkudXBkYXRlSW5jbHVkZWQoKSxpLmlzSW5jbHVkZWRTZXQoKXx8KGU9ITApKX19d2hpbGUoZSl9LGUocXIucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLnAuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcXJ9fSksR3IuTGluZVN0cmluZ0FkZGVyPXFyO3ZhciBUbz1PYmplY3QuZnJlZXplKHtQb2x5Z29uaXplcjpHcn0pO2UoQnIucHJvdG90eXBlLHtjcmVhdGVFZGdlRW5kRm9yTmV4dDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uLnNlZ21lbnRJbmRleCsxO2lmKHI+PXQuZ2V0TnVtUG9pbnRzKCkmJm51bGw9PT1pKXJldHVybiBudWxsO3ZhciBzPXQuZ2V0Q29vcmRpbmF0ZShyKTtudWxsIT09aSYmaS5zZWdtZW50SW5kZXg9PT1uLnNlZ21lbnRJbmRleCYmKHM9aS5jb29yZCk7dmFyIG89bmV3IEVuKHQsbi5jb29yZCxzLG5ldyBnbih0LmdldExhYmVsKCkpKTtlLmFkZChvKX0sY3JlYXRlRWRnZUVuZEZvclByZXY6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bi5zZWdtZW50SW5kZXg7aWYoMD09PW4uZGlzdCl7aWYoMD09PXIpcmV0dXJuIG51bGw7ci0tfXZhciBzPXQuZ2V0Q29vcmRpbmF0ZShyKTtudWxsIT09aSYmaS5zZWdtZW50SW5kZXg+PXImJihzPWkuY29vcmQpO3ZhciBvPW5ldyBnbih0LmdldExhYmVsKCkpO28uZmxpcCgpO3ZhciBhPW5ldyBFbih0LG4uY29vcmQscyxvKTtlLmFkZChhKX0sY29tcHV0ZUVkZ2VFbmRzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSSxuPXQ7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmNvbXB1dGVFZGdlRW5kcyhpLGUpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1yLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCk7by5hZGRFbmRwb2ludHMoKTt2YXIgYT1vLml0ZXJhdG9yKCksdT1udWxsLGw9bnVsbDtpZighYS5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dmFyIGg9YS5uZXh0KCk7ZG8gdT1sLGw9aCxoPW51bGwsYS5oYXNOZXh0KCkmJihoPWEubmV4dCgpKSxudWxsIT09bCYmKHRoaXMuY3JlYXRlRWRnZUVuZEZvclByZXYocixzLGwsdSksdGhpcy5jcmVhdGVFZGdlRW5kRm9yTmV4dChyLHMsbCxoKSk7d2hpbGUobnVsbCE9PWwpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQnJ9fSksaCh6cixFbiksZSh6ci5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0KXt0aGlzLmVkZ2VFbmRzLmFkZCh0KX0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiRWRnZUVuZEJ1bmRsZS0tPiBMYWJlbDogXCIrdGhpcy5sYWJlbCk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCksdC5wcmludGxuKCl9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VFbmRzLml0ZXJhdG9yKCl9LGdldEVkZ2VFbmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZUVuZHN9LGNvbXB1dGVMYWJlbE9uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAsaT0hMSxyPXRoaXMuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO289PT1MLkJPVU5EQVJZJiZuKyssbz09PUwuSU5URVJJT1ImJihpPSEwKX12YXIgbz1MLk5PTkU7aSYmKG89TC5JTlRFUklPUiksbj4wJiYobz0kbi5kZXRlcm1pbmVCb3VuZGFyeShlLG4pKSx0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsbyl9LGNvbXB1dGVMYWJlbFNpZGU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5nZXRMYWJlbCgpLmlzQXJlYSgpKXt2YXIgcj1pLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCxlKTtpZihyPT09TC5JTlRFUklPUilyZXR1cm4gdGhpcy5sYWJlbC5zZXRMb2NhdGlvbih0LGUsTC5JTlRFUklPUiksbnVsbDtyPT09TC5FWFRFUklPUiYmdGhpcy5sYWJlbC5zZXRMb2NhdGlvbih0LGUsTC5FWFRFUklPUil9fX0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sY29tcHV0ZUxhYmVsU2lkZXM6ZnVuY3Rpb24odCl7dGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsY24uTEVGVCksdGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsY24uUklHSFQpfSx1cGRhdGVJTTpmdW5jdGlvbih0KXtKbi51cGRhdGVJTSh0aGlzLmxhYmVsLHQpfSxjb21wdXRlTGFiZWw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSExLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5nZXRMYWJlbCgpLmlzQXJlYSgpJiYoZT0hMCl9ZT90aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUsTC5OT05FLEwuTk9ORSk6dGhpcy5sYWJlbD1uZXcgZ24oTC5OT05FKTtmb3IodmFyIHI9MDsyPnI7cisrKXRoaXMuY29tcHV0ZUxhYmVsT24ocix0KSxlJiZ0aGlzLmNvbXB1dGVMYWJlbFNpZGVzKHIpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6cn19KSxoKFZyLFBuKSxlKFZyLnByb3RvdHlwZSx7dXBkYXRlSU06ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24udXBkYXRlSU0odCl9fSxpbnNlcnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lZGdlTWFwLmdldCh0KTtudWxsPT09ZT8oZT1uZXcgenIodCksdGhpcy5pbnNlcnRFZGdlRW5kKHQsZSkpOmUuaW5zZXJ0KHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWcn19KSxoKGtyLHluKSxlKGtyLnByb3RvdHlwZSx7dXBkYXRlSU1Gcm9tRWRnZXM6ZnVuY3Rpb24odCl7dGhpcy5lZGdlcy51cGRhdGVJTSh0KX0sY29tcHV0ZUlNOmZ1bmN0aW9uKHQpe3Quc2V0QXRMZWFzdElmVmFsaWQodGhpcy5sYWJlbC5nZXRMb2NhdGlvbigwKSx0aGlzLmxhYmVsLmdldExvY2F0aW9uKDEpLDApfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrcn19KSxoKFlyLE5uKSxlKFlyLnByb3RvdHlwZSx7Y3JlYXRlTm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGtyKHQsbmV3IFZyKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWXJ9fSksZShVci5wcm90b3R5cGUse2luc2VydEVkZ2VFbmRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLm5vZGVzLmFkZChuKX19LGNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCksaT10aGlzLmFyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLHI9dC5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKSxzPXQuaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKTsyPT09biYmMj09PWk/ciYmZS5zZXRBdExlYXN0KFwiMjEyMTAxMjEyXCIpOjI9PT1uJiYxPT09aT8ociYmZS5zZXRBdExlYXN0KFwiRkZGMEZGRkYyXCIpLHMmJmUuc2V0QXRMZWFzdChcIjFGRkZGRjFGRlwiKSk6MT09PW4mJjI9PT1pPyhyJiZlLnNldEF0TGVhc3QoXCJGMEZGRkZGRjJcIikscyYmZS5zZXRBdExlYXN0KFwiMUYxRkZGRkZGXCIpKToxPT09biYmMT09PWkmJnMmJmUuc2V0QXRMZWFzdChcIjBGRkZGRkZGRlwiKX0sbGFiZWxJc29sYXRlZEVkZ2VzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5pc0lzb2xhdGVkKCkmJih0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlKGksZSx0aGlzLmFyZ1tlXS5nZXRHZW9tZXRyeSgpKSx0aGlzLmlzb2xhdGVkRWRnZXMuYWRkKGkpKX19LGxhYmVsSXNvbGF0ZWRFZGdlOmZ1bmN0aW9uKHQsZSxuKXtpZihuLmdldERpbWVuc2lvbigpPjApe3ZhciBpPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSxuKTt0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsaSl9ZWxzZSB0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsTC5FWFRFUklPUil9LGNvbXB1dGVJTTpmdW5jdGlvbigpe3ZhciB0PW5ldyBmZTtpZih0LnNldChMLkVYVEVSSU9SLEwuRVhURVJJT1IsMiksIXRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiB0aGlzLmNvbXB1dGVEaXNqb2ludElNKHQpLHQ7dGhpcy5hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCExKSx0aGlzLmFyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITEpO3ZhciBlPXRoaXMuYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLmFyZ1sxXSx0aGlzLmxpLCExKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlcygwKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlcygxKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscygwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscygxKSx0aGlzLmxhYmVsSXNvbGF0ZWROb2RlcygpLHRoaXMuY29tcHV0ZVByb3BlckludGVyc2VjdGlvbklNKGUsdCk7dmFyIG49bmV3IEJyLGk9bi5jb21wdXRlRWRnZUVuZHModGhpcy5hcmdbMF0uZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMoaSk7dmFyIHI9bi5jb21wdXRlRWRnZUVuZHModGhpcy5hcmdbMV0uZ2V0RWRnZUl0ZXJhdG9yKCkpO3JldHVybiB0aGlzLmluc2VydEVkZ2VFbmRzKHIpLHRoaXMubGFiZWxOb2RlRWRnZXMoKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygwLDEpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDEsMCksdGhpcy51cGRhdGVJTSh0KSx0fSxsYWJlbE5vZGVFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLmFyZyl9fSxjb3B5Tm9kZXNBbmRMYWJlbHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT10aGlzLm5vZGVzLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpO2kuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX0sbGFiZWxJbnRlcnNlY3Rpb25Ob2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSxyPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz10aGlzLm5vZGVzLmZpbmQocy5jb29yZCk7by5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmKGk9PT1MLkJPVU5EQVJZP28uc2V0TGFiZWxCb3VuZGFyeSh0KTpvLnNldExhYmVsKHQsTC5JTlRFUklPUikpfX0sbGFiZWxJc29sYXRlZE5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLG4pfSxjb21wdXRlSW50ZXJzZWN0aW9uTm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkscj1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89dGhpcy5ub2Rlcy5hZGROb2RlKHMuY29vcmQpO2k9PT1MLkJPVU5EQVJZP28uc2V0TGFiZWxCb3VuZGFyeSh0KTpvLmdldExhYmVsKCkuaXNOdWxsKHQpJiZvLnNldExhYmVsKHQsTC5JTlRFUklPUil9fSxsYWJlbElzb2xhdGVkTm9kZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7Zi5pc1RydWUobi5nZXRHZW9tZXRyeUNvdW50KCk+MCxcIm5vZGUgd2l0aCBlbXB0eSBsYWJlbCBmb3VuZFwiKSxlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwwKTp0aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMSkpfX0sdXBkYXRlSU06ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXNvbGF0ZWRFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi51cGRhdGVJTSh0KX1mb3IodmFyIGk9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci51cGRhdGVJTSh0KSxyLnVwZGF0ZUlNRnJvbUVkZ2VzKHQpfX0sY29tcHV0ZURpc2pvaW50SU06ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5hcmdbMF0uZ2V0R2VvbWV0cnkoKTtlLmlzRW1wdHkoKXx8KHQuc2V0KEwuSU5URVJJT1IsTC5FWFRFUklPUixlLmdldERpbWVuc2lvbigpKSx0LnNldChMLkJPVU5EQVJZLEwuRVhURVJJT1IsZS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSk7dmFyIG49dGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKTtuLmlzRW1wdHkoKXx8KHQuc2V0KEwuRVhURVJJT1IsTC5JTlRFUklPUixuLmdldERpbWVuc2lvbigpKSx0LnNldChMLkVYVEVSSU9SLEwuQk9VTkRBUlksbi5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFVyfX0pLGUoWHIucHJvdG90eXBlLHtpc0NvbnRhaW5lZEluQm91bmRhcnk6ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFR0KXJldHVybiExO2lmKHQgaW5zdGFuY2VvZiBMdClyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0IGluc3RhbmNlb2YgU3QpcmV0dXJuIHRoaXMuaXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeSh0KTtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KG4pKXJldHVybiExfXJldHVybiEwfSxpc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeTpmdW5jdGlvbih0LGUpe2lmKHQuZXF1YWxzKGUpKXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQueD09PWUueCl7aWYodC54PT09dGhpcy5yZWN0RW52LmdldE1pblgoKXx8dC54PT09dGhpcy5yZWN0RW52LmdldE1heFgoKSlyZXR1cm4hMH1lbHNlIGlmKHQueT09PWUueSYmKHQueT09PXRoaXMucmVjdEVudi5nZXRNaW5ZKCl8fHQueT09PXRoaXMucmVjdEVudi5nZXRNYXhZKCkpKXJldHVybiEwO3JldHVybiExfSxpc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49bmV3IGcsaT1uZXcgZyxyPTA7cjxlLnNpemUoKS0xO3IrKylpZihlLmdldENvb3JkaW5hdGUocixuKSxlLmdldENvb3JkaW5hdGUocisxLGkpLCF0aGlzLmlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5KG4saSkpcmV0dXJuITE7cmV0dXJuITB9LGlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMdCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQuZ2V0Q29vcmRpbmF0ZSgpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gZS54PT09dGhpcy5yZWN0RW52LmdldE1pblgoKXx8ZS54PT09dGhpcy5yZWN0RW52LmdldE1heFgoKXx8ZS55PT09dGhpcy5yZWN0RW52LmdldE1pblkoKXx8ZS55PT09dGhpcy5yZWN0RW52LmdldE1heFkoKX19LGNvbnRhaW5zOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlY3RFbnYuY29udGFpbnModC5nZXRFbnZlbG9wZUludGVybmFsKCkpPyF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KTohMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWHJ9fSksWHIuY29udGFpbnM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgWHIodCk7cmV0dXJuIG4uY29udGFpbnMoZSl9LGUoSHIucHJvdG90eXBlLHtpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEModCxlKTtpZighdGhpcy5yZWN0RW52LmludGVyc2VjdHMobikpcmV0dXJuITE7aWYodGhpcy5yZWN0RW52LmludGVyc2VjdHModCkpcmV0dXJuITA7aWYodGhpcy5yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuITA7aWYodC5jb21wYXJlVG8oZSk+MCl7dmFyIGk9dDt0PWUsZT1pfXZhciByPSExO3JldHVybiBlLnk+dC55JiYocj0hMCkscj90aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuZGlhZ0Rvd24wLHRoaXMuZGlhZ0Rvd24xKTp0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuZGlhZ1VwMCx0aGlzLmRpYWdVcDEpLCEhdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSHJ9fSksZShXci5wcm90b3R5cGUse2FwcGx5VG86ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKSYmIXRoaXMuX2lzRG9uZTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKG4gaW5zdGFuY2VvZiBmdCl0aGlzLmFwcGx5VG8obik7ZWxzZSBpZih0aGlzLnZpc2l0KG4pLHRoaXMuaXNEb25lKCkpcmV0dXJuIHRoaXMuX2lzRG9uZT0hMCxudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV3J9fSksZShqci5wcm90b3R5cGUse2ludGVyc2VjdHM6ZnVuY3Rpb24odCl7aWYoIXRoaXMucmVjdEVudi5pbnRlcnNlY3RzKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTt2YXIgZT1uZXcgS3IodGhpcy5yZWN0RW52KTtpZihlLmFwcGx5VG8odCksZS5pbnRlcnNlY3RzKCkpcmV0dXJuITA7dmFyIG49bmV3IFpyKHRoaXMucmVjdGFuZ2xlKTtpZihuLmFwcGx5VG8odCksbi5jb250YWluc1BvaW50KCkpcmV0dXJuITA7dmFyIGk9bmV3IFFyKHRoaXMucmVjdGFuZ2xlKTtyZXR1cm4gaS5hcHBseVRvKHQpLCEhaS5pbnRlcnNlY3RzKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGpyfX0pLGpyLmludGVyc2VjdHM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcganIodCk7cmV0dXJuIG4uaW50ZXJzZWN0cyhlKX0saChLcixXciksZShLci5wcm90b3R5cGUse2lzRG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzPT09ITB9LHZpc2l0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiB0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKT90aGlzLnJlY3RFbnYuY29udGFpbnMoZSk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6ZS5nZXRNaW5YKCk+PXRoaXMucmVjdEVudi5nZXRNaW5YKCkmJmUuZ2V0TWF4WCgpPD10aGlzLnJlY3RFbnYuZ2V0TWF4WCgpPyh0aGlzLl9pbnRlcnNlY3RzPSEwLG51bGwpOmUuZ2V0TWluWSgpPj10aGlzLnJlY3RFbnYuZ2V0TWluWSgpJiZlLmdldE1heFkoKTw9dGhpcy5yZWN0RW52LmdldE1heFkoKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTp2b2lkIDA6bnVsbH0saW50ZXJzZWN0czpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLcn19KSxoKFpyLFdyKSxlKFpyLnByb3RvdHlwZSx7aXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnQ9PT0hMH0sdmlzaXQ6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgVHQpKXJldHVybiBudWxsO3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtmb3IodmFyIG49bmV3IGcsaT0wOzQ+aTtpKyspaWYodGhpcy5yZWN0U2VxLmdldENvb3JkaW5hdGUoaSxuKSxlLmNvbnRhaW5zKG4pJiZUbi5jb250YWluc1BvaW50SW5Qb2x5Z29uKG4sdCkpcmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITAsbnVsbH0sY29udGFpbnNQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluc1BvaW50fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBacn19KSxoKFFyLFdyKSxlKFFyLnByb3RvdHlwZSx7aW50ZXJzZWN0czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uPT09ITB9LHZpc2l0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDt2YXIgbj1rbi5nZXRMaW5lcyh0KTt0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKG4pfSxjaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYodGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyhuKSx0aGlzLmhhc0ludGVyc2VjdGlvbilyZXR1cm4gbnVsbH19LGNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49MTtuPGUuc2l6ZSgpO24rKylpZihlLmdldENvb3JkaW5hdGUobi0xLHRoaXMucDApLGUuZ2V0Q29vcmRpbmF0ZShuLHRoaXMucDEpLHRoaXMucmVjdEludGVyc2VjdG9yLmludGVyc2VjdHModGhpcy5wMCx0aGlzLnAxKSlyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb249ITAsbnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUXJ9fSksaChKcix0aSksZShKci5wcm90b3R5cGUse2dldEludGVyc2VjdGlvbk1hdHJpeDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWxhdGUuY29tcHV0ZUlNKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEpyfX0pLEpyLmNvdmVycz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb3ZlcnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP3QuaXNSZWN0YW5nbGUoKT8hMDpKci5yZWxhdGUodCxlKS5pc0NvdmVycygpOiExfSxKci5pbnRlcnNlY3RzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP3QuaXNSZWN0YW5nbGUoKT9qci5pbnRlcnNlY3RzKHQsZSk6ZS5pc1JlY3RhbmdsZSgpP2pyLmludGVyc2VjdHMoZSx0KTpKci5yZWxhdGUodCxlKS5pc0ludGVyc2VjdHMoKTohMX0sSnIudG91Y2hlcz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9Kci5yZWxhdGUodCxlKS5pc1RvdWNoZXModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTohMX0sSnIud2l0aGluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuY29udGFpbnModCl9LEpyLmNvdmVyZWRCeT1mdW5jdGlvbih0LGUpe3JldHVybiBKci5jb3ZlcnMoZSx0KX0sSnIucmVsYXRlPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBKcih0LGUpLGk9bi5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKTtyZXR1cm4gaX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEIpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTtyZXR1cm4gSnIucmVsYXRlV2l0aENoZWNrKHIscykubWF0Y2hlcyhvKX1pZihSKGFyZ3VtZW50c1syXSxWKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEIpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXSxsPWFyZ3VtZW50c1syXSxuPW5ldyBKcihhLHUsbCksaT1uLmdldEludGVyc2VjdGlvbk1hdHJpeCgpO3JldHVybiBpfX19LEpyLm92ZXJsYXBzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP0pyLnJlbGF0ZSh0LGUpLmlzT3ZlcmxhcHModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTohMX0sSnIuZGlzam9pbnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4hdC5pbnRlcnNlY3RzKGUpfSxKci5yZWxhdGVXaXRoQ2hlY2s9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLEpyLnJlbGF0ZSh0LGUpfSxKci5jcm9zc2VzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP0pyLnJlbGF0ZSh0LGUpLmlzQ3Jvc3Nlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpOiExfSxKci5jb250YWlucz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/dC5pc1JlY3RhbmdsZSgpP1hyLmNvbnRhaW5zKHQsZSk6SnIucmVsYXRlKHQsZSkuaXNDb250YWlucygpOiExfTt2YXIgUG89T2JqZWN0LmZyZWV6ZSh7UmVsYXRlT3A6SnJ9KTtlKCRyLnByb3RvdHlwZSx7ZXh0cmFjdEVsZW1lbnRzOmZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Zm9yKHZhciBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pO3RoaXMuc2tpcEVtcHR5JiZpLmlzRW1wdHkoKXx8ZS5hZGQoaSl9fSxjb21iaW5lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5pbnB1dEdlb21zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3RFbGVtZW50cyhuLHQpfXJldHVybiAwPT09dC5zaXplKCk/bnVsbCE9PXRoaXMuZ2VvbUZhY3Rvcnk/dGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCk6bnVsbDp0aGlzLmdlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRyfX0pLCRyLmNvbWJpbmU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3ICRyKHQpO1xucmV0dXJuIGUuY29tYmluZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1uZXcgJHIoJHIuY3JlYXRlTGlzdChuLGkpKTtyZXR1cm4gZS5jb21iaW5lKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxlPW5ldyAkcigkci5jcmVhdGVMaXN0KHIscyxvKSk7cmV0dXJuIGUuY29tYmluZSgpfX0sJHIuZXh0cmFjdEZhY3Rvcnk9ZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNFbXB0eSgpP251bGw6dC5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCl9LCRyLmNyZWF0ZUxpc3Q9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEk7cmV0dXJuIG4uYWRkKHQpLG4uYWRkKGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxuPW5ldyBJO3JldHVybiBuLmFkZChpKSxuLmFkZChyKSxuLmFkZChzKSxufX0sZSh0cy5wcm90b3R5cGUse3VuaW9uOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBUZSxlPW5ldyBhdCxuPTA7bjx0aGlzLnBvaW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10aGlzLnBvaW50R2VvbS5nZXRHZW9tZXRyeU4obikscj1pLmdldENvb3JkaW5hdGUoKSxzPXQubG9jYXRlKHIsdGhpcy5vdGhlckdlb20pO3M9PT1MLkVYVEVSSU9SJiZlLmFkZChyKX1pZigwPT09ZS5zaXplKCkpcmV0dXJuIHRoaXMub3RoZXJHZW9tO3ZhciBvPW51bGwsYT1ILnRvQ29vcmRpbmF0ZUFycmF5KGUpO3JldHVybiBvPTE9PT1hLmxlbmd0aD90aGlzLmdlb21GYWN0LmNyZWF0ZVBvaW50KGFbMF0pOnRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoYSksJHIuY29tYmluZShvLHRoaXMub3RoZXJHZW9tKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdHN9fSksdHMudW5pb249ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgdHModCxlKTtyZXR1cm4gbi51bmlvbigpfSxlKGVzLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpey0xIT09dGhpcy5zb3J0SW5kZXgmJnQuZ2V0U29ydEluZGV4KCkhPT10aGlzLnNvcnRJbmRleHx8dGhpcy5jb21wcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2h0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZXN9fSksZXMuZXh0cmFjdD1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGVzLmV4dHJhY3QodCxlLG5ldyBJKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3JldHVybiBuLmdldFNvcnRJbmRleCgpPT09aT9yLmFkZChuKTpuIGluc3RhbmNlb2YgZnQmJm4uYXBwbHkobmV3IGVzKGkscikpLHJ9fSxlKG5zLnByb3RvdHlwZSx7cmVkdWNlVG9HZW9tZXRyaWVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9bnVsbDtSKGkseSk/cj10aGlzLnVuaW9uVHJlZShpKTppIGluc3RhbmNlb2YgQiYmKHI9aSksZS5hZGQocil9cmV0dXJuIGV9LGV4dHJhY3RCeUVudmVsb3BlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bmV3IEkscj0wO3I8ZS5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXt2YXIgcz1lLmdldEdlb21ldHJ5TihyKTtzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP2kuYWRkKHMpOm4uYWRkKHMpfXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkoaSl9LHVuaW9uT3B0aW1pemVkOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRFbnZlbG9wZUludGVybmFsKCksaT1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighbi5pbnRlcnNlY3RzKGkpKXt2YXIgcj0kci5jb21iaW5lKHQsZSk7cmV0dXJuIHJ9aWYodC5nZXROdW1HZW9tZXRyaWVzKCk8PTEmJmUuZ2V0TnVtR2VvbWV0cmllcygpPD0xKXJldHVybiB0aGlzLnVuaW9uQWN0dWFsKHQsZSk7dmFyIHM9bi5pbnRlcnNlY3Rpb24oaSk7cmV0dXJuIHRoaXMudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uKHQsZSxzKX0sdW5pb246ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5pbnB1dFBvbHlzKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJ1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlXCIpO2lmKHRoaXMuaW5wdXRQb2x5cy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZW9tRmFjdG9yeT10aGlzLmlucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO2Zvcih2YXIgdD1uZXcga2UobnMuU1RSVFJFRV9OT0RFX0NBUEFDSVRZKSxlPXRoaXMuaW5wdXRQb2x5cy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dC5pbnNlcnQobi5nZXRFbnZlbG9wZUludGVybmFsKCksbil9dGhpcy5pbnB1dFBvbHlzPW51bGw7dmFyIGk9dC5pdGVtc1RyZWUoKSxyPXRoaXMudW5pb25UcmVlKGkpO3JldHVybiByfSxiaW5hcnlVbmlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24odCwwLHQuc2l6ZSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9YXJndW1lbnRzWzJdO2lmKDE+PWktbil7dmFyIHI9bnMuZ2V0R2VvbWV0cnkoZSxuKTtyZXR1cm4gdGhpcy51bmlvblNhZmUocixudWxsKX1pZihpLW49PT0yKXJldHVybiB0aGlzLnVuaW9uU2FmZShucy5nZXRHZW9tZXRyeShlLG4pLG5zLmdldEdlb21ldHJ5KGUsbisxKSk7dmFyIHM9TWF0aC50cnVuYygoaStuKS8yKSxyPXRoaXMuYmluYXJ5VW5pb24oZSxuLHMpLG89dGhpcy5iaW5hcnlVbmlvbihlLHMsaSk7cmV0dXJuIHRoaXMudW5pb25TYWZlKHIsbyl9fSxyZXBlYXRlZFVuaW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZT1udWxsPT09ZT9pLmNvcHkoKTplLnVuaW9uKGkpfXJldHVybiBlfSx1bmlvblNhZmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PXQ/ZS5jb3B5KCk6bnVsbD09PWU/dC5jb3B5KCk6dGhpcy51bmlvbk9wdGltaXplZCh0LGUpfSx1bmlvbkFjdHVhbDpmdW5jdGlvbih0LGUpe3JldHVybiBucy5yZXN0cmljdFRvUG9seWdvbnModC51bmlvbihlKSl9LHVuaW9uVHJlZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlZHVjZVRvR2VvbWV0cmllcyh0KSxuPXRoaXMuYmluYXJ5VW5pb24oZSk7cmV0dXJuIG59LHVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEkscj10aGlzLmV4dHJhY3RCeUVudmVsb3BlKG4sdCxpKSxzPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUobixlLGkpLG89dGhpcy51bmlvbkFjdHVhbChyLHMpO2kuYWRkKG8pO3ZhciBhPSRyLmNvbWJpbmUoaSk7cmV0dXJuIGF9LGJ1ZmZlclVuaW9uOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0KDApLmdldEZhY3RvcnkoKSxuPWUuYnVpbGRHZW9tZXRyeSh0KSxpPW4uYnVmZmVyKDApO3JldHVybiBpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sZT1yLmdldEZhY3RvcnkoKSxuPWUuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFtyLHNdKSxpPW4uYnVmZmVyKDApO3JldHVybiBpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbnN9fSksbnMucmVzdHJpY3RUb1BvbHlnb25zPWZ1bmN0aW9uKHQpe2lmKFIodCxSdCkpcmV0dXJuIHQ7dmFyIGU9cHIuZ2V0UG9seWdvbnModCk7cmV0dXJuIDE9PT1lLnNpemUoKT9lLmdldCgwKTp0LmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oaWUudG9Qb2x5Z29uQXJyYXkoZSkpfSxucy5nZXRHZW9tZXRyeT1mdW5jdGlvbih0LGUpe3JldHVybiBlPj10LnNpemUoKT9udWxsOnQuZ2V0KGUpfSxucy51bmlvbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgbnModCk7cmV0dXJuIGUudW5pb24oKX0sbnMuU1RSVFJFRV9OT0RFX0NBUEFDSVRZPTQsZShpcy5wcm90b3R5cGUse3VuaW9uTm9PcHQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2ludCgpO3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlVOSU9OKX0sdW5pb25XaXRoTnVsbDpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09ZT90Om51bGw9PT10P2U6dC51bmlvbihlKX0sZXh0cmFjdDpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3Qobil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBpPWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5nZW9tRmFjdCYmKHRoaXMuZ2VvbUZhY3Q9aS5nZXRGYWN0b3J5KCkpLGVzLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9QT0xZR09OLHRoaXMucG9seWdvbnMpLGVzLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9MSU5FU1RSSU5HLHRoaXMubGluZXMpLGVzLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9QT0lOVCx0aGlzLnBvaW50cyl9fSx1bmlvbjpmdW5jdGlvbiBYbygpe2lmKG51bGw9PT10aGlzLmdlb21GYWN0KXJldHVybiBudWxsO3ZhciB0PW51bGw7aWYodGhpcy5wb2ludHMuc2l6ZSgpPjApe3ZhciBlPXRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLnBvaW50cyk7dD10aGlzLnVuaW9uTm9PcHQoZSl9dmFyIG49bnVsbDtpZih0aGlzLmxpbmVzLnNpemUoKT4wKXt2YXIgaT10aGlzLmdlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5saW5lcyk7bj10aGlzLnVuaW9uTm9PcHQoaSl9dmFyIHI9bnVsbDt0aGlzLnBvbHlnb25zLnNpemUoKT4wJiYocj1ucy51bmlvbih0aGlzLnBvbHlnb25zKSk7dmFyIHM9dGhpcy51bmlvbldpdGhOdWxsKG4sciksWG89bnVsbDtyZXR1cm4gWG89bnVsbD09PXQ/czpudWxsPT09cz90OnRzLnVuaW9uKHQscyksbnVsbD09PVhvP3RoaXMuZ2VvbUZhY3QuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6WG99LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGlzfX0pLGlzLnVuaW9uPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLHYpKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgaXModCk7cmV0dXJuIGUudW5pb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBuPWFyZ3VtZW50c1swXSxlPW5ldyBpcyhuKTtyZXR1cm4gZS51bmlvbigpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0sZT1uZXcgaXMoaSxyKTtyZXR1cm4gZS51bmlvbigpfX07dmFyIGJvPU9iamVjdC5mcmVlemUoe1VuYXJ5VW5pb25PcDppc30pO2UocnMucHJvdG90eXBlLHt2aXNpdEludGVyaW9yUmluZzpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPW5bMF0scj1ycy5maW5kRGlmZmVyZW50UG9pbnQobixpKSxzPWUuZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24oaSxyKSxvPWUuZmluZEVkZ2VFbmQocyksYT1udWxsO28uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKT09PUwuSU5URVJJT1I/YT1vOm8uZ2V0U3ltKCkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKT09PUwuSU5URVJJT1ImJihhPW8uZ2V0U3ltKCkpLGYuaXNUcnVlKG51bGwhPT1hLFwidW5hYmxlIHRvIGZpbmQgZGlyRWRnZSB3aXRoIEludGVyaW9yIG9uIFJIU1wiKSx0aGlzLnZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyhhKX0sdmlzaXRTaGVsbEludGVyaW9yczpmdW5jdGlvbih0LGUpe2lmKHQgaW5zdGFuY2VvZiBUdCl7dmFyIG49dDt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSl9aWYodCBpbnN0YW5jZW9mIE90KWZvcih2YXIgaT10LHI9MDtyPGkuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIG49aS5nZXRHZW9tZXRyeU4ocik7dGhpcy52aXNpdEludGVyaW9yUmluZyhuLmdldEV4dGVyaW9yUmluZygpLGUpfX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc2Nvbm5lY3RlZFJpbmdjb29yZH0sc2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKT09PUwuSU5URVJJT1ImJm4uc2V0SW5SZXN1bHQoITApfX0sdmlzaXRMaW5rZWREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10O2RvIGYuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBEaXJlY3RlZCBFZGdlXCIpLG4uc2V0VmlzaXRlZCghMCksbj1uLmdldE5leHQoKTt3aGlsZShuIT09ZSl9LGJ1aWxkRWRnZVJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuaXNJblJlc3VsdCgpJiZudWxsPT09aS5nZXRFZGdlUmluZygpKXt2YXIgcj1uZXcgdm4oaSx0aGlzLmdlb21ldHJ5RmFjdG9yeSk7ci5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKTt2YXIgcz1yLmJ1aWxkTWluaW1hbFJpbmdzKCk7ZS5hZGRBbGwocyl9fXJldHVybiBlfSxoYXNVbnZpc2l0ZWRTaGVsbEVkZ2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LnNpemUoKTtlKyspe3ZhciBuPXQuZ2V0KGUpO2lmKCFuLmlzSG9sZSgpKXt2YXIgaT1uLmdldEVkZ2VzKCkscj1pLmdldCgwKTtpZihyLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SKWZvcih2YXIgcz0wO3M8aS5zaXplKCk7cysrKWlmKHI9aS5nZXQocyksIXIuaXNWaXNpdGVkKCkpcmV0dXJuIHRoaXMuZGlzY29ubmVjdGVkUmluZ2Nvb3JkPXIuZ2V0Q29vcmRpbmF0ZSgpLCEwfX1yZXR1cm4hMX0saXNJbnRlcmlvcnNDb25uZWN0ZWQ6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTt0aGlzLmdlb21HcmFwaC5jb21wdXRlU3BsaXRFZGdlcyh0KTt2YXIgZT1uZXcgQ24obmV3IE9uKTtlLmFkZEVkZ2VzKHQpLHRoaXMuc2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0KGUpLGUubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKTt2YXIgbj10aGlzLmJ1aWxkRWRnZVJpbmdzKGUuZ2V0RWRnZUVuZHMoKSk7cmV0dXJuIHRoaXMudmlzaXRTaGVsbEludGVyaW9ycyh0aGlzLmdlb21HcmFwaC5nZXRHZW9tZXRyeSgpLGUpLCF0aGlzLmhhc1VudmlzaXRlZFNoZWxsRWRnZShuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcnN9fSkscnMuZmluZERpZmZlcmVudFBvaW50PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGUpKXJldHVybiB0W25dO3JldHVybiBudWxsfSxlKHNzLnByb3RvdHlwZSx7aW5zZXJ0RWRnZUVuZHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMubm9kZXMuYWRkKG4pfX0sZ2V0Tm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXMuaXRlcmF0b3IoKX0sY29weU5vZGVzQW5kTGFiZWxzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0Tm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPXRoaXMubm9kZXMuYWRkTm9kZShpLmdldENvb3JkaW5hdGUoKSk7ci5zZXRMYWJlbChlLGkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSl9fSxidWlsZDpmdW5jdGlvbih0KXt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKHQsMCk7dmFyIGU9bmV3IEJyLG49ZS5jb21wdXRlRWRnZUVuZHModC5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhuKX0sY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWZvcih2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSxzPWkuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksYT10aGlzLm5vZGVzLmFkZE5vZGUoby5jb29yZCk7cj09PUwuQk9VTkRBUlk/YS5zZXRMYWJlbEJvdW5kYXJ5KGUpOmEuZ2V0TGFiZWwoKS5pc051bGwoZSkmJmEuc2V0TGFiZWwoZSxMLklOVEVSSU9SKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHNzfX0pLGUob3MucHJvdG90eXBlLHtpc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtpZighZS5nZXRFZGdlcygpLmlzQXJlYUxhYmVsc0NvbnNpc3RlbnQodGhpcy5nZW9tR3JhcGgpKXJldHVybiB0aGlzLmludmFsaWRQb2ludD1lLmdldENvb3JkaW5hdGUoKS5jb3B5KCksITF9cmV0dXJuITB9LGdldEludmFsaWRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludmFsaWRQb2ludH0saGFzRHVwbGljYXRlUmluZ3M6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWZvcih2YXIgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5nZXRFZGdlRW5kcygpLnNpemUoKT4xKXJldHVybiB0aGlzLmludmFsaWRQb2ludD1pLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlKDApLCEwfXJldHVybiExfSxpc05vZGVDb25zaXN0ZW50QXJlYTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2VvbUdyYXBoLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMCwhMCk7cmV0dXJuIHQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuaW52YWxpZFBvaW50PXQuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6KHRoaXMubm9kZUdyYXBoLmJ1aWxkKHRoaXMuZ2VvbUdyYXBoKSx0aGlzLmlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb3N9fSksZShhcy5wcm90b3R5cGUse2J1aWxkSW5kZXg6ZnVuY3Rpb24oKXt0aGlzLmluZGV4PW5ldyBrZTtmb3IodmFyIHQ9MDt0PHRoaXMucmluZ3Muc2l6ZSgpO3QrKyl7dmFyIGU9dGhpcy5yaW5ncy5nZXQodCksbj1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTt0aGlzLmluZGV4Lmluc2VydChuLGUpfX0sZ2V0TmVzdGVkUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXN0ZWRQdH0saXNOb25OZXN0ZWQ6ZnVuY3Rpb24oKXt0aGlzLmJ1aWxkSW5kZXgoKTtmb3IodmFyIHQ9MDt0PHRoaXMucmluZ3Muc2l6ZSgpO3QrKylmb3IodmFyIGU9dGhpcy5yaW5ncy5nZXQodCksbj1lLmdldENvb3JkaW5hdGVzKCksaT10aGlzLmluZGV4LnF1ZXJ5KGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSxyPTA7cjxpLnNpemUoKTtyKyspe3ZhciBzPWkuZ2V0KHIpLG89cy5nZXRDb29yZGluYXRlcygpO2lmKGUhPT1zJiZlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSl7dmFyIGE9bHMuZmluZFB0Tm90Tm9kZShuLHMsdGhpcy5ncmFwaCk7aWYobnVsbCE9PWEpe3ZhciB1PWhlLmlzUG9pbnRJblJpbmcoYSxvKTtpZih1KXJldHVybiB0aGlzLm5lc3RlZFB0PWEsITF9fX1yZXR1cm4hMH0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMucmluZ3MuYWRkKHQpLHRoaXMudG90YWxFbnYuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYXN9fSksZSh1cy5wcm90b3R5cGUse2dldEVycm9yVHlwZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVycm9yVHlwZX0sZ2V0TWVzc2FnZTpmdW5jdGlvbigpe3JldHVybiB1cy5lcnJNc2dbdGhpcy5lcnJvclR5cGVdfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9XCJcIjtyZXR1cm4gbnVsbCE9PXRoaXMucHQmJih0PVwiIGF0IG9yIG5lYXIgcG9pbnQgXCIrdGhpcy5wdCksdGhpcy5nZXRNZXNzYWdlKCkrdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdXN9fSksdXMuRVJST1I9MCx1cy5SRVBFQVRFRF9QT0lOVD0xLHVzLkhPTEVfT1VUU0lERV9TSEVMTD0yLHVzLk5FU1RFRF9IT0xFUz0zLHVzLkRJU0NPTk5FQ1RFRF9JTlRFUklPUj00LHVzLlNFTEZfSU5URVJTRUNUSU9OPTUsdXMuUklOR19TRUxGX0lOVEVSU0VDVElPTj02LHVzLk5FU1RFRF9TSEVMTFM9Nyx1cy5EVVBMSUNBVEVfUklOR1M9OCx1cy5UT09fRkVXX1BPSU5UUz05LHVzLklOVkFMSURfQ09PUkRJTkFURT0xMCx1cy5SSU5HX05PVF9DTE9TRUQ9MTEsdXMuZXJyTXNnPVtcIlRvcG9sb2d5IFZhbGlkYXRpb24gRXJyb3JcIixcIlJlcGVhdGVkIFBvaW50XCIsXCJIb2xlIGxpZXMgb3V0c2lkZSBzaGVsbFwiLFwiSG9sZXMgYXJlIG5lc3RlZFwiLFwiSW50ZXJpb3IgaXMgZGlzY29ubmVjdGVkXCIsXCJTZWxmLWludGVyc2VjdGlvblwiLFwiUmluZyBTZWxmLWludGVyc2VjdGlvblwiLFwiTmVzdGVkIHNoZWxsc1wiLFwiRHVwbGljYXRlIFJpbmdzXCIsXCJUb28gZmV3IGRpc3RpbmN0IHBvaW50cyBpbiBnZW9tZXRyeSBjb21wb25lbnRcIixcIkludmFsaWQgQ29vcmRpbmF0ZVwiLFwiUmluZyBpcyBub3QgY2xvc2VkXCJdLGUobHMucHJvdG90eXBlLHtjaGVja0ludmFsaWRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCFscy5pc1ZhbGlkKHRbZV0pKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5JTlZBTElEX0NPT1JESU5BVEUsdFtlXSksbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTxuLmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH19LGNoZWNrSG9sZXNOb3ROZXN0ZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IGFzKGUpLGk9MDtpPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7aSsrKXt2YXIgcj10LmdldEludGVyaW9yUmluZ04oaSk7bi5hZGQocil9dmFyIHM9bi5pc05vbk5lc3RlZCgpO3N8fCh0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5ORVNURURfSE9MRVMsbi5nZXROZXN0ZWRQb2ludCgpKSl9LGNoZWNrQ29uc2lzdGVudEFyZWE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IG9zKHQpLG49ZS5pc05vZGVDb25zaXN0ZW50QXJlYSgpO3JldHVybiBuP3ZvaWQoZS5oYXNEdXBsaWNhdGVSaW5ncygpJiYodGhpcy52YWxpZEVycj1uZXcgdXModXMuRFVQTElDQVRFX1JJTkdTLGUuZ2V0SW52YWxpZFBvaW50KCkpKSk6KHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLlNFTEZfSU5URVJTRUNUSU9OLGUuZ2V0SW52YWxpZFBvaW50KCkpLG51bGwpfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLnBhcmVudEdlb21ldHJ5KSxudWxsPT09dGhpcy52YWxpZEVycn0sY2hlY2tTaGVsbEluc2lkZUhvbGU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKSxyPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPWxzLmZpbmRQdE5vdE5vZGUoaSxlLG4pO2lmKG51bGwhPT1zKXt2YXIgbz1oZS5pc1BvaW50SW5SaW5nKHMscik7aWYoIW8pcmV0dXJuIHN9dmFyIGE9bHMuZmluZFB0Tm90Tm9kZShyLHQsbik7aWYobnVsbCE9PWEpe3ZhciB1PWhlLmlzUG9pbnRJblJpbmcoYSxpKTtyZXR1cm4gdT9hOm51bGx9cmV0dXJuIGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJwb2ludHMgaW4gc2hlbGwgYW5kIGhvbGUgYXBwZWFyIHRvIGJlIGVxdWFsXCIpLG51bGx9LGNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyhuLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfX0sY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHJzKHQpO2UuaXNJbnRlcmlvcnNDb25uZWN0ZWQoKXx8KHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLkRJU0NPTk5FQ1RFRF9JTlRFUklPUixlLmdldENvb3JkaW5hdGUoKSkpfSxjaGVja05vU2VsZkludGVyc2VjdGluZ1Jpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBhdCxuPSEwLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYobiluPSExO2Vsc2V7aWYoZS5jb250YWlucyhyLmNvb3JkKSlyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgdXModXMuUklOR19TRUxGX0lOVEVSU0VDVElPTixyLmNvb3JkKSxudWxsO2UuYWRkKHIuY29vcmQpfX19LGNoZWNrSG9sZXNJblNoZWxsOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0RXh0ZXJpb3JSaW5nKCksaT1uZXcgSWkobikscj0wO3I8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtyKyspe3ZhciBzPXQuZ2V0SW50ZXJpb3JSaW5nTihyKSxvPWxzLmZpbmRQdE5vdE5vZGUocy5nZXRDb29yZGluYXRlcygpLG4sZSk7aWYobnVsbD09PW8pcmV0dXJuIG51bGw7dmFyIGE9IWkuaXNJbnNpZGUobyk7aWYoYSlyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgdXModXMuSE9MRV9PVVRTSURFX1NIRUxMLG8pLG51bGx9fSxjaGVja1Rvb0Zld1BvaW50czpmdW5jdGlvbih0KXtyZXR1cm4gdC5oYXNUb29GZXdQb2ludHMoKT8odGhpcy52YWxpZEVycj1uZXcgdXModXMuVE9PX0ZFV19QT0lOVFMsdC5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbCk6dm9pZCAwfSxnZXRWYWxpZGF0aW9uRXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMucGFyZW50R2VvbWV0cnkpLHRoaXMudmFsaWRFcnJ9LGNoZWNrVmFsaWQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQdCl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMoZS5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcobiksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIGk9bmV3ICRuKDAsbik7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt2YXIgcj1uZXcgYWU7aS5jb21wdXRlU2VsZk5vZGVzKHIsITAsITApLHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciBzPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHMuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIGk9bmV3ICRuKDAscyk7dGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe3ZhciBvPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG8pLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhvKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt2YXIgaT1uZXcgJG4oMCxvKTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKSlyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNJblNoZWxsKG8saSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKG8saSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT3Qpe2Zvcih2YXIgYT1hcmd1bWVudHNbMF0sdT0wO3U8YS5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgbD1hLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKGwpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhsKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH12YXIgaT1uZXcgJG4oMCxhKTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKSlyZXR1cm4gbnVsbDtmb3IodmFyIHU9MDt1PGEuZ2V0TnVtR2VvbWV0cmllcygpO3UrKyl7dmFyIGw9YS5nZXRHZW9tZXRyeU4odSk7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChsLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfWZvcih2YXIgdT0wO3U8YS5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgbD1hLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQobCxpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH1pZih0aGlzLmNoZWNrU2hlbGxzTm90TmVzdGVkKGEsaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZnQpZm9yKHZhciBoPWFyZ3VtZW50c1swXSx1PTA7dTxoLmdldE51bUdlb21ldHJpZXMoKTt1Kyspe3ZhciBjPWguZ2V0R2VvbWV0cnlOKHUpO2lmKHRoaXMuY2hlY2tWYWxpZChjKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIGY9YXJndW1lbnRzWzBdO2lmKHRoaXMudmFsaWRFcnI9bnVsbCxmLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZihmIGluc3RhbmNlb2YgTHQpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIFB0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBidCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgU3QpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIFR0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBPdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZXtpZighKGYgaW5zdGFuY2VvZiBmdCkpdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGYuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuY2hlY2tWYWxpZChmKX19fSxzZXRTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZDpmdW5jdGlvbih0KXt0aGlzLmlzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9dH0sY2hlY2tTaGVsbE5vdE5lc3RlZDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRDb29yZGluYXRlcygpLHI9ZS5nZXRFeHRlcmlvclJpbmcoKSxzPXIuZ2V0Q29vcmRpbmF0ZXMoKSxvPWxzLmZpbmRQdE5vdE5vZGUoaSxyLG4pO2lmKG51bGw9PT1vKXJldHVybiBudWxsO3ZhciBhPWhlLmlzUG9pbnRJblJpbmcobyxzKTtpZighYSlyZXR1cm4gbnVsbDtpZihlLmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5ORVNURURfU0hFTExTLG8pLG51bGw7Zm9yKHZhciB1PW51bGwsbD0wO2w8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtsKyspe3ZhciBoPWUuZ2V0SW50ZXJpb3JSaW5nTihsKTtpZih1PXRoaXMuY2hlY2tTaGVsbEluc2lkZUhvbGUodCxoLG4pLG51bGw9PT11KXJldHVybiBudWxsfXRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLk5FU1RFRF9TSEVMTFMsdSl9LGNoZWNrQ2xvc2VkUmluZ3M6ZnVuY3Rpb24odCl7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0LmdldEludGVyaW9yUmluZ04oZSkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfSxjaGVja0Nsb3NlZFJpbmc6ZnVuY3Rpb24odCl7aWYoIXQuaXNDbG9zZWQoKSl7dmFyIGU9bnVsbDt0LmdldE51bVBvaW50cygpPj0xJiYoZT10LmdldENvb3JkaW5hdGVOKDApKSx0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5SSU5HX05PVF9DTE9TRUQsZSl9fSxjaGVja1NoZWxsc05vdE5lc3RlZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKWZvcih2YXIgaT10LmdldEdlb21ldHJ5TihuKSxyPWkuZ2V0RXh0ZXJpb3JSaW5nKCkscz0wO3M8dC5nZXROdW1HZW9tZXRyaWVzKCk7cysrKWlmKG4hPT1zKXt2YXIgbz10LmdldEdlb21ldHJ5TihzKTtpZih0aGlzLmNoZWNrU2hlbGxOb3ROZXN0ZWQocixvLGUpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbHN9fSksbHMuZmluZFB0Tm90Tm9kZT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPW4uZmluZEVkZ2UoZSkscj1pLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkscz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgbz10W3NdO2lmKCFyLmlzSW50ZXJzZWN0aW9uKG8pKXJldHVybiBvfXJldHVybiBudWxsfSxscy5pc1ZhbGlkPWZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgbHModCk7cmV0dXJuIGUuaXNWYWxpZCgpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKG4ueCk/ITE6ci5pc0luZmluaXRlKG4ueCk/ITE6ci5pc05hTihuLnkpPyExOiFyLmlzSW5maW5pdGUobi55KX19O3ZhciBPbz1PYmplY3QuZnJlZXplKHtJc1ZhbGlkT3A6bHMsQ29uc2lzdGVudEFyZWFUZXN0ZXI6b3N9KSxfbz1PYmplY3QuZnJlZXplKHtCb3VuZGFyeU9wOmR0LElzU2ltcGxlT3A6V2ksYnVmZmVyOlNvLGRpc3RhbmNlOndvLGxpbmVtZXJnZTpMbyxvdmVybGF5OlJvLHBvbHlnb25pemU6VG8scmVsYXRlOlBvLHVuaW9uOmJvLHZhbGlkOk9vfSk7aChocyxfdC5Db29yZGluYXRlT3BlcmF0aW9uKSxlKGhzLnByb3RvdHlwZSx7ZWRpdENvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCksaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgcj1uZXcgZyh0W2ldKTt0aGlzLnRhcmdldFBNLm1ha2VQcmVjaXNlKHIpLG5baV09cn12YXIgcz1uZXcgTihuLCExKSxvPXMudG9Db29yZGluYXRlQXJyYXkoKSxhPTA7ZSBpbnN0YW5jZW9mIFN0JiYoYT0yKSxlIGluc3RhbmNlb2YgYnQmJihhPTQpO3ZhciB1PW47cmV0dXJuIHRoaXMucmVtb3ZlQ29sbGFwc2VkJiYodT1udWxsKSxvLmxlbmd0aDxhP3U6b30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHN9fSksZShjcy5wcm90b3R5cGUse2ZpeFBvbHlnb25hbFRvcG9sb2d5OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KGU9dGhpcy5jaGFuZ2VQTSh0LHRoaXMudGFyZ2V0UE0pKTt2YXIgbj1lLmJ1ZmZlcigwKSxpPW47cmV0dXJuIHRoaXMuY2hhbmdlUHJlY2lzaW9uTW9kZWx8fChpPXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5KG4pKSxpfSxyZWR1Y2VQb2ludHdpc2U6ZnVuY3Rpb24odCl7dmFyIGU9bnVsbDtpZih0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsKXt2YXIgbj10aGlzLmNyZWF0ZUZhY3RvcnkodC5nZXRGYWN0b3J5KCksdGhpcy50YXJnZXRQTSk7ZT1uZXcgX3Qobil9ZWxzZSBlPW5ldyBfdDt2YXIgaT10aGlzLnJlbW92ZUNvbGxhcHNlZDt0LmdldERpbWVuc2lvbigpPj0yJiYoaT0hMCk7dmFyIHI9ZS5lZGl0KHQsbmV3IGhzKHRoaXMudGFyZ2V0UE0saSkpO3JldHVybiByfSxjaGFuZ2VQTTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY3JlYXRlRWRpdG9yKHQuZ2V0RmFjdG9yeSgpLGUpO3JldHVybiBuLmVkaXQodCxuZXcgX3QuTm9PcEdlb21ldHJ5T3BlcmF0aW9uKX0sc2V0UmVtb3ZlQ29sbGFwc2VkQ29tcG9uZW50czpmdW5jdGlvbih0KXt0aGlzLnJlbW92ZUNvbGxhcHNlZD10fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGllKGUsdC5nZXRTUklEKCksdC5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpO3JldHVybiBufSxzZXRDaGFuZ2VQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbih0KXt0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsPXR9LHJlZHVjZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlZHVjZVBvaW50d2lzZSh0KTtyZXR1cm4gdGhpcy5pc1BvaW50d2lzZT9lOlIoZSxSdCk/ZS5pc1ZhbGlkKCk/ZTp0aGlzLmZpeFBvbHlnb25hbFRvcG9sb2d5KGUpOmV9LHNldFBvaW50d2lzZTpmdW5jdGlvbih0KXt0aGlzLmlzUG9pbnR3aXNlPXR9LGNyZWF0ZUVkaXRvcjpmdW5jdGlvbih0LGUpe2lmKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKT09PWUpcmV0dXJuIG5ldyBfdDt2YXIgbj10aGlzLmNyZWF0ZUZhY3RvcnkodCxlKSxpPW5ldyBfdChuKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY3N9fSksY3MucmVkdWNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNzKGUpO3JldHVybiBuLnJlZHVjZSh0KX0sY3MucmVkdWNlUG9pbnR3aXNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNzKGUpO3JldHVybiBuLnNldFBvaW50d2lzZSghMCksbi5yZWR1Y2UodCl9O3ZhciBNbz1PYmplY3QuZnJlZXplKHtHZW9tZXRyeVByZWNpc2lvblJlZHVjZXI6Y3N9KTtlKGZzLnByb3RvdHlwZSx7c2ltcGxpZnlTZWN0aW9uOmZ1bmN0aW9uKHQsZSl7aWYodCsxPT09ZSlyZXR1cm4gbnVsbDt0aGlzLnNlZy5wMD10aGlzLnB0c1t0XSx0aGlzLnNlZy5wMT10aGlzLnB0c1tlXTtmb3IodmFyIG49LTEsaT10LHI9dCsxO2U+cjtyKyspe3ZhciBzPXRoaXMuc2VnLmRpc3RhbmNlKHRoaXMucHRzW3JdKTtzPm4mJihuPXMsaT1yKX1pZihuPD10aGlzLmRpc3RhbmNlVG9sZXJhbmNlKWZvcih2YXIgcj10KzE7ZT5yO3IrKyl0aGlzLnVzZVB0W3JdPSExO2Vsc2UgdGhpcy5zaW1wbGlmeVNlY3Rpb24odCxpKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihpLGUpfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LHNpbXBsaWZ5OmZ1bmN0aW9uKCl7dGhpcy51c2VQdD1uZXcgQXJyYXkodGhpcy5wdHMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLnVzZVB0W3RdPSEwO3RoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5wdHMubGVuZ3RoLTEpO2Zvcih2YXIgZT1uZXcgTix0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMudXNlUHRbdF0mJmUuYWRkKG5ldyBnKHRoaXMucHRzW3RdKSk7cmV0dXJuIGUudG9Db29yZGluYXRlQXJyYXkoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZnN9fSksZnMuc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZnModCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5zaW1wbGlmeSgpfSxlKGdzLnByb3RvdHlwZSx7c2V0RW5zdXJlVmFsaWQ6ZnVuY3Rpb24odCl7dGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH0sZ2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuaW5wdXRHZW9tLmNvcHkoKTpuZXcgZHModGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuaW5wdXRHZW9tKX0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7aWYoMD50KXRocm93IG5ldyBpKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ3N9fSksZ3Muc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZ3ModCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfSxoKGRzLHhlKSxlKGRzLnByb3RvdHlwZSx7dHJhbnNmb3JtUG9seWdvbjpmdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgT3Q/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sY3JlYXRlVmFsaWRBcmVhOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT90LmJ1ZmZlcigwKTp0fSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxpPW51bGw7cmV0dXJuIGk9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOmZzLnNpbXBsaWZ5KG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSksdGhpcy5mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoaSl9LHRyYW5zZm9ybU11bHRpUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfSx0cmFuc2Zvcm1MaW5lYXJSaW5nOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSBpbnN0YW5jZW9mIFR0LGk9eGUucHJvdG90eXBlLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fGkgaW5zdGFuY2VvZiBidD9pOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGRzfX0pLGdzLkRQVHJhbnNmb3JtZXI9ZHMsaChwcyxjZSksZShwcy5wcm90b3R5cGUse2dldEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5kZXh9LGdldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHN9fSksZSh2cy5wcm90b3R5cGUse2FkZFRvUmVzdWx0OmZ1bmN0aW9uKHQpe3RoaXMucmVzdWx0U2Vncy5hZGQodCl9LGFzTGluZVN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodnMuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMucmVzdWx0U2VncykpfSxnZXRSZXN1bHRTaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yZXN1bHRTZWdzLnNpemUoKTtyZXR1cm4gMD09PXQ/MDp0KzF9LGdldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmV9LGdldFNlZ21lbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2Vnc1t0XX0sZ2V0UGFyZW50Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCl9LGdldE1pbmltdW1TaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWluaW11bVNpemV9LGFzTGluZWFyUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodnMuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMucmVzdWx0U2VncykpfSxnZXRTZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ3N9LGluaXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLnNlZ3M9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aC0xO2UrKyl7dmFyIG49bmV3IHBzKHRbZV0sdFtlKzFdLHRoaXMucGFyZW50TGluZSxlKTt0aGlzLnNlZ3NbZV09bn19LGdldFJlc3VsdENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHZzLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLnJlc3VsdFNlZ3MpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2c319KSx2cy5leHRyYWN0Q29vcmRpbmF0ZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0LnNpemUoKSsxKS5maWxsKG51bGwpLG49bnVsbCxpPTA7aTx0LnNpemUoKTtpKyspbj10LmdldChpKSxlW2ldPW4ucDA7cmV0dXJuIGVbZS5sZW5ndGgtMV09bi5wMSxlfSxlKG1zLnByb3RvdHlwZSx7cmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMuaW5kZXgucmVtb3ZlKG5ldyBDKHQucDAsdC5wMSksdCl9LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdnMpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0U2VnbWVudHMoKSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWVbbl07dGhpcy5hZGQoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgcj1hcmd1bWVudHNbMF07dGhpcy5pbmRleC5pbnNlcnQobmV3IEMoci5wMCxyLnAxKSxyKX19LHF1ZXJ5OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDKHQucDAsdC5wMSksbj1uZXcgeXModCk7dGhpcy5pbmRleC5xdWVyeShlLG4pO3ZhciBpPW4uZ2V0SXRlbXMoKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbXN9fSksZSh5cy5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt2YXIgZT10O0MuaW50ZXJzZWN0cyhlLnAwLGUucDEsdGhpcy5xdWVyeVNlZy5wMCx0aGlzLnF1ZXJ5U2VnLnAxKSYmdGhpcy5pdGVtcy5hZGQodCl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geXN9fSksZSh4cy5wcm90b3R5cGUse2ZsYXR0ZW46ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmxpbmVQdHNbdF0saT10aGlzLmxpbmVQdHNbZV0scj1uZXcgY2UobixpKTtyZXR1cm4gdGhpcy5yZW1vdmUodGhpcy5saW5lLHQsZSksdGhpcy5vdXRwdXRJbmRleC5hZGQocikscn0saGFzQmFkSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5oYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb24obik/ITA6ISF0aGlzLmhhc0JhZElucHV0SW50ZXJzZWN0aW9uKHQsZSxuKX0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxzaW1wbGlmeVNlY3Rpb246ZnVuY3Rpb24odCxlLG4pe24rPTE7dmFyIGk9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodCsxPT09ZSl7dmFyIHI9dGhpcy5saW5lLmdldFNlZ21lbnQodCk7cmV0dXJuIHRoaXMubGluZS5hZGRUb1Jlc3VsdChyKSxudWxsfXZhciBzPSEwO2lmKHRoaXMubGluZS5nZXRSZXN1bHRTaXplKCk8dGhpcy5saW5lLmdldE1pbmltdW1TaXplKCkpe3ZhciBvPW4rMTtvPHRoaXMubGluZS5nZXRNaW5pbXVtU2l6ZSgpJiYocz0hMSl9dmFyIGE9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksdT10aGlzLmZpbmRGdXJ0aGVzdFBvaW50KHRoaXMubGluZVB0cyx0LGUsYSk7YVswXT50aGlzLmRpc3RhbmNlVG9sZXJhbmNlJiYocz0hMSk7dmFyIGw9bmV3IGNlO2lmKGwucDA9dGhpcy5saW5lUHRzW3RdLGwucDE9dGhpcy5saW5lUHRzW2VdLGlbMF09dCxpWzFdPWUsdGhpcy5oYXNCYWRJbnRlcnNlY3Rpb24odGhpcy5saW5lLGksbCkmJihzPSExKSxzKXt2YXIgcj10aGlzLmZsYXR0ZW4odCxlKTtyZXR1cm4gdGhpcy5saW5lLmFkZFRvUmVzdWx0KHIpLG51bGx9dGhpcy5zaW1wbGlmeVNlY3Rpb24odCx1LG4pLHRoaXMuc2ltcGxpZnlTZWN0aW9uKHUsZSxuKX0saGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLm91dHB1dEluZGV4LnF1ZXJ5KHQpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihpLHQpKXJldHVybiEwfXJldHVybiExfSxmaW5kRnVydGhlc3RQb2ludDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uZXcgY2U7ci5wMD10W2VdLHIucDE9dFtuXTtmb3IodmFyIHM9LTEsbz1lLGE9ZSsxO24+YTthKyspe3ZhciB1PXRbYV0sbD1yLmRpc3RhbmNlKHUpO2w+cyYmKHM9bCxvPWEpfXJldHVybiBpWzBdPXMsb30sc2ltcGxpZnk6ZnVuY3Rpb24odCl7dGhpcy5saW5lPXQsdGhpcy5saW5lUHRzPXQuZ2V0UGFyZW50Q29vcmRpbmF0ZXMoKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMubGluZVB0cy5sZW5ndGgtMSwwKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9ZTtuPmk7aSsrKXt2YXIgcj10LmdldFNlZ21lbnQoaSk7dGhpcy5pbnB1dEluZGV4LnJlbW92ZShyKX19LGhhc0ludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LnAwLHQucDEsZS5wMCxlLnAxKSx0aGlzLmxpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKX0saGFzQmFkSW5wdXRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT10aGlzLmlucHV0SW5kZXgucXVlcnkobikscj1pLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHMsbikpe2lmKHhzLmlzSW5MaW5lU2VjdGlvbih0LGUscykpY29udGludWU7cmV0dXJuITB9fXJldHVybiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4c319KSx4cy5pc0luTGluZVNlY3Rpb249ZnVuY3Rpb24odCxlLG4pe2lmKG4uZ2V0UGFyZW50KCkhPT10LmdldFBhcmVudCgpKXJldHVybiExO3ZhciBpPW4uZ2V0SW5kZXgoKTtyZXR1cm4gaT49ZVswXSYmaTxlWzFdfSxlKEVzLnByb3RvdHlwZSx7c2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxzaW1wbGlmeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmlucHV0SW5kZXguYWRkKGUubmV4dCgpKTtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49bmV3IHhzKHRoaXMuaW5wdXRJbmRleCx0aGlzLm91dHB1dEluZGV4KTtuLnNldERpc3RhbmNlVG9sZXJhbmNlKHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpLG4uc2ltcGxpZnkoZS5uZXh0KCkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRXN9fSksZShJcy5wcm90b3R5cGUse2dldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7aWYodGhpcy5pbnB1dEdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmlucHV0R2VvbS5jb3B5KCk7dGhpcy5saW5lc3RyaW5nTWFwPW5ldyB0ZSx0aGlzLmlucHV0R2VvbS5hcHBseShuZXcgQ3ModGhpcykpLHRoaXMubGluZVNpbXBsaWZpZXIuc2ltcGxpZnkodGhpcy5saW5lc3RyaW5nTWFwLnZhbHVlcygpKTt2YXIgdD1uZXcgTnModGhpcy5saW5lc3RyaW5nTWFwKS50cmFuc2Zvcm0odGhpcy5pbnB1dEdlb20pO3JldHVybiB0fSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXtpZigwPnQpdGhyb3cgbmV3IGkoXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5saW5lU2ltcGxpZmllci5zZXREaXN0YW5jZVRvbGVyYW5jZSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSXN9fSksSXMuc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgSXModCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfSxoKE5zLHhlKSxlKE5zLnByb3RvdHlwZSx7dHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXtpZigwPT09dC5zaXplKCkpcmV0dXJuIG51bGw7aWYoZSBpbnN0YW5jZW9mIFN0KXt2YXIgbj10aGlzLmxpbmVzdHJpbmdNYXAuZ2V0KGUpO3JldHVybiB0aGlzLmNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZShuLmdldFJlc3VsdENvb3JkaW5hdGVzKCkpfXJldHVybiB4ZS5wcm90b3R5cGUudHJhbnNmb3JtQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQsZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5zfX0pLGUoQ3MucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFN0KXt2YXIgZT10O2lmKGUuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBuPWUuaXNDbG9zZWQoKT80OjIsaT1uZXcgdnMoZSxuKTt0aGlzLnRwcy5saW5lc3RyaW5nTWFwLnB1dChlLGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENzfX0pLElzLkxpbmVTdHJpbmdUcmFuc2Zvcm1lcj1OcyxJcy5MaW5lU3RyaW5nTWFwQnVpbGRlckZpbHRlcj1Dczt2YXIgRG89T2JqZWN0LmZyZWV6ZSh7RG91Z2xhc1BldWNrZXJTaW1wbGlmaWVyOmdzLFRvcG9sb2d5UHJlc2VydmluZ1NpbXBsaWZpZXI6SXN9KTtlKFNzLnByb3RvdHlwZSx7c3BsaXRBdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLm1pbmltdW1MZW4vdGhpcy5zZWdMZW47aWYodC5kaXN0YW5jZSh0aGlzLnNlZy5wMCk8dGhpcy5taW5pbXVtTGVuKXJldHVybiB0aGlzLnNwbGl0UHQ9dGhpcy5zZWcucG9pbnRBbG9uZyhlKSxudWxsO2lmKHQuZGlzdGFuY2UodGhpcy5zZWcucDEpPHRoaXMubWluaW11bUxlbilyZXR1cm4gdGhpcy5zcGxpdFB0PVNzLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuc2VnLGUpLG51bGw7dGhpcy5zcGxpdFB0PXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9dGhpcy5nZXRDb25zdHJhaW5lZExlbmd0aChuKSxzPXIvdGhpcy5zZWdMZW47aS5lcXVhbHMyRCh0aGlzLnNlZy5wMCk/dGhpcy5zcGxpdFB0PXRoaXMuc2VnLnBvaW50QWxvbmcocyk6dGhpcy5zcGxpdFB0PVNzLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuc2VnLHMpfX0sc2V0TWluaW11bUxlbmd0aDpmdW5jdGlvbih0KXt0aGlzLm1pbmltdW1MZW49dH0sZ2V0Q29uc3RyYWluZWRMZW5ndGg6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8dGhpcy5taW5pbXVtTGVuP3RoaXMubWluaW11bUxlbjp0fSxnZXRTcGxpdFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3BsaXRQdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU3N9fSksU3MucG9pbnRBbG9uZ1JldmVyc2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZztyZXR1cm4gbi54PXQucDEueC1lKih0LnAxLngtdC5wMC54KSxuLnk9dC5wMS55LWUqKHQucDEueS10LnAwLnkpLG59LGUod3MucHJvdG90eXBlLHtmaW5kU3BsaXRQb2ludDpmdW5jdGlvbih0LGUpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd3N9fSksZShMcy5wcm90b3R5cGUse2ZpbmRTcGxpdFBvaW50OmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRMaW5lU2VnbWVudCgpLGk9bi5nZXRMZW5ndGgoKSxyPWkvMixzPW5ldyBTcyhuKSxvPUxzLnByb2plY3RlZFNwbGl0UG9pbnQodCxlKSxhPTIqby5kaXN0YW5jZShlKSouOCx1PWE7cmV0dXJuIHU+ciYmKHU9cikscy5zZXRNaW5pbXVtTGVuZ3RoKHUpLHMuc3BsaXRBdChvKSxzLmdldFNwbGl0UG9pbnQoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bd3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMc319KSxMcy5wcm9qZWN0ZWRTcGxpdFBvaW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRMaW5lU2VnbWVudCgpLGk9bi5wcm9qZWN0KGUpO3JldHVybiBpfSxlKFJzLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUnN9fSksUnMudHJpQXJlYT1mdW5jdGlvbih0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0oZS55LXQueSkqKG4ueC10LngpfSxScy5pc0luQ2lyY2xlREROb3JtYWxpemVkPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8udmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChpLngpLHM9Xy52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KGkueSksbz1fLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QoaS54KSxhPV8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdChpLnkpLHU9Xy52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KGkueCksbD1fLnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3QoaS55KSxoPXIubXVsdGlwbHkoYSkuc2VsZlN1YnRyYWN0KG8ubXVsdGlwbHkocykpLGM9by5tdWx0aXBseShsKS5zZWxmU3VidHJhY3QodS5tdWx0aXBseShhKSksZj11Lm11bHRpcGx5KHMpLnNlbGZTdWJ0cmFjdChyLm11bHRpcGx5KGwpKSxnPXIubXVsdGlwbHkocikuc2VsZkFkZChzLm11bHRpcGx5KHMpKSxkPW8ubXVsdGlwbHkobykuc2VsZkFkZChhLm11bHRpcGx5KGEpKSxwPXUubXVsdGlwbHkodSkuc2VsZkFkZChsLm11bHRpcGx5KGwpKSx2PWcuc2VsZk11bHRpcGx5KGMpLnNlbGZBZGQoZC5zZWxmTXVsdGlwbHkoZikpLnNlbGZBZGQocC5zZWxmTXVsdGlwbHkoaCkpLG09di5kb3VibGVWYWx1ZSgpPjA7cmV0dXJuIG19LFJzLmNoZWNrUm9idXN0SW5DaXJjbGU9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9UnMuaXNJbkNpcmNsZU5vblJvYnVzdCh0LGUsbixpKSxzPVJzLmlzSW5DaXJjbGVERFNsb3codCxlLG4saSksbz1Scy5pc0luQ2lyY2xlQ0ModCxlLG4saSksYT1TaS5jaXJjdW1jZW50cmUodCxlLG4pO0Eub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGEgPSBcIitNYXRoLmFicyhpLmRpc3RhbmNlKGEpLXQuZGlzdGFuY2UoYSkpL3QuZGlzdGFuY2UoYSkpLHI9PT1zJiZyPT09b3x8KEEub3V0LnByaW50bG4oXCJpbkNpcmNsZSByb2J1c3RuZXNzIGZhaWx1cmUgKGRvdWJsZSByZXN1bHQgPSBcIityK1wiLCBERCByZXN1bHQgPSBcIitzK1wiLCBDQyByZXN1bHQgPSBcIitvK1wiKVwiKSxBLm91dC5wcmludGxuKHNlLnRvTGluZVN0cmluZyhuZXcgR3QoW3QsZSxuLGldKSkpLEEub3V0LnByaW50bG4oXCJDaXJjdW1jZW50cmUgPSBcIitzZS50b1BvaW50KGEpK1wiIHJhZGl1cyA9IFwiK3QuZGlzdGFuY2UoYSkpLEEub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGEgPSBcIitNYXRoLmFicyhpLmRpc3RhbmNlKGEpL3QuZGlzdGFuY2UoYSktMSkpLEEub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGIgPSBcIitNYXRoLmFicyhpLmRpc3RhbmNlKGEpL2UuZGlzdGFuY2UoYSktMSkpLEEub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGMgPSBcIitNYXRoLmFicyhpLmRpc3RhbmNlKGEpL24uZGlzdGFuY2UoYSktMSkpLEEub3V0LnByaW50bG4oKSl9LFJzLmlzSW5DaXJjbGVEREZhc3Q9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Xy5zcXIodC54KS5zZWxmQWRkKF8uc3FyKHQueSkpLnNlbGZNdWx0aXBseShScy50cmlBcmVhRERGYXN0KGUsbixpKSkscz1fLnNxcihlLngpLnNlbGZBZGQoXy5zcXIoZS55KSkuc2VsZk11bHRpcGx5KFJzLnRyaUFyZWFEREZhc3QodCxuLGkpKSxvPV8uc3FyKG4ueCkuc2VsZkFkZChfLnNxcihuLnkpKS5zZWxmTXVsdGlwbHkoUnMudHJpQXJlYURERmFzdCh0LGUsaSkpLGE9Xy5zcXIoaS54KS5zZWxmQWRkKF8uc3FyKGkueSkpLnNlbGZNdWx0aXBseShScy50cmlBcmVhRERGYXN0KHQsZSxuKSksdT1yLnNlbGZTdWJ0cmFjdChzKS5zZWxmQWRkKG8pLnNlbGZTdWJ0cmFjdChhKSxsPXUuZG91YmxlVmFsdWUoKT4wO3JldHVybiBsfSxScy5pc0luQ2lyY2xlQ0M9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9U2kuY2lyY3VtY2VudHJlKHQsZSxuKSxzPXQuZGlzdGFuY2Uociksbz1pLmRpc3RhbmNlKHIpLXM7cmV0dXJuIDA+PW99LFJzLmlzSW5DaXJjbGVOb3JtYWxpemVkPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQueC1pLngscz10LnktaS55LG89ZS54LWkueCxhPWUueS1pLnksdT1uLngtaS54LGw9bi55LWkueSxoPXIqYS1vKnMsYz1vKmwtdSphLGY9dSpzLXIqbCxnPXIqcitzKnMsZD1vKm8rYSphLHA9dSp1K2wqbCx2PWcqYytkKmYrcCpoO3JldHVybiB2PjB9LFJzLmlzSW5DaXJjbGVERFNsb3c9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Xy52YWx1ZU9mKGkueCkscz1fLnZhbHVlT2YoaS55KSxvPV8udmFsdWVPZih0LngpLGE9Xy52YWx1ZU9mKHQueSksdT1fLnZhbHVlT2YoZS54KSxsPV8udmFsdWVPZihlLnkpLGg9Xy52YWx1ZU9mKG4ueCksYz1fLnZhbHVlT2Yobi55KSxmPW8ubXVsdGlwbHkobykuYWRkKGEubXVsdGlwbHkoYSkpLm11bHRpcGx5KFJzLnRyaUFyZWFERFNsb3codSxsLGgsYyxyLHMpKSxnPXUubXVsdGlwbHkodSkuYWRkKGwubXVsdGlwbHkobCkpLm11bHRpcGx5KFJzLnRyaUFyZWFERFNsb3cobyxhLGgsYyxyLHMpKSxkPWgubXVsdGlwbHkoaCkuYWRkKGMubXVsdGlwbHkoYykpLm11bHRpcGx5KFJzLnRyaUFyZWFERFNsb3cobyxhLHUsbCxyLHMpKSxwPXIubXVsdGlwbHkocikuYWRkKHMubXVsdGlwbHkocykpLm11bHRpcGx5KFJzLnRyaUFyZWFERFNsb3cobyxhLHUsbCxoLGMpKSx2PWYuc3VidHJhY3QoZykuYWRkKGQpLnN1YnRyYWN0KHApLG09di5kb3VibGVWYWx1ZSgpPjA7XG5yZXR1cm4gbX0sUnMuaXNJbkNpcmNsZU5vblJvYnVzdD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj0odC54KnQueCt0LnkqdC55KSpScy50cmlBcmVhKGUsbixpKS0oZS54KmUueCtlLnkqZS55KSpScy50cmlBcmVhKHQsbixpKSsobi54Km4ueCtuLnkqbi55KSpScy50cmlBcmVhKHQsZSxpKS0oaS54KmkueCtpLnkqaS55KSpScy50cmlBcmVhKHQsZSxuKT4wO3JldHVybiByfSxScy5pc0luQ2lyY2xlUm9idXN0PWZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiBScy5pc0luQ2lyY2xlTm9ybWFsaXplZCh0LGUsbixpKX0sUnMudHJpQXJlYUREU2xvdz1mdW5jdGlvbih0LGUsbixpLHIscyl7cmV0dXJuIG4uc3VidHJhY3QodCkubXVsdGlwbHkocy5zdWJ0cmFjdChlKSkuc3VidHJhY3QoaS5zdWJ0cmFjdChlKS5tdWx0aXBseShyLnN1YnRyYWN0KHQpKSl9LFJzLnRyaUFyZWFEREZhc3Q9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPV8udmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShfLnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3QodC55KSkscj1fLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KHQueCkpO3JldHVybiBpLnNlbGZTdWJ0cmFjdChyKX0sZShUcy5wcm90b3R5cGUse2NpcmNsZUNlbnRlcjpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBUcyh0aGlzLmdldFgoKSx0aGlzLmdldFkoKSksaT10aGlzLmJpc2VjdG9yKG4sdCkscj10aGlzLmJpc2VjdG9yKHQsZSkscz1uZXcgRihpLHIpLG89bnVsbDt0cnl7bz1uZXcgVHMocy5nZXRYKCkscy5nZXRZKCkpfWNhdGNoKGEpe2lmKCEoYSBpbnN0YW5jZW9mIHcpKXRocm93IGE7QS5lcnIucHJpbnRsbihcImE6IFwiK24rXCIgIGI6IFwiK3QrXCIgIGM6IFwiK2UpLEEuZXJyLnByaW50bG4oYSl9ZmluYWxseXt9cmV0dXJuIG99LGRvdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wLngqdC5nZXRYKCkrdGhpcy5wLnkqdC5nZXRZKCl9LG1hZ246ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMucC54KnRoaXMucC54K3RoaXMucC55KnRoaXMucC55KX0sZ2V0WjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAuen0sYmlzZWN0b3I6ZnVuY3Rpb24odCxlKXt2YXIgbj1lLmdldFgoKS10LmdldFgoKSxpPWUuZ2V0WSgpLXQuZ2V0WSgpLHI9bmV3IEYodC5nZXRYKCkrbi8yLHQuZ2V0WSgpK2kvMiwxKSxzPW5ldyBGKHQuZ2V0WCgpLWkrbi8yLHQuZ2V0WSgpK24raS8yLDEpO3JldHVybiBuZXcgRihyLHMpfSxlcXVhbHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnAueD09PXQuZ2V0WCgpJiZ0aGlzLnAueT09PXQuZ2V0WSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMucC5kaXN0YW5jZShlLmdldENvb3JkaW5hdGUoKSk8bn19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wfSxpc0luQ2lyY2xlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gUnMuaXNJbkNpcmNsZVJvYnVzdCh0LnAsZS5wLG4ucCx0aGlzLnApfSxpbnRlcnBvbGF0ZVpWYWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRYKCkscj10LmdldFkoKSxzPWUuZ2V0WCgpLWksbz1uLmdldFgoKS1pLGE9ZS5nZXRZKCktcix1PW4uZ2V0WSgpLXIsbD1zKnUtbyphLGg9dGhpcy5nZXRYKCktaSxjPXRoaXMuZ2V0WSgpLXIsZj0odSpoLW8qYykvbCxnPSgtYSpoK3MqYykvbCxkPXQuZ2V0WigpK2YqKGUuZ2V0WigpLXQuZ2V0WigpKStnKihuLmdldFooKS10LmdldFooKSk7cmV0dXJuIGR9LG1pZFBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPSh0aGlzLnAueCt0LmdldFgoKSkvMixuPSh0aGlzLnAueSt0LmdldFkoKSkvMixpPSh0aGlzLnAueit0LmdldFooKSkvMjtyZXR1cm4gbmV3IFRzKGUsbixpKX0scmlnaHRPZjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0LmRlc3QoKSx0Lm9yaWcoKSl9LGlzQ0NXOmZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQucC54LXRoaXMucC54KSooZS5wLnktdGhpcy5wLnkpLSh0LnAueS10aGlzLnAueSkqKGUucC54LXRoaXMucC54KT4wfSxnZXRYOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC54fSxjcm9zc1Byb2R1Y3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucC54KnQuZ2V0WSgpLXRoaXMucC55KnQuZ2V0WCgpfSxzZXRaOmZ1bmN0aW9uKHQpe3RoaXMucC56PXR9LHRpbWVzOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVHModCp0aGlzLnAueCx0KnRoaXMucC55KX0sY3Jvc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRzKHRoaXMucC55LC10aGlzLnAueCl9LGxlZnRPZjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0Lm9yaWcoKSx0LmRlc3QoKSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJQT0lOVCAoXCIrdGhpcy5wLngrXCIgXCIrdGhpcy5wLnkrXCIpXCJ9LHN1YjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFRzKHRoaXMucC54LXQuZ2V0WCgpLHRoaXMucC55LXQuZ2V0WSgpKX0sZ2V0WTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAueX0sY2xhc3NpZnk6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLGk9ZS5zdWIodCkscj1uLnN1Yih0KSxzPWkuY3Jvc3NQcm9kdWN0KHIpO3JldHVybiBzPjA/VHMuTEVGVDowPnM/VHMuUklHSFQ6aS5nZXRYKCkqci5nZXRYKCk8MHx8aS5nZXRZKCkqci5nZXRZKCk8MD9Ucy5CRUhJTkQ6aS5tYWduKCk8ci5tYWduKCk/VHMuQkVZT05EOnQuZXF1YWxzKG4pP1RzLk9SSUdJTjplLmVxdWFscyhuKT9Ucy5ERVNUSU5BVElPTjpUcy5CRVRXRUVOfSxzdW06ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBUcyh0aGlzLnAueCt0LmdldFgoKSx0aGlzLnAueSt0LmdldFkoKSl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlLmdldFgoKS10LmdldFgoKSwyKStNYXRoLnBvdyhlLmdldFkoKS10LmdldFkoKSwyKSl9LGNpcmN1bVJhZGl1c1JhdGlvOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5jaXJjbGVDZW50ZXIodCxlKSxpPXRoaXMuZGlzdGFuY2Uobix0KSxyPXRoaXMuZGlzdGFuY2UodGhpcyx0KSxzPXRoaXMuZGlzdGFuY2UodCxlKTtyZXR1cm4gcj5zJiYocj1zKSxzPXRoaXMuZGlzdGFuY2UoZSx0aGlzKSxyPnMmJihyPXMpLGkvcn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVHN9fSksVHMuaW50ZXJwb2xhdGVaPWZ1bmN0aW9uKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWUuZGlzdGFuY2Uobikscj10LmRpc3RhbmNlKGUpLHM9bi56LWUueixvPWUueitzKihyL2kpO3JldHVybiBvfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV0sbD1hcmd1bWVudHNbMl0saD1hcmd1bWVudHNbM10sYz11LngsZj11LnksZz1sLngtYyxkPWgueC1jLHA9bC55LWYsdj1oLnktZixtPWcqdi1kKnAseT1hLngtYyx4PWEueS1mLEU9KHYqeS1kKngpL20sST0oLXAqeStnKngpL20sTj11LnorRSoobC56LXUueikrSSooaC56LXUueik7cmV0dXJuIE59fSxUcy5MRUZUPTAsVHMuUklHSFQ9MSxUcy5CRVlPTkQ9MixUcy5CRUhJTkQ9MyxUcy5CRVRXRUVOPTQsVHMuT1JJR0lOPTUsVHMuREVTVElOQVRJT049NixoKFBzLFRzKSxlKFBzLnByb3RvdHlwZSx7Z2V0Q29uc3RyYWludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cmFpbnR9LHNldE9uQ29uc3RyYWludDpmdW5jdGlvbih0KXt0aGlzLl9pc09uQ29uc3RyYWludD10fSxtZXJnZTpmdW5jdGlvbih0KXt0Ll9pc09uQ29uc3RyYWludCYmKHRoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuY29uc3RyYWludD10LmNvbnN0cmFpbnQpfSxpc09uQ29uc3RyYWludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc09uQ29uc3RyYWludH0sc2V0Q29uc3RyYWludDpmdW5jdGlvbih0KXt0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLmNvbnN0cmFpbnQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUHN9fSksZShicy5wcm90b3R5cGUse2VxdWFsc05vbk9yaWVudGVkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVxdWFsc09yaWVudGVkKHQpPyEwOiEhdGhpcy5lcXVhbHNPcmllbnRlZCh0LnN5bSgpKX0sdG9MaW5lU2VnbWVudDpmdW5jdGlvbigpe3JldHVybiBuZXcgY2UodGhpcy52ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9LGRlc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW0oKS5vcmlnKCl9LG9OZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dH0sZXF1YWxzT3JpZW50ZWQ6ZnVuY3Rpb24odCl7cmV0dXJuISghdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSl8fCF0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKSl9LGROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKS5zeW0oKX0sbFByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0LnN5bSgpfSxyUHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCl9LHJvdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3R9LG9QcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5uZXh0Ll9yb3R9LHN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3QuX3JvdH0sc2V0T3JpZzpmdW5jdGlvbih0KXt0aGlzLnZlcnRleD10fSxsTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkucm90KCl9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2UodGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX0saW52Um90OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5zeW0oKX0sc2V0RGVzdDpmdW5jdGlvbih0KXt0aGlzLnN5bSgpLnNldE9yaWcodCl9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxcImRlbGV0ZVwiOmZ1bmN0aW9uKCl7dGhpcy5fcm90PW51bGx9LG9yaWc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJ0ZXh9LHJOZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5uZXh0LmludlJvdCgpfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PXRoaXMudmVydGV4LmdldENvb3JkaW5hdGUoKSxlPXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKTtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKHQsZSl9LGlzTGl2ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5fcm90fSxnZXRQcmltYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTw9MD90aGlzOnRoaXMuc3ltKCl9LGRQcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5pbnZSb3QoKX0sc2V0TmV4dDpmdW5jdGlvbih0KXt0aGlzLm5leHQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYnN9fSksYnMubWFrZUVkZ2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgYnMsaT1uZXcgYnMscj1uZXcgYnMscz1uZXcgYnM7bi5fcm90PWksaS5fcm90PXIsci5fcm90PXMscy5fcm90PW4sbi5zZXROZXh0KG4pLGkuc2V0TmV4dChzKSxyLnNldE5leHQocikscy5zZXROZXh0KGkpO3ZhciBvPW47cmV0dXJuIG8uc2V0T3JpZyh0KSxvLnNldERlc3QoZSksb30sYnMuc3dhcD1mdW5jdGlvbih0KXt2YXIgZT10Lm9QcmV2KCksbj10LnN5bSgpLm9QcmV2KCk7YnMuc3BsaWNlKHQsZSksYnMuc3BsaWNlKHQuc3ltKCksbiksYnMuc3BsaWNlKHQsZS5sTmV4dCgpKSxicy5zcGxpY2UodC5zeW0oKSxuLmxOZXh0KCkpLHQuc2V0T3JpZyhlLmRlc3QoKSksdC5zZXREZXN0KG4uZGVzdCgpKX0sYnMuc3BsaWNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5vTmV4dCgpLnJvdCgpLGk9ZS5vTmV4dCgpLnJvdCgpLHI9ZS5vTmV4dCgpLHM9dC5vTmV4dCgpLG89aS5vTmV4dCgpLGE9bi5vTmV4dCgpO3Quc2V0TmV4dChyKSxlLnNldE5leHQocyksbi5zZXROZXh0KG8pLGkuc2V0TmV4dChhKX0sYnMuY29ubmVjdD1mdW5jdGlvbih0LGUpe3ZhciBuPWJzLm1ha2VFZGdlKHQuZGVzdCgpLGUub3JpZygpKTtyZXR1cm4gYnMuc3BsaWNlKG4sdC5sTmV4dCgpKSxicy5zcGxpY2Uobi5zeW0oKSxlKSxufSxlKE9zLnByb3RvdHlwZSx7aW5zZXJ0U2l0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnN1YmRpdi5sb2NhdGUodCk7aWYodGhpcy5zdWJkaXYuaXNWZXJ0ZXhPZkVkZ2UoZSx0KSlyZXR1cm4gZTt0aGlzLnN1YmRpdi5pc09uRWRnZShlLHQuZ2V0Q29vcmRpbmF0ZSgpKSYmKGU9ZS5vUHJldigpLHRoaXMuc3ViZGl2W1wiZGVsZXRlXCJdKGUub05leHQoKSkpO3ZhciBuPXRoaXMuc3ViZGl2Lm1ha2VFZGdlKGUub3JpZygpLHQpO2JzLnNwbGljZShuLGUpO3ZhciBpPW47ZG8gbj10aGlzLnN1YmRpdi5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCk7d2hpbGUoZS5sTmV4dCgpIT09aSk7Zm9yKDs7KXt2YXIgcj1lLm9QcmV2KCk7aWYoci5kZXN0KCkucmlnaHRPZihlKSYmdC5pc0luQ2lyY2xlKGUub3JpZygpLHIuZGVzdCgpLGUuZGVzdCgpKSlicy5zd2FwKGUpLGU9ZS5vUHJldigpO2Vsc2V7aWYoZS5vTmV4dCgpPT09aSlyZXR1cm4gbjtlPWUub05leHQoKS5sUHJldigpfX19LGluc2VydFNpdGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUobil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPc319KSxlKF9zLnByb3RvdHlwZSx7bG9jYXRlOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX3N9fSksZShNcy5wcm90b3R5cGUse2luaXQ6ZnVuY3Rpb24oKXt0aGlzLmxhc3RFZGdlPXRoaXMuZmluZEVkZ2UoKX0sbG9jYXRlOmZ1bmN0aW9uKHQpe3RoaXMubGFzdEVkZ2UuaXNMaXZlKCl8fHRoaXMuaW5pdCgpO3ZhciBlPXRoaXMuc3ViZGl2LmxvY2F0ZUZyb21FZGdlKHQsdGhpcy5sYXN0RWRnZSk7cmV0dXJuIHRoaXMubGFzdEVkZ2U9ZSxlfSxmaW5kRWRnZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3ViZGl2LmdldEVkZ2VzKCk7cmV0dXJuIHQuaXRlcmF0b3IoKS5uZXh0KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW19zXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTXN9fSksaChEcyxsKSxlKERzLnByb3RvdHlwZSx7Z2V0U2VnbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRHN9fSksRHMubXNnV2l0aFNwYXRpYWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9LGUoQXMucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFzfX0pLGUoRnMucHJvdG90eXBlLHtnZXRUcmlhbmdsZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBCcztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVWZXJ0aWNlcygpfSxpc0ZyYW1lVmVydGV4OmZ1bmN0aW9uKHQpe3JldHVybiB0LmVxdWFscyh0aGlzLmZyYW1lVmVydGV4WzBdKT8hMDp0LmVxdWFscyh0aGlzLmZyYW1lVmVydGV4WzFdKT8hMDohIXQuZXF1YWxzKHRoaXMuZnJhbWVWZXJ0ZXhbMl0pfSxpc1ZlcnRleE9mRWRnZTpmdW5jdGlvbih0LGUpe3JldHVybiEoIWUuZXF1YWxzKHQub3JpZygpLHRoaXMudG9sZXJhbmNlKSYmIWUuZXF1YWxzKHQuZGVzdCgpLHRoaXMudG9sZXJhbmNlKSl9LGNvbm5lY3Q6ZnVuY3Rpb24odCxlKXt2YXIgbj1icy5jb25uZWN0KHQsZSk7cmV0dXJuIHRoaXMucXVhZEVkZ2VzLmFkZChuKSxufSxnZXRWb3Jvbm9pQ2VsbFBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgSSxpPXQ7ZG97dmFyIHI9dC5yb3QoKS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpO24uYWRkKHIpLHQ9dC5vUHJldigpfXdoaWxlKHQhPT1pKTt2YXIgcz1uZXcgTjtzLmFkZEFsbChuLCExKSxzLmNsb3NlUmluZygpLHMuc2l6ZSgpPDQmJihBLm91dC5wcmludGxuKHMpLHMuYWRkKHMuZ2V0KHMuc2l6ZSgpLTEpLCEwKSk7dmFyIG89cy50b0Nvb3JkaW5hdGVBcnJheSgpLGE9ZS5jcmVhdGVQb2x5Z29uKGUuY3JlYXRlTGluZWFyUmluZyhvKSxudWxsKSx1PWkub3JpZygpO3JldHVybiBhLnNldFVzZXJEYXRhKHUuZ2V0Q29vcmRpbmF0ZSgpKSxhfSxzZXRMb2NhdG9yOmZ1bmN0aW9uKHQpe3RoaXMubG9jYXRvcj10fSxpbml0U3ViZGl2OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tYWtlRWRnZSh0aGlzLmZyYW1lVmVydGV4WzBdLHRoaXMuZnJhbWVWZXJ0ZXhbMV0pLGU9dGhpcy5tYWtlRWRnZSh0aGlzLmZyYW1lVmVydGV4WzFdLHRoaXMuZnJhbWVWZXJ0ZXhbMl0pO2JzLnNwbGljZSh0LnN5bSgpLGUpO3ZhciBuPXRoaXMubWFrZUVkZ2UodGhpcy5mcmFtZVZlcnRleFsyXSx0aGlzLmZyYW1lVmVydGV4WzBdKTtyZXR1cm4gYnMuc3BsaWNlKGUuc3ltKCksbiksYnMuc3BsaWNlKG4uc3ltKCksdCksdH0saXNGcmFtZUJvcmRlckVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7RnMuZ2V0VHJpYW5nbGVFZGdlcyh0LGUpO3ZhciBuPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO0ZzLmdldFRyaWFuZ2xlRWRnZXModC5zeW0oKSxuKTt2YXIgaT10LmxOZXh0KCkuZGVzdCgpO2lmKHRoaXMuaXNGcmFtZVZlcnRleChpKSlyZXR1cm4hMDt2YXIgcj10LnN5bSgpLmxOZXh0KCkuZGVzdCgpO3JldHVybiEhdGhpcy5pc0ZyYW1lVmVydGV4KHIpfSxtYWtlRWRnZTpmdW5jdGlvbih0LGUpe3ZhciBuPWJzLm1ha2VFZGdlKHQsZSk7cmV0dXJuIHRoaXMucXVhZEVkZ2VzLmFkZChuKSxufSx2aXNpdFRyaWFuZ2xlczpmdW5jdGlvbih0LGUpe3RoaXMudmlzaXRlZEtleSsrO3ZhciBuPW5ldyBwZTtuLnB1c2godGhpcy5zdGFydGluZ0VkZ2UpO2Zvcih2YXIgaT1uZXcgSjshbi5lbXB0eSgpOyl7dmFyIHI9bi5wb3AoKTtpZighaS5jb250YWlucyhyKSl7dmFyIHM9dGhpcy5mZXRjaFRyaWFuZ2xlVG9WaXNpdChyLG4sZSxpKTtudWxsIT09cyYmdC52aXNpdChzKX19fSxpc0ZyYW1lRWRnZTpmdW5jdGlvbih0KXtyZXR1cm4hKCF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5vcmlnKCkpJiYhdGhpcy5pc0ZyYW1lVmVydGV4KHQuZGVzdCgpKSl9LGlzT25FZGdlOmZ1bmN0aW9uKHQsZSl7dGhpcy5zZWcuc2V0Q29vcmRpbmF0ZXModC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSk7dmFyIG49dGhpcy5zZWcuZGlzdGFuY2UoZSk7cmV0dXJuIG48dGhpcy5lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2V9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDKHRoaXMuZnJhbWVFbnYpfSxjcmVhdGVGcmFtZTpmdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpLGk9MDtpPWU+bj8xMCplOjEwKm4sdGhpcy5mcmFtZVZlcnRleFswXT1uZXcgVHMoKHQuZ2V0TWF4WCgpK3QuZ2V0TWluWCgpKS8yLHQuZ2V0TWF4WSgpK2kpLHRoaXMuZnJhbWVWZXJ0ZXhbMV09bmV3IFRzKHQuZ2V0TWluWCgpLWksdC5nZXRNaW5ZKCktaSksdGhpcy5mcmFtZVZlcnRleFsyXT1uZXcgVHModC5nZXRNYXhYKCkraSx0LmdldE1pblkoKS1pKSx0aGlzLmZyYW1lRW52PW5ldyBDKHRoaXMuZnJhbWVWZXJ0ZXhbMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZnJhbWVWZXJ0ZXhbMV0uZ2V0Q29vcmRpbmF0ZSgpKSx0aGlzLmZyYW1lRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmZyYW1lVmVydGV4WzJdLmdldENvb3JkaW5hdGUoKSl9LGdldFRyaWFuZ2xlQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHpzO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZXMoKX0sZ2V0VmVydGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBKLG49dGhpcy5xdWFkRWRnZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5vcmlnKCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQocik7dmFyIHM9aS5kZXN0KCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChzKXx8ZS5hZGQocyl9cmV0dXJuIGV9LGZldGNoVHJpYW5nbGVUb1Zpc2l0OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQscz0wLG89ITE7ZG97dGhpcy50cmlFZGdlc1tzXT1yLHRoaXMuaXNGcmFtZUVkZ2UocikmJihvPSEwKTt2YXIgYT1yLnN5bSgpO2kuY29udGFpbnMoYSl8fGUucHVzaChhKSxpLmFkZChyKSxzKysscj1yLmxOZXh0KCl9d2hpbGUociE9PXQpO3JldHVybiBvJiYhbj9udWxsOnRoaXMudHJpRWRnZXN9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMucXVhZEVkZ2VzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5nZXRQcmltYXJ5RWRnZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpLGk9MCxyPWUuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO25baSsrXT10LmNyZWF0ZUxpbmVTdHJpbmcoW3Mub3JpZygpLmdldENvb3JkaW5hdGUoKSxzLmRlc3QoKS5nZXRDb29yZGluYXRlKCldKX1yZXR1cm4gdC5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobil9fSxnZXRWZXJ0ZXhVbmlxdWVFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj1uZXcgSixpPXRoaXMucXVhZEVkZ2VzLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKSxzPXIub3JpZygpO24uY29udGFpbnMocyl8fChuLmFkZChzKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHMpfHxlLmFkZChyKSk7dmFyIG89ci5zeW0oKSxhPW8ub3JpZygpO24uY29udGFpbnMoYSl8fChuLmFkZChhKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KGEpfHxlLmFkZChvKSl9cmV0dXJuIGV9LGdldFRyaWFuZ2xlRWRnZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHFzO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZUVkZ2VzKCl9LGdldFByaW1hcnlFZGdlczpmdW5jdGlvbih0KXt0aGlzLnZpc2l0ZWRLZXkrKzt2YXIgZT1uZXcgSSxuPW5ldyBwZTtuLnB1c2godGhpcy5zdGFydGluZ0VkZ2UpO2Zvcih2YXIgaT1uZXcgSjshbi5lbXB0eSgpOyl7dmFyIHI9bi5wb3AoKTtpZighaS5jb250YWlucyhyKSl7dmFyIHM9ci5nZXRQcmltYXJ5KCk7IXQmJnRoaXMuaXNGcmFtZUVkZ2Uocyl8fGUuYWRkKHMpLG4ucHVzaChyLm9OZXh0KCkpLG4ucHVzaChyLnN5bSgpLm9OZXh0KCkpLGkuYWRkKHIpLGkuYWRkKHIuc3ltKCkpfX1yZXR1cm4gZX0sXCJkZWxldGVcIjpmdW5jdGlvbih0KXticy5zcGxpY2UodCx0Lm9QcmV2KCkpLGJzLnNwbGljZSh0LnN5bSgpLHQuc3ltKCkub1ByZXYoKSk7dmFyIGU9dC5zeW0oKSxuPXQucm90KCksaT10LnJvdCgpLnN5bSgpO3RoaXMucXVhZEVkZ2VzLnJlbW92ZSh0KSx0aGlzLnF1YWRFZGdlcy5yZW1vdmUoZSksdGhpcy5xdWFkRWRnZXMucmVtb3ZlKG4pLHRoaXMucXVhZEVkZ2VzLnJlbW92ZShpKSx0W1wiZGVsZXRlXCJdKCksZVtcImRlbGV0ZVwiXSgpLG5bXCJkZWxldGVcIl0oKSxpW1wiZGVsZXRlXCJdKCl9LGxvY2F0ZUZyb21FZGdlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAsaT10aGlzLnF1YWRFZGdlcy5zaXplKCkscj1lOzspe2lmKG4rKyxuPmkpdGhyb3cgbmV3IERzKHIudG9MaW5lU2VnbWVudCgpKTtpZih0LmVxdWFscyhyLm9yaWcoKSl8fHQuZXF1YWxzKHIuZGVzdCgpKSlicmVhaztpZih0LnJpZ2h0T2Yocikpcj1yLnN5bSgpO2Vsc2UgaWYodC5yaWdodE9mKHIub05leHQoKSkpe2lmKHQucmlnaHRPZihyLmRQcmV2KCkpKWJyZWFrO3I9ci5kUHJldigpfWVsc2Ugcj1yLm9OZXh0KCl9cmV0dXJuIHJ9LGdldFRvbGVyYW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvbGVyYW5jZX0sZ2V0Vm9yb25vaUNlbGxQb2x5Z29uczpmdW5jdGlvbih0KXt0aGlzLnZpc2l0VHJpYW5nbGVzKG5ldyBHcywhMCk7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5nZXRWZXJ0ZXhVbmlxdWVFZGdlcyghMSksaT1uLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtlLmFkZCh0aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbihyLHQpKX1yZXR1cm4gZX0sZ2V0Vm9yb25vaURpYWdyYW06ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb25zKHQpO3JldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkoZSkpfSxnZXRUcmlhbmdsZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZ2V0VHJpYW5nbGVDb29yZGluYXRlcyghMSksbj1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCksaT0wLHI9ZS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7bltpKytdPXQuY3JlYXRlUG9seWdvbih0LmNyZWF0ZUxpbmVhclJpbmcocyksbnVsbCl9cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG4pfSxpbnNlcnRTaXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubG9jYXRlKHQpO2lmKHQuZXF1YWxzKGUub3JpZygpLHRoaXMudG9sZXJhbmNlKXx8dC5lcXVhbHMoZS5kZXN0KCksdGhpcy50b2xlcmFuY2UpKXJldHVybiBlO3ZhciBuPXRoaXMubWFrZUVkZ2UoZS5vcmlnKCksdCk7YnMuc3BsaWNlKG4sZSk7dmFyIGk9bjtkbyBuPXRoaXMuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpO3doaWxlKGUubE5leHQoKSE9PWkpO3JldHVybiBpfSxsb2NhdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUcyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmxvY2F0b3IubG9jYXRlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmxvY2F0b3IubG9jYXRlKG5ldyBUcyhlKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPXRoaXMubG9jYXRvci5sb2NhdGUobmV3IFRzKG4pKTtpZihudWxsPT09cilyZXR1cm4gbnVsbDt2YXIgcz1yO3IuZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRChuKSYmKHM9ci5zeW0oKSk7dmFyIG89cztkb3tpZihvLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQoaSkpcmV0dXJuIG87bz1vLm9OZXh0KCl9d2hpbGUobyE9PXMpO3JldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRnN9fSksRnMuZ2V0VHJpYW5nbGVFZGdlcz1mdW5jdGlvbih0LGUpe2lmKGVbMF09dCxlWzFdPWVbMF0ubE5leHQoKSxlWzJdPWVbMV0ubE5leHQoKSxlWzJdLmxOZXh0KCkhPT1lWzBdKXRocm93IG5ldyBpKFwiRWRnZXMgZG8gbm90IGZvcm0gYSB0cmlhbmdsZVwiKX0sZShHcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10WzBdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksbj10WzFdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksaT10WzJdLm9yaWcoKS5nZXRDb29yZGluYXRlKCkscj1TaS5jaXJjdW1jZW50cmUoZSxuLGkpLHM9bmV3IFRzKHIpLG89MDszPm87bysrKXRbb10ucm90KCkuc2V0T3JpZyhzKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQXNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHc319KSxlKHFzLnByb3RvdHlwZSx7Z2V0VHJpYW5nbGVFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyaUxpc3R9LHZpc2l0OmZ1bmN0aW9uKHQpe3RoaXMudHJpTGlzdC5hZGQodC5jbG9uZSgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQXNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxc319KSxlKEJzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7dGhpcy50cmlMaXN0LmFkZChbdFswXS5vcmlnKCksdFsxXS5vcmlnKCksdFsyXS5vcmlnKCldKX0sZ2V0VHJpYW5nbGVWZXJ0aWNlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyaUxpc3R9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQnN9fSksZSh6cy5wcm90b3R5cGUse2NoZWNrVHJpYW5nbGVTaXplOmZ1bmN0aW9uKHQpe3ZhciBlPVwiXCI7dC5sZW5ndGg+PTI/ZT1zZS50b0xpbmVTdHJpbmcodFswXSx0WzFdKTp0Lmxlbmd0aD49MSYmKGU9c2UudG9Qb2ludCh0WzBdKSl9LHZpc2l0OmZ1bmN0aW9uKHQpe3RoaXMuY29vcmRMaXN0LmNsZWFyKCk7Zm9yKHZhciBlPTA7Mz5lO2UrKyl7dmFyIG49dFtlXS5vcmlnKCk7dGhpcy5jb29yZExpc3QuYWRkKG4uZ2V0Q29vcmRpbmF0ZSgpKX1pZih0aGlzLmNvb3JkTGlzdC5zaXplKCk+MCl7dGhpcy5jb29yZExpc3QuY2xvc2VSaW5nKCk7dmFyIGk9dGhpcy5jb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKTtpZig0IT09aS5sZW5ndGgpcmV0dXJuIG51bGw7dGhpcy50cmlDb29yZHMuYWRkKGkpfX0sZ2V0VHJpYW5nbGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJpQ29vcmRzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHpzfX0pLEZzLlRyaWFuZ2xlQ2lyY3VtY2VudHJlVmlzaXRvcj1HcyxGcy5UcmlhbmdsZUVkZ2VzTGlzdFZpc2l0b3I9cXMsRnMuVHJpYW5nbGVWZXJ0ZXhMaXN0VmlzaXRvcj1CcyxGcy5UcmlhbmdsZUNvb3JkaW5hdGVzVmlzaXRvcj16cyxGcy5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1I9MWUzLGUoVnMucHJvdG90eXBlLHtnZXRMaW5lU2VnbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzfSxnZXRFbmRaOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDEpO3JldHVybiB0Lnp9LGdldFN0YXJ0WjpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgwKTtyZXR1cm4gdC56fSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubHMuaW50ZXJzZWN0aW9uKHQuZ2V0TGluZVNlZ21lbnQoKSl9LGdldFN0YXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgwKX0sZ2V0RW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKX0sZ2V0RW5kWTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKTtyZXR1cm4gdC55fSxnZXRTdGFydFg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMCk7cmV0dXJuIHQueH0sZXF1YWxzVG9wbzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5scy5lcXVhbHNUb3BvKHQuZ2V0TGluZVNlZ21lbnQoKSl9LGdldFN0YXJ0WTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgwKTtyZXR1cm4gdC55fSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZ2V0RW5kWDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKTtyZXR1cm4gdC54fSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzLnRvU3RyaW5nKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZzfX0pLGUoa3MucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtzfX0pLGUoWXMucHJvdG90eXBlLHtpc1JlcGVhdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY291bnQ+MX0sZ2V0UmlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB9LHNldExlZnQ6ZnVuY3Rpb24odCl7dGhpcy5sZWZ0PXR9LGdldFg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnh9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxnZXRDb3VudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvdW50fSxnZXRMZWZ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVmdH0sZ2V0WTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAueX0saW5jcmVtZW50OmZ1bmN0aW9uKCl7dGhpcy5jb3VudD10aGlzLmNvdW50KzF9LHNldFJpZ2h0OmZ1bmN0aW9uKHQpe3RoaXMucmlnaHQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWXN9fSksZShVcy5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5zZXJ0KHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtpZihudWxsPT09dGhpcy5yb290KXJldHVybiB0aGlzLnJvb3Q9bmV3IFlzKGUsbiksdGhpcy5yb290O2lmKHRoaXMudG9sZXJhbmNlPjApe3ZhciBpPXRoaXMuZmluZEJlc3RNYXRjaE5vZGUoZSk7aWYobnVsbCE9PWkpcmV0dXJuIGkuaW5jcmVtZW50KCksaX1yZXR1cm4gdGhpcy5pbnNlcnRFeGFjdChlLG4pfX0scXVlcnk6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMsZT10aGlzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1uZXcgSTtyZXR1cm4gdGhpcy5xdWVyeShuLGkpLGl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDJiZSKGFyZ3VtZW50c1sxXSx5KSkhZnVuY3Rpb24oKXt2YXIgbj10WzBdLGk9dFsxXTtlLnF1ZXJ5Tm9kZShlLnJvb3QsbiwhMCx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5ba3NdfSx2aXNpdDpmdW5jdGlvbih0KXtpLmFkZCh0KX19KX0oKTtlbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyYmUihhcmd1bWVudHNbMV0sa3MpKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV07dGhpcy5xdWVyeU5vZGUodGhpcy5yb290LHIsITAscyl9fSxxdWVyeU5vZGU6ZnVuY3Rpb24odCxlLG4saSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dmFyIHI9bnVsbCxzPW51bGwsbz1udWxsO24/KHI9ZS5nZXRNaW5YKCkscz1lLmdldE1heFgoKSxvPXQuZ2V0WCgpKToocj1lLmdldE1pblkoKSxzPWUuZ2V0TWF4WSgpLG89dC5nZXRZKCkpO3ZhciBhPW8+cix1PXM+PW87YSYmdGhpcy5xdWVyeU5vZGUodC5nZXRMZWZ0KCksZSwhbixpKSxlLmNvbnRhaW5zKHQuZ2V0Q29vcmRpbmF0ZSgpKSYmaS52aXNpdCh0KSx1JiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldFJpZ2h0KCksZSwhbixpKX0sZmluZEJlc3RNYXRjaE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IFhzKHQsdGhpcy50b2xlcmFuY2UpO3JldHVybiB0aGlzLnF1ZXJ5KGUucXVlcnlFbnZlbG9wZSgpLGUpLGUuZ2V0Tm9kZSgpfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnJvb3R9LGluc2VydEV4YWN0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMucm9vdCxpPXRoaXMucm9vdCxyPSEwLHM9ITA7bnVsbCE9PW47KXtpZihudWxsIT09bil7dmFyIG89dC5kaXN0YW5jZShuLmdldENvb3JkaW5hdGUoKSk8PXRoaXMudG9sZXJhbmNlO2lmKG8pcmV0dXJuIG4uaW5jcmVtZW50KCksbn1zPXI/dC54PG4uZ2V0WCgpOnQueTxuLmdldFkoKSxpPW4sbj1zP24uZ2V0TGVmdCgpOm4uZ2V0UmlnaHQoKSxyPSFyfXRoaXMubnVtYmVyT2ZOb2Rlcz10aGlzLm51bWJlck9mTm9kZXMrMTt2YXIgYT1uZXcgWXModCxlKTtyZXR1cm4gcz9pLnNldExlZnQoYSk6aS5zZXRSaWdodChhKSxhfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVc319KSxVcy50b0Nvb3JkaW5hdGVzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gVXMudG9Db29yZGluYXRlcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPW5ldyBOLHI9ZS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOylmb3IodmFyIHM9ci5uZXh0KCksbz1uP3MuZ2V0Q291bnQoKToxLGE9MDtvPmE7YSsrKWkuYWRkKHMuZ2V0Q29vcmRpbmF0ZSgpLCEwKTtyZXR1cm4gaS50b0Nvb3JkaW5hdGVBcnJheSgpfX0sZShYcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSksbj1lPD10aGlzLnRvbGVyYW5jZTtpZighbilyZXR1cm4gbnVsbDt2YXIgaT0hMTsobnVsbD09PXRoaXMubWF0Y2hOb2RlfHxlPHRoaXMubWF0Y2hEaXN0fHxudWxsIT09dGhpcy5tYXRjaE5vZGUmJmU9PT10aGlzLm1hdGNoRGlzdCYmdC5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMubWF0Y2hOb2RlLmdldENvb3JkaW5hdGUoKSk8MSkmJihpPSEwKSxpJiYodGhpcy5tYXRjaE5vZGU9dCx0aGlzLm1hdGNoRGlzdD1lKX0scXVlcnlFbnZlbG9wZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBDKHRoaXMucCk7cmV0dXJuIHQuZXhwYW5kQnkodGhpcy50b2xlcmFuY2UpLHR9LGdldE5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXRjaE5vZGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2tzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWHN9fSksVXMuQmVzdE1hdGNoVmlzaXRvcj1YcyxlKEhzLnByb3RvdHlwZSx7Z2V0SW5pdGlhbFZlcnRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdGlhbFZlcnRpY2VzfSxnZXRLRFQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZHR9LGVuZm9yY2VDb25zdHJhaW50czpmdW5jdGlvbigpe3RoaXMuYWRkQ29uc3RyYWludFZlcnRpY2VzKCk7dmFyIHQ9MCxlPTA7ZG8gZT10aGlzLmVuZm9yY2VHYWJyaWVsKHRoaXMuc2VnbWVudHMpLHQrKzt3aGlsZShlPjAmJnQ8SHMuTUFYX1NQTElUX0lURVIpfSxpbnNlcnRTaXRlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKG4pfX0sZ2V0VmVydGV4RmFjdG9yeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleEZhY3Rvcnl9LGdldFBvaW50QXJyYXk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuaW5pdGlhbFZlcnRpY2VzLnNpemUoKSt0aGlzLnNlZ1ZlcnRpY2VzLnNpemUoKSkuZmlsbChudWxsKSxlPTAsbj10aGlzLmluaXRpYWxWZXJ0aWNlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dFtlKytdPWkuZ2V0Q29vcmRpbmF0ZSgpfWZvcih2YXIgcj10aGlzLnNlZ1ZlcnRpY2VzLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgaT1yLm5leHQoKTt0W2UrK109aS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIHR9LHNldENvbnN0cmFpbnRzOmZ1bmN0aW9uKHQsZSl7dGhpcy5zZWdtZW50cz10LHRoaXMuc2VnVmVydGljZXM9ZX0sY29tcHV0ZUNvbnZleEh1bGw6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgaWUsZT10aGlzLmdldFBvaW50QXJyYXkoKSxuPW5ldyBtZShlLHQpO3RoaXMuY29udmV4SHVsbD1uLmdldENvbnZleEh1bGwoKX0sYWRkQ29uc3RyYWludFZlcnRpY2VzOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlQ29udmV4SHVsbCgpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5zZWdWZXJ0aWNlcyl9LGZpbmROb25HYWJyaWVsUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRTdGFydCgpLG49dC5nZXRFbmQoKSxpPW5ldyBnKChlLngrbi54KS8yLChlLnkrbi55KS8yKSxzPWUuZGlzdGFuY2UoaSksbz1uZXcgQyhpKTtvLmV4cGFuZEJ5KHMpO2Zvcih2YXIgYT10aGlzLmtkdC5xdWVyeShvKSx1PW51bGwsbD1yLk1BWF9WQUxVRSxoPWEuaXRlcmF0b3IoKTtoLmhhc05leHQoKTspe3ZhciBjPWgubmV4dCgpLGY9Yy5nZXRDb29yZGluYXRlKCk7aWYoIWYuZXF1YWxzMkQoZSkmJiFmLmVxdWFsczJEKG4pKXt2YXIgZD1pLmRpc3RhbmNlKGYpO2lmKHM+ZCl7dmFyIHA9ZDsobnVsbD09PXV8fGw+cCkmJih1PWYsbD1wKX19fXJldHVybiB1fSxnZXRDb25zdHJhaW50U2VnbWVudHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdtZW50c30sc2V0U3BsaXRQb2ludEZpbmRlcjpmdW5jdGlvbih0KXt0aGlzLnNwbGl0RmluZGVyPXR9LGdldENvbnZleEh1bGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb252ZXhIdWxsfSxnZXRUb2xlcmFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2xlcmFuY2V9LGVuZm9yY2VHYWJyaWVsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPTAsaT1uZXcgSSxyPXQuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89dGhpcy5maW5kTm9uR2FicmllbFBvaW50KHMpO2lmKG51bGwhPT1vKXt0aGlzLnNwbGl0UHQ9dGhpcy5zcGxpdEZpbmRlci5maW5kU3BsaXRQb2ludChzLG8pO3ZhciBhPXRoaXMuY3JlYXRlVmVydGV4KHRoaXMuc3BsaXRQdCxzKSx1PSh0aGlzLmluc2VydFNpdGUoYSksbmV3IFZzKHMuZ2V0U3RhcnRYKCkscy5nZXRTdGFydFkoKSxzLmdldFN0YXJ0WigpLGEuZ2V0WCgpLGEuZ2V0WSgpLGEuZ2V0WigpLHMuZ2V0RGF0YSgpKSksbD1uZXcgVnMoYS5nZXRYKCksYS5nZXRZKCksYS5nZXRaKCkscy5nZXRFbmRYKCkscy5nZXRFbmRZKCkscy5nZXRFbmRaKCkscy5nZXREYXRhKCkpO2UuYWRkKHUpLGUuYWRkKGwpLGkuYWRkKHMpLG4rPTF9fXJldHVybiB0LnJlbW92ZUFsbChpKSx0LmFkZEFsbChlKSxufSxjcmVhdGVWZXJ0ZXg6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bnVsbDtyZXR1cm4gZT1udWxsIT09dGhpcy52ZXJ0ZXhGYWN0b3J5P3RoaXMudmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgodCxudWxsKTpuZXcgUHModCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW51bGw7cmV0dXJuIGU9bnVsbCE9PXRoaXMudmVydGV4RmFjdG9yeT90aGlzLnZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KG4saSk6bmV3IFBzKG4pLGUuc2V0T25Db25zdHJhaW50KCEwKSxlfX0sZ2V0U3ViZGl2aXNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdWJkaXZ9LGNvbXB1dGVCb3VuZGluZ0JveDpmdW5jdGlvbigpe3ZhciB0PUhzLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLmluaXRpYWxWZXJ0aWNlcyksZT1Icy5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5zZWdWZXJ0aWNlcyksbj1uZXcgQyh0KTtuLmV4cGFuZFRvSW5jbHVkZShlKTt2YXIgaT0uMipuLmdldFdpZHRoKCkscj0uMipuLmdldEhlaWdodCgpLHM9TWF0aC5tYXgoaSxyKTt0aGlzLmNvbXB1dGVBcmVhRW52PW5ldyBDKG4pLHRoaXMuY29tcHV0ZUFyZWFFbnYuZXhwYW5kQnkocyl9LHNldFZlcnRleEZhY3Rvcnk6ZnVuY3Rpb24odCl7dGhpcy52ZXJ0ZXhGYWN0b3J5PXR9LGZvcm1Jbml0aWFsRGVsYXVuYXk6ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLHRoaXMuc3ViZGl2PW5ldyBGcyh0aGlzLmNvbXB1dGVBcmVhRW52LHRoaXMudG9sZXJhbmNlKSx0aGlzLnN1YmRpdi5zZXRMb2NhdG9yKG5ldyBNcyh0aGlzLnN1YmRpdikpLHRoaXMuaW5jRGVsPW5ldyBPcyh0aGlzLnN1YmRpdiksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLmluaXRpYWxWZXJ0aWNlcyl9LGluc2VydFNpdGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFBzKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLmtkdC5pbnNlcnQodC5nZXRDb29yZGluYXRlKCksdCk7aWYoZS5pc1JlcGVhdGVkKCkpe3ZhciBuPWUuZ2V0RGF0YSgpO3JldHVybiBuLm1lcmdlKHQpLG59cmV0dXJuIHRoaXMuaW5jRGVsLmluc2VydFNpdGUodCksdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBpPWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFNpdGUodGhpcy5jcmVhdGVWZXJ0ZXgoaSkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSHN9fSksSHMuY29tcHV0ZVZlcnRleEVudmVsb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQyxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKGkuZ2V0Q29vcmRpbmF0ZSgpKX1yZXR1cm4gZX0sSHMuTUFYX1NQTElUX0lURVI9OTksZShXcy5wcm90b3R5cGUse2NyZWF0ZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnN1YmRpdilyZXR1cm4gbnVsbDt2YXIgdD1Xcy5lbnZlbG9wZSh0aGlzLnNpdGVDb29yZHMpLGU9V3MudG9WZXJ0aWNlcyh0aGlzLnNpdGVDb29yZHMpO3RoaXMuc3ViZGl2PW5ldyBGcyh0LHRoaXMudG9sZXJhbmNlKTt2YXIgbj1uZXcgT3ModGhpcy5zdWJkaXYpO24uaW5zZXJ0U2l0ZXMoZSl9LHNldFRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLnRvbGVyYW5jZT10fSxzZXRTaXRlczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy51bmlxdWUoSC50b0Nvb3JkaW5hdGVBcnJheShlKSl9fSxnZXRFZGdlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRFZGdlcyh0KX0sZ2V0U3ViZGl2aXNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdn0sZ2V0VHJpYW5nbGVzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV3N9fSksV3MuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXJldHVybiBuZXcgTjt2YXIgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIFdzLnVuaXF1ZShlKX0sV3MuZW52ZWxvcGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBDLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5leHBhbmRUb0luY2x1ZGUoaSl9cmV0dXJuIGV9LFdzLnVuaXF1ZT1mdW5jdGlvbih0KXt2YXIgZT1ILmNvcHlEZWVwKHQpO3V0LnNvcnQoZSk7dmFyIG49bmV3IE4oZSwhMSk7cmV0dXJuIG59LFdzLnRvVmVydGljZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5hZGQobmV3IFRzKGkpKX1yZXR1cm4gZX0sZShqcy5wcm90b3R5cGUse2NyZWF0ZVNpdGVWZXJ0aWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXAuY29udGFpbnNLZXkoaSl8fGUuYWRkKG5ldyBQcyhpKSl9cmV0dXJuIGV9LGNyZWF0ZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnN1YmRpdilyZXR1cm4gbnVsbDt2YXIgdD1Xcy5lbnZlbG9wZSh0aGlzLnNpdGVDb29yZHMpLGU9bmV3IEk7bnVsbCE9PXRoaXMuY29uc3RyYWludExpbmVzJiYodC5leHBhbmRUb0luY2x1ZGUodGhpcy5jb25zdHJhaW50TGluZXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSx0aGlzLmNyZWF0ZVZlcnRpY2VzKHRoaXMuY29uc3RyYWludExpbmVzKSxlPWpzLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyh0aGlzLmNvbnN0cmFpbnRMaW5lcykpO3ZhciBuPXRoaXMuY3JlYXRlU2l0ZVZlcnRpY2VzKHRoaXMuc2l0ZUNvb3JkcyksaT1uZXcgSHMobix0aGlzLnRvbGVyYW5jZSk7aS5zZXRDb25zdHJhaW50cyhlLG5ldyBJKHRoaXMuY29uc3RyYWludFZlcnRleE1hcC52YWx1ZXMoKSkpLGkuZm9ybUluaXRpYWxEZWxhdW5heSgpLGkuZW5mb3JjZUNvbnN0cmFpbnRzKCksdGhpcy5zdWJkaXY9aS5nZXRTdWJkaXZpc2lvbigpfSxzZXRUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy50b2xlcmFuY2U9dH0sc2V0Q29uc3RyYWludHM6ZnVuY3Rpb24odCl7dGhpcy5jb25zdHJhaW50TGluZXM9dH0sc2V0U2l0ZXM6ZnVuY3Rpb24odCl7dGhpcy5zaXRlQ29vcmRzPVdzLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX0sZ2V0RWRnZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0RWRnZXModCl9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGdldFRyaWFuZ2xlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRUcmlhbmdsZXModCl9LGNyZWF0ZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVzKCksbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1uZXcgUHMoZVtuXSk7dGhpcy5jb25zdHJhaW50VmVydGV4TWFwLnB1dChlW25dLGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ganN9fSksanMuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1rbi5nZXRMaW5lcyh0KSxuPW5ldyBJLGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7anMuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKHIsbil9cmV0dXJuIG59aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPXMuZ2V0Q29vcmRpbmF0ZXMoKSxpPTE7aTxhLmxlbmd0aDtpKyspby5hZGQobmV3IFZzKGFbaS0xXSxhW2ldKSl9LGUoS3MucHJvdG90eXBlLHtjcmVhdGU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5zdWJkaXYpcmV0dXJuIG51bGw7dmFyIHQ9V3MuZW52ZWxvcGUodGhpcy5zaXRlQ29vcmRzKTt0aGlzLmRpYWdyYW1FbnY9dDt2YXIgZT1NYXRoLm1heCh0aGlzLmRpYWdyYW1FbnYuZ2V0V2lkdGgoKSx0aGlzLmRpYWdyYW1FbnYuZ2V0SGVpZ2h0KCkpO3RoaXMuZGlhZ3JhbUVudi5leHBhbmRCeShlKSxudWxsIT09dGhpcy5jbGlwRW52JiZ0aGlzLmRpYWdyYW1FbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY2xpcEVudik7dmFyIG49V3MudG9WZXJ0aWNlcyh0aGlzLnNpdGVDb29yZHMpO3RoaXMuc3ViZGl2PW5ldyBGcyh0LHRoaXMudG9sZXJhbmNlKTt2YXIgaT1uZXcgT3ModGhpcy5zdWJkaXYpO2kuaW5zZXJ0U2l0ZXMobil9LGdldERpYWdyYW06ZnVuY3Rpb24odCl7dGhpcy5jcmVhdGUoKTt2YXIgZT10aGlzLnN1YmRpdi5nZXRWb3Jvbm9pRGlhZ3JhbSh0KTtyZXR1cm4gS3MuY2xpcEdlb21ldHJ5Q29sbGVjdGlvbihlLHRoaXMuZGlhZ3JhbUVudil9LHNldFRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLnRvbGVyYW5jZT10fSxzZXRTaXRlczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy51bmlxdWUoSC50b0Nvb3JkaW5hdGVBcnJheShlKSl9fSxzZXRDbGlwRW52ZWxvcGU6ZnVuY3Rpb24odCl7dGhpcy5jbGlwRW52PXR9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtzfX0pLEtzLmNsaXBHZW9tZXRyeUNvbGxlY3Rpb249ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeShlKSxpPW5ldyBJLHI9MDtyPHQuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIHM9dC5nZXRHZW9tZXRyeU4ociksbz1udWxsO2UuY29udGFpbnMocy5nZXRFbnZlbG9wZUludGVybmFsKCkpP289czplLmludGVyc2VjdHMocy5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYobz1uLmludGVyc2VjdGlvbihzKSxvLnNldFVzZXJEYXRhKHMuZ2V0VXNlckRhdGEoKSkpLG51bGw9PT1vfHxvLmlzRW1wdHkoKXx8aS5hZGQobyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkoaSkpfTt2YXIgQW89T2JqZWN0LmZyZWV6ZSh7Q29uZm9ybWluZ0RlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6anMsRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpXcyxWb3Jvbm9pRGlhZ3JhbUJ1aWxkZXI6S3N9KTtlKFpzLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWnN9fSksWnMudW5pb249ZnVuY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LGUoQi5wcm90b3R5cGUse2VxdWFsc1RvcG86ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmVxdWFscyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk/SnIucmVsYXRlKHRoaXMsdCkuaXNFcXVhbHModGhpcy5nZXREaW1lbnNpb24oKSx0LmdldERpbWVuc2lvbigpKTohMX0sdW5pb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaXMudW5pb24odGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gWnMudW5pb24odGhpcyx0KX19LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbHMuaXNWYWxpZCh0aGlzKX0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNFbXB0eSgpfHx0LmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuSU5URVJTRUNUSU9OLHRoaXMsdCx0aGlzLmZhY3RvcnkpO2lmKHRoaXMuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7dmFyIGU9dDtyZXR1cm4gaG4ubWFwKHRoaXMse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW01hcE9wXX0sbWFwOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyc2VjdGlvbihlKX19KX1yZXR1cm4gdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSx0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHNpLm92ZXJsYXlPcCh0aGlzLHQsaWkuSU5URVJTRUNUSU9OKX0sY292ZXJzOmZ1bmN0aW9uKHQpe3JldHVybiBKci5jb3ZlcnModGhpcyx0KX0sY292ZXJlZEJ5OmZ1bmN0aW9uKHQpe3JldHVybiBKci5jb3ZlcmVkQnkodGhpcyx0KX0sdG91Y2hlczpmdW5jdGlvbih0KXtyZXR1cm4gSnIudG91Y2hlcyh0aGlzLHQpfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQpe3JldHVybiBKci5pbnRlcnNlY3RzKHRoaXMsdCl9LHdpdGhpbjpmdW5jdGlvbih0KXtyZXR1cm4gSnIud2l0aGluKHRoaXMsdCl9LG92ZXJsYXBzOmZ1bmN0aW9uKHQpe3JldHVybiBKci5vdmVybGFwcyh0aGlzLHQpfSxkaXNqb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gSnIuZGlzam9pbnQodGhpcyx0KX0sY3Jvc3NlczpmdW5jdGlvbih0KXtyZXR1cm4gSnIuY3Jvc3Nlcyh0aGlzLHQpfSxidWZmZXI6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBkci5idWZmZXJPcCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIGRyLmJ1ZmZlck9wKHRoaXMsZSxuKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3JldHVybiBkci5idWZmZXJPcCh0aGlzLGkscixzKX19LGNvbnZleEh1bGw6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG1lKHRoaXMpLmdldENvbnZleEh1bGwoKX0scmVsYXRlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1BcnJheSh0KSxuPTA7dD5uO24rKyllW25dPWFyZ3VtZW50c1tuXTtyZXR1cm4gSnIucmVsYXRlLmFwcGx5KEpyLFt0aGlzXS5jb25jYXQoZSkpfSxnZXRDZW50cm9pZDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9pbnQoKTt2YXIgdD1nZS5nZXRDZW50cm9pZCh0aGlzKTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsdGhpcyl9LGdldEludGVyaW9yUG9pbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvaW50KCk7dmFyIHQ9bnVsbCxlPXRoaXMuZ2V0RGltZW5zaW9uKCk7aWYoMD09PWUpe3ZhciBuPW5ldyBsaSh0aGlzKTt0PW4uZ2V0SW50ZXJpb3JQb2ludCgpfWVsc2UgaWYoMT09PWUpe3ZhciBuPW5ldyB1aSh0aGlzKTt0PW4uZ2V0SW50ZXJpb3JQb2ludCgpfWVsc2V7dmFyIG49bmV3IG9pKHRoaXMpO3Q9bi5nZXRJbnRlcmlvclBvaW50KCl9cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LHRoaXMpfSxzeW1EaWZmZXJlbmNlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNFbXB0eSgpfHx0LmlzRW1wdHkoKSl7aWYodGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpKXJldHVybiBpaS5jcmVhdGVFbXB0eVJlc3VsdChpaS5TWU1ESUZGRVJFTkNFLHRoaXMsdCx0aGlzLmZhY3RvcnkpO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5jb3B5KCl9cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSxzaS5vdmVybGF5T3AodGhpcyx0LGlpLlNZTURJRkZFUkVOQ0UpfSxjcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX0sdG9UZXh0OmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IHNlO3JldHVybiB0LndyaXRlKHRoaXMpfSx0b1N0cmluZzpmdW5jdGlvbigpe3RoaXMudG9UZXh0KCl9LGNvbnRhaW5zOmZ1bmN0aW9uKHQpe3JldHVybiBKci5jb250YWlucyh0aGlzLHQpfSxkaWZmZXJlbmNlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9paS5jcmVhdGVFbXB0eVJlc3VsdChpaS5ESUZGRVJFTkNFLHRoaXMsdCx0aGlzLmZhY3RvcnkpOnQuaXNFbXB0eSgpP3RoaXMuY29weSgpOih0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksc2kub3ZlcmxheU9wKHRoaXMsdCxpaS5ESUZGRVJFTkNFKSl9LGlzU2ltcGxlOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFdpKHRoaXMpO3JldHVybiB0LmlzU2ltcGxlKCl9LGlzV2l0aGluRGlzdGFuY2U6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIG4+ZT8hMTp4ci5pc1dpdGhpbkRpc3RhbmNlKHRoaXMsdCxlKX0sZGlzdGFuY2U6ZnVuY3Rpb24odCl7cmV0dXJuIHhyLmRpc3RhbmNlKHRoaXMsdCl9LGlzRXF1aXZhbGVudENsYXNzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldENsYXNzKCk9PT10LmdldENsYXNzKCl9fSk7dmFyIEZvPVwiMS4yLjAgKGQ0MDVjODkpXCI7dC52ZXJzaW9uPUZvLHQuYWxnb3JpdGhtPWNvLHQuZGVuc2lmeT1mbyx0LmRpc3NvbHZlPWdvLHQuZ2VvbT1sbyx0Lmdlb21ncmFwaD1wbyx0LmluZGV4PXlvLHQuaW89Tm8sdC5ub2Rpbmc9Q28sdC5vcGVyYXRpb249X28sdC5wcmVjaXNpb249TW8sdC5zaW1wbGlmeT1Ebyx0LnRyaWFuZ3VsYXRlPUFvfSk7XG4iLCIvKlxuIExlYWZsZXQgMS4wLjEsIGEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwcy4gaHR0cDovL2xlYWZsZXRqcy5jb21cbiAoYykgMjAxMC0yMDE2IFZsYWRpbWlyIEFnYWZvbmtpbiwgKGMpIDIwMTAtMjAxMSBDbG91ZE1hZGVcbiovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG52YXIgTCA9IHtcclxuXHR2ZXJzaW9uOiBcIjEuMC4xXCJcclxufTtcclxuXHJcbmZ1bmN0aW9uIGV4cG9zZSgpIHtcclxuXHR2YXIgb2xkTCA9IHdpbmRvdy5MO1xyXG5cclxuXHRMLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR3aW5kb3cuTCA9IG9sZEw7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cclxuXHR3aW5kb3cuTCA9IEw7XHJcbn1cclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGZvciBOb2RlIG1vZHVsZSBwYXR0ZXJuIGxvYWRlcnMsIGluY2x1ZGluZyBCcm93c2VyaWZ5XHJcbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBMO1xyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYW4gQU1EIG1vZHVsZVxyXG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdGRlZmluZShMKTtcclxufVxyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYSBnbG9iYWwgTCB2YXJpYWJsZSwgc2F2aW5nIHRoZSBvcmlnaW5hbCBMIHRvIHJlc3RvcmUgbGF0ZXIgaWYgbmVlZGVkXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdGV4cG9zZSgpO1xyXG59XHJcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG5MLlV0aWwgPSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxyXG5cdGV4dGVuZDogZnVuY3Rpb24gKGRlc3QpIHtcclxuXHRcdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0XHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG5cdFx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGRlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNyZWF0ZShwcm90bzogT2JqZWN0LCBwcm9wZXJ0aWVzPzogT2JqZWN0KTogT2JqZWN0XHJcblx0Ly8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcblx0Y3JlYXRlOiBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0XHRmdW5jdGlvbiBGKCkge31cclxuXHRcdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuXHRcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdFx0cmV0dXJuIG5ldyBGKCk7XHJcblx0XHR9O1xyXG5cdH0pKCksXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuXHQvLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcblx0Ly8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuXHRiaW5kOiBmdW5jdGlvbiAoZm4sIG9iaikge1xyXG5cdFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuXHRcdGlmIChmbi5iaW5kKSB7XHJcblx0XHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcblx0c3RhbXA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdG9iai5fbGVhZmxldF9pZCA9IG9iai5fbGVhZmxldF9pZCB8fCArK0wuVXRpbC5sYXN0SWQ7XHJcblx0XHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG5cdFx0Lyplc2xpbnQtZW5hYmxlICovXHJcblx0fSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcblx0Ly8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuXHRsYXN0SWQ6IDAsXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuXHQvLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuXHQvLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG5cdC8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuXHQvLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcblx0Ly8gSGFzIGFuIGBMLmJpbmRgIHNob3J0Y3V0LlxyXG5cdHRocm90dGxlOiBmdW5jdGlvbiAoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuXHRcdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRcdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG5cdFx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRcdGlmIChhcmdzKSB7XHJcblx0XHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmIChsb2NrKSB7XHJcblx0XHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcblx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG5cdFx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcblx0XHRcdFx0bG9jayA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIHdyYXBwZXJGbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcblx0Ly8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG5cdC8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5cdHdyYXBOdW06IGZ1bmN0aW9uICh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdFx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG5cdFx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG5cdFx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0XHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuXHRmYWxzZUZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgZGlnaXRzPzogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgdG8gYGRpZ2l0c2AgZGVjaW1hbHMsIG9yIHRvIDUgZGVjaW1hbHMgYnkgZGVmYXVsdC5cclxuXHRmb3JtYXROdW06IGZ1bmN0aW9uIChudW0sIGRpZ2l0cykge1xyXG5cdFx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCBkaWdpdHMgfHwgNSk7XHJcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0cmltKHN0cjogU3RyaW5nKTogU3RyaW5nXHJcblx0Ly8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcblx0dHJpbTogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyOiBTdHJpbmcpOiBTdHJpbmdbXVxyXG5cdC8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuXHRzcGxpdFdvcmRzOiBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRyZXR1cm4gTC5VdGlsLnRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcblx0c2V0T3B0aW9uczogZnVuY3Rpb24gKG9iaiwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xyXG5cdFx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gTC5VdGlsLmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG5cdC8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuXHQvLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcblx0Ly8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuXHQvLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcblx0Z2V0UGFyYW1TdHJpbmc6IGZ1bmN0aW9uIChvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHRcdHZhciBwYXJhbXMgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0ZW1wbGF0ZShzdHI6IFN0cmluZywgZGF0YTogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcblx0Ly8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuXHQvLyBgKCdIZWxsbyBmb28sIGJhcicpYC4gWW91IGNhbiBhbHNvIHNwZWNpZnkgZnVuY3Rpb25zIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3JcclxuXHQvLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuXHR0ZW1wbGF0ZTogZnVuY3Rpb24gKHN0ciwgZGF0YSkge1xyXG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKEwuVXRpbC50ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZShkYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdmFsdWU7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR0ZW1wbGF0ZVJlOiAvXFx7ICooW1xcd19cXC1dKykgKlxcfS9nLFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcblx0Ly8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuXHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcblx0aW5kZXhPZjogZnVuY3Rpb24gKGFycmF5LCBlbCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG5cdC8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG5cdC8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG5cdC8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxuXHRlbXB0eUltYWdlVXJsOiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSdcclxufTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0Ly8gaW5zcGlyZWQgYnkgaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcblx0ZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdFx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcblx0fVxyXG5cclxuXHR2YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuXHQvLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcblx0ZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0XHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdFx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0XHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXIsXHJcblx0ICAgIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgZ2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuXHQvLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG5cdC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuXHQvLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcblx0Ly8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcblx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUgPSBmdW5jdGlvbiAoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG5cdFx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgTC5iaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcblx0Ly8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcblx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0aWYgKGlkKSB7XHJcblx0XHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0XHR9XHJcblx0fTtcclxufSkoKTtcclxuXHJcbi8vIHNob3J0Y3V0cyBmb3IgbW9zdCB1c2VkIHV0aWxpdHkgZnVuY3Rpb25zXHJcbkwuZXh0ZW5kID0gTC5VdGlsLmV4dGVuZDtcclxuTC5iaW5kID0gTC5VdGlsLmJpbmQ7XHJcbkwuc3RhbXAgPSBMLlV0aWwuc3RhbXA7XHJcbkwuc2V0T3B0aW9ucyA9IEwuVXRpbC5zZXRPcHRpb25zO1xyXG5cblxuXG5cclxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuTC5DbGFzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuTC5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBMLlV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0TC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRMLlV0aWwuZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcblx0XHRkZWxldGUgcHJvcHMuaW5jbHVkZXM7XHJcblx0fVxyXG5cclxuXHQvLyBtZXJnZSBvcHRpb25zXHJcblx0aWYgKHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3BzLm9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKEwuVXRpbC5jcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0TC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuTC5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0TC5leHRlbmQodGhpcy5wcm90b3R5cGUsIHByb3BzKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uczogT2JqZWN0KTogdGhpc1xyXG4vLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuTC5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdEwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuTC5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5MLkV2ZW50ZWQgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghdHlwZXMpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG5cdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcblxyXG5cdFx0LyogZ2V0L2luaXQgbGlzdGVuZXJzIGZvciB0eXBlICovXHJcblx0XHR2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmICghdHlwZUxpc3RlbmVycykge1xyXG5cdFx0XHR0eXBlTGlzdGVuZXJzID0gW107XHJcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fSxcclxuXHRcdCAgICBsaXN0ZW5lcnMgPSB0eXBlTGlzdGVuZXJzO1xyXG5cclxuXHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3RlbmVycy5wdXNoKG5ld0xpc3RlbmVyKTtcclxuXHRcdHR5cGVMaXN0ZW5lcnMuY291bnQrKztcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMsXHJcblx0XHQgICAgaSxcclxuXHRcdCAgICBsZW47XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWZuKSB7XHJcblx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcCBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgbWlnaHQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBMLlV0aWwuZXh0ZW5kKHt9LCBkYXRhLCB7dHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IEwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbTC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tMLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIEwuZXh0ZW5kKHtsYXllcjogZS50YXJnZXR9LCBlKSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBwcm90byA9IEwuRXZlbnRlZC5wcm90b3R5cGU7XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbnByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5vbjtcclxuXHJcbi8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4vLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG8uY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IHByb3RvLm9mZjtcclxuXHJcbi8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbnByb3RvLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gcHJvdG8ub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5wcm90by5maXJlRXZlbnQgPSBwcm90by5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxucHJvdG8uaGFzRXZlbnRMaXN0ZW5lcnMgPSBwcm90by5saXN0ZW5zO1xyXG5cclxuTC5NaXhpbiA9IHtFdmVudHM6IHByb3RvfTtcclxuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxyXG5cdCAgICBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcblxyXG5cdCAgICBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3csXHJcblxyXG5cdCAgICB3ZWJraXQgICAgPSB1YS5pbmRleE9mKCd3ZWJraXQnKSAhPT0gLTEsXHJcblx0ICAgIHBoYW50b21qcyA9IHVhLmluZGV4T2YoJ3BoYW50b20nKSAhPT0gLTEsXHJcblx0ICAgIGFuZHJvaWQyMyA9IHVhLnNlYXJjaCgnYW5kcm9pZCBbMjNdJykgIT09IC0xLFxyXG5cdCAgICBjaHJvbWUgICAgPSB1YS5pbmRleE9mKCdjaHJvbWUnKSAhPT0gLTEsXHJcblx0ICAgIGdlY2tvICAgICA9IHVhLmluZGV4T2YoJ2dlY2tvJykgIT09IC0xICAmJiAhd2Via2l0ICYmICF3aW5kb3cub3BlcmEgJiYgIWllLFxyXG5cclxuXHQgICAgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwLFxyXG5cclxuXHQgICAgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1YS5pbmRleE9mKCdtb2JpbGUnKSAhPT0gLTEsXHJcblx0ICAgIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudCxcclxuXHQgICAgcG9pbnRlciA9IHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyLFxyXG5cclxuXHQgICAgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gZG9jLnN0eWxlKSxcclxuXHQgICAgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMyxcclxuXHQgICAgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gZG9jLnN0eWxlLFxyXG5cdCAgICBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBkb2Muc3R5bGU7XHJcblxyXG5cclxuXHR2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHBvaW50ZXIgfHwgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XHJcblx0XHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG5cdEwuQnJvd3NlciA9IHtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgaWU6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcblx0XHRpZTogaWUsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG5cdFx0aWVsdDk6IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG5cdFx0ZWRnZTogJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCksXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcblx0XHR3ZWJraXQ6IHdlYmtpdCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG5cdFx0Z2Vja286IGdlY2tvLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxuXHRcdGFuZHJvaWQ6IHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcblx0XHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuXHRcdGNocm9tZTogY2hyb21lLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG5cdFx0c2FmYXJpOiAhY2hyb21lICYmIHVhLmluZGV4T2YoJ3NhZmFyaScpICE9PSAtMSxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdpbjogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuXHRcdHdpbjogd2luLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdGllM2Q6IGllM2QsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRnZWNrbzNkOiBnZWNrbzNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG5cdFx0b3BlcmExMjogb3BlcmExMixcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRhbnkzZDogIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b21qcyxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGU6IG1vYmlsZSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlV2Via2l0OiBtb2JpbGUgJiYgd2Via2l0LFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZSAmJiB3ZWJraXQzZCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlT3BlcmE6IG1vYmlsZSAmJiB3aW5kb3cub3BlcmEsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5cdFx0bW9iaWxlR2Vja286IG1vYmlsZSAmJiBnZWNrbyxcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG5cdFx0dG91Y2g6ICEhdG91Y2gsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcblx0XHRtc1BvaW50ZXI6ICEhbXNQb2ludGVyLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcblx0XHRwb2ludGVyOiAhIXBvaW50ZXIsXHJcblxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4uXHJcblx0XHRyZXRpbmE6ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMVxyXG5cdH07XHJcblxyXG59KCkpO1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLlBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHJvdW5kKSB7XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufTtcclxuXHJcbkwuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQoTC5wb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdChMLnBvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG5cdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcblx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcblx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG5cdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcblx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5MLnBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBMLlBvaW50KSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKEwuVXRpbC5pc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeFswXSwgeFsxXSk7XHJcblx0fVxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5LCByb3VuZCk7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBCb3VuZHNcclxuICogQGFrYSBMLkJvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkJvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gTC5wb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5ib3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5Cb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gTC5ib3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSBMLmJvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcblx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHRvcExlZnQ6IFBvaW50LCBib3R0b21SaWdodDogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvb3JkaW5hdGVzICh1c3VhbGx5IHRvcC1sZWZ0IGFuZCBib3R0b20tcmlnaHQgY29ybmVycykuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIHBvaW50cyBpdCBjb250YWluc1xyXG5MLmJvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Cb3VuZHMoYSwgYik7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBuZXcgTC5UcmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbkwuVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59O1xyXG5cclxuTC5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyByZWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyByZWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5MLkRvbVV0aWwgPSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcblx0Ly8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuXHRnZXQ6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuXHQvLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcclxuXHJcblx0XHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0XHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5cdGNyZWF0ZTogZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblxyXG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0XHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdGlmIChwYXJlbnQpIHtcclxuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuXHRlbXB0eTogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZHJlbiBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuXHR0b0Zyb250OiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdGVsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkcmVuIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmFjayBmcm9tIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuXHR0b0JhY2s6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuXHRoYXNDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHRcdH1cclxuXHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcblx0Ly8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHZhciBjbGFzc2VzID0gTC5VdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICghTC5Eb21VdGlsLmhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gTC5Eb21VdGlsLmdldENsYXNzKGVsKTtcclxuXHRcdFx0TC5Eb21VdGlsLnNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG5cdC8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0Q2xhc3MoZWwsIEwuVXRpbC50cmltKCgnICcgKyBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcblx0Ly8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5cdHNldENsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5cdGdldENsYXNzOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcblx0Ly8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcblx0Ly8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcclxuXHJcblx0XHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5fc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NldE9wYWNpdHlJRTogZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xyXG5cdFx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdFx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHRcdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdFx0aWYgKGZpbHRlcikge1xyXG5cdFx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG5cdC8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuXHQvLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG5cdC8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5cdHRlc3RQcm9wOiBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcblx0Ly8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcblx0Ly8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcblx0c2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHRcdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IEwuUG9pbnQoMCwgMCk7XHJcblxyXG5cdFx0ZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPVxyXG5cdFx0XHQoTC5Ccm93c2VyLmllM2QgP1xyXG5cdFx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcblx0Ly8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuXHQvLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCwgcG9pbnQpIHsgLy8gKEhUTUxFbGVtZW50LCBQb2ludFssIEJvb2xlYW5dKVxyXG5cclxuXHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdFx0Lyplc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0XHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRcdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IEwuUG9pbnQoMCwgMCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0Ly8gcHJlZml4IHN0eWxlIHByb3BlcnR5IG5hbWVzXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG5cdC8vIFZlbmRvci1wcmVmaXhlZCBmcmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5cdEwuRG9tVXRpbC5UUkFOU0ZPUk0gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcblxyXG5cdC8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuXHQvLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcblx0Ly8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG5cdC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZS5cclxuXHR2YXIgdHJhbnNpdGlvbiA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG5cdFx0XHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcblx0TC5Eb21VdGlsLlRSQU5TSVRJT05fRU5EID1cclxuXHRcdFx0dHJhbnNpdGlvbiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IHRyYW5zaXRpb24gPT09ICdPVHJhbnNpdGlvbicgPyB0cmFuc2l0aW9uICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcblx0Ly8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuXHQvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG5cdC8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuXHQvLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG5cdC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuXHRpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH07XHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH07XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG5cdFx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdFx0dGhpcy5fdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSB0aGlzLl91c2VyU2VsZWN0O1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl91c2VyU2VsZWN0O1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG5cdC8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuXHQvLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuXHRMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcblx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcblx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcblx0Ly8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuXHQvLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG5cdC8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuXHQvLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcblx0TC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuXHRcdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdFx0TC5Eb21VdGlsLnJlc3RvcmVPdXRsaW5lKCk7XHJcblx0XHR0aGlzLl9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcblx0XHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCBMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUsIHRoaXMpO1xyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcblx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuXHRMLkRvbVV0aWwucmVzdG9yZU91dGxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5fb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IHRoaXMuX291dGxpbmVTdHlsZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9vdXRsaW5lRWxlbWVudDtcclxuXHRcdGRlbGV0ZSB0aGlzLl9vdXRsaW5lU3R5bGU7XHJcblx0XHRMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdrZXlkb3duJywgTC5Eb21VdGlsLnJlc3RvcmVPdXRsaW5lLCB0aGlzKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cblxuXG4vKiBAY2xhc3MgTGF0TG5nXHJcbiAqIEBha2EgTC5MYXRMbmdcclxuICpcclxuICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTGF0TG5nID0gZnVuY3Rpb24gKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufTtcclxuXHJcbkwuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmosIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0b2JqID0gTC5sYXRMbmcob2JqKTtcclxuXHJcblx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuXHRcdHJldHVybiBtYXJnaW4gPD0gKG1heE1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMS4wRS05IDogbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IChmb3IgZGVidWdnaW5nIHB1cnBvc2VzKS5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEwuQ1JTLkVhcnRoLmRpc3RhbmNlKHRoaXMsIEwubGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkNSUy5FYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnNgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gTC5sYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5MLmxhdExuZyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChMLlV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkxhdExuZyhhLCBiLCBjKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHNvdXRoV2VzdCA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIG5vcnRoRWFzdCA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKHNvdXRoV2VzdCwgbm9ydGhFYXN0KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5MYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoc291dGhXZXN0LCBub3J0aEVhc3QpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFzb3V0aFdlc3QpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gbm9ydGhFYXN0ID8gW3NvdXRoV2VzdCwgbm9ydGhFYXN0XSA6IHNvdXRoV2VzdDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKEwubGF0TG5nKG9iaikgfHwgTC5sYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMLkxhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IEwuTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBiaWdnZXIgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHBlcmNlbnRhZ2UgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTC5MYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5sYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhzb3V0aFdlc3Q6IExhdExuZywgbm9ydGhFYXN0OiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgc291dGgtd2VzdCBhbmQgbm9ydGgtZWFzdCBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuTC5sYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHNlY3Rpb25cclxuICogTGVhZmxldCBjb21lcyB3aXRoIGEgc2V0IG9mIGFscmVhZHkgZGVmaW5lZCBQcm9qZWN0aW9ucyBvdXQgb2YgdGhlIGJveDpcclxuICpcclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gKlxyXG4gKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICogbGF0aXR1ZGUuIEFsc28gc3VpdGFibGUgZm9yIGZsYXQgd29ybGRzLCBlLmcuIGdhbWUgbWFwcy4gVXNlZCBieSB0aGVcclxuICogYEVQU0c6MzM5NWAgYW5kIGBTaW1wbGVgIENSUy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24gPSB7fTtcclxuXHJcbkwuUHJvamVjdGlvbi5Mb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogTC5ib3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxufTtcclxuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuXHRSOiA2Mzc4MTM3LFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuXHRcdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IDYzNzgxMzcgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIEwuYm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG5cdH0pKClcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIENSU1xyXG4gKiBAYWthIEwuQ1JTXHJcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICovXHJcblxyXG5MLkNSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIEwuYm91bmRzKG1pbiwgbWF4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuXHQvLyBAcHJvcGVydHkgY29kZTogU3RyaW5nXHJcblx0Ly8gU3RhbmRhcmQgY29kZSBuYW1lIG9mIHRoZSBDUlMgcGFzc2VkIGludG8gV01TIHNlcnZpY2VzIChlLmcuIGAnRVBTRzozODU3J2ApXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExuZzogTnVtYmVyW11cclxuXHQvLyBBbiBhcnJheSBvZiB0d28gbnVtYmVycyBkZWZpbmluZyB3aGV0aGVyIHRoZSBsb25naXR1ZGUgKGhvcml6b250YWwpIGNvb3JkaW5hdGVcclxuXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG5cdC8vIGdlb2dyYXBoaWNhbCBDUlNzLiBJZiBgdW5kZWZpbmVkYCwgdGhlIGxvbmdpdHVkZSBheGlzIGRvZXMgbm90IHdyYXAgYXJvdW5kLlxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcblx0Ly8gTGlrZSBgd3JhcExuZ2AsIGJ1dCBmb3IgdGhlIGxhdGl0dWRlICh2ZXJ0aWNhbCkgYXhpcy5cclxuXHJcblx0Ly8gd3JhcExuZzogW21pbiwgbWF4XSxcclxuXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuXHQvLyBAcHJvcGVydHkgaW5maW5pdGU6IEJvb2xlYW5cclxuXHQvLyBJZiB0cnVlLCB0aGUgY29vcmRpbmF0ZSBzcGFjZSB3aWxsIGJlIHVuYm91bmRlZCAoaW5maW5pdGUgaW4gYm90aCBheGVzKVxyXG5cdGluZmluaXRlOiBmYWxzZSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGxhdCBhbmQgbG5nIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgbG5nID0gdGhpcy53cmFwTG5nID8gTC5VdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gTC5VdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gTC5sYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuU2ltcGxlXG4gKlxuICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gKiBNYXkgYmUgdXNlZCBmb3IgbWFwcyBvZiBmbGF0IHN1cmZhY2VzIChlLmcuIGdhbWUgbWFwcykuIE5vdGUgdGhhdCB0aGUgYHlgXG4gKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gKi9cblxuTC5DUlMuU2ltcGxlID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5Mb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuXHR9LFxuXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG5cblxuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbkwuQ1JTLkVhcnRoID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgYSA9IE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0MikgK1xuXHRcdCAgICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCk7XG5cblx0XHRyZXR1cm4gdGhpcy5SICogTWF0aC5hY29zKE1hdGgubWluKGEsIDEpKTtcblx0fVxufSk7XG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0czODU3ID0gTC5leHRlbmQoe30sIEwuQ1JTLkVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlRyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cclxuTC5DUlMuRVBTRzkwMDkxMyA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICpcclxuICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAqL1xyXG5cclxuTC5DUlMuRVBTRzQzMjYgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIE1hcFxyXG4gKiBAYWthIEwuTWFwXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogLy8gaW5pdGlhbGl6ZSB0aGUgbWFwIG9uIHRoZSBcIm1hcFwiIGRpdiB3aXRoIGEgZ2l2ZW4gY2VudGVyIGFuZCB6b29tXHJcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gKiBcdHpvb206IDEzXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICovXHJcblxyXG5MLk1hcCA9IEwuRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEwuQ1JTLkVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIE92ZXJyaWRlcyBhbnkgYG1pblpvb21gIG9wdGlvbiBzZXQgb24gbWFwIGxheWVycy5cclxuXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIE92ZXJyaWRlcyBhbnkgYG1heFpvb21gIG9wdGlvbiBzZXQgb24gbWFwIGxheWVycy5cclxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcblx0XHQvLyBBcnJheSBvZiBsYXllcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgaW5pdGlhbGx5XHJcblx0XHRsYXllcnM6IFtdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcblx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXHJcblx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIHdoZW4gaGUgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1hcmtlclpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG5cdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuXHRcdC8vIGVuYWJsZWQgaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuXHRcdC8vIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiBhIENTUyB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0uIFRoZSBkZWZhdWx0XHJcblx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG5cdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuXHRcdHRyYW5zZm9ybTNETGltaXQ6IDgzODg2MDgsIC8vIFByZWNpc2lvbiBsaW1pdCBvZiBhIDMyLWJpdCBmbG9hdFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuXHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcclxuXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcblx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuXHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcclxuXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0em9vbVNuYXA6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tRGVsdGE6IE51bWJlciA9IDFcclxuXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcblx0XHQvLyBvciBgLWAgb24gdGhlIGtleWJvYXJkLCBvciB1c2luZyB0aGUgW3pvb20gY29udHJvbHNdKCNjb250cm9sLXpvb20pLlxyXG5cdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG5cdFx0em9vbURlbHRhOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhY2tSZXNpemU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IEwuYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KEwubGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHQvLyByZXBsYWNlZCBieSBhbmltYXRpb24tcG93ZXJlZCBpbXBsZW1lbnRhdGlvbiBpbiBNYXAuUGFuQW5pbWF0aW9uLmpzXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tO1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KEwubGF0TG5nKGNlbnRlciksIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoTC5Ccm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEwuQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgTC5Qb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gTC5wb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IEwucG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG5cdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9uczogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCkgeyAvLyAoUG9pbnQpXHJcblx0XHQvLyByZXBsYWNlZCB3aXRoIGFuaW1hdGVkIHBhbkJ5IGluIE1hcC5QYW5BbmltYXRpb24uanNcclxuXHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblxyXG5cdFx0dGhpcy5fcmF3UGFuQnkoTC5wb2ludChvZmZzZXQpKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heEJvdW5kcyhib3VuZHM6IEJvdW5kcyk6IHRoaXNcclxuXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcblx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuXHRcdFx0cmV0dXJuIHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcblx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcblx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCBMLmxhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcblx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG5cdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcblx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcblx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuZXh0ZW5kKHtcclxuXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcblx0XHRcdHBhbjogdHJ1ZVxyXG5cdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gVE9ETyBoYW5kbGVyLmFkZFRvXHJcblx0Ly8gVE9ETyBBcHByb3BpYXRlIGRvY3Mgc2VjdGlvbj9cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qZXNsaW50LWVuYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHVubG9hZDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcblx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGRyZW4gb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZHJlbiBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAobmFtZSkge1xyXG5cdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNaW5ab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcblx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1heFpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLlxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG5cdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcblx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHRcdHBhZGRpbmcgPSBMLnBvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcblx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG5cdFx0ICAgIGJvdW5kc1NpemUgPSB0aGlzLnByb2plY3Qoc2UsIHpvb20pLnN1YnRyYWN0KHRoaXMucHJvamVjdChudywgem9vbSkpLFxyXG5cdFx0ICAgIHNuYXAgPSBMLkJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cclxuXHRcdHZhciBzY2FsZSA9IE1hdGgubWluKHNpemUueCAvIGJvdW5kc1NpemUueCwgc2l6ZS55IC8gYm91bmRzU2l6ZS55KTtcclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IEwuUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcblx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIG5ldyBMLkJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KEwubGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKEwucG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QoTC5sYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKEwubGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKEwubGF0TG5nKGxhdGxuZzEpLCBMLmxhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoTC5wb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQoTC5sYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gTC5VdGlsLnN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgTC5Ccm93c2VyLmFueTNkO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBMLlBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvciBvdmVybGF5cyAoYFBhdGhgcyksIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgbWFya2VyUGFuZTogSFRNTEVsZW1lbnQgPSA2MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHRvb2x0aXBQYW5lOiBIVE1MRWxlbWVudCA9IDY1MFxyXG5cdFx0Ly8gUGFuZSBmb3IgdG9vbHRpcC5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHBvcHVwUGFuZTogSFRNTEVsZW1lbnQgPSA3MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBMLlBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhKSB7XHJcblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHJcblx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcblx0XHR0aGlzLl9waXhlbE9yaWdpbiA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsIGluY2x1ZGluZyB6b29tXHJcblx0XHQvLyBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsIGluY2x1ZGluZyBwYW4gYW5kXHJcblx0XHQvLyBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBoYXMgY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0b3BwZWRcclxuXHRcdC8vIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdGlmICghTC5Eb21FdmVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcblx0XHR0aGlzLl90YXJnZXRzW0wuc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJztcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdEwuRG9tRXZlbnRbb25PZmZdKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG5cdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcycsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRbb25PZmZdKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdHRoaXNbb25PZmZdKCdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW0wuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgIWUuX3NpbXVsYXRlZCAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcblx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcblx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhTC5Eb21FdmVudC5faXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiBMLkRvbUV2ZW50Ll9pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHtcclxuXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IEwuRG9tRXZlbnQuX3NraXBwZWQoZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGUgPT09ICdrZXlwcmVzcycgJiYgZS5rZXlDb2RlID09PSAxMyA/ICdjbGljaycgOiBlLnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHRMLkRvbVV0aWwucHJldmVudE91dGxpbmUoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIHRhcmdldHMpIHtcclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cclxuXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcblx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXHJcblx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG5cdFx0XHR2YXIgc3ludGggPSBMLlV0aWwuZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGUudHlwZSAhPT0gJ2tleXByZXNzJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQgaW5zdGFuY2VvZiBMLk1hcmtlcjtcclxuXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuXHRcdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG5cdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMubm9uQnViYmxpbmdFdmVudHMgJiYgTC5VdGlsLmluZGV4T2YodGFyZ2V0c1tpXS5vcHRpb25zLm5vbkJ1YmJsaW5nRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG5cdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG5cdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBMLlBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEwuQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChvZmZzZXQucm91bmQoKS5lcXVhbHMoWzAsIDBdKSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEwuQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSBMLmJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcblx0XHQgICAgKSxcclxuXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gTC5Ccm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuXHJcbi8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuLy9cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG5MLm1hcCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5NYXAoaWQsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLk1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbkwuTGF5ZXIgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXHRcdG5vbkJ1YmJsaW5nRXZlbnRzOiBbXSAgLy8gQXJyYXkgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIG5vdCBiZSBidWJibGVkIHRvIERPTSBwYXJlbnRzIChsaWtlIHRoZSBtYXApXG5cdH0sXG5cblx0LyogQHNlY3Rpb25cblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXBcblx0ICovXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBtYXBcblx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuXHR9LFxuXG5cdGFkZEludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHR0aGlzLl9tYXAuX3RhcmdldHNbTC5zdGFtcCh0YXJnZXRFbCldID0gdGhpcztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tMLnN0YW1wKHRhcmdldEVsKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0aWYgKHRoaXMuZ2V0QXR0cmlidXRpb24gJiYgdGhpcy5fbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5fbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5MLk1hcC5pbmNsdWRlKHtcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiAhIWxheWVyICYmIChMLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChMLlV0aWwuaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbTC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG5cdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG5cdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcblx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAqXHJcbiAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBUYWtlcyBpbnRvIGFjY291bnQgdGhhdCBFYXJ0aCBpcyBhIGdlb2lkLCBub3QgYSBwZXJmZWN0IHNwaGVyZS4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBMLmJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAqXHJcbiAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAqL1xyXG5cclxuTC5DUlMuRVBTRzMzOTUgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBMLlByb2plY3Rpb24uTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gbmV3IEwuVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxuXG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbkwuR3JpZExheWVyID0gTC5MYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIElmIGBmYWxzZWAsIG5ldyB0aWxlcyBhcmUgbG9hZGVkIGR1cmluZyBwYW5uaW5nLCBvdGhlcndpc2Ugb25seSBhZnRlciBpdCAoZm9yIGJldHRlciBwZXJmb3JtYW5jZSkuIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2Vycywgb3RoZXJ3aXNlIGBmYWxzZWAuXG5cdFx0dXBkYXRlV2hlbklkbGU6IEwuQnJvd3Nlci5tb2JpbGUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG5cdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhLCBlLmcuIFwiwqkgTWFwYm94XCIuXG5cdFx0YXR0cmlidXRpb246IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIHRoYXQgdGlsZXMgd2lsbCBiZSBsb2FkZWQgYXQuIEJ5IGRlZmF1bHQgdGhlIGVudGlyZSBtYXAuXG5cdFx0bWluWm9vbTogMCxcblxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB0aGF0IHRpbGVzIHdpbGwgYmUgbG9hZGVkIGF0LlxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLlxuXHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuXHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcblx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG5cdFx0a2VlcEJ1ZmZlcjogMlxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdEwuRG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gTC5VdGlsLnRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIEwuUG9pbnQgPyBzIDogbmV3IEwuUG9pbnQocywgcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcblx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cblx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cblx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcblx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG5cdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHsgd2lsbFBydW5lID0gdHJ1ZTsgfVxuXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuXHRcdGlmIChuZXh0RnJhbWUpIHtcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdEwuVXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cdH0sXG5cblx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcblx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcblx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcblx0XHQgICAgejIgPSB6IC0gMSxcblx0XHQgICAgY29vcmRzMiA9IG5ldyBMLlBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgTC5Qb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcblx0XHR2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBMLkJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuXHR9LFxuXG5cdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cblx0XHR2YXIgem9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEwuQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhMLnBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgTC5Qb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcblx0XHRcdFx0aWYgKHRpbGUpIHtcblx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG5cdFx0fSk7XG5cblx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG5cdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG5cdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcblx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG5cdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdHJldHVybiBMLmxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcblx0fSxcblxuXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG5cdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cblx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcblx0XHQgICAgc2UgPSBtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuXHRcdFx0bncgPSBtYXAud3JhcExhdExuZyhudyk7XG5cdFx0XHRzZSA9IG1hcC53cmFwTGF0TG5nKHNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKG53LCBzZSk7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG5cdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuXHRcdCAgICBjb29yZHMgPSBuZXcgTC5Qb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRpbGUuZWwpO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gTC5VdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IEwuVXRpbC5mYWxzZUZuO1xuXG5cdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKEwuQnJvd3Nlci5hbmRyb2lkICYmICFMLkJyb3dzZXIuYW5kcm9pZDIzKSB7XG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBMLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcblx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHMsXG5cdFx0XHRjdXJyZW50OiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHR9KTtcblx0fSxcblxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBMLlBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyBMLlV0aWwud3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG5cdFx0XHR0aGlzLl93cmFwWSA/IEwuVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgTC5Cb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbkwuZ3JpZExheWVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkdyaWRMYXllcihvcHRpb25zKTtcbn07XG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllclxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30udGlsZS5vc20ub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIEAyeCB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5MLlRpbGVMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxyXG5cdFx0Ly8gTWluaW11bSB6b29tIG51bWJlci5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlci5cclxuXHRcdG1heFpvb206IDE4LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxyXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcclxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cclxuXHRcdG1heE5hdGl2ZVpvb206IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgTC5Ccm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHRcdFx0XHRvcHRpb25zLm1heFpvb20tLTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20rKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5ab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIUwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG5cdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3BpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBMLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0TC5Eb21FdmVudC5vbih0aWxlLCAnZXJyb3InLCBMLmJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSAnJztcclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuXHRcdCBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcblx0XHQqL1xyXG5cdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcblx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcblx0Ly8gQHVuaW5oZXJpdGFibGVcclxuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0cjogTC5Ccm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEwuVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIEwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0c2V0VGltZW91dChMLmJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsKSB7XHJcblx0XHRcdHRpbGUuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0XHRkb25lKGUsIHRpbGUpO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gTC5HcmlkTGF5ZXIucHJvdG90eXBlLmdldFRpbGVTaXplLmNhbGwodGhpcyksXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX3RpbGVab29tICsgdGhpcy5vcHRpb25zLnpvb21PZmZzZXQsXHJcblx0XHQgICAgem9vbU4gPSB0aGlzLm9wdGlvbnMubWF4TmF0aXZlWm9vbTtcclxuXHJcblx0XHQvLyBpbmNyZWFzZSB0aWxlIHNpemUgd2hlbiBvdmVyc2NhbGluZ1xyXG5cdFx0cmV0dXJuIHpvb21OICE9PSBudWxsICYmIHpvb20gPiB6b29tTiA/XHJcblx0XHRcdFx0dGlsZVNpemUuZGl2aWRlQnkobWFwLmdldFpvb21TY2FsZSh6b29tTiwgem9vbSkpLnJvdW5kKCkgOlxyXG5cdFx0XHRcdHRpbGVTaXplO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl90aWxlWm9vbTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHR6b29tID0gb3B0aW9ucy5tYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHR6b29tICs9IG9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tICE9PSBudWxsID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhOYXRpdmVab29tKSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0XHR0aWxlLnNyYyA9IEwuVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aWxlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbkwudGlsZUxheWVyID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5UaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5UaWxlTGF5ZXIuV01TID0gTC5UaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IEwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gd21zUGFyYW1zLmhlaWdodCA9IG9wdGlvbnMudGlsZVNpemUgKiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgTC5Ccm93c2VyLnJldGluYSA/IDIgOiAxKTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdEwuVGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3JkcyksXHJcblx0XHQgICAgbncgPSB0aGlzLl9jcnMucHJvamVjdCh0aWxlQm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICBzZSA9IHRoaXMuX2Nycy5wcm9qZWN0KHRpbGVCb3VuZHMuZ2V0U291dGhFYXN0KCkpLFxyXG5cclxuXHRcdCAgICBiYm94ID0gKHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gTC5DUlMuRVBTRzQzMjYgP1xyXG5cdFx0XHQgICAgW3NlLnksIG53LngsIG53LnksIHNlLnhdIDpcclxuXHRcdFx0ICAgIFtudy54LCBzZS55LCBzZS54LCBudy55XSkuam9pbignLCcpLFxyXG5cclxuXHRcdCAgICB1cmwgPSBMLlRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHVybCArXHJcblx0XHRcdEwuVXRpbC5nZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRMLmV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVMYXllci53bXMoYmFzZVVybDogU3RyaW5nLCBvcHRpb25zOiBUaWxlTGF5ZXIuV01TIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuTC50aWxlTGF5ZXIud21zID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5UaWxlTGF5ZXIuV01TKHVybCwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5JbWFnZU92ZXJsYXkgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcclxuXHRcdC8vIEFuIG9wdGlvbmFsIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYFxyXG5cdFx0YXR0cmlidXRpb246IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiB0cnVlLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvICcnLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGVPcHRzKSB7XHJcblx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRMLkRvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdEwuRG9tVXRpbC50b0JhY2sodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSBMLkRvbVV0aWwuY3JlYXRlKCdpbWcnLFxyXG5cdFx0XHRcdCdsZWFmbGV0LWltYWdlLWxheWVyICcgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcgOiAnJykpO1xyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRpbWcub25sb2FkID0gTC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpLCBlLnpvb20sIGUuY2VudGVyKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMLkJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsOiBTdHJpbmcsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogSW1hZ2VPdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuTC5pbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIEljb25cclxuICogQGFrYSBMLkljb25cclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gKiB9KTtcclxuICpcclxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICpcclxuICovXHJcblxyXG5MLkljb24gPSBMLkNsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcclxuXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQXMgYGNyZWF0ZUljb25gLCBidXQgZm9yIHRoZSBzaGFkb3cgYmVuZWF0aCBpdC5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0lNRycgPyBvbGRJY29uIDogbnVsbCk7XHJcblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaXplID0gTC5wb2ludChzaXplT3B0aW9uKSxcclxuXHRcdCAgICBhbmNob3IgPSBMLnBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gTC5Ccm93c2VyLnJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5MLmljb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5JY29uKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICovXG5cbkwuSWNvbi5EZWZhdWx0ID0gTC5JY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICghTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRMLkljb24uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgTC5JY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBhYnNvbHV0ZSBsb2NhdGlvbiBvZiB0aGVcblx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG5cdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IGFic29sdXRlIHBhdGguXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCkgKyBMLkljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcblx0XHQgICAgICAgICAgIEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuXHRcdHJldHVybiBwYXRoLmluZGV4T2YoJ3VybCcpID09PSAwID9cblx0XHRcdHBhdGgucmVwbGFjZSgvXnVybFxcKFtcXFwiXFwnXT8vLCAnJykucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXFxcIlxcJ10/XFwpJC8sICcnKSA6ICcnO1xuXHR9XG59KTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTWFya2VyID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGNsYXNzIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi4gSWYgbm90IHNwZWNpZmllZCwgYSBuZXcgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEZJWE1FOiBzaGFkb3dQYW5lIGlzIG5vIGxvbmdlciBhIHZhbGlkIG9wdGlvblxyXG5cdFx0bm9uQnViYmxpbmdFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J11cclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqXHJcblx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMudXBkYXRlXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmFsdCkge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCdzaGFkb3dQYW5lJykuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5faWNvbik7XHJcblx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTC5IYW5kbGVyLk1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTC5IYW5kbGVyLk1hcmtlckRyYWcodGhpcyk7XHJcblxyXG5cdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuTC5tYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxuTC5EaXZJY29uID0gTC5JY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gTC5wb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuZGl2SWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5EaXZJY29uKG9wdGlvbnMpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIHBvcHVwIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuTC5EaXZPdmVybGF5ID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLiBVc2VmdWwgdG8gY29udHJvbCB0aGUgYW5jaG9yXHJcblx0XHQvLyBvZiB0aGUgcG9wdXAgd2hlbiBvcGVuaW5nIGl0IG9uIHNvbWUgb3ZlcmxheXMuXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKEwuRG9tVXRpbC5yZW1vdmUsIEwuRG9tVXRpbCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiBwb3B1cC5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4uXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBwb3B1cC4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBwb3B1cC5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBBbGlhcyBmb3IgW2dldENvbnRlbnQoKV0oI3BvcHVwLWdldGNvbnRlbnQpXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIHBvcHVwIGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIHBvcHVwIGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBwb3B1cCBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdEwuRG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gTC5wb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuTC5Qb3B1cCA9IEwuRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAgKHNldCBnbG9iYWxseSBieVxyXG5cdFx0Ly8gdGhlIE1hcCdzIFtjbG9zZVBvcHVwT25DbGlja10oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uKS5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgc2FtZSBhcyBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9wZW5Qb3B1cCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgTC5QYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBMLlBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBMLkRpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICgnY2xvc2VPbkNsaWNrJyBpbiB0aGlzLm9wdGlvbnMgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblxyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCB0aGlzLl9vbkNsb3NlQnV0dG9uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0XHQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24od3JhcHBlcilcclxuXHRcdFx0LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSlcclxuXHRcdFx0Lm9uKHdyYXBwZXIsICdjb250ZXh0bWVudScsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuIHx8ICh0aGlzLl9tYXAuX3BhbkFuaW0gJiYgdGhpcy5fbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KEwuRG9tVXRpbC5nZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IEwuUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0bGF5ZXJQb3MuX2FkZChMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcblx0XHRyZXR1cm4gTC5wb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbi8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuTC5wb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IEwuUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxufTtcclxuXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAqIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHBvcHVwcyB0byBjbG9zZSB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAuXHJcbiAqL1xyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBMLlBvcHVwKSkge1xyXG5cdFx0XHRwb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Qb3B1cCgpO1xuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xuICogYGBgXG4gKlxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXG4gKi9cblxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xuTC5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRQb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258UG9wdXAsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Qb3B1cCkge1xuXHRcdFx0TC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XG5cdFx0XHR0aGlzLm9uKHtcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHR0aGlzLm9mZih7XG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpY2VkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXIpKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcblx0XHRcdGxheWVyID0gdGhpcztcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkge1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFsYXRsbmcpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX21hcCkge1xuXHRcdFx0Ly8gc2V0IHBvcHVwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgcG9wdXAgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxuXHRcdFx0dGhpcy5fcG9wdXAudXBkYXRlKCk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXAsIGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMuX3BvcHVwLl9jbG9zZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb3B1cC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XG5cdH0sXG5cblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcHJldmVudCBtYXAgY2xpY2tcblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XG5cdFx0Ly8gb3BlbiB0aGUgcG9wdXAgYXQgdGhlIG5ldyBsb2NhdGlvblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuUGF0aCkge1xuXHRcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXllciB8fCBlLnRhcmdldCwgZS5sYXRsbmcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XG5cdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxuXHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApICYmIHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IGxheWVyKSB7XG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcGVuUG9wdXAobGF5ZXIsIGUubGF0bG5nKTtcblx0XHR9XG5cdH0sXG5cblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xuXHR9XG59KTtcblxuXG5cbi8qXHJcbiAqIFBvcHVwIGV4dGVuc2lvbiB0byBMLk1hcmtlciwgYWRkaW5nIHBvcHVwLXJlbGF0ZWQgbWV0aG9kcy5cclxuICovXHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yIHx8IFswLCAwXTtcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXRpbmc6XG4gKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gKi9cblxuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbkwuVG9vbHRpcCA9IEwuRGl2T3ZlcmxheS5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG5cdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuXHRcdG9mZnNldDogWzAsIDBdLFxuXG5cdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG5cdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0TC5EaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBMLkRpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCAmJiAhdGhpcy5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VUb29sdGlwKHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcblx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IEwucG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHBvcyA9IHBvcy5hZGQoTC5wb2ludCgtdG9vbHRpcFdpZHRoIC8gMiArIG9mZnNldC54LCAtdG9vbHRpcEhlaWdodCArIG9mZnNldC55ICsgYW5jaG9yLnkpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdChMLnBvaW50KHRvb2x0aXBXaWR0aCAvIDIgLSBvZmZzZXQueCwgLW9mZnNldC55KSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QoTC5wb2ludCh0b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkgKyBvZmZzZXQueSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHBvcyA9IHBvcy5hZGQoW29mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDIgKyBvZmZzZXQueV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QoTC5wb2ludCh0b29sdGlwV2lkdGggKyBhbmNob3IueCAtIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55IC0gb2Zmc2V0LnkpKTtcblx0XHR9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuXHRcdHJldHVybiBMLnBvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdH1cblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuLy8gSW5zdGFudGlhdGVzIGEgVG9vbHRpcCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbkwudG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcblx0cmV0dXJuIG5ldyBMLlRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5MLk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIEwuVG9vbHRpcCkpIHtcblx0XHRcdHRvb2x0aXAgPSBuZXcgTC5Ub29sdGlwKG9wdGlvbnMpLnNldENvbnRlbnQodG9vbHRpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0dG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cblxuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICogYGBgXG4gKi9cblxuLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5MLkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Ub29sdGlwKSB7XG5cdFx0XHRMLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBMLnRvb2x0aXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuXHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG5cdHVuYmluZFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG5cdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdGlmICghcmVtb3ZlICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcblx0XHQgICAgZXZlbnRzID0ge1xuXHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlVG9vbHRpcCxcblx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG5cdFx0ICAgIH07XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG5cdFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcblx0XHRcdH1cblx0XHRcdGlmIChMLkJyb3dzZXIudG91Y2gpIHtcblx0XHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpY2VkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyKSkge1xuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XG5cdFx0XHRsYXllciA9IHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5GZWF0dXJlR3JvdXApIHtcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbGF0bG5nKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBzb3VyY2UgdG8gdGhpcyBsYXllclxuXHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgdG9vbHRpcCAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcblx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5fY2xvc2UoKTtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNUb29sdGlwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG5cdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHR9LFxuXG5cdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5vcGVuVG9vbHRpcChsYXllciwgdGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcblx0fSxcblxuXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG5cdFx0fVxuXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdH1cbn0pO1xuXG5cblxuLypcclxuICogVG9vbHRpcCBleHRlbnNpb24gdG8gTC5NYXJrZXIsIGFkZGluZyB0b29sdGlwLXJlbGF0ZWQgbWV0aG9kcy5cclxuICovXHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvciB8fCBbMCwgMF07XHJcblx0fVxyXG59KTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIExheWVyR3JvdXBcclxuICogQGFrYSBMLkxheWVyR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5MYXllckdyb3VwID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKGxheWVyIGluIHRoaXMuX2xheWVycyB8fCB0aGlzLmdldExheWVySWQobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1hcC5hZGRMYXllcih0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVycy5wdXNoKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIEwuc3RhbXAobGF5ZXIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVyczogTGF5ZXJbXSlcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG5MLmxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0cmV0dXJuIG5ldyBMLkxheWVyR3JvdXAobGF5ZXJzKTtcclxufTtcclxuXG5cblxuLypcclxuICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAqXHJcbiAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5GZWF0dXJlR3JvdXAgPSBMLkxheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzOiBMYXllcltdKVxyXG4vLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycy5cclxuTC5mZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5MLlJlbmRlcmVyID0gTC5MYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcblx0XHQvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cblx0XHRwYWRkaW5nOiAwLjFcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRMLnN0YW1wKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZVxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuQm91bmRzKG1pbiwgbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKSkucm91bmQoKSk7XG5cblx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG5cdFx0dGhpcy5fem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdH1cbn0pO1xuXG5cbkwuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgTC5jYW52YXMoKSkgfHwgTC5zdmcoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSAoTC5TVkcgJiYgTC5zdmcoe3BhbmU6IG5hbWV9KSkgfHwgKEwuQ2FudmFzICYmIEwuY2FudmFzKHtwYW5lOiBuYW1lfSkpO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH1cbn0pO1xuXG5cblxuLypcbiAqIEBjbGFzcyBQYXRoXG4gKiBAYWthIEwuUGF0aFxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAqL1xuXG5MLlBhdGggPSBMLkxheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQYXRoIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gZHJhdyBzdHJva2UgYWxvbmcgdGhlIHBhdGguIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYm9yZGVycyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdHN0cm9rZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuXHRcdC8vIFN0cm9rZSBjb2xvclxuXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cblx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuXHRcdC8vIFN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcblx0XHR3ZWlnaHQ6IDMsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIFN0cm9rZSBvcGFjaXR5XG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBlbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXApIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBbZGFzaCBwYXR0ZXJuXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBbZGlzdGFuY2UgaW50byB0aGUgZGFzaCBwYXR0ZXJuIHRvIHN0YXJ0IHRoZSBkYXNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNob2Zmc2V0KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gV2hldGhlciB0byBmaWxsIHRoZSBwYXRoIHdpdGggY29sb3IuIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZmlsbGluZyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdGZpbGw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcblx0XHQvLyBGaWxsIGNvbG9yLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgdGhlIFtgY29sb3JgXSgjcGF0aC1jb2xvcikgb3B0aW9uXG5cdFx0ZmlsbENvbG9yOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG5cdFx0Ly8gRmlsbCBvcGFjaXR5LlxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW2hvdyB0aGUgaW5zaWRlIG9mIGEgc2hhcGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlKSBpcyBkZXRlcm1pbmVkLlxuXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cblx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuXHRcdGludGVyYWN0aXZlOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVuZGVyZXIub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZW5kZXJlci5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHpvb21lbmQ6IHRoaXMuX3Byb2plY3QsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkcmVuIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICsgKEwuQnJvd3Nlci50b3VjaCA/IDEwIDogMCk7XG5cdH1cbn0pO1xuXG5cblxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5aW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG5MLkxpbmVVdGlsID0ge1xyXG5cclxuXHQvLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuXHQvLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuXHQvLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG5cdC8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcblx0Ly8gW0RvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcblx0Ly8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG5cdC8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuXHQvLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG5cdC8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5jb20vc2ltcGxpZnktanMvKS5cclxuXHRzaW1wbGlmeTogZnVuY3Rpb24gKHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0XHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHRcdC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0XHQvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcblx0cG9pbnRUb1NlZ21lbnREaXN0YW5jZTogIGZ1bmN0aW9uIChwLCBwMSwgcDIpIHtcclxuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuXHRjbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uIChwLCBwMSwgcDIpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5cdF9zaW1wbGlmeURQOiBmdW5jdGlvbiAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHRcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0XHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdFx0bWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHRcdHZhciBpLFxyXG5cdFx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3UG9pbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcDogZnVuY3Rpb24gKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdFx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0XHQgICAgaW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0XHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0XHRzcURpc3QgPSB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5cdF9yZWR1Y2VQb2ludHM6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0XHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0XHRwcmV2ID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG5cdC8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcblx0Ly8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG5cdC8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcblx0Y2xpcFNlZ21lbnQ6IGZ1bmN0aW9uIChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdFx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyB0aGlzLl9sYXN0Q29kZSA6IHRoaXMuX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHRcdCAgICBjb2RlQiA9IHRoaXMuX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0XHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0XHQvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHRcdHRoaXMuX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG5cdFx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcblx0XHRcdHAgPSB0aGlzLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRuZXdDb2RlID0gdGhpcy5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdFx0YSA9IHA7XHJcblx0XHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGIgPSBwO1xyXG5cdFx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdFx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG5cdFx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4LCB5O1xyXG5cclxuXHRcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG5cdFx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG5cdFx0XHR5ID0gbWluLnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0XHR4ID0gbWF4Lng7XHJcblx0XHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdFx0eCA9IG1pbi54O1xyXG5cdFx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHksIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qml0Q29kZTogZnVuY3Rpb24gKHAsIGJvdW5kcykge1xyXG5cdFx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRcdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG5cdFx0XHRjb2RlIHw9IDE7XHJcblx0XHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0XHRjb2RlIHw9IDI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdFx0Y29kZSB8PSA0O1xyXG5cdFx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRcdGNvZGUgfD0gODtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29kZTtcclxuXHR9LFxyXG5cclxuXHQvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocDEsIHAyKSB7XHJcblx0XHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5cdF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0XHR2YXIgeCA9IHAxLngsXHJcblx0XHQgICAgeSA9IHAxLnksXHJcblx0XHQgICAgZHggPSBwMi54IC0geCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdFx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdFx0ICAgIHQ7XHJcblxyXG5cdFx0aWYgKGRvdCA+IDApIHtcclxuXHRcdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHRcdHkgPSBwMi55O1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRkeCA9IHAueCAtIHg7XHJcblx0XHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdFx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IEwuUG9pbnQoeCwgeSk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFBvbHlsaW5lXG4gKiBAYWthIEwuUG9seWxpbmVcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFstMTIyLjY4LCA0NS41MV0sXG4gKiBcdFstMTIyLjQzLCAzNy43N10sXG4gKiBcdFstMTE4LjIsIDM0LjA0XVxuICogXTtcbiAqXG4gKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0W1stMTIyLjY4LCA0NS41MV0sXG4gKiBcdCBbLTEyMi40MywgMzcuNzddLFxuICogXHQgWy0xMTguMiwgMzQuMDRdXSxcbiAqIFx0W1stNzMuOTEsIDQwLjc4XSxcbiAqIFx0IFstODcuNjIsIDQxLjgzXSxcbiAqIFx0IFstOTYuNzIsIDMyLjc2XV1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5MLlBvbHlsaW5lID0gTC5QYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuXHRcdG5vQ2xpcDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG5cdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcblx0fSxcblxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gTC5MaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5bGluZSBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cblx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IEwuUG9seWxpbmUuX2ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gTC5sYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgTC5Cb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgTC5Qb2ludCh3LCB3KTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0cHhCb3VuZHMubWluLl9zdWJ0cmFjdChwKTtcblx0XHRcdHB4Qm91bmRzLm1heC5fYWRkKHApO1xuXHRcdFx0dGhpcy5fcHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHR9XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTC5MYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTC5MaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTC5MaW5lVXRpbC5zaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5MLnBvbHlsaW5lID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLlBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufTtcblxuTC5Qb2x5bGluZS5fZmxhdCA9IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdC8vIHRydWUgaWYgaXQncyBhIGZsYXQgYXJyYXkgb2YgbGF0bG5nczsgZmFsc2UgaWYgbmVzdGVkXG5cdHJldHVybiAhTC5VdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbkwuUG9seVV0aWwgPSB7fTtcclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnZW1hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBlcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuTC5Qb2x5VXRpbC5jbGlwUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcblx0ICAgIGksIGosIGssXHJcblx0ICAgIGEsIGIsXHJcblx0ICAgIGxlbiwgZWRnZSwgcCxcclxuXHQgICAgbHUgPSBMLkxpbmVVdGlsO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IGx1Ll9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gbHUuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1stMTExLjAzLCA0MV0sWy0xMTEuMDQsIDQ1XSxbLTEwNC4wNSwgNDVdLFstMTA0LjA1LCA0MV1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWy0xMTEuMDMsIDQxXSxbLTExMS4wNCwgNDVdLFstMTA0LjA1LCA0NV0sWy0xMDQuMDUsIDQxXV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1stMTA4LjU4LDM3LjI5XSxbLTEwOC41OCw0MC43MV0sWy0xMDIuNTAsNDAuNzFdLFstMTAyLjUwLDM3LjI5XV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1stMTExLjAzLCA0MV0sWy0xMTEuMDQsIDQ1XSxbLTEwNC4wNSwgNDVdLFstMTA0LjA1LCA0MV1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1stMTA4LjU4LDM3LjI5XSxbLTEwOC41OCw0MC43MV0sWy0xMDIuNTAsNDAuNzFdLFstMTAyLjUwLDM3LjI5XV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1stMTA5LjA1LCAzN10sWy0xMDkuMDMsIDQxXSxbLTEwMi4wNSwgNDFdLFstMTAyLjA0LCAzN10sWy0xMDkuMDUsIDM4XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbkwuUG9seWdvbiA9IEwuUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0YXJlYSA9IHggPSB5ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2pdO1xuXG5cdFx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcblx0XHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XG5cdFx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xuXHRcdFx0YXJlYSArPSBmICogMztcblx0XHR9XG5cblx0XHRpZiAoYXJlYSA9PT0gMCkge1xuXHRcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXG5cdFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhjZW50ZXIpO1xuXHR9LFxuXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gTC5Qb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIEwuTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdEwuUG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG5cdFx0aWYgKEwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IEwuUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEwuQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbGlwcGVkID0gTC5Qb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuTC5wb2x5Z29uID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLlBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG59O1xuXG5cblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZXRhbmdsZVxuICogQGluaGVyaXRzIFBvbHlnb25cbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICogYGBgXG4gKlxuICovXG5cblxuTC5SZWN0YW5nbGUgPSBMLlBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdEwuUG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5MLnJlY3RhbmdsZSA9IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLlJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufTtcblxuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5MLkNpcmNsZU1hcmtlciA9IEwuUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcblx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuXHRcdHJhZGl1czogMTBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBjaXJjbGUgbWFya2VyIHRvIGEgbmV3IGxvY2F0aW9uLlxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRMLlBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcblx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEwuQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbkwuY2lyY2xlTWFya2VyID0gZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59O1xuXG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbkwuQ2lyY2xlID0gTC5DaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gTC5leHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IEwuUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEwuQ1JTLkVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gTC5DUlMuRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IE1hdGgubWF4KE1hdGgucm91bmQocC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54KSwgMSk7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gTWF0aC5tYXgoTWF0aC5yb3VuZChwLnkgLSB0b3AueSksIDEpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4vLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG5MLmNpcmNsZSA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xufTtcblxuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5TVkdcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9c3ZnKSwgU1ZHIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAqIHRoaXMgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbkwuU1ZHID0gTC5SZW5kZXJlci5leHRlbmQoe1xuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBMLlJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuU1ZHLmNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBMLlNWRy5jcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEcmFnLXRoZW4tcGluY2ggaW50ZXJhY3Rpb25zIG1pZ2h0IG1lc3MgdXAgdGhlIGNlbnRlciBhbmQgem9vbS5cblx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG5cdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG5cdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG5cdFx0aWYgKCF0aGlzLl9zdmdTaXplIHx8ICF0aGlzLl9zdmdTaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuXHRcdH1cblxuXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBMLlNWRy5jcmVhdGUoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgTC5TVkcucG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBsYXllci5fcmFkaXVzLFxuXHRcdCAgICByMiA9IGxheWVyLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG5cdFx0dmFyIGQgPSBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRcdGFyYyArICgtciAqIDIpICsgJywwICc7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG5cdH0sXG5cblx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuXG4vLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5MLmV4dGVuZChMLlNWRywge1xuXHQvLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG5cdC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG5cdC8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cblx0Y3JlYXRlOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG5cdH0sXG5cblx0Ly8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG5cdC8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcblx0Ly8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuXHRwb2ludHNUb1BhdGg6IGZ1bmN0aW9uIChyaW5ncywgY2xvc2VkKSB7XG5cdFx0dmFyIHN0ciA9ICcnLFxuXHRcdCAgICBpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBvaW50c1tqXTtcblx0XHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuXHRcdFx0c3RyICs9IGNsb3NlZCA/IChMLkJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHRcdH1cblxuXHRcdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdFx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG5cdH1cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIEJyb3dzZXI7IEBwcm9wZXJ0eSBzdmc6IEJvb2xlYW5cbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG5MLkJyb3dzZXIuc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIEwuU1ZHLmNyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XG5cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuTC5zdmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gTC5Ccm93c2VyLnN2ZyB8fCBMLkJyb3dzZXIudm1sID8gbmV3IEwuU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn07XG5cblxuXG4vKlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0IFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW4gdGhpcyBjYXNlLlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgQnJvd3NlcjsgQHByb3BlcnR5IHZtbDogQm9vbGVhblxuLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxuTC5Ccm93c2VyLnZtbCA9ICFMLkJyb3dzZXIuc3ZnICYmIChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xuXG5cdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xuXG5cdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XG5cblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSgpKTtcblxuLy8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbkwuU1ZHLmluY2x1ZGUoIUwuQnJvd3Nlci52bWwgPyB7fSA6IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gTC5TVkcuY3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG5cdFx0bGF5ZXIuX3BhdGggPSBMLlNWRy5jcmVhdGUoJ3BhdGgnKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSBMLlNWRy5jcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IEwuVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IEwuU1ZHLmNyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuXHR9XG59KTtcblxuaWYgKEwuQnJvd3Nlci52bWwpIHtcblx0TC5TVkcuY3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0pKCk7XG59XG5cblxuXG4vKlxuICogQGNsYXNzIENhbnZhc1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuQ2FudmFzXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbkwuQ2FudmFzID0gTC5SZW5kZXJlci5leHRlbmQoe1xuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCBMLlV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3VzZU1vdmUsIDMyLCB0aGlzKSwgdGhpcylcblx0XHRcdC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpXG5cdFx0XHQub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cblx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9kcmF3bkxheWVycyA9IHt9O1xuXG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gTC5Ccm93c2VyLnJldGluYSA/IDIgOiAxO1xuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChMLkJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tMLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogTC5VdGlsLmZhbHNlRm4sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9yZW1vdmVkID0gdHJ1ZTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbGF5ZXIuX3B4Qm91bmRzO1xuXHRcdHRoaXMuX2RyYXcodHJ1ZSk7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fZHJhdygpO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5vcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoJywnKSxcblx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKE51bWJlcihwYXJ0c1tpXSkpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBMLkJvdW5kcygpO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHR0aGlzLl9kcmF3KHRydWUpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uIChjbGVhcikge1xuXHRcdHRoaXMuX2NsZWFyID0gY2xlYXI7XG5cdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54LCBib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkpO1xuXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHRcdGlmIChjbGVhciAmJiBsYXllci5fcmVtb3ZlZCkge1xuXHRcdFx0XHRkZWxldGUgbGF5ZXIuX3JlbW92ZWQ7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cblx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcblx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG5cdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9kcmF3bkxheWVyc1tsYXllci5fbGVhZmxldF9pZF0gPSBsYXllcjtcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAobGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gbGF5ZXIuX3JhZGl1cyxcblx0XHQgICAgcyA9IChsYXllci5fcmFkaXVzWSB8fCByKSAvIHI7XG5cblx0XHR0aGlzLl9kcmF3bkxheWVyc1tsYXllci5fbGVhZmxldF9pZF0gPSBsYXllcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIGNsZWFyID0gdGhpcy5fY2xlYXIsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNsZWFyID8gJ2Rlc3RpbmF0aW9uLW91dCcgOiAnc291cmNlLW92ZXInO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY2xlYXIgPyAxIDogb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY2xlYXIgPyAxIDogb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHQvLyBpZiBjbGVhcmluZyBzaGFwZSwgZG8gaXQgd2l0aCB0aGUgcHJldmlvdXNseSBkcmF3biBsaW5lIHdpZHRoXG5cdFx0XHRsYXllci5fcHJldldlaWdodCA9IGN0eC5saW5lV2lkdGggPSBjbGVhciA/IGxheWVyLl9wcmV2V2VpZ2h0ICsgMSA6IG9wdGlvbnMud2VpZ2h0O1xuXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcblx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVycyA9IFtdLCBsYXllcjtcblxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRMLkRvbUV2ZW50Ll9mYWtlU3RvcChlKTtcblx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobGF5ZXJzLmxlbmd0aCkgIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChsYXllcnMsIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUsIHBvaW50KTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllciAmJiAoZS50eXBlID09PSAnbW91c2VvdXQnIHx8ICFsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHR2YXIgaWQsIGxheWVyO1xuXG5cdFx0Zm9yIChpZCBpbiB0aGlzLl9kcmF3bkxheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9kcmF3bkxheWVyc1tpZF07XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbiAobGF5ZXJzLCBlLCB0eXBlKSB7XG5cdFx0dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoZSwgdHlwZSB8fCBlLnR5cGUsIGxheWVycyk7XG5cdH0sXG5cblx0Ly8gVE9ETyBfYnJpbmdUb0Zyb250ICYgX2JyaW5nVG9CYWNrLCBwcmV0dHkgdHJpY2t5XG5cblx0X2JyaW5nVG9Gcm9udDogTC5VdGlsLmZhbHNlRm4sXG5cdF9icmluZ1RvQmFjazogTC5VdGlsLmZhbHNlRm5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIEJyb3dzZXI7IEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG5MLkJyb3dzZXIuY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcbn0oKSk7XG5cbi8vIEBuYW1lc3BhY2UgQ2FudmFzXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuY2FudmFzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIEwuQnJvd3Nlci5jYW52YXMgPyBuZXcgTC5DYW52YXMob3B0aW9ucykgOiBudWxsO1xufTtcblxuTC5Qb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRpZiAoIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmIChMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuTC5Qb2x5Z29uLnByb3RvdHlwZS5fY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG5cdHZhciBpbnNpZGUgPSBmYWxzZSxcblx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0cDEgPSBwYXJ0W2pdO1xuXHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRyZXR1cm4gaW5zaWRlIHx8IEwuUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG59O1xuXG5MLkNpcmNsZU1hcmtlci5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocCkge1xuXHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5HZW9KU09OID0gTC5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiBMYXllclxyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IEwuVXRpbC5pc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBMLkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBMLkdlb0pTT04uYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllciApOiBMYXllclxyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gTC5VdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogTGF5ZXJcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcbkwuZXh0ZW5kKEwuR2VvSlNPTiwge1xyXG5cdC8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcblx0Ly8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG5cdC8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG5cdC8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5cdGdlb21ldHJ5VG9MYXllcjogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdFx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdFx0ICAgIGxheWVycyA9IFtdLFxyXG5cdFx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcblx0XHQgICAgY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZyxcclxuXHRcdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0XHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0XHRjYXNlICdQb2ludCc6XHJcblx0XHRcdGxhdGxuZyA9IGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRcdHJldHVybiBwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBMLk1hcmtlcihsYXRsbmcpO1xyXG5cclxuXHRcdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBjb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IEwuTWFya2VyKGxhdGxuZykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0XHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRcdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdQb2x5Z29uJzpcclxuXHRcdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLmdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0XHRpZiAobGF5ZXIpIHtcclxuXHRcdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG5cdC8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcblx0Ly8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcblx0Y29vcmRzVG9MYXRMbmc6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuXHQvLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcblx0Ly8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG5cdC8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuXHRjb29yZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChjb29yZHMsIGxldmVsc0RlZXAsIGNvb3Jkc1RvTGF0TG5nKSB7XHJcblx0XHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0ICAgICAgICB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBjb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQgICAgICAgIChjb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZ3M7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nKTogQXJyYXlcclxuXHQvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuXHRsYXRMbmdUb0Nvb3JkczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdFx0W2xhdGxuZy5sbmcsIGxhdGxuZy5sYXQsIGxhdGxuZy5hbHRdIDpcclxuXHRcdFx0XHRbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF07XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcblx0Ly8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuXHQvLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcblx0bGF0TG5nc1RvQ29vcmRzOiBmdW5jdGlvbiAobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdFx0TC5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkKSA6XHJcblx0XHRcdFx0TC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0pKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvb3JkcztcclxuXHR9LFxyXG5cclxuXHRnZXRGZWF0dXJlOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRcdFx0TC5leHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRcdFx0TC5HZW9KU09OLmFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuXHRhc0ZlYXR1cmU6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIHtcclxuXHRcdFx0cmV0dXJuIGdlb2pzb247XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBMLkdlb0pTT04ubGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSlcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTC5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkwuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuTC5Qb2x5bGluZS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBtdWx0aSA9ICFMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHR2YXIgY29vcmRzID0gTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwKTtcclxuXHJcblx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0fSk7XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5MLlBvbHlnb24ucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgaG9sZXMgPSAhTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHQgICAgbXVsdGkgPSBob2xlcyAmJiAhTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0dmFyIGNvb3JkcyA9IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSk7XHJcblxyXG5cdGlmICghaG9sZXMpIHtcclxuXHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkwuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgR2VvbWV0cnlDb2xsZWN0aW9uYCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKCk7XHJcblx0XHRcdFx0anNvbnMucHVzaChpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGpzb24uZ2VvbWV0cnkgOiBMLkdlb0pTT04uYXNGZWF0dXJlKGpzb24pKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sKSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuTC5nZW9KU09OID0gZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufTtcclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuTC5nZW9Kc29uID0gTC5nZW9KU09OO1xyXG5cblxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcblxyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuTC5Eb21FdmVudCA9IHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG5cdC8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcblx0Ly8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuXHQvLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0b246IGZ1bmN0aW9uIChvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vbihvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24ob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLFxyXG5cdC8vIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBET00gZXZlbnQgZnJvbSB0aGUgZWxlbWVudC5cclxuXHQvLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcblx0Ly8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0b2ZmOiBmdW5jdGlvbiAob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGlkID0gdHlwZSArIEwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBMLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuXHRcdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0dGhpcy5hZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMuYWRkRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5hZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICgodHlwZSA9PT0gJ21vdXNlZW50ZXInKSB8fCAodHlwZSA9PT0gJ21vdXNlbGVhdmUnKSkge1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdFx0aWYgKEwuRG9tRXZlbnQuX2lzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycgJiYgTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gTC5Eb21FdmVudC5fZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdFx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdHZhciBpZCA9IHR5cGUgKyBMLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgTC5zdGFtcChjb250ZXh0KSA6ICcnKSxcclxuXHRcdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRcdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMucmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuXHRcdFx0XHRcdHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDpcclxuXHRcdFx0XHRcdHR5cGUgPT09ICdtb3VzZWxlYXZlJyA/ICdtb3VzZW91dCcgOiB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuXHQvLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuXHQvLyBgYGBqc1xyXG5cdC8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuXHQvLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcHBlZChlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuXHQvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdtb3VzZXdoZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5cdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5vbihlbCwgJ21vdXNld2hlZWwnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuXHQvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcblx0Ly8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5cdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbihlbCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCBzdG9wKTtcclxuXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5vbihlbCwge1xyXG5cdFx0XHRjbGljazogTC5Eb21FdmVudC5fZmFrZVN0b3AsXHJcblx0XHRcdGRibGNsaWNrOiBzdG9wXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG5cdC8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuXHQvLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcblx0Ly8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuXHQvLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3RvcChldik6IHRoaXNcclxuXHQvLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcblx0c3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50XHJcblx0XHRcdC5wcmV2ZW50RGVmYXVsdChlKVxyXG5cdFx0XHQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG5cdC8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIGBjb250YWluZXJgIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcblx0Z2V0TW91c2VQb3NpdGlvbjogZnVuY3Rpb24gKGUsIGNvbnRhaW5lcikge1xyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHRcdGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0XHRlLmNsaWVudFkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3ApO1xyXG5cdH0sXHJcblxyXG5cdC8vIENocm9tZSBvbiBXaW4gc2Nyb2xscyBkb3VibGUgdGhlIHBpeGVscyBhcyBpbiBvdGhlciBwbGF0Zm9ybXMgKHNlZSAjNDUzOCksXHJcblx0Ly8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG5cdF93aGVlbFB4RmFjdG9yOiAoTC5Ccm93c2VyLndpbiAmJiBMLkJyb3dzZXIuY2hyb21lKSA/IDIgOlxyXG5cdCAgICAgICAgICAgICAgICBMLkJyb3dzZXIuZ2Vja28gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcblx0ICAgICAgICAgICAgICAgIDEsXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG5cdC8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2V3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcblx0Ly8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcblx0Ly8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuXHQvLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5cdGdldFdoZWVsRGVsdGE6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gKEwuQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0XHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIEwuRG9tRXZlbnQuX3doZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHRcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG5cdFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0XHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdFx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG5cdFx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHRcdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0XHQgICAgICAgMDtcclxuXHR9LFxyXG5cclxuXHRfc2tpcEV2ZW50czoge30sXHJcblxyXG5cdF9mYWtlU3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggTC5Eb21FdmVudC5fc2tpcHBlZChlKVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfc2tpcHBlZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBza2lwcGVkID0gdGhpcy5fc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdFx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRcdHRoaXMuX3NraXBFdmVudHNbZS50eXBlXSA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHNraXBwZWQ7XHJcblx0fSxcclxuXHJcblx0Ly8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcblx0X2lzRXh0ZXJuYWxUYXJnZXQ6IGZ1bmN0aW9uIChlbCwgZSkge1xyXG5cclxuXHRcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcblx0fSxcclxuXHJcblx0Ly8gdGhpcyBpcyBhIGhvcnJpYmxlIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIEFuZHJvaWQgd2hlcmUgYSBzaW5nbGUgdG91Y2ggdHJpZ2dlcnMgdHdvIGNsaWNrIGV2ZW50c1xyXG5cdF9maWx0ZXJDbGljazogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcclxuXHRcdHZhciB0aW1lU3RhbXAgPSAoZS50aW1lU3RhbXAgfHwgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQudGltZVN0YW1wKSksXHJcblx0XHQgICAgZWxhcHNlZCA9IEwuRG9tRXZlbnQuX2xhc3RDbGljayAmJiAodGltZVN0YW1wIC0gTC5Eb21FdmVudC5fbGFzdENsaWNrKTtcclxuXHJcblx0XHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXHJcblx0XHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0XHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRcdGlmICgoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCA1MDApIHx8IChlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgJiYgIWUuX3NpbXVsYXRlZCkpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdFx0aGFuZGxlcihlKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub25gXSgjZG9tZXZlbnQtb24pXHJcbkwuRG9tRXZlbnQuYWRkTGlzdGVuZXIgPSBMLkRvbUV2ZW50Lm9uO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9mZmBdKCNkb21ldmVudC1vZmYpXHJcbkwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIgPSBMLkRvbUV2ZW50Lm9mZjtcclxuXG5cblxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5EcmFnZ2FibGUgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0U1RBUlQ6IEwuQnJvd3Nlci50b3VjaCA/IFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nXSA6IFsnbW91c2Vkb3duJ10sXHJcblx0XHRFTkQ6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0XHRcdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcblx0XHR9LFxyXG5cdFx0TU9WRToge1xyXG5cdFx0XHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU6IEJvb2xlYW4pXHJcblx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUpIHtcclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBMLkRyYWdnYWJsZS5TVEFSVC5qb2luKCcgJyksIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChMLkRvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHRcdEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRydWU7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHRcdC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgbmV3UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGlmICgod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkgJiYgKHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpKSB7XHJcblx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlUG9zaXRpb24sIHRoaXMsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIEwuRHJhZ2dhYmxlLk1PVkUpIHtcclxuXHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcylcclxuXHRcdFx0XHQub2ZmKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZykge1xyXG5cdFx0XHQvLyBlbnN1cmUgZHJhZyBpcyBub3QgZmlyZWQgYWZ0ZXIgZHJhZ2VuZFxyXG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdEwuRHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuLy8gQGNsYXNzIEhhbmRsZXJcbi8vIEBha2EgTC5IYW5kbGVyXG4vLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbkwuSGFuZGxlciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG5cblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBiZSBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXG5cdGRyYWdnaW5nOiB0cnVlLFxuXG5cdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG5cdC8vIEBvcHRpb24gaW5lcnRpYTogQm9vbGVhbiA9ICpcblx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuXHQvLyB0aGUgc2FtZSBkaXJlY3Rpb24gZm9yIHNvbWUgdGltZS4gRmVlbHMgZXNwZWNpYWxseSBuaWNlIG9uIHRvdWNoXG5cdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdCB1bmxlc3MgcnVubmluZyBvbiBvbGQgQW5kcm9pZCBkZXZpY2VzLlxuXHRpbmVydGlhOiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbkwuTWFwLkRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkb3duOiB0aGlzLl9vbkRvd24sXG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5fc3RvcCgpO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gTC5ib3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0aWYgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcblx0fSxcblxuXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cblx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcblx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG5cdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG5cdFx0aWYgKG5vSW5lcnRpYSkge1xuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG5cdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgTC5NYXAuRHJhZyk7XG5cblxuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG5cdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcblx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Eb3VibGVDbGlja1pvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBMLk1hcC5Eb3VibGVDbGlja1pvb20pO1xuXG5cblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gTW91c2V3aGVlbCBvcHRpb25zXG5cdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcblx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcblx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcblx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG5cdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG5cdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcblx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cblx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbn0pO1xuXG5MLk1hcC5TY3JvbGxXaGVlbFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cblx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcblx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcblx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG5cdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbi8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBMLk1hcC5TY3JvbGxXaGVlbFpvb20pO1xuXG5cblxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcclxuXHJcblx0X3RvdWNoc3RhcnQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBMLkJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCcsXHJcblx0X3RvdWNoZW5kOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnLFxyXG5cclxuXHQvLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5cdGFkZERvdWJsZVRhcExpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdFx0dmFyIGxhc3QsIHRvdWNoLFxyXG5cdFx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxyXG5cdFx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblx0XHRcdHZhciBjb3VudDtcclxuXHJcblx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdGNvdW50ID0gTC5Eb21FdmVudC5fcG9pbnRlcnNDb3VudDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb3VudCA9IGUudG91Y2hlcy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb3VudCA+IDEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdFx0ICAgIGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcblx0XHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRcdGxhc3QgPSBub3c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcclxuXHRcdFx0aWYgKGRvdWJsZVRhcCAmJiAhdG91Y2guY2FuY2VsQnViYmxlKSB7XHJcblx0XHRcdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXHJcblx0XHRcdFx0XHR2YXIgbmV3VG91Y2ggPSB7fSxcclxuXHRcdFx0XHRcdCAgICBwcm9wLCBpO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gpIDogcHJvcDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxyXG5cdFx0ICAgIHRvdWNoc3RhcnQgPSB0aGlzLl90b3VjaHN0YXJ0LFxyXG5cdFx0ICAgIHRvdWNoZW5kID0gdGhpcy5fdG91Y2hlbmQ7XHJcblxyXG5cdFx0b2JqW3ByZSArIHRvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0XHRvYmpbcHJlICsgdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cdFx0b2JqW3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xyXG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHJcblx0XHQvLyBPbiBzb21lIHBsYXRmb3JtcyAobm90YWJseSwgY2hyb21lIG9uIHdpbjEwICsgdG91Y2hzY3JlZW4gKyBtb3VzZSksXHJcblx0XHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcblx0XHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcblx0XHRpZiAoIUwuQnJvd3Nlci5lZGdlKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgaWQpIHtcclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaHN0YXJ0ID0gb2JqW3ByZSArIHRoaXMuX3RvdWNoc3RhcnQgKyBpZF0sXHJcblx0XHQgICAgdG91Y2hlbmQgPSBvYmpbcHJlICsgdGhpcy5fdG91Y2hlbmQgKyBpZF0sXHJcblx0XHQgICAgZGJsY2xpY2sgPSBvYmpbcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBmYWxzZSk7XHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaGVuZCwgdG91Y2hlbmQsIGZhbHNlKTtcclxuXHRcdGlmICghTC5Ccm93c2VyLmVkZ2UpIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZGJsY2xpY2ssIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG5MLmV4dGVuZChMLkRvbUV2ZW50LCB7XG5cblx0UE9JTlRFUl9ET1dOOiAgIEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bicsXG5cdFBPSU5URVJfTU9WRTogICBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnLFxuXHRQT0lOVEVSX1VQOiAgICAgTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCcsXG5cdFBPSU5URVJfQ0FOQ0VMOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCcsXG5cdFRBR19XSElURV9MSVNUOiBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXSxcblxuXHRfcG9pbnRlcnM6IHt9LFxuXHRfcG9pbnRlcnNDb3VudDogMCxcblxuXHQvLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG5cdC8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cblx0YWRkUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXG5cdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdFx0dGhpcy5fYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdFx0dGhpcy5fYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBpZCkge1xuXHRcdHZhciBoYW5kbGVyID0gb2JqWydfbGVhZmxldF8nICsgdHlwZSArIGlkXTtcblxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfTU9WRSwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkUG9pbnRlclN0YXJ0OiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBvbkRvd24gPSBMLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcblx0XHRcdFx0Ly8gSW4gSUUxMSwgc29tZSB0b3VjaCBldmVudHMgbmVlZHMgdG8gZmlyZSBmb3IgZm9ybSBjb250cm9scywgb3Jcblx0XHRcdFx0Ly8gdGhlIGNvbnRyb2xzIHdpbGwgc3RvcCB3b3JraW5nLiBXZSBrZWVwIGEgd2hpdGVsaXN0IG9mIHRhZyBuYW1lcyB0aGF0XG5cdFx0XHRcdC8vIG5lZWQgdGhlc2UgZXZlbnRzLiBGb3Igb3RoZXIgdGFyZ2V0IHRhZ3MsIHdlIHByZXZlbnQgZGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5cdFx0XHRcdGlmICh0aGlzLlRBR19XSElURV9MSVNULmluZGV4T2YoZS50YXJnZXQudGFnTmFtZSkgPCAwKSB7XG5cdFx0XHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIG9uRG93biwgZmFsc2UpO1xuXG5cdFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdFx0aWYgKCF0aGlzLl9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHRcdHZhciBwb2ludGVyVXAgPSBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlclVwLCB0aGlzKTtcblxuXHRcdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlckRvd24sIHRoaXMpLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBMLmJpbmQodGhpcy5fZ2xvYmFsUG9pbnRlck1vdmUsIHRoaXMpLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgcG9pbnRlclVwLCB0cnVlKTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIHBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9nbG9iYWxQb2ludGVyRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRcdHRoaXMuX3BvaW50ZXJzQ291bnQrKztcblx0fSxcblxuXHRfZ2xvYmFsUG9pbnRlck1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdFx0dGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0XHR9XG5cdH0sXG5cblx0X2dsb2JhbFBvaW50ZXJVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRkZWxldGUgdGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdO1xuXHRcdHRoaXMuX3BvaW50ZXJzQ291bnQtLTtcblx0fSxcblxuXHRfaGFuZGxlUG9pbnRlcjogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcblx0XHRlLnRvdWNoZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3BvaW50ZXJzKSB7XG5cdFx0XHRlLnRvdWNoZXMucHVzaCh0aGlzLl9wb2ludGVyc1tpXSk7XG5cdFx0fVxuXHRcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0XHRoYW5kbGVyKGUpO1xuXHR9LFxuXG5cdF9hZGRQb2ludGVyTW92ZTogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgb25Nb3ZlID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuXHRcdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfTU9WRSwgb25Nb3ZlLCBmYWxzZSk7XG5cdH0sXG5cblx0X2FkZFBvaW50ZXJFbmQ6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIG9uVXAgPSBMLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgb25VcCwgZmFsc2UpO1xuXHR9XG59KTtcblxuXG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG5cdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG5cdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdC8vIGJyb3dzZXJzIGV4Y2VwdCBmb3Igb2xkIEFuZHJvaWRzLlxuXHR0b3VjaFpvb206IEwuQnJvd3Nlci50b3VjaCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuTC5NYXAuVG91Y2hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG5cdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IEwuYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0pO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpXG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBMLk1hcC5Ub3VjaFpvb20pO1xuXG5cblxuLypcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIEVuYWJsZXMgbW9iaWxlIGhhY2tzIGZvciBzdXBwb3J0aW5nIGluc3RhbnQgdGFwcyAoZml4aW5nIDIwMG1zIGNsaWNrXG5cdC8vIGRlbGF5IG9uIGlPUy9BbmRyb2lkKSBhbmQgdG91Y2ggaG9sZHMgKGZpcmVkIGFzIGBjb250ZXh0bWVudWAgZXZlbnRzKS5cblx0dGFwOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbkwuTWFwLlRhcCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cblx0XHR0aGlzLl9maXJlQ2xpY2sgPSB0cnVlO1xuXG5cdFx0Ly8gZG9uJ3Qgc2ltdWxhdGUgY2xpY2sgb3IgdHJhY2sgbG9uZ3ByZXNzIGlmIG1vcmUgdGhhbiAxIHRvdWNoXG5cdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdLFxuXHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuXHRcdFx0dmFyIGZpcnN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXSxcblx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0aWYgKGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlbW92ZScsIGZpcnN0KTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcblx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuXHRcdCAgICAgICAgZS5jbGllbnRYLCBlLmNsaWVudFksXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdGFwOiBIYW5kbGVyXG4vLyBNb2JpbGUgdG91Y2ggaGFja3MgKHF1aWNrIHRhcCBhbmQgdG91Y2ggaG9sZCkgaGFuZGxlci5cbmlmIChMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5wb2ludGVyKSB7XG5cdEwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIEwuTWFwLlRhcCk7XG59XG5cblxuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Cb3hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogTC5Eb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEwuQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBMLkRvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9maW5pc2goKTtcblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG5cdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBMLk1hcC5Cb3hab29tKTtcblxuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5MLk1hcC5LZXlib2FyZCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblxuXHRcdFx0aWYgKG1hcC5fcGFuQW5pbSAmJiBtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdG9mZnNldCA9IEwucG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblxuXHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcpIHtcblx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEwuTWFwLktleWJvYXJkKTtcblxuXG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG4gKi9cblxuTC5IYW5kbGVyLk1hcmtlckRyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5jbG9zZVBvcHVwKClcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKlxyXG4gKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICovXHJcblxyXG5MLkNvbnRyb2wgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcblx0XHRcdHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuXHRcdFx0Y29ybmVyc1t2U2lkZSArIGhTaWRlXSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sLlpvb20gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJysnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnKycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnLSdcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJy0nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHQgICAgLm9uKGxpbmssICdtb3VzZWRvd24gZGJsY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcylcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gbGluaztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IEwuQ29udHJvbC5ab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbkwuY29udHJvbC56b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5ab29tKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuQXR0cmlidXRpb24gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cDovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0aWYgKEwuRG9tRXZlbnQpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdGV4dCBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJ1ZlY3RvciBkYXRhICZjb3B5OyBNYXBib3gnYCkuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG5cdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcblx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIHwgJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIGF0dHJpYnV0aW9uQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5MLmNvbnRyb2wuYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLkF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5MLkNvbnRyb2wuU2NhbGUgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cblx0XHRtYXhXaWR0aDogMTAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG5cdFx0bWV0cmljOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cblx0XHRpbXBlcmlhbDogdHJ1ZVxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG5cdFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbkwuY29udHJvbC5zY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5Db250cm9sLlNjYWxlKG9wdGlvbnMpO1xufTtcblxuXG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gKiBAYWthIEwuQ29udHJvbC5MYXllcnNcclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGxheWVycyBjb250cm9sIGdpdmVzIHVzZXJzIHRoZSBhYmlsaXR5IHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBiYXNlIGxheWVycyBhbmQgc3dpdGNoIG92ZXJsYXlzIG9uL29mZiAoY2hlY2sgb3V0IHRoZSBbZGV0YWlsZWQgZXhhbXBsZV0oaHR0cDovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wuaHRtbCkpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbkwuQ29udHJvbC5MYXllcnMgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyIG9yIHRvdWNoLlxyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuXHRcdGF1dG9aSW5kZXg6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG5cdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihMLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX2Zvcm0uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fZm9ybS5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZvcm0gPSB0aGlzLl9mb3JtID0gTC5Eb21VdGlsLmNyZWF0ZSgnZm9ybScsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdGlmICghTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xyXG5cdFx0XHRcdFx0bW91c2VlbnRlcjogdGhpcy5leHBhbmQsXHJcblx0XHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gd29yayBhcm91bmQgZm9yIEZpcmVmb3ggQW5kcm9pZCBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDMzXHJcblx0XHRcdEwuRG9tRXZlbnQub24oZm9ybSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyksIDApO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHRcdFx0Ly8gVE9ETyBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1iYXNlJywgZm9ybSk7XHJcblx0XHR0aGlzLl9zZXBhcmF0b3IgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIGZvcm0pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIGZvcm0pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgTC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHRMLkRvbVV0aWwuZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihMLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnMnLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHRpbnB1dC5sYXllcklkID0gTC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2Zvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JyksXHJcblx0XHQgICAgaW5wdXQsIGxheWVyLCBoYXNMYXllcjtcclxuXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG5cdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRoYXNMYXllciA9IHRoaXMuX21hcC5oYXNMYXllcihsYXllcik7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCAmJiAhaGFzTGF5ZXIpIHtcclxuXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQgJiYgaGFzTGF5ZXIpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9mb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGxheWVyLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuY29sbGFwc2UoKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuTC5jb250cm9sLmxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLkxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8qXG4gKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAqXG4gKi9cblxuTC5Qb3NBbmltYXRpb24gPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc3RvcCgpXG5cdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG5cdFx0dGhpcy5fY29tcGxldGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5fYW5pbUlkID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdC8vIEBldmVudCBlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcblxuXG5cbi8qXG4gKiBFeHRlbmRzIEwuTWFwIHRvIGhhbmRsZSBwYW5uaW5nIGFuaW1hdGlvbnMuXG4gKi9cblxuTC5NYXAuaW5jbHVkZSh7XG5cblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoTC5sYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR0aGlzLl9zdG9wKCk7XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcblxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xuXHRcdFx0XHRvcHRpb25zLnBhbiA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xuXG5cdFx0XHRpZiAobW92ZWQpIHtcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XG5cdFx0b2Zmc2V0ID0gTC5wb2ludChvZmZzZXQpLnJvdW5kKCk7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuXHRcdH1cblx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcblxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xuXHR9LFxuXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0fSxcblxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZmxvb3IoKTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG5cblxuLypcbiAqIEV4dGVuZHMgTC5NYXAgdG8gaGFuZGxlIHpvb20gYW5pbWF0aW9ucy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXG5cdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cblx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcblx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxuXHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0XG59KTtcblxudmFyIHpvb21BbmltYXRlZCA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OICYmIEwuQnJvd3Nlci5hbnkzZCAmJiAhTC5Ccm93c2VyLm1vYmlsZU9wZXJhO1xuXG5pZiAoem9vbUFuaW1hdGVkKSB7XG5cblx0TC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xuXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcblxuXHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9wcm94eSwgTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG59XG5cbkwuTWFwLmluY2x1ZGUoIXpvb21BbmltYXRlZCA/IHt9IDoge1xuXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XG5cblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgcHJvcCA9IEwuRG9tVXRpbC5UUkFOU0ZPUk0sXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gcHJveHkuc3R5bGVbcHJvcF07XG5cblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0ocHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XG5cblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSBwcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcblx0XHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHByb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHR9XG5cdH0sXG5cblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XG5cdH0sXG5cblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSlcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcblx0XHRpZiAoc3RhcnRBbmltKSB7XG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcblxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XG5cdFx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcblxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xuXHRcdH1cblxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxuXHRcdC8vIEZpcmVkIG9uIGV2ZXJ5IGZyYW1lIG9mIGEgem9vbSBhbmltYXRpb25cblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHR6b29tOiB6b29tLFxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXG5cdFx0fSk7XG5cblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXG5cdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XG5cdH0sXG5cblx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XG5cblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XG5cblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSk7XG5cblx0XHQvLyBUaGlzIGFuaW0gZnJhbWUgc2hvdWxkIHByZXZlbnQgYW4gb2JzY3VyZSBpT1Mgd2Via2l0IHRpbGUgbG9hZGluZyByYWNlIGNvbmRpdGlvbi5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xuXHRcdH0sIHRoaXMpO1xuXHR9XG59KTtcblxuXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXG5MLk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cblx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8ICFMLkJyb3dzZXIuYW55M2QpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdG9wKCk7XG5cblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcblx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xuXG5cdFx0dGFyZ2V0Q2VudGVyID0gTC5sYXRMbmcodGFyZ2V0Q2VudGVyKTtcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcblxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXG5cdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXG5cdFx0ICAgIHJobyA9IDEuNDIsXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XG5cblx0XHRmdW5jdGlvbiByKGkpIHtcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXG5cdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXG5cdFx0XHQgICAgYiA9IHQxIC8gYjEsXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XG5cblx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcblxuXHRcdFx0cmV0dXJuIGxvZztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxuXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cblxuXHRcdHZhciByMCA9IHIoMCk7XG5cblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XG5cblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxuXG5cdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xuXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXG5cdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xuXG5cdFx0XHRpZiAodCA8PSAxKSB7XG5cdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XG5cblx0XHRcdFx0dGhpcy5fbW92ZShcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXG5cdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlKTtcblxuXHRcdGZyYW1lLmNhbGwodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXG5cdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xuXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcblx0fVxufSk7XG5cblxuXG4vKlxyXG4gKiBQcm92aWRlcyBMLk1hcCB3aXRoIGNvbnZlbmllbnQgc2hvcnRjdXRzIGZvciB1c2luZyBicm93c2VyIGdlb2xvY2F0aW9uIGZlYXR1cmVzLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0X2RlZmF1bHRMb2NhdGVPcHRpb25zOiB7XHJcblx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdHdhdGNoOiBmYWxzZVxyXG5cdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcblx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLl9kZWZhdWx0TG9jYXRlT3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBMLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IEwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMLkxhdExuZyhsYXQsIGxuZyksXHJcblx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcblx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcblx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbn0od2luZG93LCBkb2N1bWVudCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC1zcmMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICB7XG4gICAgICAgIFwicmF3XCI6IFwibWFwYm94LmpzXCIsXG4gICAgICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICAgICAgXCJlc2NhcGVkTmFtZVwiOiBcIm1hcGJveC5qc1wiLFxuICAgICAgICBcIm5hbWVcIjogXCJtYXBib3guanNcIixcbiAgICAgICAgXCJyYXdTcGVjXCI6IFwiXCIsXG4gICAgICAgIFwic3BlY1wiOiBcImxhdGVzdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0YWdcIlxuICAgICAgfSxcbiAgICAgIFwiL1VzZXJzL2thcmxnL0RvY3VtZW50cy9SZXBvcy90b3BvdGltZVwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwibWFwYm94LmpzQGxhdGVzdFwiLFxuICBcIl9pZFwiOiBcIm1hcGJveC5qc0AzLjAuMFwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL21hcGJveC5qc1wiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjQuNi4xXCIsXG4gIFwiX25wbU9wZXJhdGlvbmFsSW50ZXJuYWxcIjoge1xuICAgIFwiaG9zdFwiOiBcInBhY2thZ2VzLTEyLXdlc3QuaW50ZXJuYWwubnBtanMuY29tXCIsXG4gICAgXCJ0bXBcIjogXCJ0bXAvbWFwYm94LmpzLTMuMC4wLnRnel8xNDc3MDg2MDc2MTc4XzAuMzYyMzE5MDk0MTI4OTA2N1wiXG4gIH0sXG4gIFwiX25wbVVzZXJcIjoge1xuICAgIFwibmFtZVwiOiBcInRtY3dcIixcbiAgICBcImVtYWlsXCI6IFwidG9tQG1hY3dyaWdodC5vcmdcIlxuICB9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMi4xNS45XCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInJhd1wiOiBcIm1hcGJveC5qc1wiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcImVzY2FwZWROYW1lXCI6IFwibWFwYm94LmpzXCIsXG4gICAgXCJuYW1lXCI6IFwibWFwYm94LmpzXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiXCIsXG4gICAgXCJzcGVjXCI6IFwibGF0ZXN0XCIsXG4gICAgXCJ0eXBlXCI6IFwidGFnXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIjVVNFUlwiLFxuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvbWFwYm94LmpzLy0vbWFwYm94LmpzLTMuMC4wLnRnelwiLFxuICBcIl9zaGFzdW1cIjogXCI4Y2QzYjI1NmZlYjRkMjJhOTQ3ODM4ZTQwNjkzNjExNThkNWVkMmE4XCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcIm1hcGJveC5qc1wiLFxuICBcIl93aGVyZVwiOiBcIi9Vc2Vycy9rYXJsZy9Eb2N1bWVudHMvUmVwb3MvdG9wb3RpbWVcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIk1hcGJveFwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC5qcy9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJjb3JzbGl0ZVwiOiBcIjAuMC42XCIsXG4gICAgXCJpc2FycmF5XCI6IFwiMC4wLjFcIixcbiAgICBcImxlYWZsZXRcIjogXCIxLjAuMVwiLFxuICAgIFwibXVzdGFjaGVcIjogXCIyLjIuMVwiLFxuICAgIFwic2FuaXRpemUtY2FqYVwiOiBcIjAuMS40XCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIm1hcGJveCBqYXZhc2NyaXB0IGFwaVwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjEzLjAuMFwiLFxuICAgIFwiY2xlYW4tY3NzXCI6IFwifjIuMC43XCIsXG4gICAgXCJlc2xpbnRcIjogXCJeMC4yMy4wXCIsXG4gICAgXCJleHBlY3QuanNcIjogXCIwLjMuMVwiLFxuICAgIFwiaGFwcGVuXCI6IFwiMC4xLjNcIixcbiAgICBcImxlYWZsZXQtZnVsbHNjcmVlblwiOiBcIjAuMC40XCIsXG4gICAgXCJsZWFmbGV0LWhhc2hcIjogXCIwLjIuMVwiLFxuICAgIFwibWFya2VkXCI6IFwifjAuMy4wXCIsXG4gICAgXCJtaW5pZnlpZnlcIjogXCJeNi4xLjBcIixcbiAgICBcIm1pbmltaXN0XCI6IFwiMC4wLjVcIixcbiAgICBcIm1vY2hhXCI6IFwiMi40LjVcIixcbiAgICBcIm1vY2hhLXBoYW50b21qcy1jb3JlXCI6IFwiMi4wLjFcIixcbiAgICBcInBoYW50b21qcy1wcmVidWlsdFwiOiBcIjIuMS4xMlwiLFxuICAgIFwic2lub25cIjogXCIxLjEwLjJcIlxuICB9LFxuICBcImRpcmVjdG9yaWVzXCI6IHt9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiOGNkM2IyNTZmZWI0ZDIyYTk0NzgzOGU0MDY5MzYxMTU4ZDVlZDJhOFwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL21hcGJveC5qcy8tL21hcGJveC5qcy0zLjAuMC50Z3pcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIipcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCJkOWE1YWYwZjAzMTZmYTgwMzUwOGZiNTBlMTdlZTFmMzAxODk1YWZhXCIsXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwOi8vbWFwYm94LmNvbS9cIixcbiAgXCJsaWNlbnNlXCI6IFwiQlNELTMtQ2xhdXNlXCIsXG4gIFwibWFpblwiOiBcInNyYy9pbmRleC5qc1wiLFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCIxZWM1XCIsXG4gICAgICBcImVtYWlsXCI6IFwibXhuQDFlYzUub3JnXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImFhcm9ubGlkbWFuXCIsXG4gICAgICBcImVtYWlsXCI6IFwiYWFyb25saWRtYW5AZ21haWwuY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImFqYXNodG9uXCIsXG4gICAgICBcImVtYWlsXCI6IFwiYWouYXNodG9uQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJhbHVsc2hcIixcbiAgICAgIFwiZW1haWxcIjogXCJ1bHNoQG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiYW5zaXNcIixcbiAgICAgIFwiZW1haWxcIjogXCJhbnNpcy5icmFtbWFuaXNAZ21haWwuY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImFwZW5kbGV0b25cIixcbiAgICAgIFwiZW1haWxcIjogXCJhbmRyZXdAbWFwYm94LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJiZXJnd2Vya2dpc1wiLFxuICAgICAgXCJlbWFpbFwiOiBcIndiQGJlcmd3ZXJrLWdpcy5hdFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJiaG91c2VsXCIsXG4gICAgICBcImVtYWlsXCI6IFwiYnJ5YW5AbWFwYm94LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJic3VkZWt1bVwiLFxuICAgICAgXCJlbWFpbFwiOiBcImJvYmJ5QG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiY2FtaWxsZWFubmVcIixcbiAgICAgIFwiZW1haWxcIjogXCJjYW1pbGxlQG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiZG5vbWFkYlwiLFxuICAgICAgXCJlbWFpbFwiOiBcImRhbW9uQG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiZHRob21wc29uXCIsXG4gICAgICBcImVtYWlsXCI6IFwiZHRob21wc29uQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJlbWlseW1jYWZlZVwiLFxuICAgICAgXCJlbWFpbFwiOiBcImVtaWx5QG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiZmxpcHBtb2tlXCIsXG4gICAgICBcImVtYWlsXCI6IFwiZmxpcHBtb2tlQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJmcmVlbmVyZFwiLFxuICAgICAgXCJlbWFpbFwiOiBcInNwYW1AZnJlZW5lcmQuZGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiZ3JldGFjYlwiLFxuICAgICAgXCJlbWFpbFwiOiBcImNhcm9sQG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiaWFuMjlcIixcbiAgICAgIFwiZW1haWxcIjogXCJpYW4udmlsbGVkYUBnbWFpbC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiaWFuc2h3YXJkXCIsXG4gICAgICBcImVtYWlsXCI6IFwiaWFuQG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiaW5nYWxsc1wiLFxuICAgICAgXCJlbWFpbFwiOiBcIm5pY2hvbGFzLmluZ2FsbHNAZ21haWwuY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImpmaXJlYmF1Z2hcIixcbiAgICAgIFwiZW1haWxcIjogXCJqb2huLmZpcmViYXVnaEBnbWFpbC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwianJwcnVpdDFcIixcbiAgICAgIFwiZW1haWxcIjogXCJqYWtlQGpha2VwcnVpdHQuY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImthcmVuenNoZWFcIixcbiAgICAgIFwiZW1haWxcIjogXCJrYXJlbkBtYXBib3guY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImtlbHZpbmFicm9rd2FcIixcbiAgICAgIFwiZW1haWxcIjogXCJrZWx2aW5hYnJva3dhQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJra2FlZmVyXCIsXG4gICAgICBcImVtYWlsXCI6IFwia2thZWZlckBnbWFpbC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwibGJ1ZFwiLFxuICAgICAgXCJlbWFpbFwiOiBcImxhdXJlbkBtYXBib3guY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImx1Y2Fzd29qXCIsXG4gICAgICBcImVtYWlsXCI6IFwibHVjYXNAbHVjYXN3b2ouY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImx4YmFydGhcIixcbiAgICAgIFwiZW1haWxcIjogXCJhbGV4QG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwibHl6aWRpYW1vbmRcIixcbiAgICAgIFwiZW1haWxcIjogXCJseXppQG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwibWFwYm94LWFkbWluXCIsXG4gICAgICBcImVtYWlsXCI6IFwiYWNjb3VudHNAbWFwYm94LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJtYXRlb3ZcIixcbiAgICAgIFwiZW1haWxcIjogXCJtYXR0QG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwibWN3aGl0dGVtb3JlXCIsXG4gICAgICBcImVtYWlsXCI6IFwibWN3aGl0dGVtb3JlQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJtaWNjb2xpc1wiLFxuICAgICAgXCJlbWFpbFwiOiBcImplZmZAbWljY29saXMubmV0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIm1pa2Vtb3JyaXNcIixcbiAgICAgIFwiZW1haWxcIjogXCJtaWNoYWVsLnBhdHJpY2subW9ycmlzQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJtb3JnYW5oZXJsb2NrZXJcIixcbiAgICAgIFwiZW1haWxcIjogXCJtb3JnYW4uaGVybG9ja2VyQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJtb3VybmVyXCIsXG4gICAgICBcImVtYWlsXCI6IFwiYWdhZm9ua2luQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJtdGlyd2luXCIsXG4gICAgICBcImVtYWlsXCI6IFwiaXJ3aW5AbWFwYm94LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJuaWNraWRsdWdhc2hcIixcbiAgICAgIFwiZW1haWxcIjogXCJuaWNraUBtYXBib3guY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcInJjbGFya1wiLFxuICAgICAgXCJlbWFpbFwiOiBcInJ5YW4uY2xhcmsuakBnbWFpbC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwic2FtYW5iYlwiLFxuICAgICAgXCJlbWFpbFwiOiBcInNhbWFuQG1hcGJveC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwic2JtYTQ0XCIsXG4gICAgICBcImVtYWlsXCI6IFwidGxlZUBtYXBib3guY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcInNjb3RoaXNcIixcbiAgICAgIFwiZW1haWxcIjogXCJzY290aGlzQGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJzZ2lsbGllc1wiLFxuICAgICAgXCJlbWFpbFwiOiBcInNlYW5AbWFwYm94LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJzcHJpbmdtZXllclwiLFxuICAgICAgXCJlbWFpbFwiOiBcImRhbmVAbWFwYm94LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJ0aGVtYXJleFwiLFxuICAgICAgXCJlbWFpbFwiOiBcInBhdHJpY2tAbWFwYm94LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJ0bWN3XCIsXG4gICAgICBcImVtYWlsXCI6IFwidG9tQG1hY3dyaWdodC5vcmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwidHJpc3RlblwiLFxuICAgICAgXCJlbWFpbFwiOiBcInRyaXN0ZW4uYnJvd25AZ21haWwuY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIndpbGx3aGl0ZVwiLFxuICAgICAgXCJlbWFpbFwiOiBcIndpbGxAbWFwYm94LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJ5aGFoblwiLFxuICAgICAgXCJlbWFpbFwiOiBcInlvdW5nQG1hcGJveC5jb21cIlxuICAgIH1cbiAgXSxcbiAgXCJuYW1lXCI6IFwibWFwYm94LmpzXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LmpzLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZXNsaW50IC0tbm8tZXNsaW50cmMgLWMgLmVzbGludHJjIHNyYyAmJiBwaGFudG9tanMgbm9kZV9tb2R1bGVzL21vY2hhLXBoYW50b21qcy1jb3JlL21vY2hhLXBoYW50b21qcy1jb3JlLmpzIHRlc3QvaW5kZXguaHRtbFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjMuMC4wXCJcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSFRUUF9VUkw6ICdodHRwOi8vYS50aWxlcy5tYXBib3guY29tL3Y0JyxcbiAgICBIVFRQU19VUkw6ICdodHRwczovL2EudGlsZXMubWFwYm94LmNvbS92NCcsXG4gICAgRk9SQ0VfSFRUUFM6IGZhbHNlLFxuICAgIFJFUVVJUkVfQUNDRVNTX1RPS0VOOiB0cnVlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIGZvcm1hdF91cmwgPSByZXF1aXJlKCcuL2Zvcm1hdF91cmwnKSxcbiAgICByZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0JyksXG4gICAgbWFya2VyID0gcmVxdWlyZSgnLi9tYXJrZXInKSxcbiAgICBzaW1wbGVzdHlsZSA9IHJlcXVpcmUoJy4vc2ltcGxlc3R5bGUnKTtcblxuLy8gIyBmZWF0dXJlTGF5ZXJcbi8vXG4vLyBBIGxheWVyIG9mIGZlYXR1cmVzLCBsb2FkZWQgZnJvbSBNYXBib3ggb3IgZWxzZS4gQWRkcyB0aGUgYWJpbGl0eVxuLy8gdG8gcmVzZXQgZmVhdHVyZXMsIGZpbHRlciB0aGVtLCBhbmQgbG9hZCB0aGVtIGZyb20gYSBHZW9KU09OIFVSTC5cbnZhciBGZWF0dXJlTGF5ZXIgPSBMLkZlYXR1cmVHcm91cC5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgIHNhbml0aXplcjogcmVxdWlyZSgnc2FuaXRpemUtY2FqYScpLFxuICAgICAgICBzdHlsZTogc2ltcGxlc3R5bGUuc3R5bGUsXG4gICAgICAgIHBvcHVwT3B0aW9uczogeyBjbG9zZUJ1dHRvbjogZmFsc2UgfVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihfLCBvcHRpb25zKSB7XG4gICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIF8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1dGlsLmlkVXJsKF8sIHRoaXMpO1xuICAgICAgICAvLyBqYXZhc2NyaXB0IG9iamVjdCBvZiBUaWxlSlNPTiBkYXRhXG4gICAgICAgIH0gZWxzZSBpZiAoXyAmJiB0eXBlb2YgXyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0R2VvSlNPTihfKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRHZW9KU09OOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIHRoaXMuX2dlb2pzb24gPSBfO1xuICAgICAgICB0aGlzLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemUoXyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRHZW9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlb2pzb247XG4gICAgfSxcblxuICAgIGxvYWRVUkw6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdCAmJiAnYWJvcnQnIGluIHRoaXMuX3JlcXVlc3QpIHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3QodXJsLCBMLmJpbmQoZnVuY3Rpb24oZXJyLCBqc29uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLnR5cGUgIT09ICdhYm9ydCcpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmxvZygnY291bGQgbm90IGxvYWQgZmVhdHVyZXMgYXQgJyArIHVybCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGpzb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEdlb0pTT04oanNvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdyZWFkeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBsb2FkSUQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRVUkwoZm9ybWF0X3VybCgnL3Y0LycgKyBpZCArICcvZmVhdHVyZXMuanNvbicsIHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbikpO1xuICAgIH0sXG5cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IF87XG4gICAgICAgIGlmICh0aGlzLl9nZW9qc29uKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKHRoaXMuX2dlb2pzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICB9LFxuXG4gICAgX2luaXRpYWxpemU6IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gTC5VdGlsLmlzQXJyYXkoanNvbikgPyBqc29uIDoganNvbi5mZWF0dXJlcyxcbiAgICAgICAgICAgIGksIGxlbjtcblxuICAgICAgICBpZiAoZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzW2ldLmdlb21ldHJpZXMgfHwgZmVhdHVyZXNbaV0uZ2VvbWV0cnkgfHwgZmVhdHVyZXNbaV0uZmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShmZWF0dXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5maWx0ZXIoanNvbikpIHtcblxuICAgICAgICAgICAgdmFyIG9wdHMgPSB7YWNjZXNzVG9rZW46IHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbn0sXG4gICAgICAgICAgICAgICAgcG9pbnRUb0xheWVyID0gdGhpcy5vcHRpb25zLnBvaW50VG9MYXllciB8fCBmdW5jdGlvbihmZWF0dXJlLCBsYXRsb24pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXIuc3R5bGUoZmVhdHVyZSwgbGF0bG9uLCBvcHRzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyID0gTC5HZW9KU09OLmdlb21ldHJ5VG9MYXllcihqc29uLCB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50VG9MYXllcjogcG9pbnRUb0xheWVyXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcG9wdXBIdG1sID0gbWFya2VyLmNyZWF0ZVBvcHVwKGpzb24sIHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIpLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gdGhpcy5vcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRTdHlsZSA9IHN0eWxlID09PSBzaW1wbGVzdHlsZS5zdHlsZTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlICYmICdzZXRTdHlsZScgaW4gbGF5ZXIgJiZcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3R5bGUgbWV0aG9kIGlzIHRoZSBzaW1wbGVzdHlsZSBkZWZhdWx0LCB0aGVuXG4gICAgICAgICAgICAgICAgLy8gbmV2ZXIgc3R5bGUgTC5DaXJjbGUgb3IgTC5DaXJjbGVNYXJrZXIgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHNpbXBsZXN0eWxlIGhhcyBubyBydWxlcyBvdmVyIHRoZW0sIG9ubHkgb3ZlciBnZW9tZXRyeVxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgZGlyZWN0bHkgZnJvbSBHZW9KU09OXG4gICAgICAgICAgICAgICAgKCEoZGVmYXVsdFN0eWxlICYmIChsYXllciBpbnN0YW5jZW9mIEwuQ2lyY2xlIHx8XG4gICAgICAgICAgICAgICAgICBsYXllciBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyKSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlKGpzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXllci5zZXRTdHlsZShzdHlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxheWVyLmZlYXR1cmUgPSBqc29uO1xuXG4gICAgICAgICAgICBpZiAocG9wdXBIdG1sKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuYmluZFBvcHVwKHBvcHVwSHRtbCwgdGhpcy5vcHRpb25zLnBvcHVwT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzLkZlYXR1cmVMYXllciA9IEZlYXR1cmVMYXllcjtcblxubW9kdWxlLmV4cG9ydHMuZmVhdHVyZUxheWVyID0gZnVuY3Rpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmVhdHVyZUxheWVyKF8sIG9wdGlvbnMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlZWRiYWNrID0gTC5DbGFzcy5leHRlbmQoe1xuICAgIGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcbiAgICBkYXRhOiB7fSxcbiAgICByZWNvcmQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgTC5leHRlbmQodGhpcy5kYXRhLCBkYXRhKTtcbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRmVlZGJhY2soKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyksXG4gICAgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0aCwgYWNjZXNzVG9rZW4pIHtcbiAgICBhY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIHx8IEwubWFwYm94LmFjY2Vzc1Rva2VuO1xuXG4gICAgaWYgKCFhY2Nlc3NUb2tlbiAmJiBjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBBUEkgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkIHRvIHVzZSBNYXBib3guanMuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC5qcy9hcGkvdicgKyB2ZXJzaW9uICsgJy9hcGktYWNjZXNzLXRva2Vucy8nKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsID0gKGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCBjb25maWcuRk9SQ0VfSFRUUFMpID8gY29uZmlnLkhUVFBTX1VSTCA6IGNvbmZpZy5IVFRQX1VSTDtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwvdjQkLywgJycpO1xuICAgIHVybCArPSBwYXRoO1xuXG4gICAgaWYgKGNvbmZpZy5SRVFVSVJFX0FDQ0VTU19UT0tFTikge1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW5bMF0gPT09ICdzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgYSBwdWJsaWMgYWNjZXNzIHRva2VuIChway4qKSB3aXRoIE1hcGJveC5qcywgbm90IGEgc2VjcmV0IGFjY2VzcyB0b2tlbiAoc2suKikuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3guanMvYXBpL3YnICsgdmVyc2lvbiArICcvYXBpLWFjY2Vzcy10b2tlbnMvJyk7XG4gICAgICAgIH1cblxuICAgICAgICB1cmwgKz0gdXJsLmluZGV4T2YoJz8nKSAhPT0gLTEgPyAnJmFjY2Vzc190b2tlbj0nIDogJz9hY2Nlc3NfdG9rZW49JztcbiAgICAgICAgdXJsICs9IGFjY2Vzc1Rva2VuO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy50aWxlSlNPTiA9IGZ1bmN0aW9uKHVybE9yTWFwSUQsIGFjY2Vzc1Rva2VuKSB7XG5cbiAgICBpZiAodXJsT3JNYXBJRC5pbmRleE9mKCdtYXBib3g6Ly9zdHlsZXMnKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0eWxlcyBjcmVhdGVkIHdpdGggTWFwYm94IFN0dWRpbyBuZWVkIHRvIGJlIHVzZWQgd2l0aCAnICtcbiAgICAgICAgICAgICdMLm1hcGJveC5zdHlsZUxheWVyLCBub3QgTC5tYXBib3gudGlsZUxheWVyJyk7XG4gICAgfVxuXG4gICAgaWYgKHVybE9yTWFwSUQuaW5kZXhPZignLycpICE9PSAtMSlcbiAgICAgICAgcmV0dXJuIHVybE9yTWFwSUQ7XG5cbiAgICB2YXIgdXJsID0gbW9kdWxlLmV4cG9ydHMoJy92NC8nICsgdXJsT3JNYXBJRCArICcuanNvbicsIGFjY2Vzc1Rva2VuKTtcblxuICAgIC8vIFRpbGVKU09OIHJlcXVlc3RzIG5lZWQgYSBzZWN1cmUgZmxhZyBhcHBlbmRlZCB0byB0aGVpciBVUkxzIHNvXG4gICAgLy8gdGhhdCB0aGUgc2VydmVyIGtub3dzIHRvIHNlbmQgU1NMLWlmaWVkIHJlc291cmNlIHJlZmVyZW5jZXMuXG4gICAgaWYgKHVybC5pbmRleE9mKCdodHRwcycpID09PSAwKVxuICAgICAgICB1cmwgKz0gJyZzZWN1cmUnO1xuXG4gICAgcmV0dXJuIHVybDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuc3R5bGUgPSBmdW5jdGlvbihzdHlsZVVSTCwgYWNjZXNzVG9rZW4pIHtcbiAgICBpZiAoc3R5bGVVUkwuaW5kZXhPZignbWFwYm94Oi8vc3R5bGVzLycpID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3RseSBmb3JtYXR0ZWQgTWFwYm94IHN0eWxlIGF0ICcgKyBzdHlsZVVSTCk7XG5cbiAgICB2YXIgb3duZXJJRFN0eWxlID0gc3R5bGVVUkwuc3BsaXQoJ21hcGJveDovL3N0eWxlcy8nKVsxXTtcbiAgICB2YXIgdXJsID0gbW9kdWxlLmV4cG9ydHMoJy9zdHlsZXMvdjEvJyArIG93bmVySURTdHlsZSwgYWNjZXNzVG9rZW4pXG4gICAgICAgIC5yZXBsYWNlKCdodHRwOi8vJywgJ2h0dHBzOi8vJyk7XG5cbiAgICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIGZvcm1hdF91cmwgPSByZXF1aXJlKCcuL2Zvcm1hdF91cmwnKSxcbiAgICBmZWVkYmFjayA9IHJlcXVpcmUoJy4vZmVlZGJhY2snKSxcbiAgICByZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0Jyk7XG5cbi8vIExvdy1sZXZlbCBnZW9jb2RpbmcgaW50ZXJmYWNlIC0gd3JhcHMgc3BlY2lmaWMgQVBJIGNhbGxzIGFuZCB0aGVpclxuLy8gcmV0dXJuIHZhbHVlcy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGdlb2NvZGVyID0ge307XG5cbiAgICB1dGlsLnN0cmljdCh1cmwsICdzdHJpbmcnKTtcblxuICAgIGlmICh1cmwuaW5kZXhPZignLycpID09PSAtMSkge1xuICAgICAgICB1cmwgPSBmb3JtYXRfdXJsKCcvZ2VvY29kaW5nL3Y1LycgKyB1cmwgKyAnL3txdWVyeX0uanNvbicsIG9wdGlvbnMuYWNjZXNzVG9rZW4sIDUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJvdW5kVG8obGF0TG5nLCBwcmVjaXNpb24pIHtcbiAgICAgICAgdmFyIG11bHQgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgbGF0TG5nLmxhdCA9IE1hdGgucm91bmQobGF0TG5nLmxhdCAqIG11bHQpIC8gbXVsdDtcbiAgICAgICAgbGF0TG5nLmxuZyA9IE1hdGgucm91bmQobGF0TG5nLmxuZyAqIG11bHQpIC8gbXVsdDtcbiAgICAgICAgcmV0dXJuIGxhdExuZztcbiAgICB9XG5cbiAgICBnZW9jb2Rlci5nZXRVUkwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuXG4gICAgZ2VvY29kZXIucXVlcnlVUkwgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIHZhciBpc09iamVjdCA9ICEoaXNBcnJheShfKSB8fCB0eXBlb2YgXyA9PT0gJ3N0cmluZycpLFxuICAgICAgICAgICAgcXVlcnkgPSBpc09iamVjdCA/IF8ucXVlcnkgOiBfO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHF1ZXJ5KSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbaV0gPSBlbmNvZGVVUklDb21wb25lbnQocXVlcnlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnkgPSBwYXJ0cy5qb2luKCc7Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeSA9IGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBmZWVkYmFjay5yZWNvcmQoeyBnZW9jb2Rpbmc6IHF1ZXJ5IH0pO1xuXG4gICAgICAgIHZhciB1cmwgPSBMLlV0aWwudGVtcGxhdGUoZ2VvY29kZXIuZ2V0VVJMKCksIHtxdWVyeTogcXVlcnl9KTtcblxuICAgICAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChfLnR5cGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoXy50eXBlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICcmdHlwZXM9JyArIF8udHlwZXMuam9pbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAnJnR5cGVzPScgKyBfLnR5cGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF8uY291bnRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KF8uY291bnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICcmY291bnRyeT0nICsgXy5jb3VudHJ5LmpvaW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gJyZjb3VudHJ5PScgKyBfLmNvdW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5wcm94aW1pdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJveGltaXR5ID0gcm91bmRUbyhMLmxhdExuZyhfLnByb3hpbWl0eSksIDMpO1xuICAgICAgICAgICAgICAgIHVybCArPSAnJnByb3hpbWl0eT0nICsgcHJveGltaXR5LmxuZyArICcsJyArIHByb3hpbWl0eS5sYXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgXy5hdXRvY29tcGxldGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHVybCArPSAnJmF1dG9jb21wbGV0ZT0nICsgXy5hdXRvY29tcGxldGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cbiAgICBnZW9jb2Rlci5xdWVyeSA9IGZ1bmN0aW9uKF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHV0aWwuc3RyaWN0KGNhbGxiYWNrLCAnZnVuY3Rpb24nKTtcblxuICAgICAgICByZXF1ZXN0KGdlb2NvZGVyLnF1ZXJ5VVJMKF8pLCBmdW5jdGlvbihlcnIsIGpzb24pIHtcbiAgICAgICAgICAgIGlmIChqc29uICYmIChqc29uLmxlbmd0aCB8fCBqc29uLmZlYXR1cmVzKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IGpzb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChqc29uLmZlYXR1cmVzICYmIGpzb24uZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5sYXRsbmcgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmZlYXR1cmVzWzBdLmNlbnRlclsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uZmVhdHVyZXNbMF0uY2VudGVyWzBdXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5mZWF0dXJlc1swXS5iYm94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuYm91bmRzID0ganNvbi5mZWF0dXJlc1swXS5iYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmxib3VuZHMgPSB1dGlsLmxib3VuZHMocmVzLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSBjYWxsYmFjayhlcnIgfHwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBnZW9jb2RlcjtcbiAgICB9O1xuXG4gICAgLy8gYSByZXZlcnNlIGdlb2NvZGU6XG4gICAgLy9cbiAgICAvLyAgZ2VvY29kZXIucmV2ZXJzZVF1ZXJ5KFs4MCwgMjBdKVxuICAgIGdlb2NvZGVyLnJldmVyc2VRdWVyeSA9IGZ1bmN0aW9uKF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBxID0gJyc7XG5cbiAgICAgICAgLy8gc29ydCB0aHJvdWdoIGRpZmZlcmVudCB3YXlzIHBlb3BsZSByZXByZXNlbnQgbGF0IGFuZCBsb24gcGFpcnNcbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKHgpIHtcbiAgICAgICAgICAgIHZhciBsYXRMbmc7XG4gICAgICAgICAgICBpZiAoeC5sYXQgIT09IHVuZGVmaW5lZCAmJiB4LmxuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGF0TG5nID0gTC5sYXRMbmcoeC5sYXQsIHgubG5nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeC5sYXQgIT09IHVuZGVmaW5lZCAmJiB4LmxvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGF0TG5nID0gTC5sYXRMbmcoeC5sYXQsIHgubG9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGF0TG5nID0gTC5sYXRMbmcoeFsxXSwgeFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXRMbmcgPSByb3VuZFRvKGxhdExuZywgNSk7XG4gICAgICAgICAgICByZXR1cm4gbGF0TG5nLmxuZyArICcsJyArIGxhdExuZy5sYXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5sZW5ndGggJiYgX1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwdHMgPSBbXTsgaSA8IF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwdHMucHVzaChub3JtYWxpemUoX1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcSA9IHB0cy5qb2luKCc7Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxID0gbm9ybWFsaXplKF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdChnZW9jb2Rlci5xdWVyeVVSTChxKSwgZnVuY3Rpb24oZXJyLCBqc29uKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIGpzb24pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZ2VvY29kZXI7XG4gICAgfTtcblxuICAgIHJldHVybiBnZW9jb2Rlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZW9jb2RlciA9IHJlcXVpcmUoJy4vZ2VvY29kZXInKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBHZW9jb2RlckNvbnRyb2wgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcbiAgICBpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHByb3hpbWl0eTogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICd0b3BsZWZ0JyxcbiAgICAgICAgcG9pbnRab29tOiAxNixcbiAgICAgICAga2VlcE9wZW46IGZhbHNlLFxuICAgICAgICBhdXRvY29tcGxldGU6IGZhbHNlLFxuICAgICAgICBxdWVyeU9wdGlvbnM6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0VVJMKF8pO1xuICAgICAgICB0aGlzLl91cGRhdGVTdWJtaXQgPSBMLmJpbmQodGhpcy5fdXBkYXRlU3VibWl0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQXV0b2NvbXBsZXRlID0gTC5iaW5kKHRoaXMuX3VwZGF0ZUF1dG9jb21wbGV0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2Nob29zZVJlc3VsdCA9IEwuYmluZCh0aGlzLl9jaG9vc2VSZXN1bHQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBzZXRVUkw6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgdGhpcy5nZW9jb2RlciA9IGdlb2NvZGVyKF8sIHtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRVUkw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9jb2Rlci5nZXRVUkwoKTtcbiAgICB9LFxuXG4gICAgc2V0SUQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VVJMKF8pO1xuICAgIH0sXG5cbiAgICBzZXRUaWxlSlNPTjogZnVuY3Rpb24oXykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRVUkwoXy5nZW9jb2Rlcik7XG4gICAgfSxcblxuICAgIF90b2dnbGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUpIEwuRG9tRXZlbnQuc3RvcChlKTtcbiAgICAgICAgaWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9jb250YWluZXIsICdhY3RpdmUnKSkge1xuICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cy5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LmJsdXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xvc2VJZk9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2FjdGl2ZScpICYmXG4gICAgICAgICAgICAhdGhpcy5vcHRpb25zLmtlZXBPcGVuKSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRzLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5faW5wdXQuYmx1cigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1tYXBib3gtZ2VvY29kZXIgbGVhZmxldC1iYXIgbGVhZmxldC1jb250cm9sJyksXG4gICAgICAgICAgICBsaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsICdsZWFmbGV0LWNvbnRyb2wtbWFwYm94LWdlb2NvZGVyLXRvZ2dsZSBtYXBib3gtaWNvbiBtYXBib3gtaWNvbi1nZW9jb2RlcicsIGNvbnRhaW5lciksXG4gICAgICAgICAgICByZXN1bHRzID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1tYXBib3gtZ2VvY29kZXItcmVzdWx0cycsIGNvbnRhaW5lciksXG4gICAgICAgICAgICB3cmFwID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1tYXBib3gtZ2VvY29kZXItd3JhcCcsIGNvbnRhaW5lciksXG4gICAgICAgICAgICBmb3JtID0gTC5Eb21VdGlsLmNyZWF0ZSgnZm9ybScsICdsZWFmbGV0LWNvbnRyb2wtbWFwYm94LWdlb2NvZGVyLWZvcm0nLCB3cmFwKSxcbiAgICAgICAgICAgIGlucHV0ID0gTC5Eb21VdGlsLmNyZWF0ZSgnaW5wdXQnLCAnJywgZm9ybSk7XG5cbiAgICAgICAgbGluay5ocmVmID0gJyMnO1xuICAgICAgICBsaW5rLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuXG4gICAgICAgIGlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCAnU2VhcmNoJyk7XG5cbiAgICAgICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihmb3JtLCAnc3VibWl0JywgdGhpcy5fZ2VvY29kZSwgdGhpcyk7XG4gICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoaW5wdXQsICdrZXl1cCcsIHRoaXMuX2F1dG9jb21wbGV0ZSwgdGhpcyk7XG4gICAgICAgIEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX3Jlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9mb3JtID0gZm9ybTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBPcGVuKSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnYWN0aXZlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fY2xvc2VJZk9wZW4sIHRoaXMpO1xuICAgICAgICAgICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihsaW5rLCAnY2xpY2snLCB0aGlzLl90b2dnbGUsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVN1Ym1pdDogZnVuY3Rpb24oZXJyLCByZXNwKSB7XG4gICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdzZWFyY2hpbmcnKTtcbiAgICAgICAgdGhpcy5fcmVzdWx0cy5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgaWYgKGVyciB8fCAhcmVzcCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChyZXNwLnJlc3VsdHMgJiYgcmVzcC5yZXN1bHRzLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZXMgPSByZXNwLnJlc3VsdHMuZmVhdHVyZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdhdXRvc2VsZWN0JywgeyBmZWF0dXJlOiBmZWF0dXJlc1swXSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2ZvdW5kJywge3Jlc3VsdHM6IHJlc3AucmVzdWx0c30pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nob29zZVJlc3VsdChmZWF0dXJlc1swXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VJZk9wZW4oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmVhdHVyZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnZm91bmQnLCB7cmVzdWx0czogcmVzcC5yZXN1bHRzfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheVJlc3VsdHMoZmVhdHVyZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ25vdGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheVJlc3VsdHMoZmVhdHVyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVBdXRvY29tcGxldGU6IGZ1bmN0aW9uKGVyciwgcmVzcCkge1xuICAgICAgICB0aGlzLl9yZXN1bHRzLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBpZiAoZXJyIHx8ICFyZXNwKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHJlc3AucmVzdWx0cyAmJiByZXNwLnJlc3VsdHMuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHJlc3AucmVzdWx0cy5mZWF0dXJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2ZvdW5kJywge3Jlc3VsdHM6IHJlc3AucmVzdWx0c30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ25vdGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5UmVzdWx0cyhmZWF0dXJlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Rpc3BsYXlSZXN1bHRzOiBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGZlYXR1cmVzLmxlbmd0aCwgNSk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV07XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGZlYXR1cmUucGxhY2VfbmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZS5sZW5ndGgpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCAnJywgdGhpcy5fcmVzdWx0cyk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICgnaW5uZXJUZXh0JyBpbiByKSA/ICdpbm5lclRleHQnIDogJ3RleHRDb250ZW50JztcbiAgICAgICAgICAgIHJbdGV4dF0gPSBuYW1lO1xuICAgICAgICAgICAgci5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgbmFtZSk7XG4gICAgICAgICAgICByLmhyZWYgPSAnIyc7XG5cbiAgICAgICAgICAgIChMLmJpbmQoZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIociwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaG9vc2VSZXN1bHQoZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQuc3RvcChlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdzZWxlY3QnLCB7IGZlYXR1cmU6IGZlYXR1cmUgfSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKSkoZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlYXR1cmVzLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgIHZhciBvdXRvZiA9IEwuRG9tVXRpbC5jcmVhdGUoJ3NwYW4nLCAnJywgdGhpcy5fcmVzdWx0cyk7XG4gICAgICAgICAgICBvdXRvZi5pbm5lckhUTUwgPSAnVG9wIDUgb2YgJyArIGZlYXR1cmVzLmxlbmd0aCArICcgIHJlc3VsdHMnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jaG9vc2VSZXN1bHQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LmJib3gpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5maXRCb3VuZHModXRpbC5sYm91bmRzKHJlc3VsdC5iYm94KSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNlbnRlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnNldFZpZXcoW3Jlc3VsdC5jZW50ZXJbMV0sIHJlc3VsdC5jZW50ZXJbMF1dLCAodGhpcy5fbWFwLmdldFpvb20oKSA9PT0gdW5kZWZpbmVkKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBvaW50Wm9vbSA6XG4gICAgICAgICAgICAgICAgTWF0aC5tYXgodGhpcy5fbWFwLmdldFpvb20oKSwgdGhpcy5vcHRpb25zLnBvaW50Wm9vbSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZW9jb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC52YWx1ZSA9PT0gJycpIHJldHVybiB0aGlzLl91cGRhdGVTdWJtaXQoKTtcbiAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ3NlYXJjaGluZycpO1xuICAgICAgICB0aGlzLmdlb2NvZGVyLnF1ZXJ5KEwuVXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgcXVlcnk6IHRoaXMuX2lucHV0LnZhbHVlLFxuICAgICAgICAgICAgcHJveGltaXR5OiB0aGlzLm9wdGlvbnMucHJveGltaXR5ID8gdGhpcy5fbWFwLmdldENlbnRlcigpIDogZmFsc2VcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLnF1ZXJ5T3B0aW9ucyksIHRoaXMuX3VwZGF0ZVN1Ym1pdCk7XG4gICAgfSxcblxuICAgIF9hdXRvY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hdXRvY29tcGxldGUpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnZhbHVlID09PSAnJykgcmV0dXJuIHRoaXMuX3VwZGF0ZUF1dG9jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmdlb2NvZGVyLnF1ZXJ5KEwuVXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgcXVlcnk6IHRoaXMuX2lucHV0LnZhbHVlLFxuICAgICAgICAgICAgcHJveGltaXR5OiB0aGlzLm9wdGlvbnMucHJveGltaXR5ID8gdGhpcy5fbWFwLmdldENlbnRlcigpIDogZmFsc2VcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLnF1ZXJ5T3B0aW9ucyksIHRoaXMuX3VwZGF0ZUF1dG9jb21wbGV0ZSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzLkdlb2NvZGVyQ29udHJvbCA9IEdlb2NvZGVyQ29udHJvbDtcblxubW9kdWxlLmV4cG9ydHMuZ2VvY29kZXJDb250cm9sID0gZnVuY3Rpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgR2VvY29kZXJDb250cm9sKF8sIG9wdGlvbnMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gdXRmRGVjb2RlKGMpIHtcbiAgICBpZiAoYyA+PSA5MykgYy0tO1xuICAgIGlmIChjID49IDM1KSBjLS07XG4gICAgcmV0dXJuIGMgLSAzMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG4gICAgICAgIHZhciBpZHggPSB1dGZEZWNvZGUoZGF0YS5ncmlkW3ldLmNoYXJDb2RlQXQoeCkpLFxuICAgICAgICAgICAga2V5ID0gZGF0YS5rZXlzW2lkeF07XG4gICAgICAgIHJldHVybiBkYXRhLmRhdGFba2V5XTtcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBNdXN0YWNoZSA9IHJlcXVpcmUoJ211c3RhY2hlJyk7XG5cbnZhciBHcmlkQ29udHJvbCA9IEwuQ29udHJvbC5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwaW5uYWJsZTogdHJ1ZSxcbiAgICAgICAgZm9sbG93OiBmYWxzZSxcbiAgICAgICAgc2FuaXRpemVyOiByZXF1aXJlKCdzYW5pdGl6ZS1jYWphJyksXG4gICAgICAgIHRvdWNoVGVhc2VyOiB0cnVlLFxuICAgICAgICBsb2NhdGlvbjogdHJ1ZVxuICAgIH0sXG5cbiAgICBfY3VycmVudENvbnRlbnQ6ICcnLFxuXG4gICAgLy8gcGlubmVkIG1lYW5zIHRoYXQgdGhpcyBjb250cm9sIGlzIG9uIGEgZmVhdHVyZSBhbmQgdGhlIHVzZXIgaGFzIGxpa2VseVxuICAgIC8vIGNsaWNrZWQuIHBpbm5lZCB3aWxsIG5vdCBiZWNvbWUgZmFsc2UgdW5sZXNzIHRoZSB1c2VyIGNsaWNrcyBvZmZcbiAgICAvLyBvZiB0aGUgZmVhdHVyZSBvbnRvIGFub3RoZXIgb3IgY2xpY2tzIHhcbiAgICBfcGlubmVkOiBmYWxzZSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHV0aWwuc3RyaWN0X2luc3RhbmNlKF8sIEwuQ2xhc3MsICdMLm1hcGJveC5ncmlkTGF5ZXInKTtcbiAgICAgICAgdGhpcy5fbGF5ZXIgPSBfO1xuICAgIH0sXG5cbiAgICBzZXRUZW1wbGF0ZTogZnVuY3Rpb24odGVtcGxhdGUpIHtcbiAgICAgICAgdXRpbC5zdHJpY3QodGVtcGxhdGUsICdzdHJpbmcnKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdGVtcGxhdGU6IGZ1bmN0aW9uKGZvcm1hdCwgZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlIHx8IHRoaXMuX2xheWVyLmdldFRpbGVKU09OKCkudGVtcGxhdGU7XG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGQgPSB7fTtcbiAgICAgICAgICAgIGRbJ19fJyArIGZvcm1hdCArICdfXyddID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKFxuICAgICAgICAgICAgICAgIE11c3RhY2hlLnRvX2h0bWwodGVtcGxhdGUsIEwuZXh0ZW5kKGQsIGRhdGEpKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gY2hhbmdlIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIEhUTUwgaWYgaXQgaGFzIGNoYW5nZWQsIG90aGVyd2lzZVxuICAgIC8vIG5vb3BcbiAgICBfc2hvdzogZnVuY3Rpb24oY29udGVudCwgbykge1xuICAgICAgICBpZiAoY29udGVudCA9PT0gdGhpcy5fY3VycmVudENvbnRlbnQpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9jdXJyZW50Q29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb2xsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudClcbiAgICAgICAgICAgICAgICAuc2V0TGF0TG5nKG8ubGF0TG5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXAuX3BvcHVwICE9PSB0aGlzLl9wb3B1cCkgdGhpcy5fcG9wdXAub3Blbk9uKHRoaXMuX21hcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50V3JhcHBlci5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9waW5uZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudENvbnRlbnQgPSAnJztcblxuICAgICAgICB0aGlzLl9tYXAuY2xvc2VQb3B1cCgpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5fY29udGVudFdyYXBwZXIuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2Nsb3NhYmxlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9tb3VzZW92ZXI6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKG8uZGF0YSkge1xuICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbWFwLWNsaWNrYWJsZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbWFwLWNsaWNrYWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Bpbm5lZCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fdGVtcGxhdGUoJ3RlYXNlcicsIG8uZGF0YSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93KGNvbnRlbnQsIG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX21vdXNlbW92ZTogZnVuY3Rpb24obykge1xuICAgICAgICBpZiAodGhpcy5fcGlubmVkKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZvbGxvdykgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX3BvcHVwLnNldExhdExuZyhvLmxhdExuZyk7XG4gICAgfSxcblxuICAgIF9uYXZpZ2F0ZVRvOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgd2luZG93LnRvcC5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgIH0sXG5cbiAgICBfY2xpY2s6IGZ1bmN0aW9uKG8pIHtcblxuICAgICAgICB2YXIgbG9jYXRpb25fZm9ybWF0dGVkID0gdGhpcy5fdGVtcGxhdGUoJ2xvY2F0aW9uJywgby5kYXRhKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbiAmJiBsb2NhdGlvbl9mb3JtYXR0ZWQgJiZcbiAgICAgICAgICAgIGxvY2F0aW9uX2Zvcm1hdHRlZC5zZWFyY2goL15odHRwcz86LykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXZpZ2F0ZVRvKHRoaXMuX3RlbXBsYXRlKCdsb2NhdGlvbicsIG8uZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGlubmFibGUpIHJldHVybjtcblxuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX3RlbXBsYXRlKCdmdWxsJywgby5kYXRhKTtcblxuICAgICAgICBpZiAoIWNvbnRlbnQgJiYgdGhpcy5vcHRpb25zLnRvdWNoVGVhc2VyICYmIEwuQnJvd3Nlci50b3VjaCkge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMuX3RlbXBsYXRlKCd0ZWFzZXInLCBvLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdjbG9zYWJsZScpO1xuICAgICAgICAgICAgdGhpcy5fcGlubmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3coY29udGVudCwgbyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcGlubmVkKSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnY2xvc2FibGUnKTtcbiAgICAgICAgICAgIHRoaXMuX3Bpbm5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uUG9wdXBDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGlubmVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9jcmVhdGVDbG9zZWJ1dHRvbjogZnVuY3Rpb24oY29udGFpbmVyLCBmbikge1xuICAgICAgICB2YXIgbGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCAnY2xvc2UnLCBjb250YWluZXIpO1xuXG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gJ2Nsb3NlJztcbiAgICAgICAgbGluay5ocmVmID0gJyMnO1xuICAgICAgICBsaW5rLnRpdGxlID0gJ2Nsb3NlJztcblxuICAgICAgICBMLkRvbUV2ZW50XG4gICAgICAgICAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAub24obGluaywgJ21vdXNlZG93bicsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgLm9uKGxpbmssICdkYmxjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICAub24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcblxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1ncmlkIG1hcC10b29sdGlwJyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG4gICAgICAgICAgICBjb250ZW50V3JhcHBlciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdtYXAtdG9vbHRpcC1jb250ZW50Jyk7XG5cbiAgICAgICAgLy8gaGlkZSB0aGUgY29udGFpbmVyIGVsZW1lbnQgaW5pdGlhbGx5XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9jcmVhdGVDbG9zZWJ1dHRvbihjb250YWluZXIsIHRoaXMuaGlkZSk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250ZW50V3JhcHBlcik7XG5cbiAgICAgICAgdGhpcy5fY29udGVudFdyYXBwZXIgPSBjb250ZW50V3JhcHBlcjtcbiAgICAgICAgdGhpcy5fcG9wdXAgPSBuZXcgTC5Qb3B1cCh7IGF1dG9QYW46IGZhbHNlLCBjbG9zZU9uQ2xpY2s6IGZhbHNlIH0pO1xuXG4gICAgICAgIG1hcC5vbigncG9wdXBjbG9zZScsIHRoaXMuX29uUG9wdXBDbG9zZSwgdGhpcyk7XG5cbiAgICAgICAgTC5Eb21FdmVudFxuICAgICAgICAgICAgLmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcilcbiAgICAgICAgICAgIC8vIGFsbG93IHBlb3BsZSB0byBzY3JvbGwgdG9vbHRpcHMgd2l0aCBtb3VzZXdoZWVsXG4gICAgICAgICAgICAuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcblxuICAgICAgICB0aGlzLl9sYXllclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCB0aGlzLl9tb3VzZW92ZXIsIHRoaXMpXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlbW92ZSwgdGhpcylcbiAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLl9jbGljaywgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblxuICAgICAgICBtYXAub2ZmKCdwb3B1cGNsb3NlJywgdGhpcy5fb25Qb3B1cENsb3NlLCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9sYXllclxuICAgICAgICAgICAgLm9mZignbW91c2VvdmVyJywgdGhpcy5fbW91c2VvdmVyLCB0aGlzKVxuICAgICAgICAgICAgLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2Vtb3ZlLCB0aGlzKVxuICAgICAgICAgICAgLm9mZignY2xpY2snLCB0aGlzLl9jbGljaywgdGhpcyk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzLkdyaWRDb250cm9sID0gR3JpZENvbnRyb2w7XG5cbm1vZHVsZS5leHBvcnRzLmdyaWRDb250cm9sID0gZnVuY3Rpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgR3JpZENvbnRyb2woXywgb3B0aW9ucyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIHJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKSxcbiAgICBncmlkID0gcmVxdWlyZSgnLi9ncmlkJyk7XG5cbi8vIGZvcmtlZCBmcm9tIGRhbnplbC9MLlVURkdyaWRcbnZhciBHcmlkTGF5ZXIgPSBMLkxheWVyLmV4dGVuZCh7XG4gICAgaW5jbHVkZXM6IFtyZXF1aXJlKCcuL2xvYWRfdGlsZWpzb24nKV0sXG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHsgcmV0dXJuICcnOyB9XG4gICAgfSxcblxuICAgIF9tb3VzZU9uOiBudWxsLFxuICAgIF90aWxlanNvbjoge30sXG4gICAgX2NhY2hlOiB7fSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2xvYWRUaWxlSlNPTihfKTtcbiAgICB9LFxuXG4gICAgX3NldFRpbGVKU09OOiBmdW5jdGlvbihqc29uKSB7XG4gICAgICAgIHV0aWwuc3RyaWN0KGpzb24sICdvYmplY3QnKTtcblxuICAgICAgICBMLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgIGdyaWRzOiBqc29uLmdyaWRzLFxuICAgICAgICAgICAgbWluWm9vbToganNvbi5taW56b29tLFxuICAgICAgICAgICAgbWF4Wm9vbToganNvbi5tYXh6b29tLFxuICAgICAgICAgICAgYm91bmRzOiBqc29uLmJvdW5kcyAmJiB1dGlsLmxib3VuZHMoanNvbi5ib3VuZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3RpbGVqc29uID0ganNvbjtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldFRpbGVKU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVqc29uO1xuICAgIH0sXG5cbiAgICBhY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5fbWFwICYmIHRoaXMub3B0aW9ucy5ncmlkcyAmJiB0aGlzLm9wdGlvbnMuZ3JpZHMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgLm9uKCdjbGljaycsIHRoaXMuX2NsaWNrLCB0aGlzKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlLCB0aGlzKVxuICAgICAgICAgICAgLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgIC5vZmYoJ2NsaWNrJywgdGhpcy5fY2xpY2ssIHRoaXMpXG4gICAgICAgICAgICAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlLCB0aGlzKVxuICAgICAgICAgICAgLm9mZignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGdldERhdGE6IGZ1bmN0aW9uKGxhdGxuZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgIHBvaW50ID0gbWFwLnByb2plY3QobGF0bG5nLndyYXAoKSksXG4gICAgICAgICAgICB0aWxlU2l6ZSA9IDI1NixcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSA0LFxuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IocG9pbnQueCAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKHBvaW50LnkgLyB0aWxlU2l6ZSksXG4gICAgICAgICAgICBtYXggPSBtYXAub3B0aW9ucy5jcnMuc2NhbGUobWFwLmdldFpvb20oKSkgLyB0aWxlU2l6ZTtcblxuICAgICAgICB4ID0gKHggKyBtYXgpICUgbWF4O1xuICAgICAgICB5ID0gKHkgKyBtYXgpICUgbWF4O1xuXG4gICAgICAgIHRoaXMuX2dldFRpbGUobWFwLmdldFpvb20oKSwgeCwgeSwgZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICAgICAgdmFyIGdyaWRYID0gTWF0aC5mbG9vcigocG9pbnQueCAtICh4ICogdGlsZVNpemUpKSAvIHJlc29sdXRpb24pLFxuICAgICAgICAgICAgICAgIGdyaWRZID0gTWF0aC5mbG9vcigocG9pbnQueSAtICh5ICogdGlsZVNpemUpKSAvIHJlc29sdXRpb24pO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhncmlkKGdyaWRYLCBncmlkWSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2NsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YShlLmxhdGxuZywgTC5iaW5kKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgbGF0TG5nOiBlLmxhdGxuZyxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcykpO1xuICAgIH0sXG5cbiAgICBfbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmdldERhdGEoZS5sYXRsbmcsIEwuYmluZChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdGhpcy5fbW91c2VPbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRMbmc6IGUubGF0bG5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5fbW91c2VPblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgbGF0TG5nOiBlLmxhdGxuZyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPbiA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2Vtb3ZlJywge1xuICAgICAgICAgICAgICAgICAgICBsYXRMbmc6IGUubGF0bG5nLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX2dldFRpbGVVUkw6IGZ1bmN0aW9uKHRpbGVQb2ludCkge1xuICAgICAgICB2YXIgdXJscyA9IHRoaXMub3B0aW9ucy5ncmlkcyxcbiAgICAgICAgICAgIGluZGV4ID0gKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdXJscy5sZW5ndGgsXG4gICAgICAgICAgICB1cmwgPSB1cmxzW2luZGV4XTtcblxuICAgICAgICByZXR1cm4gTC5VdGlsLnRlbXBsYXRlKHVybCwgdGlsZVBvaW50KTtcbiAgICB9LFxuXG4gICAgLy8gTG9hZCB1cCBhbGwgcmVxdWlyZWQganNvbiBncmlkIGZpbGVzXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUoKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcbiAgICAgICAgICAgIHogPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgdGlsZVNpemUgPSAyNTY7XG5cbiAgICAgICAgaWYgKHogPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fCB6IDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHJldHVybjtcblxuICAgICAgICB2YXIgdGlsZUJvdW5kcyA9IEwuYm91bmRzKFxuICAgICAgICAgICAgICAgIGJvdW5kcy5taW4uZGl2aWRlQnkodGlsZVNpemUpLl9mbG9vcigpLFxuICAgICAgICAgICAgICAgIGJvdW5kcy5tYXguZGl2aWRlQnkodGlsZVNpemUpLl9mbG9vcigpKSxcbiAgICAgICAgICAgIG1heCA9IHRoaXMuX21hcC5vcHRpb25zLmNycy5zY2FsZSh6KSAvIHRpbGVTaXplO1xuXG4gICAgICAgIGZvciAodmFyIHggPSB0aWxlQm91bmRzLm1pbi54OyB4IDw9IHRpbGVCb3VuZHMubWF4Lng7IHgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IHRpbGVCb3VuZHMubWluLnk7IHkgPD0gdGlsZUJvdW5kcy5tYXgueTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgLy8geCB3cmFwcGVkXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0VGlsZSh6LCAoKHggJSBtYXgpICsgbWF4KSAlIG1heCwgKCh5ICUgbWF4KSArIG1heCkgJSBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRUaWxlOiBmdW5jdGlvbih6LCB4LCB5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIga2V5ID0geiArICdfJyArIHggKyAnXycgKyB5LFxuICAgICAgICAgICAgdGlsZVBvaW50ID0gTC5wb2ludCh4LCB5KTtcblxuICAgICAgICB0aWxlUG9pbnQueiA9IHo7XG5cbiAgICAgICAgaWYgKCF0aGlzLl90aWxlU2hvdWxkQmVMb2FkZWQodGlsZVBvaW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NhY2hlW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLl9jYWNoZVtrZXldKTsgLy8gQWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVba2V5XS5wdXNoKGNhbGxiYWNrKTsgLy8gUGVuZGluZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWNoZVtrZXldID0gW107XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVtrZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdCh0aGlzLl9nZXRUaWxlVVJMKHRpbGVQb2ludCksIEwuYmluZChmdW5jdGlvbihlcnIsIGpzb24pIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWNoZVtrZXldO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVba2V5XSA9IGdyaWQoanNvbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXSh0aGlzLl9jYWNoZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcykpO1xuICAgIH0sXG5cbiAgICBfdGlsZVNob3VsZEJlTG9hZGVkOiBmdW5jdGlvbih0aWxlUG9pbnQpIHtcbiAgICAgICAgaWYgKHRpbGVQb2ludC56ID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHwgdGlsZVBvaW50LnogPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlU2l6ZSA9IDI1NixcbiAgICAgICAgICAgICAgICBud1BvaW50ID0gdGlsZVBvaW50Lm11bHRpcGx5QnkodGlsZVNpemUpLFxuICAgICAgICAgICAgICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZChuZXcgTC5Qb2ludCh0aWxlU2l6ZSwgdGlsZVNpemUpKSxcbiAgICAgICAgICAgICAgICBudyA9IHRoaXMuX21hcC51bnByb2plY3QobndQb2ludCksXG4gICAgICAgICAgICAgICAgc2UgPSB0aGlzLl9tYXAudW5wcm9qZWN0KHNlUG9pbnQpLFxuICAgICAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcyhbbncsIHNlXSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMuR3JpZExheWVyID0gR3JpZExheWVyO1xuXG5tb2R1bGUuZXhwb3J0cy5ncmlkTGF5ZXIgPSBmdW5jdGlvbihfLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBHcmlkTGF5ZXIoXywgb3B0aW9ucyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGVhZmxldCA9IHJlcXVpcmUoJy4vbGVhZmxldCcpO1xuXG5yZXF1aXJlKCcuL21hcGJveCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxlYWZsZXQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5MID0gcmVxdWlyZSgnbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBMZWdlbmRDb250cm9sID0gTC5Db250cm9sLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxuICAgICAgICBzYW5pdGl6ZXI6IHJlcXVpcmUoJ3Nhbml0aXplLWNhamEnKVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbGVnZW5kcyA9IHt9O1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdtYXAtbGVnZW5kcyB3YXgtbGVnZW5kcycpO1xuICAgICAgICBMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgYWRkTGVnZW5kOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbGVnZW5kc1t0ZXh0XSkge1xuICAgICAgICAgICAgdGhpcy5fbGVnZW5kc1t0ZXh0XSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sZWdlbmRzW3RleHRdKys7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGVnZW5kOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxuICAgICAgICBpZiAodGhpcy5fbGVnZW5kc1t0ZXh0XSkgdGhpcy5fbGVnZW5kc1t0ZXh0XS0tO1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdmFyIGhpZGUgPSAnbm9uZSc7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9sZWdlbmRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGVnZW5kcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0aGlzLl9sZWdlbmRzW2ldKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdtYXAtbGVnZW5kIHdheC1sZWdlbmQnLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGkpO1xuICAgICAgICAgICAgICAgIGhpZGUgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGlkZSB0aGUgY29udHJvbCBlbnRpcmVseSB1bmxlc3MgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxlZ2VuZDtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgYSBzbWFsbCBncmV5IGJsZW1pc2ggb24gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBoaWRlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5MZWdlbmRDb250cm9sID0gTGVnZW5kQ29udHJvbDtcblxubW9kdWxlLmV4cG9ydHMubGVnZW5kQ29udHJvbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExlZ2VuZENvbnRyb2wob3B0aW9ucyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpLFxuICAgIGZvcm1hdF91cmwgPSByZXF1aXJlKCcuL2Zvcm1hdF91cmwnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIF9sb2FkVGlsZUpTT046IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgXyA9IGZvcm1hdF91cmwudGlsZUpTT04oXywgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICByZXF1ZXN0KF8sIEwuYmluZChmdW5jdGlvbihlcnIsIGpzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubG9nKCdjb3VsZCBub3QgbG9hZCBUaWxlSlNPTiBhdCAnICsgXyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRUaWxlSlNPTihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdyZWFkeScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfICYmIHR5cGVvZiBfID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGlsZUpTT04oXyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGlsZUxheWVyID0gcmVxdWlyZSgnLi90aWxlX2xheWVyJykudGlsZUxheWVyLFxuICAgIGZlYXR1cmVMYXllciA9IHJlcXVpcmUoJy4vZmVhdHVyZV9sYXllcicpLmZlYXR1cmVMYXllcixcbiAgICBncmlkTGF5ZXIgPSByZXF1aXJlKCcuL2dyaWRfbGF5ZXInKS5ncmlkTGF5ZXIsXG4gICAgZ3JpZENvbnRyb2wgPSByZXF1aXJlKCcuL2dyaWRfY29udHJvbCcpLmdyaWRDb250cm9sLFxuICAgIHNoYXJlQ29udHJvbCA9IHJlcXVpcmUoJy4vc2hhcmVfY29udHJvbCcpLnNoYXJlQ29udHJvbCxcbiAgICBsZWdlbmRDb250cm9sID0gcmVxdWlyZSgnLi9sZWdlbmRfY29udHJvbCcpLmxlZ2VuZENvbnRyb2wsXG4gICAgbWFwYm94TG9nb0NvbnRyb2wgPSByZXF1aXJlKCcuL21hcGJveF9sb2dvJykubWFwYm94TG9nb0NvbnRyb2wsXG4gICAgZmVlZGJhY2sgPSByZXF1aXJlKCcuL2ZlZWRiYWNrJyk7XG5cbmZ1bmN0aW9uIHdpdGhBY2Nlc3NUb2tlbihvcHRpb25zLCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghYWNjZXNzVG9rZW4gfHwgb3B0aW9ucy5hY2Nlc3NUb2tlbilcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgcmV0dXJuIEwuZXh0ZW5kKHthY2Nlc3NUb2tlbjogYWNjZXNzVG9rZW59LCBvcHRpb25zKTtcbn1cblxudmFyIExNYXAgPSBMLk1hcC5leHRlbmQoe1xuICAgIGluY2x1ZGVzOiBbcmVxdWlyZSgnLi9sb2FkX3RpbGVqc29uJyldLFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICB0aWxlTGF5ZXI6IHt9LFxuICAgICAgICBmZWF0dXJlTGF5ZXI6IHt9LFxuICAgICAgICBncmlkTGF5ZXI6IHt9LFxuICAgICAgICBsZWdlbmRDb250cm9sOiB7fSxcbiAgICAgICAgZ3JpZENvbnRyb2w6IHt9LFxuICAgICAgICBzaGFyZUNvbnRyb2w6IGZhbHNlLFxuICAgICAgICBzYW5pdGl6ZXI6IHJlcXVpcmUoJ3Nhbml0aXplLWNhamEnKVxuICAgIH0sXG5cbiAgICBfdGlsZWpzb246IHt9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWxlbWVudCwgXywgb3B0aW9ucykge1xuXG4gICAgICAgIEwuTWFwLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWxlbWVudCxcbiAgICAgICAgICAgIEwuZXh0ZW5kKHt9LCBMLk1hcC5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucykpO1xuXG4gICAgICAgIC8vIERpc2FibGUgdGhlIGRlZmF1bHQgJ0xlYWZsZXQnIHRleHRcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5zZXRQcmVmaXgoJycpO1xuXG4gICAgICAgICAgICB2YXIgY29tcGFjdCA9IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wuY29tcGFjdDtcbiAgICAgICAgICAgIC8vIFNldCBhIGNvbXBhY3QgZGlzcGxheSBpZiBtYXAgY29udGFpbmVyIHdpZHRoIGlzIDwgNjQwIG9yXG4gICAgICAgICAgICAvLyBjb21wYWN0IGlzIHNldCB0byBgdHJ1ZWAgaW4gYXR0cmlidXRpb25Db250cm9sIG9wdGlvbnMuXG4gICAgICAgICAgICBpZiAoY29tcGFjdCB8fCAoY29tcGFjdCAhPT0gZmFsc2UgJiYgdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoIDw9IDY0MCkpIHtcbiAgICAgICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29tcGFjdC1hdHRyaWJ1dGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcGFjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGggPiA2NDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5fY29udGFpbmVyLCAnbGVhZmxldC1jb21wYWN0LWF0dHJpYnV0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29tcGFjdC1hdHRyaWJ1dGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRpbGVMYXllcikge1xuICAgICAgICAgICAgdGhpcy50aWxlTGF5ZXIgPSB0aWxlTGF5ZXIodW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHdpdGhBY2Nlc3NUb2tlbih0aGlzLm9wdGlvbnMudGlsZUxheWVyLCB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW4pKTtcbiAgICAgICAgICAgIHRoaXMuYWRkTGF5ZXIodGhpcy50aWxlTGF5ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mZWF0dXJlTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUxheWVyID0gZmVhdHVyZUxheWVyKHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB3aXRoQWNjZXNzVG9rZW4odGhpcy5vcHRpb25zLmZlYXR1cmVMYXllciwgdGhpcy5vcHRpb25zLmFjY2Vzc1Rva2VuKSk7XG4gICAgICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMuZmVhdHVyZUxheWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JpZExheWVyKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRMYXllciA9IGdyaWRMYXllcih1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgd2l0aEFjY2Vzc1Rva2VuKHRoaXMub3B0aW9ucy5ncmlkTGF5ZXIsIHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbikpO1xuICAgICAgICAgICAgdGhpcy5hZGRMYXllcih0aGlzLmdyaWRMYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdyaWRMYXllciAmJiB0aGlzLm9wdGlvbnMuZ3JpZENvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZENvbnRyb2wgPSBncmlkQ29udHJvbCh0aGlzLmdyaWRMYXllciwgdGhpcy5vcHRpb25zLmdyaWRDb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLmdyaWRDb250cm9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVnZW5kQ29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5sZWdlbmRDb250cm9sID0gbGVnZW5kQ29udHJvbCh0aGlzLm9wdGlvbnMubGVnZW5kQ29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLmFkZENvbnRyb2wodGhpcy5sZWdlbmRDb250cm9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcmVDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlQ29udHJvbCA9IHNoYXJlQ29udHJvbCh1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgd2l0aEFjY2Vzc1Rva2VuKHRoaXMub3B0aW9ucy5zaGFyZUNvbnRyb2wsIHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbikpO1xuICAgICAgICAgICAgdGhpcy5hZGRDb250cm9sKHRoaXMuc2hhcmVDb250cm9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcGJveExvZ29Db250cm9sID0gbWFwYm94TG9nb0NvbnRyb2wodGhpcy5vcHRpb25zLm1hcGJveExvZ29Db250cm9sKTtcbiAgICAgICAgdGhpcy5hZGRDb250cm9sKHRoaXMuX21hcGJveExvZ29Db250cm9sKTtcblxuICAgICAgICB0aGlzLl9sb2FkVGlsZUpTT04oXyk7XG5cbiAgICAgICAgdGhpcy5vbignbGF5ZXJhZGQnLCB0aGlzLl9vbkxheWVyQWRkLCB0aGlzKVxuICAgICAgICAgICAgLm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX29uTGF5ZXJSZW1vdmUsIHRoaXMpXG4gICAgICAgICAgICAub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVNYXBGZWVkYmFja0xpbmssIHRoaXMpO1xuXG4gICAgICAgIHRoaXMud2hlblJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrLm9uKCdjaGFuZ2UnLCB0aGlzLl91cGRhdGVNYXBGZWVkYmFja0xpbmssIHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uKCd1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmZWVkYmFjay5vZmYoJ2NoYW5nZScsIHRoaXMuX3VwZGF0ZU1hcEZlZWRiYWNrTGluaywgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyB1c2UgYSBqYXZhc2NyaXB0IG9iamVjdCBvZiB0aWxlanNvbiBkYXRhIHRvIGNvbmZpZ3VyZSB0aGlzIGxheWVyXG4gICAgX3NldFRpbGVKU09OOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIHRoaXMuX3RpbGVqc29uID0gXztcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShfKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldFRpbGVKU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVqc29uO1xuICAgIH0sXG5cbiAgICBfaW5pdGlhbGl6ZTogZnVuY3Rpb24oanNvbikge1xuICAgICAgICBpZiAodGhpcy50aWxlTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZUxheWVyLl9zZXRUaWxlSlNPTihqc29uKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKHRoaXMudGlsZUxheWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVMYXllciAmJiAhdGhpcy5mZWF0dXJlTGF5ZXIuZ2V0R2VvSlNPTigpICYmIGpzb24uZGF0YSAmJiBqc29uLmRhdGFbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUxheWVyLmxvYWRVUkwoanNvbi5kYXRhWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyaWRMYXllcikge1xuICAgICAgICAgICAgdGhpcy5ncmlkTGF5ZXIuX3NldFRpbGVKU09OKGpzb24pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXIodGhpcy5ncmlkTGF5ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGVnZW5kQ29udHJvbCAmJiBqc29uLmxlZ2VuZCkge1xuICAgICAgICAgICAgdGhpcy5sZWdlbmRDb250cm9sLmFkZExlZ2VuZChqc29uLmxlZ2VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaGFyZUNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVDb250cm9sLl9zZXRUaWxlSlNPTihqc29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcGJveExvZ29Db250cm9sLl9zZXRUaWxlSlNPTihqc29uKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCAmJiBqc29uLmNlbnRlcikge1xuICAgICAgICAgICAgdmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSAhPT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiBqc29uLmNlbnRlclsyXSxcbiAgICAgICAgICAgICAgICBjZW50ZXIgPSBMLmxhdExuZyhqc29uLmNlbnRlclsxXSwganNvbi5jZW50ZXJbMF0pO1xuXG4gICAgICAgICAgICB0aGlzLnNldFZpZXcoY2VudGVyLCB6b29tKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlTWFwRmVlZGJhY2tMaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb250cm9sQ29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHJldHVybjtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21hcGJveC1pbXByb3ZlLW1hcCcpO1xuICAgICAgICBpZiAobGluay5sZW5ndGggJiYgdGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKS53cmFwKCk7XG4gICAgICAgICAgICB2YXIgdGlsZWpzb24gPSB0aGlzLl90aWxlanNvbiB8fCB7fTtcbiAgICAgICAgICAgIHZhciBpZCA9IHRpbGVqc29uLmlkIHx8ICcnO1xuXG4gICAgICAgICAgICB2YXIgaGFzaCA9ICcjJyArIGlkICsgJy8nICtcbiAgICAgICAgICAgICAgICBjZW50ZXIubG5nLnRvRml4ZWQoMykgKyAnLycgK1xuICAgICAgICAgICAgICAgIGNlbnRlci5sYXQudG9GaXhlZCgzKSArICcvJyArXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRab29tKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBmZWVkYmFjay5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaGFzaCArPSAnLycgKyBrZXkgKyAnPScgKyBmZWVkYmFjay5kYXRhW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbmtbaV0uaGFzaCA9IGhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uTGF5ZXJBZGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCdvbicgaW4gZS5sYXllcikge1xuICAgICAgICAgICAgZS5sYXllci5vbigncmVhZHknLCB0aGlzLl9vbkxheWVyUmVhZHksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KEwuYmluZCh0aGlzLl91cGRhdGVNYXBGZWVkYmFja0xpbmssIHRoaXMpLCAwKTsgLy8gVXBkYXRlIGFmdGVyIGF0dHJpYnV0aW9uIGNvbnRyb2wgcmVzZXRzIHRoZSBIVE1MLlxuICAgIH0sXG5cbiAgICBfb25MYXllclJlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoJ29uJyBpbiBlLmxheWVyKSB7XG4gICAgICAgICAgICBlLmxheWVyLm9mZigncmVhZHknLCB0aGlzLl9vbkxheWVyUmVhZHksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KEwuYmluZCh0aGlzLl91cGRhdGVNYXBGZWVkYmFja0xpbmssIHRoaXMpLCAwKTsgLy8gVXBkYXRlIGFmdGVyIGF0dHJpYnV0aW9uIGNvbnRyb2wgcmVzZXRzIHRoZSBIVE1MLlxuICAgIH0sXG5cbiAgICBfb25MYXllclJlYWR5OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKGUudGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUxheWVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICBpZiAoIWxheWVyLm9wdGlvbnMpIHJldHVybjtcblxuICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wgJiYgdGhpcy5fbG9hZGVkICYmIGxheWVyLmdldEF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKEwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykgJiZcbiAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tIHx8IGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvb21Cb3VuZExheWVyc1tMLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hcEZlZWRiYWNrTGluaygpO1xuICAgICAgICB0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzLk1hcCA9IExNYXA7XG5cbm1vZHVsZS5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uKGVsZW1lbnQsIF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExNYXAoZWxlbWVudCwgXywgb3B0aW9ucyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2VvY29kZXJDb250cm9sID0gcmVxdWlyZSgnLi9nZW9jb2Rlcl9jb250cm9sJyksXG4gICAgZ3JpZENvbnRyb2wgPSByZXF1aXJlKCcuL2dyaWRfY29udHJvbCcpLFxuICAgIGZlYXR1cmVMYXllciA9IHJlcXVpcmUoJy4vZmVhdHVyZV9sYXllcicpLFxuICAgIGxlZ2VuZENvbnRyb2wgPSByZXF1aXJlKCcuL2xlZ2VuZF9jb250cm9sJyksXG4gICAgc2hhcmVDb250cm9sID0gcmVxdWlyZSgnLi9zaGFyZV9jb250cm9sJyksXG4gICAgdGlsZUxheWVyID0gcmVxdWlyZSgnLi90aWxlX2xheWVyJyksXG4gICAgbWFwID0gcmVxdWlyZSgnLi9tYXAnKSxcbiAgICBncmlkTGF5ZXIgPSByZXF1aXJlKCcuL2dyaWRfbGF5ZXInKSxcbiAgICBzdHlsZUxheWVyID0gcmVxdWlyZSgnLi9zdHlsZV9sYXllcicpO1xuXG5MLm1hcGJveCA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIFZFUlNJT046IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG4gICAgZ2VvY29kZXI6IHJlcXVpcmUoJy4vZ2VvY29kZXInKSxcbiAgICBtYXJrZXI6IHJlcXVpcmUoJy4vbWFya2VyJyksXG4gICAgc2ltcGxlc3R5bGU6IHJlcXVpcmUoJy4vc2ltcGxlc3R5bGUnKSxcbiAgICB0aWxlTGF5ZXI6IHRpbGVMYXllci50aWxlTGF5ZXIsXG4gICAgVGlsZUxheWVyOiB0aWxlTGF5ZXIuVGlsZUxheWVyLFxuICAgIHN0eWxlTGF5ZXI6IHN0eWxlTGF5ZXIuc3R5bGVMYXllcixcbiAgICBTdHlsZUxheWVyOiBzdHlsZUxheWVyLlN0eWxlTGF5ZXIsXG4gICAgc2hhcmVDb250cm9sOiBzaGFyZUNvbnRyb2wuc2hhcmVDb250cm9sLFxuICAgIFNoYXJlQ29udHJvbDogc2hhcmVDb250cm9sLlNoYXJlQ29udHJvbCxcbiAgICBsZWdlbmRDb250cm9sOiBsZWdlbmRDb250cm9sLmxlZ2VuZENvbnRyb2wsXG4gICAgTGVnZW5kQ29udHJvbDogbGVnZW5kQ29udHJvbC5MZWdlbmRDb250cm9sLFxuICAgIGdlb2NvZGVyQ29udHJvbDogZ2VvY29kZXJDb250cm9sLmdlb2NvZGVyQ29udHJvbCxcbiAgICBHZW9jb2RlckNvbnRyb2w6IGdlb2NvZGVyQ29udHJvbC5HZW9jb2RlckNvbnRyb2wsXG4gICAgZ3JpZENvbnRyb2w6IGdyaWRDb250cm9sLmdyaWRDb250cm9sLFxuICAgIEdyaWRDb250cm9sOiBncmlkQ29udHJvbC5HcmlkQ29udHJvbCxcbiAgICBncmlkTGF5ZXI6IGdyaWRMYXllci5ncmlkTGF5ZXIsXG4gICAgR3JpZExheWVyOiBncmlkTGF5ZXIuR3JpZExheWVyLFxuICAgIGZlYXR1cmVMYXllcjogZmVhdHVyZUxheWVyLmZlYXR1cmVMYXllcixcbiAgICBGZWF0dXJlTGF5ZXI6IGZlYXR1cmVMYXllci5GZWF0dXJlTGF5ZXIsXG4gICAgbWFwOiBtYXAubWFwLFxuICAgIE1hcDogbWFwLk1hcCxcbiAgICBjb25maWc6IHJlcXVpcmUoJy4vY29uZmlnJyksXG4gICAgc2FuaXRpemU6IHJlcXVpcmUoJ3Nhbml0aXplLWNhamEnKSxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnbXVzdGFjaGUnKS50b19odG1sLFxuICAgIGZlZWRiYWNrOiByZXF1aXJlKCcuL2ZlZWRiYWNrJylcbn07XG5cblxuLy8gSGFyZGNvZGUgaW1hZ2UgcGF0aCwgYmVjYXVzZSBMZWFmbGV0J3MgYXV0b2RldGVjdGlvblxuLy8gZmFpbHMsIGJlY2F1c2UgbWFwYm94LmpzIGlzIG5vdCBuYW1lZCBsZWFmbGV0LmpzXG53aW5kb3cuTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoID1cbiAgICAvLyBEZXRlY3QgYmFkLW5ld3MgcHJvdG9jb2xzIGxpa2UgZmlsZTovLyBhbmQgaGFyZGNvZGVcbiAgICAvLyB0byBodHRwcyBpZiB0aGV5J3JlIGRldGVjdGVkLlxuICAgICgoZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8XG4gICAgZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpID8gJycgOiAnaHR0cHM6JykgK1xuICAgICcvL2FwaS50aWxlcy5tYXBib3guY29tL21hcGJveC5qcy8nICsgJ3YnICtcbiAgICByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uICsgJy9pbWFnZXMnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWFwYm94TG9nb0NvbnRyb2wgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICdib3R0b21sZWZ0J1xuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbWFwYm94LWxvZ28nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX3NldFRpbGVKU09OOiBmdW5jdGlvbihqc29uKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGFjY291bnQgcmVmZXJlbmNlZCBieSB0aGUgYWNjZXNzVG9rZW5cbiAgICAgICAgLy8gaXMgYXNzY29jaWF0ZWQgd2l0aCB0aGUgTWFwYm94IExvZ29cbiAgICAgICAgLy8gYXMgZGV0ZXJtaW5lZCBieSBtYXBib3gtbWFwcy5cbiAgICAgICAgaWYgKGpzb24ubWFwYm94X2xvZ28pIHtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdtYXBib3gtbG9nby10cnVlJyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMuTWFwYm94TG9nb0NvbnRyb2wgPSBNYXBib3hMb2dvQ29udHJvbDtcblxubW9kdWxlLmV4cG9ydHMubWFwYm94TG9nb0NvbnRyb2wgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBNYXBib3hMb2dvQ29udHJvbChvcHRpb25zKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXRfdXJsID0gcmVxdWlyZSgnLi9mb3JtYXRfdXJsJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIHNhbml0aXplID0gcmVxdWlyZSgnc2FuaXRpemUtY2FqYScpO1xuXG4vLyBtYXBib3gtcmVsYXRlZCBtYXJrZXJzIGZ1bmN0aW9uYWxpdHlcbi8vIHByb3ZpZGUgYW4gaWNvbiBmcm9tIG1hcGJveCdzIHNpbXBsZS1zdHlsZSBzcGVjIGFuZCBob3N0ZWQgbWFya2Vyc1xuLy8gc2VydmljZVxuZnVuY3Rpb24gaWNvbihmcCwgb3B0aW9ucykge1xuICAgIGZwID0gZnAgfHwge307XG5cbiAgICB2YXIgc2l6ZXMgPSB7XG4gICAgICAgICAgICBzbWFsbDogWzIwLCA1MF0sXG4gICAgICAgICAgICBtZWRpdW06IFszMCwgNzBdLFxuICAgICAgICAgICAgbGFyZ2U6IFszNSwgOTBdXG4gICAgICAgIH0sXG4gICAgICAgIHNpemUgPSBmcFsnbWFya2VyLXNpemUnXSB8fCAnbWVkaXVtJyxcbiAgICAgICAgc3ltYm9sID0gKCdtYXJrZXItc3ltYm9sJyBpbiBmcCAmJiBmcFsnbWFya2VyLXN5bWJvbCddICE9PSAnJykgPyAnLScgKyBmcFsnbWFya2VyLXN5bWJvbCddIDogJycsXG4gICAgICAgIGNvbG9yID0gKGZwWydtYXJrZXItY29sb3InXSB8fCAnN2U3ZTdlJykucmVwbGFjZSgnIycsICcnKTtcblxuICAgIHJldHVybiBMLmljb24oe1xuICAgICAgICBpY29uVXJsOiBmb3JtYXRfdXJsKCcvdjQvbWFya2VyLycgK1xuICAgICAgICAgICAgJ3Bpbi0nICsgc2l6ZS5jaGFyQXQoMCkgKyBzeW1ib2wgKyAnKycgKyBjb2xvciArXG4gICAgICAgICAgICAvLyBkZXRlY3QgYW5kIHVzZSByZXRpbmEgbWFya2Vycywgd2hpY2ggYXJlIHgyIHJlc29sdXRpb25cbiAgICAgICAgICAgIChMLkJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJykgKyAnLnBuZycsIG9wdGlvbnMgJiYgb3B0aW9ucy5hY2Nlc3NUb2tlbiksXG4gICAgICAgIGljb25TaXplOiBzaXplc1tzaXplXSxcbiAgICAgICAgaWNvbkFuY2hvcjogW3NpemVzW3NpemVdWzBdIC8gMiwgc2l6ZXNbc2l6ZV1bMV0gLyAyXSxcbiAgICAgICAgcG9wdXBBbmNob3I6IFswLCAtc2l6ZXNbc2l6ZV1bMV0gLyAyXVxuICAgIH0pO1xufVxuXG4vLyBhIGZhY3RvcnkgdGhhdCBwcm92aWRlcyBtYXJrZXJzIGZvciBMZWFmbGV0IGZyb20gTWFwYm94J3Ncbi8vIFtzaW1wbGUtc3R5bGUgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9zaW1wbGVzdHlsZS1zcGVjKVxuLy8gYW5kIFtNYXJrZXJzIEFQSV0oaHR0cDovL21hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI21hcmtlcnMpLlxuZnVuY3Rpb24gc3R5bGUoZiwgbGF0bG9uLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIEwubWFya2VyKGxhdGxvbiwge1xuICAgICAgICBpY29uOiBpY29uKGYucHJvcGVydGllcywgb3B0aW9ucyksXG4gICAgICAgIHRpdGxlOiB1dGlsLnN0cmlwX3RhZ3MoXG4gICAgICAgICAgICBzYW5pdGl6ZSgoZi5wcm9wZXJ0aWVzICYmIGYucHJvcGVydGllcy50aXRsZSkgfHwgJycpKVxuICAgIH0pO1xufVxuXG4vLyBTYW5pdGl6ZSBhbmQgZm9ybWF0IHByb3BlcnRpZXMgb2YgYSBHZW9KU09OIEZlYXR1cmUgb2JqZWN0IGluIG9yZGVyXG4vLyB0byBmb3JtIHRoZSBIVE1MIHN0cmluZyB1c2VkIGFzIHRoZSBhcmd1bWVudCBmb3IgYEwuY3JlYXRlUG9wdXBgXG5mdW5jdGlvbiBjcmVhdGVQb3B1cChmLCBzYW5pdGl6ZXIpIHtcbiAgICBpZiAoIWYgfHwgIWYucHJvcGVydGllcykgcmV0dXJuICcnO1xuICAgIHZhciBwb3B1cCA9ICcnO1xuXG4gICAgaWYgKGYucHJvcGVydGllcy50aXRsZSkge1xuICAgICAgICBwb3B1cCArPSAnPGRpdiBjbGFzcz1cIm1hcmtlci10aXRsZVwiPicgKyBmLnByb3BlcnRpZXMudGl0bGUgKyAnPC9kaXY+JztcbiAgICB9XG5cbiAgICBpZiAoZi5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHBvcHVwICs9ICc8ZGl2IGNsYXNzPVwibWFya2VyLWRlc2NyaXB0aW9uXCI+JyArIGYucHJvcGVydGllcy5kZXNjcmlwdGlvbiArICc8L2Rpdj4nO1xuICAgIH1cblxuICAgIHJldHVybiAoc2FuaXRpemVyIHx8IHNhbml0aXplKShwb3B1cCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGljb246IGljb24sXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNyZWF0ZVBvcHVwOiBjcmVhdGVQb3B1cFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvcnNsaXRlID0gcmVxdWlyZSgnY29yc2xpdGUnKSxcbiAgICBzdHJpY3QgPSByZXF1aXJlKCcuL3V0aWwnKS5zdHJpY3QsXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIHByb3RvY29sID0gL14oaHR0cHM/Oik/KD89XFwvXFwvKC58YXBpKVxcLnRpbGVzXFwubWFwYm94XFwuY29tXFwvKS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHN0cmljdCh1cmwsICdzdHJpbmcnKTtcbiAgICBzdHJpY3QoY2FsbGJhY2ssICdmdW5jdGlvbicpO1xuXG4gICAgdXJsID0gdXJsLnJlcGxhY2UocHJvdG9jb2wsIGZ1bmN0aW9uKG1hdGNoLCBwcm90b2NvbCkge1xuICAgICAgICBpZiAoISgnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCkpKSB7XG4gICAgICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBpbiB1c2U7IGRvZXNuJ3Qgc3VwcG9ydCBjcm9zcy1wcm90b2NvbCByZXF1ZXN0c1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3RvY29sID09PSAnaHR0cHM6JyB8fCBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgY29uZmlnLkZPUkNFX0hUVFBTKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2h0dHBzOic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ2h0dHA6JztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25sb2FkKGVyciwgcmVzcCkge1xuICAgICAgICBpZiAoIWVyciAmJiByZXNwKSB7XG4gICAgICAgICAgICByZXNwID0gSlNPTi5wYXJzZShyZXNwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29yc2xpdGUodXJsLCBvbmxvYWQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvcm1hdF91cmwgPSByZXF1aXJlKCcuL2Zvcm1hdF91cmwnKTtcblxudmFyIFNoYXJlQ29udHJvbCA9IEwuQ29udHJvbC5leHRlbmQoe1xuICAgIGluY2x1ZGVzOiBbcmVxdWlyZSgnLi9sb2FkX3RpbGVqc29uJyldLFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxuICAgICAgICB1cmw6ICcnXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9sb2FkVGlsZUpTT04oXyk7XG4gICAgfSxcblxuICAgIF9zZXRUaWxlSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgICB0aGlzLl90aWxlanNvbiA9IGpzb247XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLW1hcGJveC1zaGFyZSBsZWFmbGV0LWJhcicpO1xuICAgICAgICB2YXIgbGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCAnbWFwYm94LXNoYXJlIG1hcGJveC1pY29uIG1hcGJveC1pY29uLXNoYXJlJywgY29udGFpbmVyKTtcbiAgICAgICAgbGluay5ocmVmID0gJyMnO1xuXG4gICAgICAgIHRoaXMuX21vZGFsID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ21hcGJveC1tb2RhbCcsIHRoaXMuX21hcC5fY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fbWFzayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdtYXBib3gtbW9kYWwtbWFzaycsIHRoaXMuX21vZGFsKTtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdtYXBib3gtbW9kYWwtY29udGVudCcsIHRoaXMuX21vZGFsKTtcblxuICAgICAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGxpbmssICdjbGljaycsIHRoaXMuX3NoYXJlQ2xpY2ssIHRoaXMpO1xuICAgICAgICBMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9jbGlja091dCwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX2NsaWNrT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFyaW5nKSB7XG4gICAgICAgICAgICBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21vZGFsLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fc2hhcmluZyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NoYXJlQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgTC5Eb21FdmVudC5zdG9wKGUpO1xuICAgICAgICBpZiAodGhpcy5fc2hhcmluZykgcmV0dXJuIHRoaXMuX2NsaWNrT3V0KGUpO1xuXG4gICAgICAgIHZhciB0aWxlanNvbiA9IHRoaXMuX3RpbGVqc29uIHx8IHRoaXMuX21hcC5fdGlsZWpzb24gfHwge30sXG4gICAgICAgICAgICB1cmwgPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy5vcHRpb25zLnVybCB8fCB0aWxlanNvbi53ZWJwYWdlIHx8IHdpbmRvdy5sb2NhdGlvbiksXG4gICAgICAgICAgICBuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KHRpbGVqc29uLm5hbWUpLFxuICAgICAgICAgICAgaW1hZ2UgPSBmb3JtYXRfdXJsKCcvdjQvJyArIHRpbGVqc29uLmlkICsgJy8nICsgdGhpcy5fbWFwLmdldENlbnRlcigpLmxuZyArICcsJyArIHRoaXMuX21hcC5nZXRDZW50ZXIoKS5sYXQgKyAnLCcgKyB0aGlzLl9tYXAuZ2V0Wm9vbSgpICsgJy82MDB4NjAwLnBuZycsIHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbiksXG4gICAgICAgICAgICBlbWJlZCA9IGZvcm1hdF91cmwoJy92NC8nICsgdGlsZWpzb24uaWQgKyAnLmh0bWwnLCB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW4pLFxuICAgICAgICAgICAgdHdpdHRlclVSTCA9ICcvL3R3aXR0ZXIuY29tL2ludGVudC90d2VldD9zdGF0dXM9JyArIG5hbWUgKyAnICcgKyB1cmwsXG4gICAgICAgICAgICBmYWNlYm9va1VSTCA9ICcvL3d3dy5mYWNlYm9vay5jb20vc2hhcmVyLnBocD91PScgKyB1cmwgKyAnJnQ9JyArIG5hbWUsXG4gICAgICAgICAgICBwaW50ZXJlc3RVUkwgPSAnLy93d3cucGludGVyZXN0LmNvbS9waW4vY3JlYXRlL2J1dHRvbi8/dXJsPScgKyB1cmwgKyAnJm1lZGlhPScgKyBpbWFnZSArICcmZGVzY3JpcHRpb249JyArIG5hbWUsXG4gICAgICAgICAgICBlbWJlZFZhbHVlID0gJzxpZnJhbWUgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiNTAwcHhcIiBmcmFtZUJvcmRlcj1cIjBcIiBzcmM9XCInICsgZW1iZWQgKyAnXCI+PC9pZnJhbWU+JyxcbiAgICAgICAgICAgIGVtYmVkTGFiZWwgPSAnQ29weSBhbmQgcGFzdGUgdGhpcyA8c3Ryb25nPkhUTUwgY29kZTwvc3Ryb25nPiBpbnRvIGRvY3VtZW50cyB0byBlbWJlZCB0aGlzIG1hcCBvbiB3ZWIgcGFnZXMuJztcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVTaGFyZUJ1dHRvbihidXR0b25DbGFzcywgaHJlZiwgc29jaWFsTWVkaWFOYW1lKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdjbGFzcycsIGJ1dHRvbkNsYXNzKTtcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19ibGFuaycpO1xuICAgICAgICAgICAgc29jaWFsTWVkaWFOYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc29jaWFsTWVkaWFOYW1lKTtcbiAgICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoc29jaWFsTWVkaWFOYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbW9kYWwsICdhY3RpdmUnKTtcblxuICAgICAgICB0aGlzLl9zaGFyaW5nID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ21hcGJveC1tb2RhbC1ib2R5JywgdGhpcy5fY29udGVudCk7XG5cbiAgICAgICAgdmFyIHR3aXR0ZXJCdXR0b24gPSBjcmVhdGVTaGFyZUJ1dHRvbignbWFwYm94LWJ1dHRvbiBtYXBib3gtYnV0dG9uLWljb24gbWFwYm94LWljb24tdHdpdHRlcicsIHR3aXR0ZXJVUkwsICdUd2l0dGVyJyk7XG4gICAgICAgIHZhciBmYWNlYm9va0J1dHRvbiA9IGNyZWF0ZVNoYXJlQnV0dG9uKCdtYXBib3gtYnV0dG9uIG1hcGJveC1idXR0b24taWNvbiBtYXBib3gtaWNvbi1mYWNlYm9vaycsIGZhY2Vib29rVVJMLCAnRmFjZWJvb2snKTtcbiAgICAgICAgdmFyIHBpbnRlcmVzdEJ1dHRvbiA9IGNyZWF0ZVNoYXJlQnV0dG9uKCdtYXBib3gtYnV0dG9uIG1hcGJveC1idXR0b24taWNvbiBtYXBib3gtaWNvbi1waW50ZXJlc3QnLCBwaW50ZXJlc3RVUkwsICdQaW50ZXJlc3QnKTtcblxuICAgICAgICB2YXIgc2hhcmVIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgICAgICB2YXIgc2hhcmVUZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1NoYXJlIHRoaXMgbWFwJyk7XG4gICAgICAgIHNoYXJlSGVhZGVyLmFwcGVuZENoaWxkKHNoYXJlVGV4dCk7XG5cbiAgICAgICAgdmFyIHNoYXJlQnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzaGFyZUJ1dHRvbnMuc2V0QXR0cmlidXRlKCdjbGFzcycsICdtYXBib3gtc2hhcmUtYnV0dG9ucycpO1xuICAgICAgICBzaGFyZUJ1dHRvbnMuYXBwZW5kQ2hpbGQoZmFjZWJvb2tCdXR0b24pO1xuICAgICAgICBzaGFyZUJ1dHRvbnMuYXBwZW5kQ2hpbGQodHdpdHRlckJ1dHRvbik7XG4gICAgICAgIHNoYXJlQnV0dG9ucy5hcHBlbmRDaGlsZChwaW50ZXJlc3RCdXR0b24pO1xuXG4gICAgICAgIHRoaXMuX3NoYXJpbmcuYXBwZW5kQ2hpbGQoc2hhcmVIZWFkZXIpO1xuICAgICAgICB0aGlzLl9zaGFyaW5nLmFwcGVuZENoaWxkKHNoYXJlQnV0dG9ucyk7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gTC5Eb21VdGlsLmNyZWF0ZSgnaW5wdXQnLCAnbWFwYm94LWVtYmVkJywgdGhpcy5fc2hhcmluZyk7XG4gICAgICAgIGlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlucHV0LnZhbHVlID0gZW1iZWRWYWx1ZTtcblxuICAgICAgICB2YXIgbGFiZWwgPSBMLkRvbVV0aWwuY3JlYXRlKCdsYWJlbCcsICdtYXBib3gtZW1iZWQtZGVzY3JpcHRpb24nLCB0aGlzLl9zaGFyaW5nKTtcbiAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gZW1iZWRMYWJlbDtcblxuICAgICAgICB2YXIgY2xvc2UgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgJ2xlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uJywgdGhpcy5fc2hhcmluZyk7XG4gICAgICAgIGNsb3NlLmhyZWYgPSAnIyc7XG5cbiAgICAgICAgTC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9zaGFyaW5nKTtcbiAgICAgICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjbG9zZSwgJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXQsIHRoaXMpO1xuICAgICAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGlucHV0LCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5mb2N1cygpO1xuICAgICAgICAgICAgZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5TaGFyZUNvbnRyb2wgPSBTaGFyZUNvbnRyb2w7XG5cbm1vZHVsZS5leHBvcnRzLnNoYXJlQ29udHJvbCA9IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNoYXJlQ29udHJvbChfLCBvcHRpb25zKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzaW1wbGVzdHlsZSBzcGVjIGZvciBwb2x5Z29uIGFuZCBsaW5lc3RyaW5nIGZlYXR1cmVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L3NpbXBsZXN0eWxlLXNwZWNcbnZhciBkZWZhdWx0cyA9IHtcbiAgICBzdHJva2U6ICcjNTU1NTU1JyxcbiAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAgIGZpbGw6ICcjNTU1NTU1JyxcbiAgICAnZmlsbC1vcGFjaXR5JzogMC41XG59O1xuXG52YXIgbWFwcGluZyA9IFtcbiAgICBbJ3N0cm9rZScsICdjb2xvciddLFxuICAgIFsnc3Ryb2tlLXdpZHRoJywgJ3dlaWdodCddLFxuICAgIFsnc3Ryb2tlLW9wYWNpdHknLCAnb3BhY2l0eSddLFxuICAgIFsnZmlsbCcsICdmaWxsQ29sb3InXSxcbiAgICBbJ2ZpbGwtb3BhY2l0eScsICdmaWxsT3BhY2l0eSddXG5dO1xuXG5mdW5jdGlvbiBmYWxsYmFjayhhLCBiKSB7XG4gICAgdmFyIGMgPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIGIpIHtcbiAgICAgICAgaWYgKGFba10gPT09IHVuZGVmaW5lZCkgY1trXSA9IGJba107XG4gICAgICAgIGVsc2UgY1trXSA9IGFba107XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiByZW1hcChhKSB7XG4gICAgdmFyIGQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHBpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZFttYXBwaW5nW2ldWzFdXSA9IGFbbWFwcGluZ1tpXVswXV07XG4gICAgfVxuICAgIHJldHVybiBkO1xufVxuXG5mdW5jdGlvbiBzdHlsZShmZWF0dXJlKSB7XG4gICAgcmV0dXJuIHJlbWFwKGZhbGxiYWNrKGZlYXR1cmUucHJvcGVydGllcyB8fCB7fSwgZGVmYXVsdHMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGRlZmF1bHRzOiBkZWZhdWx0c1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBmb3JtYXRfdXJsID0gcmVxdWlyZSgnLi9mb3JtYXRfdXJsJyk7XG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xuXG52YXIgU3R5bGVMYXllciA9IEwuVGlsZUxheWVyLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNhbml0aXplcjogcmVxdWlyZSgnc2FuaXRpemUtY2FqYScpXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICAgICAgTC5UaWxlTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy50aWxlcyA9IHRoaXMuX2Zvcm1hdFRpbGVVUkwoXyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSA9IDUxMjtcbiAgICAgICAgdGhpcy5vcHRpb25zLnpvb21PZmZzZXQgPSAtMTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRtcyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2dldEF0dHJpYnV0aW9uKF8pO1xuICAgIH0sXG5cbiAgICBfZ2V0QXR0cmlidXRpb246IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgdmFyIHN0eWxlVVJMID0gZm9ybWF0X3VybC5zdHlsZShfLCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmFjY2Vzc1Rva2VuKTtcbiAgICAgICAgcmVxdWVzdChzdHlsZVVSTCwgTC5iaW5kKGZ1bmN0aW9uKGVyciwgc3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmxvZygnY291bGQgbm90IGxvYWQgTWFwYm94IHN0eWxlIGF0ICcgKyBzdHlsZVVSTCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gc3R5bGUuc291cmNlcykge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzdHlsZS5zb3VyY2VzW2lkXS51cmwuc3BsaXQoJ21hcGJveDovLycpWzFdO1xuICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdChmb3JtYXRfdXJsLnRpbGVKU09OKHNvdXJjZXMuam9pbigpLCB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW4pLCBMLmJpbmQoZnVuY3Rpb24oZXJyLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmxvZygnY291bGQgbm90IGxvYWQgVGlsZUpTT04gYXQgJyArIF8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5zdHJpY3QoanNvbiwgJ29iamVjdCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbiA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoanNvbi5hdHRyaWJ1dGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGlsZWpzb24gPSBqc29uO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3JlYWR5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSxcblxuICAgIC8vIGRpc2FibGUgdGhlIHNldFVybCBmdW5jdGlvbiwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBvbiBtYXBib3ggdGlsZWxheWVyc1xuICAgIHNldFVybDogbnVsbCxcblxuICAgIF9mb3JtYXRUaWxlVVJMOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICB2YXIgcmV0aW5hID0gTC5Ccm93c2VyLnJldGluYSA/ICdAMngnIDogJyc7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZignbWFwYm94Oi8vc3R5bGVzLycpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHV0aWwubG9nKCdJbmNvcnJlY3RseSBmb3JtYXR0ZWQgTWFwYm94IHN0eWxlIGF0ICcgKyBzdHlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG93bmVySURTdHlsZSA9IHN0eWxlLnNwbGl0KCdtYXBib3g6Ly9zdHlsZXMvJylbMV07XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0X3VybCgnL3N0eWxlcy92MS8nICsgb3duZXJJRFN0eWxlICsgJy90aWxlcy97en0ve3h9L3t5fScgKyByZXRpbmEsIHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdF91cmwoJy9zdHlsZXMvdjEvJyArIHN0eWxlLm93bmVyICsgJy8nICsgc3R5bGUuaWQgKyAnL3RpbGVzL3t6fS97eH0ve3l9JyArIHJldGluYSwgdGhpcy5vcHRpb25zLmFjY2Vzc1Rva2VuKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyB0aGlzIGlzIGFuIGV4Y2VwdGlvbiB0byBtYXBib3guanMgbmFtaW5nIHJ1bGVzIGJlY2F1c2UgaXQncyBjYWxsZWRcbiAgICAvLyBieSBgTC5tYXBgXG4gICAgZ2V0VGlsZVVybDogZnVuY3Rpb24odGlsZVBvaW50KSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZWQgPSBMLlV0aWwudGVtcGxhdGUodGhpcy5vcHRpb25zLnRpbGVzLCB0aWxlUG9pbnQpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVkO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5TdHlsZUxheWVyID0gU3R5bGVMYXllcjtcblxubW9kdWxlLmV4cG9ydHMuc3R5bGVMYXllciA9IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlTGF5ZXIoXywgb3B0aW9ucyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGZvcm1hdFBhdHRlcm4gPSAvXFwuKCg/OnBuZ3xqcGcpXFxkKikoPz0kfFxcPykvO1xuXG52YXIgVGlsZUxheWVyID0gTC5UaWxlTGF5ZXIuZXh0ZW5kKHtcbiAgICBpbmNsdWRlczogW3JlcXVpcmUoJy4vbG9hZF90aWxlanNvbicpXSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2FuaXRpemVyOiByZXF1aXJlKCdzYW5pdGl6ZS1jYWphJylcbiAgICB9LFxuXG4gICAgLy8gaHR0cDovL21hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI2ltYWdlX3F1YWxpdHlcbiAgICBmb3JtYXRzOiBbXG4gICAgICAgICdwbmcnLCAnanBnJyxcbiAgICAgICAgLy8gUE5HXG4gICAgICAgICdwbmczMicsICdwbmc2NCcsICdwbmcxMjgnLCAncG5nMjU2JyxcbiAgICAgICAgLy8gSlBHXG4gICAgICAgICdqcGc3MCcsICdqcGc4MCcsICdqcGc5MCddLFxuXG4gICAgc2NhbGVQcmVmaXg6ICdAMnguJyxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICAgICAgTC5UaWxlTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX3RpbGVqc29uID0ge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHV0aWwuc3RyaWN0X29uZW9mKG9wdGlvbnMuZm9ybWF0LCB0aGlzLmZvcm1hdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9hZFRpbGVKU09OKF8pO1xuICAgIH0sXG5cbiAgICBzZXRGb3JtYXQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgdXRpbC5zdHJpY3QoXywgJ3N0cmluZycpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZm9ybWF0ID0gXztcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGRpc2FibGUgdGhlIHNldFVybCBmdW5jdGlvbiwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBvbiBtYXBib3ggdGlsZWxheWVyc1xuICAgIHNldFVybDogbnVsbCxcblxuICAgIF9zZXRUaWxlSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgICB1dGlsLnN0cmljdChqc29uLCAnb2JqZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmZvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQgfHxcbiAgICAgICAgICAgIGpzb24udGlsZXNbMF0ubWF0Y2goZm9ybWF0UGF0dGVybilbMV07XG5cbiAgICAgICAgTC5leHRlbmQodGhpcy5vcHRpb25zLCB7XG4gICAgICAgICAgICB0aWxlczoganNvbi50aWxlcyxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGpzb24uYXR0cmlidXRpb24pLFxuICAgICAgICAgICAgbWluWm9vbToganNvbi5taW56b29tIHx8IDAsXG4gICAgICAgICAgICBtYXhab29tOiBqc29uLm1heHpvb20gfHwgMTgsXG4gICAgICAgICAgICB0bXM6IGpzb24uc2NoZW1lID09PSAndG1zJyxcbiAgICAgICAgICAgIGJvdW5kczoganNvbi5ib3VuZHMgJiYgdXRpbC5sYm91bmRzKGpzb24uYm91bmRzKVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl90aWxlanNvbiA9IGpzb247XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRUaWxlSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlanNvbjtcbiAgICB9LFxuXG4gICAgLy8gdGhpcyBpcyBhbiBleGNlcHRpb24gdG8gbWFwYm94LmpzIG5hbWluZyBydWxlcyBiZWNhdXNlIGl0J3MgY2FsbGVkXG4gICAgLy8gYnkgYEwubWFwYFxuICAgIGdldFRpbGVVcmw6IGZ1bmN0aW9uKHRpbGVQb2ludCkge1xuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLm9wdGlvbnMudGlsZXMsXG4gICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aWxlcy5sZW5ndGgpLFxuICAgICAgICAgICAgdXJsID0gdGlsZXNbaW5kZXhdO1xuXG4gICAgICAgIHZhciB0ZW1wbGF0ZWQgPSBMLlV0aWwudGVtcGxhdGUodXJsLCB0aWxlUG9pbnQpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZWQucmVwbGFjZShmb3JtYXRQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIChMLkJyb3dzZXIucmV0aW5hID8gdGhpcy5zY2FsZVByZWZpeCA6ICcuJykgKyB0aGlzLm9wdGlvbnMuZm9ybWF0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUaWxlSlNPTi5UaWxlTGF5ZXJzIGFyZSBhZGRlZCB0byB0aGUgbWFwIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHRoZXkgZ2V0XG4gICAgLy8gdGhlIGRlc2lyZWQgei1pbmRleCwgYnV0IGRvIG5vdCB1cGRhdGUgdW50aWwgdGhlIFRpbGVKU09OIGhhcyBiZWVuIGxvYWRlZC5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aWxlcykge1xuICAgICAgICAgICAgTC5UaWxlTGF5ZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5UaWxlTGF5ZXIgPSBUaWxlTGF5ZXI7XG5cbm1vZHVsZS5leHBvcnRzLnRpbGVMYXllciA9IGZ1bmN0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbGVMYXllcihfLCBvcHRpb25zKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGl0ZW0sIGxpc3QpIHtcbiAgICBpZiAoIWxpc3QgfHwgIWxpc3QubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0W2ldID09PSBpdGVtKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpZFVybDogZnVuY3Rpb24oXywgdCkge1xuICAgICAgICBpZiAoXy5pbmRleE9mKCcvJykgPT09IC0xKSB0LmxvYWRJRChfKTtcbiAgICAgICAgZWxzZSB0LmxvYWRVUkwoXyk7XG4gICAgfSxcbiAgICBsb2c6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmljdDogZnVuY3Rpb24oXywgdHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIF8gIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudDogJyArIHR5cGUgKyAnIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmljdF9pbnN0YW5jZTogZnVuY3Rpb24oXywga2xhc3MsIG5hbWUpIHtcbiAgICAgICAgaWYgKCEoXyBpbnN0YW5jZW9mIGtsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiAnICsgbmFtZSArICcgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RyaWN0X29uZW9mOiBmdW5jdGlvbihfLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFjb250YWlucyhfLCB2YWx1ZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6ICcgKyBfICsgJyBnaXZlbiwgdmFsaWQgdmFsdWVzIGFyZSAnICtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmlwX3RhZ3M6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcmV0dXJuIF8ucmVwbGFjZSgvPFtePF0rPi9nLCAnJyk7XG4gICAgfSxcbiAgICBsYm91bmRzOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIC8vIGxlYWZsZXQtY29tcGF0aWJsZSBib3VuZHMsIHNpbmNlIGxlYWZsZXQgZG9lcyBub3QgZG8gZ2VvanNvblxuICAgICAgICByZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKFtbX1sxXSwgX1swXV0sIFtfWzNdLCBfWzJdXV0pO1xuICAgIH1cbn07XG4iLCIvKiFcbiAqIG11c3RhY2hlLmpzIC0gTG9naWMtbGVzcyB7e211c3RhY2hlfX0gdGVtcGxhdGVzIHdpdGggSmF2YVNjcmlwdFxuICogaHR0cDovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qc1xuICovXG5cbi8qZ2xvYmFsIGRlZmluZTogZmFsc2UgTXVzdGFjaGU6IHRydWUqL1xuXG4oZnVuY3Rpb24gZGVmaW5lTXVzdGFjaGUgKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgdHlwZW9mIGV4cG9ydHMubm9kZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTsgLy8gQ29tbW9uSlNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpOyAvLyBBTURcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuTXVzdGFjaGUgPSB7fTtcbiAgICBmYWN0b3J5KGdsb2JhbC5NdXN0YWNoZSk7IC8vIHNjcmlwdCwgd3NoLCBhc3BcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiBtdXN0YWNoZUZhY3RvcnkgKG11c3RhY2hlKSB7XG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICAgKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgKi9cbiAgZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG4gIH1cblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG4gIHZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuICBmdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBub25TcGFjZVJlID0gL1xcUy87XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnLyc6ICcmI3gyRjsnLFxuICAgICdgJzogJyYjeDYwOycsXG4gICAgJz0nOiAnJiN4M0Q7J1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwgKHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInYD1cXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2hpdGVSZSA9IC9cXHMqLztcbiAgdmFyIHNwYWNlUmUgPSAvXFxzKy87XG4gIHZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG4gIHZhciBjdXJseVJlID0gL1xccypcXH0vO1xuICB2YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuICAvKipcbiAgICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAgICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICAgKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAgICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICAgKlxuICAgKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gICAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gICAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAgICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gICAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAgICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gICAqXG4gICAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAgICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAgICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gICAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgaWYgKCF0ZW1wbGF0ZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZWN0aW9ucyA9IFtdOyAgICAgLy8gU3RhY2sgdG8gaG9sZCBzZWN0aW9uIHRva2Vuc1xuICAgIHZhciB0b2tlbnMgPSBbXTsgICAgICAgLy8gQnVmZmVyIHRvIGhvbGQgdGhlIHRva2Vuc1xuICAgIHZhciBzcGFjZXMgPSBbXTsgICAgICAgLy8gSW5kaWNlcyBvZiB3aGl0ZXNwYWNlIHRva2VucyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgdmFyIGhhc1RhZyA9IGZhbHNlOyAgICAvLyBJcyB0aGVyZSBhIHt7dGFnfX0gb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgICB2YXIgbm9uU3BhY2UgPSBmYWxzZTsgIC8vIElzIHRoZXJlIGEgbm9uLXNwYWNlIGNoYXIgb24gdGhlIGN1cnJlbnQgbGluZT9cblxuICAgIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gICAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGFzVGFnID0gZmFsc2U7XG4gICAgICBub25TcGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gICAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIH1cblxuICAgIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICAgIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICAgIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaChbICd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxIF0pO1xuICAgICAgICAgIHN0YXJ0ICs9IDE7XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3Igd2hpdGVzcGFjZSBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAgIGlmIChjaHIgPT09ICdcXG4nKVxuICAgICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBvcGVuaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKG9wZW5pbmdUYWdSZSkpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdDdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgICB0eXBlID0gJyYnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihjbG9zaW5nVGFnUmUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHRhZyBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcyBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJyMnIHx8IHR5cGUgPT09ICdeJykge1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIENoZWNrIHNlY3Rpb24gbmVzdGluZy5cbiAgICAgICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgICAgICBpZiAoIW9wZW5TZWN0aW9uKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5vcGVuZWQgc2VjdGlvbiBcIicgKyB2YWx1ZSArICdcIiBhdCAnICsgc3RhcnQpO1xuXG4gICAgICAgIGlmIChvcGVuU2VjdGlvblsxXSAhPT0gdmFsdWUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduYW1lJyB8fCB0eXBlID09PSAneycgfHwgdHlwZSA9PT0gJyYnKSB7XG4gICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIC8vIFNldCB0aGUgdGFncyBmb3IgdGhlIG5leHQgdGltZSBhcm91bmQuXG4gICAgICAgIGNvbXBpbGVUYWdzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG9wZW4gc2VjdGlvbnMgd2hlbiB3ZSdyZSBkb25lLlxuICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICBpZiAob3BlblNlY3Rpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICAgKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNxdWFzaFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIHNxdWFzaGVkVG9rZW5zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIGxhc3RUb2tlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbiAmJiBsYXN0VG9rZW5bMF0gPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlblsxXSArPSB0b2tlblsxXTtcbiAgICAgICAgICBsYXN0VG9rZW5bM10gPSB0b2tlblszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcXVhc2hlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcXVhc2hlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgaW50byBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZSB3aGVyZVxuICAgKiB0b2tlbnMgdGhhdCByZXByZXNlbnQgYSBzZWN0aW9uIGhhdmUgdHdvIGFkZGl0aW9uYWwgaXRlbXM6IDEpIGFuIGFycmF5IG9mXG4gICAqIGFsbCB0b2tlbnMgdGhhdCBhcHBlYXIgaW4gdGhhdCBzZWN0aW9uIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsXG4gICAqIHRlbXBsYXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoYXQgc2VjdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG5lc3RUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBuZXN0ZWRUb2tlbnMgPSBbXTtcbiAgICB2YXIgY29sbGVjdG9yID0gbmVzdGVkVG9rZW5zO1xuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBzZWN0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgIGNhc2UgJyMnOlxuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29sbGVjdG9yID0gdG9rZW5bNF0gPSBbXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuICAgICAgICAgIHNlY3Rpb25bNV0gPSB0b2tlblsyXTtcbiAgICAgICAgICBjb2xsZWN0b3IgPSBzZWN0aW9ucy5sZW5ndGggPiAwID8gc2VjdGlvbnNbc2VjdGlvbnMubGVuZ3RoIC0gMV1bNF0gOiBuZXN0ZWRUb2tlbnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXN0ZWRUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgc3RyaW5nIHNjYW5uZXIgdGhhdCBpcyB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZSBwYXJzZXIgdG8gZmluZFxuICAgKiB0b2tlbnMgaW4gdGVtcGxhdGUgc3RyaW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIFNjYW5uZXIgKHN0cmluZykge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMudGFpbCA9IHN0cmluZztcbiAgICB0aGlzLnBvcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRhaWwgaXMgZW1wdHkgKGVuZCBvZiBzdHJpbmcpLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuZW9zID0gZnVuY3Rpb24gZW9zICgpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsID09PSAnJztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZXMgdG8gbWF0Y2ggdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICogUmV0dXJucyB0aGUgbWF0Y2hlZCB0ZXh0IGlmIGl0IGNhbiBtYXRjaCwgdGhlIGVtcHR5IHN0cmluZyBvdGhlcndpc2UuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5zY2FuID0gZnVuY3Rpb24gc2NhbiAocmUpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnRhaWwubWF0Y2gocmUpO1xuXG4gICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCAhPT0gMClcbiAgICAgIHJldHVybiAnJztcblxuICAgIHZhciBzdHJpbmcgPSBtYXRjaFswXTtcblxuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCk7XG4gICAgdGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNraXBzIGFsbCB0ZXh0IHVudGlsIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gY2FuIGJlIG1hdGNoZWQuIFJldHVybnNcbiAgICogdGhlIHNraXBwZWQgc3RyaW5nLCB3aGljaCBpcyB0aGUgZW50aXJlIHRhaWwgaWYgbm8gbWF0Y2ggY2FuIGJlIG1hZGUuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVW50aWwgPSBmdW5jdGlvbiBzY2FuVW50aWwgKHJlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50YWlsLnNlYXJjaChyZSksIG1hdGNoO1xuXG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgbWF0Y2ggPSB0aGlzLnRhaWw7XG4gICAgICAgIHRoaXMudGFpbCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgbWF0Y2ggPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtYXRjaCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKGluZGV4KTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcyArPSBtYXRjaC5sZW5ndGg7XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSByZW5kZXJpbmcgY29udGV4dCBieSB3cmFwcGluZyBhIHZpZXcgb2JqZWN0IGFuZFxuICAgKiBtYWludGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBDb250ZXh0ICh2aWV3LCBwYXJlbnRDb250ZXh0KSB7XG4gICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB0aGlzLmNhY2hlID0geyAnLic6IHRoaXMudmlldyB9O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgdXNpbmcgdGhlIGdpdmVuIHZpZXcgd2l0aCB0aGlzIGNvbnRleHRcbiAgICogYXMgdGhlIHBhcmVudC5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoICh2aWV3KSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KHZpZXcsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGlzIGNvbnRleHQsIHRyYXZlcnNpbmdcbiAgICogdXAgdGhlIGNvbnRleHQgaGllcmFyY2h5IGlmIHRoZSB2YWx1ZSBpcyBhYnNlbnQgaW4gdGhpcyBjb250ZXh0J3Mgdmlldy5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cCAobmFtZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB2YWx1ZSA9IGNhY2hlW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIG5hbWVzLCBpbmRleCwgbG9va3VwSGl0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQudmlldztcbiAgICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2luZyB0aGUgZG90IG5vdGlvbiBwYXRoIGluIGBuYW1lYCwgd2UgZGVzY2VuZCB0aHJvdWdoIHRoZVxuICAgICAgICAgICAqIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVG8gYmUgY2VydGFpbiB0aGF0IHRoZSBsb29rdXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bCwgd2UgaGF2ZSB0b1xuICAgICAgICAgICAqIGNoZWNrIGlmIHRoZSBsYXN0IG9iamVjdCBpbiB0aGUgcGF0aCBhY3R1YWxseSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICogd2UgYXJlIGxvb2tpbmcgZm9yLiBXZSBzdG9yZSB0aGUgcmVzdWx0IGluIGBsb29rdXBIaXRgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyBzcGVjaWFsbHkgbmVjZXNzYXJ5IGZvciB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgICAgICAgKiBgdW5kZWZpbmVkYCBhbmQgd2Ugd2FudCB0byBhdm9pZCBsb29raW5nIHVwIHBhcmVudCBjb250ZXh0cy5cbiAgICAgICAgICAgKiovXG4gICAgICAgICAgd2hpbGUgKHZhbHVlICE9IG51bGwgJiYgaW5kZXggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbmFtZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgbG9va3VwSGl0ID0gaGFzUHJvcGVydHkodmFsdWUsIG5hbWVzW2luZGV4XSk7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbbmFtZXNbaW5kZXgrK11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQudmlld1tuYW1lXTtcbiAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eShjb250ZXh0LnZpZXcsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2t1cEhpdClcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKVxuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMudmlldyk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgV3JpdGVyIGtub3dzIGhvdyB0byB0YWtlIGEgc3RyZWFtIG9mIHRva2VucyBhbmQgcmVuZGVyIHRoZW0gdG8gYVxuICAgKiBzdHJpbmcsIGdpdmVuIGEgY29udGV4dC4gSXQgYWxzbyBtYWludGFpbnMgYSBjYWNoZSBvZiB0ZW1wbGF0ZXMgdG9cbiAgICogYXZvaWQgdGhlIG5lZWQgdG8gcGFyc2UgdGhlIHNhbWUgdGVtcGxhdGUgdHdpY2UuXG4gICAqL1xuICBmdW5jdGlvbiBXcml0ZXIgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiBgdGVtcGxhdGVgIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB0b2tlbnNcbiAgICogdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcGFyc2UuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdO1xuXG4gICAgaWYgKHRva2VucyA9PSBudWxsKVxuICAgICAgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGFncyk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWdoLWxldmVsIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHdpdGhcbiAgICogdGhlIGdpdmVuIGB2aWV3YC5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGBwYXJ0aWFsc2AgYXJndW1lbnQgbWF5IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiBuYW1lcyBhbmQgdGVtcGxhdGVzIG9mIHBhcnRpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLiBJdCBtYXlcbiAgICogYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBsb2FkIHBhcnRpYWwgdGVtcGxhdGVzIG9uIHRoZSBmbHlcbiAgICogdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UodGVtcGxhdGUpO1xuICAgIHZhciBjb250ZXh0ID0gKHZpZXcgaW5zdGFuY2VvZiBDb250ZXh0KSA/IHZpZXcgOiBuZXcgQ29udGV4dCh2aWV3KTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgdGVtcGxhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb3ctbGV2ZWwgbWV0aG9kIHRoYXQgcmVuZGVycyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgdXNpbmdcbiAgICogdGhlIGdpdmVuIGBjb250ZXh0YCBhbmQgYHBhcnRpYWxzYC5cbiAgICpcbiAgICogTm90ZTogVGhlIGBvcmlnaW5hbFRlbXBsYXRlYCBpcyBvbmx5IGV2ZXIgdXNlZCB0byBleHRyYWN0IHRoZSBwb3J0aW9uXG4gICAqIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjb250YWluZWQgaW4gYSBoaWdoZXItb3JkZXIgc2VjdGlvbi5cbiAgICogSWYgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucywgdGhpcyBhcmd1bWVudCBtYXlcbiAgICogYmUgb21pdHRlZC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyVG9rZW5zID0gZnVuY3Rpb24gcmVuZGVyVG9rZW5zICh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuXG4gICAgdmFyIHRva2VuLCBzeW1ib2wsIHZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBzeW1ib2wgPSB0b2tlblswXTtcblxuICAgICAgaWYgKHN5bWJvbCA9PT0gJyMnKSB2YWx1ZSA9IHRoaXMucmVuZGVyU2VjdGlvbih0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnXicpIHZhbHVlID0gdGhpcy5yZW5kZXJJbnZlcnRlZCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnPicpIHZhbHVlID0gdGhpcy5yZW5kZXJQYXJ0aWFsKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICcmJykgdmFsdWUgPSB0aGlzLnVuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ25hbWUnKSB2YWx1ZSA9IHRoaXMuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ3RleHQnKSB2YWx1ZSA9IHRoaXMucmF3VmFsdWUodG9rZW4pO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gcmVuZGVyU2VjdGlvbiAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBidWZmZXIgPSAnJztcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVuZGVyIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgIC8vIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYnkgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLlxuICAgIGZ1bmN0aW9uIHN1YlJlbmRlciAodGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMpO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUpIHJldHVybjtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yICh2YXIgaiA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBqIDwgdmFsdWVMZW5ndGg7ICsraikge1xuICAgICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZVtqXSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVGVtcGxhdGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zIHdpdGhvdXQgdGhlIG9yaWdpbmFsIHRlbXBsYXRlJyk7XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIHBvcnRpb24gb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgdGhlIHNlY3Rpb24gY29udGFpbnMuXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoY29udGV4dC52aWV3LCBvcmlnaW5hbFRlbXBsYXRlLnNsaWNlKHRva2VuWzNdLCB0b2tlbls1XSksIHN1YlJlbmRlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVySW52ZXJ0ZWQgPSBmdW5jdGlvbiByZW5kZXJJbnZlcnRlZCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gICAgLy8gVXNlIEphdmFTY3JpcHQncyBkZWZpbml0aW9uIG9mIGZhbHN5LiBJbmNsdWRlIGVtcHR5IGFycmF5cy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4NlxuICAgIGlmICghdmFsdWUgfHwgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclBhcnRpYWwgPSBmdW5jdGlvbiByZW5kZXJQYXJ0aWFsICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMpIHtcbiAgICBpZiAoIXBhcnRpYWxzKSByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKHBhcnRpYWxzKSA/IHBhcnRpYWxzKHRva2VuWzFdKSA6IHBhcnRpYWxzW3Rva2VuWzFdXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0aGlzLnBhcnNlKHZhbHVlKSwgY29udGV4dCwgcGFydGlhbHMsIHZhbHVlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnVuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gdW5lc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiBtdXN0YWNoZS5lc2NhcGUodmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmF3VmFsdWUgPSBmdW5jdGlvbiByYXdWYWx1ZSAodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW5bMV07XG4gIH07XG5cbiAgbXVzdGFjaGUubmFtZSA9ICdtdXN0YWNoZS5qcyc7XG4gIG11c3RhY2hlLnZlcnNpb24gPSAnMi4yLjEnO1xuICBtdXN0YWNoZS50YWdzID0gWyAne3snLCAnfX0nIF07XG5cbiAgLy8gQWxsIGhpZ2gtbGV2ZWwgbXVzdGFjaGUuKiBmdW5jdGlvbnMgdXNlIHRoaXMgd3JpdGVyLlxuICB2YXIgZGVmYXVsdFdyaXRlciA9IG5ldyBXcml0ZXIoKTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5jbGVhckNhY2hlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiB0ZW1wbGF0ZSBpbiB0aGUgZGVmYXVsdCB3cml0ZXIgYW5kIHJldHVybnMgdGhlXG4gICAqIGFycmF5IG9mIHRva2VucyBpdCBjb250YWlucy4gRG9pbmcgdGhpcyBhaGVhZCBvZiB0aW1lIGF2b2lkcyB0aGUgbmVlZCB0b1xuICAgKiBwYXJzZSB0ZW1wbGF0ZXMgb24gdGhlIGZseSBhcyB0aGV5IGFyZSByZW5kZXJlZC5cbiAgICovXG4gIG11c3RhY2hlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucGFyc2UodGVtcGxhdGUsIHRhZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBgdGVtcGxhdGVgIHdpdGggdGhlIGdpdmVuIGB2aWV3YCBhbmQgYHBhcnRpYWxzYCB1c2luZyB0aGVcbiAgICogZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBtdXN0YWNoZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscykge1xuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRlbXBsYXRlISBUZW1wbGF0ZSBzaG91bGQgYmUgYSBcInN0cmluZ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYnV0IFwiJyArIHR5cGVTdHIodGVtcGxhdGUpICsgJ1wiIHdhcyBnaXZlbiBhcyB0aGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudCBmb3IgbXVzdGFjaGUjcmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC40LnguLFxuICAvKmVzbGludC1kaXNhYmxlICovIC8vIGVzbGludCB3YW50cyBjYW1lbCBjYXNlZCBmdW5jdGlvbiBuYW1lXG4gIG11c3RhY2hlLnRvX2h0bWwgPSBmdW5jdGlvbiB0b19odG1sICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIHNlbmQpIHtcbiAgICAvKmVzbGludC1lbmFibGUqL1xuXG4gICAgdmFyIHJlc3VsdCA9IG11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VuZCkpIHtcbiAgICAgIHNlbmQocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBlc2NhcGluZyBmdW5jdGlvbiBzbyB0aGF0IHRoZSB1c2VyIG1heSBvdmVycmlkZSBpdC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8yNDRcbiAgbXVzdGFjaGUuZXNjYXBlID0gZXNjYXBlSHRtbDtcblxuICAvLyBFeHBvcnQgdGhlc2UgbWFpbmx5IGZvciB0ZXN0aW5nLCBidXQgYWxzbyBmb3IgYWR2YW5jZWQgdXNhZ2UuXG4gIG11c3RhY2hlLlNjYW5uZXIgPSBTY2FubmVyO1xuICBtdXN0YWNoZS5Db250ZXh0ID0gQ29udGV4dDtcbiAgbXVzdGFjaGUuV3JpdGVyID0gV3JpdGVyO1xuXG59KSk7XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJ2YXIgaHRtbF9zYW5pdGl6ZSA9IHJlcXVpcmUoJy4vc2FuaXRpemVyLWJ1bmRsZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIV8pIHJldHVybiAnJztcbiAgICByZXR1cm4gaHRtbF9zYW5pdGl6ZShfLCBjbGVhblVybCwgY2xlYW5JZCk7XG59O1xuXG4vLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yNTUxMDdcbmZ1bmN0aW9uIGNsZWFuVXJsKHVybCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAoL15odHRwcz8vLnRlc3QodXJsLmdldFNjaGVtZSgpKSkgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIGlmICgvXm1haWx0bz8vLnRlc3QodXJsLmdldFNjaGVtZSgpKSkgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIGlmICgnZGF0YScgPT0gdXJsLmdldFNjaGVtZSgpICYmIC9eaW1hZ2UvLnRlc3QodXJsLmdldFBhdGgoKSkpIHtcbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5JZChpZCkgeyByZXR1cm4gaWQ7IH1cbiIsIlxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIEdvb2dsZSBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBJbXBsZW1lbnRzIFJGQyAzOTg2IGZvciBwYXJzaW5nL2Zvcm1hdHRpbmcgVVJJcy5cbiAqXG4gKiBAYXV0aG9yIG1pa2VzYW11ZWxAZ21haWwuY29tXG4gKiBcXEBwcm92aWRlcyBVUklcbiAqIFxcQG92ZXJyaWRlcyB3aW5kb3dcbiAqL1xuXG52YXIgVVJJID0gKGZ1bmN0aW9uICgpIHtcblxuLyoqXG4gKiBjcmVhdGVzIGEgdXJpIGZyb20gdGhlIHN0cmluZyBmb3JtLiAgVGhlIHBhcnNlciBpcyByZWxheGVkLCBzbyBzcGVjaWFsXG4gKiBjaGFyYWN0ZXJzIHRoYXQgYXJlbid0IGVzY2FwZWQgYnV0IGRvbid0IGNhdXNlIGFtYmlndWl0aWVzIHdpbGwgbm90IGNhdXNlXG4gKiBwYXJzZSBmYWlsdXJlcy5cbiAqXG4gKiBAcmV0dXJuIHtVUkl8bnVsbH1cbiAqL1xuZnVuY3Rpb24gcGFyc2UodXJpU3RyKSB7XG4gIHZhciBtID0gKCcnICsgdXJpU3RyKS5tYXRjaChVUklfUkVfKTtcbiAgaWYgKCFtKSB7IHJldHVybiBudWxsOyB9XG4gIHJldHVybiBuZXcgVVJJKFxuICAgICAgbnVsbElmQWJzZW50KG1bMV0pLFxuICAgICAgbnVsbElmQWJzZW50KG1bMl0pLFxuICAgICAgbnVsbElmQWJzZW50KG1bM10pLFxuICAgICAgbnVsbElmQWJzZW50KG1bNF0pLFxuICAgICAgbnVsbElmQWJzZW50KG1bNV0pLFxuICAgICAgbnVsbElmQWJzZW50KG1bNl0pLFxuICAgICAgbnVsbElmQWJzZW50KG1bN10pKTtcbn1cblxuXG4vKipcbiAqIGNyZWF0ZXMgYSB1cmkgZnJvbSB0aGUgZ2l2ZW4gcGFydHMuXG4gKlxuICogQHBhcmFtIHNjaGVtZSB7c3RyaW5nfSBhbiB1bmVuY29kZWQgc2NoZW1lIHN1Y2ggYXMgXCJodHRwXCIgb3IgbnVsbFxuICogQHBhcmFtIGNyZWRlbnRpYWxzIHtzdHJpbmd9IHVuZW5jb2RlZCB1c2VyIGNyZWRlbnRpYWxzIG9yIG51bGxcbiAqIEBwYXJhbSBkb21haW4ge3N0cmluZ30gYW4gdW5lbmNvZGVkIGRvbWFpbiBuYW1lIG9yIG51bGxcbiAqIEBwYXJhbSBwb3J0IHtudW1iZXJ9IGEgcG9ydCBudW1iZXIgaW4gWzEsIDMyNzY4XS5cbiAqICAgIC0xIGluZGljYXRlcyBubyBwb3J0LCBhcyBkb2VzIG51bGwuXG4gKiBAcGFyYW0gcGF0aCB7c3RyaW5nfSBhbiB1bmVuY29kZWQgcGF0aFxuICogQHBhcmFtIHF1ZXJ5IHtBcnJheS48c3RyaW5nPnxzdHJpbmd8bnVsbH0gYSBsaXN0IG9mIHVuZW5jb2RlZCBjZ2lcbiAqICAgcGFyYW1ldGVycyB3aGVyZSBldmVuIHZhbHVlcyBhcmUga2V5cyBhbmQgb2RkcyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAqICAgb3IgYW4gdW5lbmNvZGVkIHF1ZXJ5LlxuICogQHBhcmFtIGZyYWdtZW50IHtzdHJpbmd9IGFuIHVuZW5jb2RlZCBmcmFnbWVudCB3aXRob3V0IHRoZSBcIiNcIiBvciBudWxsLlxuICogQHJldHVybiB7VVJJfVxuICovXG5mdW5jdGlvbiBjcmVhdGUoc2NoZW1lLCBjcmVkZW50aWFscywgZG9tYWluLCBwb3J0LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQpIHtcbiAgdmFyIHVyaSA9IG5ldyBVUkkoXG4gICAgICBlbmNvZGVJZkV4aXN0czIoc2NoZW1lLCBVUklfRElTQUxMT1dFRF9JTl9TQ0hFTUVfT1JfQ1JFREVOVElBTFNfKSxcbiAgICAgIGVuY29kZUlmRXhpc3RzMihcbiAgICAgICAgICBjcmVkZW50aWFscywgVVJJX0RJU0FMTE9XRURfSU5fU0NIRU1FX09SX0NSRURFTlRJQUxTXyksXG4gICAgICBlbmNvZGVJZkV4aXN0cyhkb21haW4pLFxuICAgICAgcG9ydCA+IDAgPyBwb3J0LnRvU3RyaW5nKCkgOiBudWxsLFxuICAgICAgZW5jb2RlSWZFeGlzdHMyKHBhdGgsIFVSSV9ESVNBTExPV0VEX0lOX1BBVEhfKSxcbiAgICAgIG51bGwsXG4gICAgICBlbmNvZGVJZkV4aXN0cyhmcmFnbWVudCkpO1xuICBpZiAocXVlcnkpIHtcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBxdWVyeSkge1xuICAgICAgdXJpLnNldFJhd1F1ZXJ5KHF1ZXJ5LnJlcGxhY2UoL1tePyY9MC05QS1aYS16X1xcLX4uJV0vZywgZW5jb2RlT25lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVyaS5zZXRBbGxQYXJhbWV0ZXJzKHF1ZXJ5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVyaTtcbn1cbmZ1bmN0aW9uIGVuY29kZUlmRXhpc3RzKHVuZXNjYXBlZFBhcnQpIHtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1bmVzY2FwZWRQYXJ0KSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZWRQYXJ0KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIGlmIHVuZXNjYXBlZFBhcnQgaXMgbm9uIG51bGwsIHRoZW4gZXNjYXBlcyBhbnkgY2hhcmFjdGVycyBpbiBpdCB0aGF0IGFyZW4ndFxuICogdmFsaWQgY2hhcmFjdGVycyBpbiBhIHVybCBhbmQgYWxzbyBlc2NhcGVzIGFueSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdFxuICogYXBwZWFyIGluIGV4dHJhLlxuICpcbiAqIEBwYXJhbSB1bmVzY2FwZWRQYXJ0IHtzdHJpbmd9XG4gKiBAcGFyYW0gZXh0cmEge1JlZ0V4cH0gYSBjaGFyYWN0ZXIgc2V0IG9mIGNoYXJhY3RlcnMgaW4gW1xcMDEtXFwxNzddLlxuICogQHJldHVybiB7c3RyaW5nfG51bGx9IG51bGwgaWZmIHVuZXNjYXBlZFBhcnQgPT0gbnVsbC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlSWZFeGlzdHMyKHVuZXNjYXBlZFBhcnQsIGV4dHJhKSB7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdW5lc2NhcGVkUGFydCkge1xuICAgIHJldHVybiBlbmNvZGVVUkkodW5lc2NhcGVkUGFydCkucmVwbGFjZShleHRyYSwgZW5jb2RlT25lKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4vKiogY29udmVydHMgYSBjaGFyYWN0ZXIgaW4gW1xcMDEtXFwxNzddIHRvIGl0cyB1cmwgZW5jb2RlZCBlcXVpdmFsZW50LiAqL1xuZnVuY3Rpb24gZW5jb2RlT25lKGNoKSB7XG4gIHZhciBuID0gY2guY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuICclJyArICcwMTIzNDU2Nzg5QUJDREVGJy5jaGFyQXQoKG4gPj4gNCkgJiAweGYpICtcbiAgICAgICcwMTIzNDU2Nzg5QUJDREVGJy5jaGFyQXQobiAmIDB4Zik7XG59XG5cbi8qKlxuICoge0B1cGRvY1xuICogICQgbm9ybVBhdGgoJ2Zvby8uL2JhcicpXG4gKiAgIyAnZm9vL2JhcidcbiAqICAkIG5vcm1QYXRoKCcuL2ZvbycpXG4gKiAgIyAnZm9vJ1xuICogICQgbm9ybVBhdGgoJ2Zvby8uJylcbiAqICAjICdmb28nXG4gKiAgJCBub3JtUGF0aCgnZm9vLy9iYXInKVxuICogICMgJ2Zvby9iYXInXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIG5vcm1QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvKF58XFwvKVxcLig/OlxcL3wkKS9nLCAnJDEnKS5yZXBsYWNlKC9cXC97Mix9L2csICcvJyk7XG59XG5cbnZhciBQQVJFTlRfRElSRUNUT1JZX0hBTkRMRVIgPSBuZXcgUmVnRXhwKFxuICAgICcnXG4gICAgLy8gQSBwYXRoIGJyZWFrXG4gICAgKyAnKC98XiknXG4gICAgLy8gZm9sbG93ZWQgYnkgYSBub24gLi4gcGF0aCBlbGVtZW50XG4gICAgLy8gKGNhbm5vdCBiZSAuIGJlY2F1c2Ugbm9ybVBhdGggaXMgdXNlZCBwcmlvciB0byB0aGlzIFJlZ0V4cClcbiAgICArICcoPzpbXi4vXVteL10qfFxcXFwuezIsfSg/OlteLi9dW14vXSopfFxcXFwuezMsfVteL10qKSdcbiAgICAvLyBmb2xsb3dlZCBieSAuLiBmb2xsb3dlZCBieSBhIHBhdGggYnJlYWsuXG4gICAgKyAnL1xcXFwuXFxcXC4oPzovfCQpJyk7XG5cbnZhciBQQVJFTlRfRElSRUNUT1JZX0hBTkRMRVJfUkUgPSBuZXcgUmVnRXhwKFBBUkVOVF9ESVJFQ1RPUllfSEFORExFUik7XG5cbnZhciBFWFRSQV9QQVJFTlRfUEFUSFNfUkUgPSAvXig/OlxcLlxcLlxcLykqKD86XFwuXFwuJCk/LztcblxuLyoqXG4gKiBOb3JtYWxpemVzIGl0cyBpbnB1dCBwYXRoIGFuZCBjb2xsYXBzZXMgYWxsIC4gYW5kIC4uIHNlcXVlbmNlcyBleGNlcHQgZm9yXG4gKiAuLiBzZXF1ZW5jZXMgdGhhdCB3b3VsZCB0YWtlIGl0IGFib3ZlIHRoZSByb290IG9mIHRoZSBjdXJyZW50IHBhcmVudFxuICogZGlyZWN0b3J5LlxuICoge0B1cGRvY1xuICogICQgY29sbGFwc2VfZG90cygnZm9vLy4uL2JhcicpXG4gKiAgIyAnYmFyJ1xuICogICQgY29sbGFwc2VfZG90cygnZm9vLy4vYmFyJylcbiAqICAjICdmb28vYmFyJ1xuICogICQgY29sbGFwc2VfZG90cygnZm9vLy4uL2Jhci8uLy4uLy4uL2JheicpXG4gKiAgIyAnYmF6J1xuICogICQgY29sbGFwc2VfZG90cygnLi4vZm9vJylcbiAqICAjICcuLi9mb28nXG4gKiAgJCBjb2xsYXBzZV9kb3RzKCcuLi9mb28nKS5yZXBsYWNlKEVYVFJBX1BBUkVOVF9QQVRIU19SRSwgJycpXG4gKiAgIyAnZm9vJ1xuICogfVxuICovXG5mdW5jdGlvbiBjb2xsYXBzZV9kb3RzKHBhdGgpIHtcbiAgaWYgKHBhdGggPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgdmFyIHAgPSBub3JtUGF0aChwYXRoKTtcbiAgLy8gT25seSAvLi4vIGxlZnQgdG8gZmxhdHRlblxuICB2YXIgciA9IFBBUkVOVF9ESVJFQ1RPUllfSEFORExFUl9SRTtcbiAgLy8gV2UgcmVwbGFjZSB3aXRoICQxIHdoaWNoIG1hdGNoZXMgYSAvIGJlZm9yZSB0aGUgLi4gYmVjYXVzZSB0aGlzXG4gIC8vIGd1YXJhbnRlZXMgdGhhdDpcbiAgLy8gKDEpIHdlIGhhdmUgYXQgbW9zdCAxIC8gYmV0d2VlbiB0aGUgYWRqYWNlbnQgcGxhY2UsXG4gIC8vICgyKSBhbHdheXMgaGF2ZSBhIHNsYXNoIGlmIHRoZXJlIGlzIGEgcHJlY2VkaW5nIHBhdGggc2VjdGlvbiwgYW5kXG4gIC8vICgzKSB3ZSBuZXZlciB0dXJuIGEgcmVsYXRpdmUgcGF0aCBpbnRvIGFuIGFic29sdXRlIHBhdGguXG4gIGZvciAodmFyIHE7IChxID0gcC5yZXBsYWNlKHIsICckMScpKSAhPSBwOyBwID0gcSkge307XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIHJlc29sdmVzIGEgcmVsYXRpdmUgdXJsIHN0cmluZyB0byBhIGJhc2UgdXJpLlxuICogQHJldHVybiB7VVJJfVxuICovXG5mdW5jdGlvbiByZXNvbHZlKGJhc2VVcmksIHJlbGF0aXZlVXJpKSB7XG4gIC8vIHRoZXJlIGFyZSBzZXZlcmFsIGtpbmRzIG9mIHJlbGF0aXZlIHVybHM6XG4gIC8vIDEuIC8vZm9vIC0gcmVwbGFjZXMgZXZlcnl0aGluZyBmcm9tIHRoZSBkb21haW4gb24uICBmb28gaXMgYSBkb21haW4gbmFtZVxuICAvLyAyLiBmb28gLSByZXBsYWNlcyB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBwYXRoLCB0aGUgd2hvbGUgcXVlcnkgYW5kIGZyYWdtZW50XG4gIC8vIDMuIC9mb28gLSByZXBsYWNlcyB0aGUgdGhlIHBhdGgsIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnRcbiAgLy8gNC4gP2ZvbyAtIHJlcGxhY2UgdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudFxuICAvLyA1LiAjZm9vIC0gcmVwbGFjZSB0aGUgZnJhZ21lbnQgb25seVxuXG4gIHZhciBhYnNvbHV0ZVVyaSA9IGJhc2VVcmkuY2xvbmUoKTtcbiAgLy8gd2Ugc2F0aXNmeSB0aGVzZSBjb25kaXRpb25zIGJ5IGxvb2tpbmcgZm9yIHRoZSBmaXJzdCBwYXJ0IG9mIHJlbGF0aXZlVXJpXG4gIC8vIHRoYXQgaXMgbm90IGJsYW5rIGFuZCBhcHBseWluZyBkZWZhdWx0cyB0byB0aGUgcmVzdFxuXG4gIHZhciBvdmVycmlkZGVuID0gcmVsYXRpdmVVcmkuaGFzU2NoZW1lKCk7XG5cbiAgaWYgKG92ZXJyaWRkZW4pIHtcbiAgICBhYnNvbHV0ZVVyaS5zZXRSYXdTY2hlbWUocmVsYXRpdmVVcmkuZ2V0UmF3U2NoZW1lKCkpO1xuICB9IGVsc2Uge1xuICAgIG92ZXJyaWRkZW4gPSByZWxhdGl2ZVVyaS5oYXNDcmVkZW50aWFscygpO1xuICB9XG5cbiAgaWYgKG92ZXJyaWRkZW4pIHtcbiAgICBhYnNvbHV0ZVVyaS5zZXRSYXdDcmVkZW50aWFscyhyZWxhdGl2ZVVyaS5nZXRSYXdDcmVkZW50aWFscygpKTtcbiAgfSBlbHNlIHtcbiAgICBvdmVycmlkZGVuID0gcmVsYXRpdmVVcmkuaGFzRG9tYWluKCk7XG4gIH1cblxuICBpZiAob3ZlcnJpZGRlbikge1xuICAgIGFic29sdXRlVXJpLnNldFJhd0RvbWFpbihyZWxhdGl2ZVVyaS5nZXRSYXdEb21haW4oKSk7XG4gIH0gZWxzZSB7XG4gICAgb3ZlcnJpZGRlbiA9IHJlbGF0aXZlVXJpLmhhc1BvcnQoKTtcbiAgfVxuXG4gIHZhciByYXdQYXRoID0gcmVsYXRpdmVVcmkuZ2V0UmF3UGF0aCgpO1xuICB2YXIgc2ltcGxpZmllZFBhdGggPSBjb2xsYXBzZV9kb3RzKHJhd1BhdGgpO1xuICBpZiAob3ZlcnJpZGRlbikge1xuICAgIGFic29sdXRlVXJpLnNldFBvcnQocmVsYXRpdmVVcmkuZ2V0UG9ydCgpKTtcbiAgICBzaW1wbGlmaWVkUGF0aCA9IHNpbXBsaWZpZWRQYXRoXG4gICAgICAgICYmIHNpbXBsaWZpZWRQYXRoLnJlcGxhY2UoRVhUUkFfUEFSRU5UX1BBVEhTX1JFLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgb3ZlcnJpZGRlbiA9ICEhcmF3UGF0aDtcbiAgICBpZiAob3ZlcnJpZGRlbikge1xuICAgICAgLy8gcmVzb2x2ZSBwYXRoIHByb3Blcmx5XG4gICAgICBpZiAoc2ltcGxpZmllZFBhdGguY2hhckNvZGVBdCgwKSAhPT0gMHgyZiAvKiAvICovKSB7ICAvLyBwYXRoIGlzIHJlbGF0aXZlXG4gICAgICAgIHZhciBhYnNSYXdQYXRoID0gY29sbGFwc2VfZG90cyhhYnNvbHV0ZVVyaS5nZXRSYXdQYXRoKCkgfHwgJycpXG4gICAgICAgICAgICAucmVwbGFjZShFWFRSQV9QQVJFTlRfUEFUSFNfUkUsICcnKTtcbiAgICAgICAgdmFyIHNsYXNoID0gYWJzUmF3UGF0aC5sYXN0SW5kZXhPZignLycpICsgMTtcbiAgICAgICAgc2ltcGxpZmllZFBhdGggPSBjb2xsYXBzZV9kb3RzKFxuICAgICAgICAgICAgKHNsYXNoID8gYWJzUmF3UGF0aC5zdWJzdHJpbmcoMCwgc2xhc2gpIDogJycpXG4gICAgICAgICAgICArIGNvbGxhcHNlX2RvdHMocmF3UGF0aCkpXG4gICAgICAgICAgICAucmVwbGFjZShFWFRSQV9QQVJFTlRfUEFUSFNfUkUsICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2ltcGxpZmllZFBhdGggPSBzaW1wbGlmaWVkUGF0aFxuICAgICAgICAgICYmIHNpbXBsaWZpZWRQYXRoLnJlcGxhY2UoRVhUUkFfUEFSRU5UX1BBVEhTX1JFLCAnJyk7XG4gICAgICBpZiAoc2ltcGxpZmllZFBhdGggIT09IHJhd1BhdGgpIHtcbiAgICAgICAgYWJzb2x1dGVVcmkuc2V0UmF3UGF0aChzaW1wbGlmaWVkUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG92ZXJyaWRkZW4pIHtcbiAgICBhYnNvbHV0ZVVyaS5zZXRSYXdQYXRoKHNpbXBsaWZpZWRQYXRoKTtcbiAgfSBlbHNlIHtcbiAgICBvdmVycmlkZGVuID0gcmVsYXRpdmVVcmkuaGFzUXVlcnkoKTtcbiAgfVxuXG4gIGlmIChvdmVycmlkZGVuKSB7XG4gICAgYWJzb2x1dGVVcmkuc2V0UmF3UXVlcnkocmVsYXRpdmVVcmkuZ2V0UmF3UXVlcnkoKSk7XG4gIH0gZWxzZSB7XG4gICAgb3ZlcnJpZGRlbiA9IHJlbGF0aXZlVXJpLmhhc0ZyYWdtZW50KCk7XG4gIH1cblxuICBpZiAob3ZlcnJpZGRlbikge1xuICAgIGFic29sdXRlVXJpLnNldFJhd0ZyYWdtZW50KHJlbGF0aXZlVXJpLmdldFJhd0ZyYWdtZW50KCkpO1xuICB9XG5cbiAgcmV0dXJuIGFic29sdXRlVXJpO1xufVxuXG4vKipcbiAqIGEgbXV0YWJsZSBVUkkuXG4gKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBzZXR0ZXJzIGFuZCBnZXR0ZXJzIGZvciB0aGUgcGFydHMgb2YgdGhlIFVSSS5cbiAqIFRoZSA8dHQ+Z2V0WFlaPC90dD4vPHR0PnNldFhZWjwvdHQ+IG1ldGhvZHMgcmV0dXJuIHRoZSBkZWNvZGVkIHBhcnQgLS0gc29cbiAqIDxjb2RlPnVyaS5wYXJzZSgnL2ZvbyUyMGJhcicpLmdldFBhdGgoKTwvY29kZT4gd2lsbCByZXR1cm4gdGhlIGRlY29kZWQgcGF0aCxcbiAqIDx0dD4vZm9vIGJhcjwvdHQ+LlxuICpcbiAqIDxwPlRoZSByYXcgdmVyc2lvbnMgb2YgZmllbGRzIGFyZSBhdmFpbGFibGUgdG9vLlxuICogPGNvZGU+dXJpLnBhcnNlKCcvZm9vJTIwYmFyJykuZ2V0UmF3UGF0aCgpPC9jb2RlPiB3aWxsIHJldHVybiB0aGUgcmF3IHBhdGgsXG4gKiA8dHQ+L2ZvbyUyMGJhcjwvdHQ+LiAgVXNlIHRoZSByYXcgc2V0dGVycyB3aXRoIGNhcmUsIHNpbmNlXG4gKiA8Y29kZT5VUkk6OnRvU3RyaW5nPC9jb2RlPiBpcyBub3QgZ3VhcmFudGVlZCB0byByZXR1cm4gYSB2YWxpZCB1cmwgaWYgYVxuICogcmF3IHNldHRlciB3YXMgdXNlZC5cbiAqXG4gKiA8cD5BbGwgc2V0dGVycyByZXR1cm4gPHR0PnRoaXM8L3R0PiBhbmQgc28gbWF5IGJlIGNoYWluZWQsIGEgbGFcbiAqIDxjb2RlPnVyaS5wYXJzZSgnL2ZvbycpLnNldEZyYWdtZW50KCdwYXJ0JykudG9TdHJpbmcoKTwvY29kZT4uXG4gKlxuICogPHA+WW91IHNob3VsZCBub3QgdXNlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkgLS0gcGxlYXNlIHByZWZlciB0aGUgZmFjdG9yeVxuICogZnVuY3Rpb25zIHtAbGluayB1cmkucGFyc2V9LCB7QGxpbmsgdXJpLmNyZWF0ZX0sIHtAbGluayB1cmkucmVzb2x2ZX1cbiAqIGluc3RlYWQuPC9wPlxuICpcbiAqIDxwPlRoZSBwYXJhbWV0ZXJzIGFyZSBhbGwgcmF3IChhc3N1bWVkIHRvIGJlIHByb3Blcmx5IGVzY2FwZWQpIHBhcnRzLCBhbmRcbiAqIGFueSAoYnV0IG5vdCBhbGwpIG1heSBiZSBudWxsLiAgVW5kZWZpbmVkIGlzIG5vdCBhbGxvd2VkLjwvcD5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVVJJKFxuICAgIHJhd1NjaGVtZSxcbiAgICByYXdDcmVkZW50aWFscywgcmF3RG9tYWluLCBwb3J0LFxuICAgIHJhd1BhdGgsIHJhd1F1ZXJ5LCByYXdGcmFnbWVudCkge1xuICB0aGlzLnNjaGVtZV8gPSByYXdTY2hlbWU7XG4gIHRoaXMuY3JlZGVudGlhbHNfID0gcmF3Q3JlZGVudGlhbHM7XG4gIHRoaXMuZG9tYWluXyA9IHJhd0RvbWFpbjtcbiAgdGhpcy5wb3J0XyA9IHBvcnQ7XG4gIHRoaXMucGF0aF8gPSByYXdQYXRoO1xuICB0aGlzLnF1ZXJ5XyA9IHJhd1F1ZXJ5O1xuICB0aGlzLmZyYWdtZW50XyA9IHJhd0ZyYWdtZW50O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5fG51bGx9XG4gICAqL1xuICB0aGlzLnBhcmFtQ2FjaGVfID0gbnVsbDtcbn1cblxuLyoqIHJldHVybnMgdGhlIHN0cmluZyBmb3JtIG9mIHRoZSB1cmwuICovXG5VUkkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGlmIChudWxsICE9PSB0aGlzLnNjaGVtZV8pIHsgb3V0LnB1c2godGhpcy5zY2hlbWVfLCAnOicpOyB9XG4gIGlmIChudWxsICE9PSB0aGlzLmRvbWFpbl8pIHtcbiAgICBvdXQucHVzaCgnLy8nKTtcbiAgICBpZiAobnVsbCAhPT0gdGhpcy5jcmVkZW50aWFsc18pIHsgb3V0LnB1c2godGhpcy5jcmVkZW50aWFsc18sICdAJyk7IH1cbiAgICBvdXQucHVzaCh0aGlzLmRvbWFpbl8pO1xuICAgIGlmIChudWxsICE9PSB0aGlzLnBvcnRfKSB7IG91dC5wdXNoKCc6JywgdGhpcy5wb3J0Xy50b1N0cmluZygpKTsgfVxuICB9XG4gIGlmIChudWxsICE9PSB0aGlzLnBhdGhfKSB7IG91dC5wdXNoKHRoaXMucGF0aF8pOyB9XG4gIGlmIChudWxsICE9PSB0aGlzLnF1ZXJ5XykgeyBvdXQucHVzaCgnPycsIHRoaXMucXVlcnlfKTsgfVxuICBpZiAobnVsbCAhPT0gdGhpcy5mcmFnbWVudF8pIHsgb3V0LnB1c2goJyMnLCB0aGlzLmZyYWdtZW50Xyk7IH1cbiAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn07XG5cblVSSS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgVVJJKHRoaXMuc2NoZW1lXywgdGhpcy5jcmVkZW50aWFsc18sIHRoaXMuZG9tYWluXywgdGhpcy5wb3J0XyxcbiAgICAgICAgICAgICAgICAgdGhpcy5wYXRoXywgdGhpcy5xdWVyeV8sIHRoaXMuZnJhZ21lbnRfKTtcbn07XG5cblVSSS5wcm90b3R5cGUuZ2V0U2NoZW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBIVE1MNSBzcGVjIGRvZXMgbm90IHJlcXVpcmUgdGhlIHNjaGVtZSB0byBiZSBsb3dlcmNhc2VkIGJ1dFxuICAvLyBhbGwgY29tbW9uIGJyb3dzZXJzIGV4Y2VwdCBTYWZhcmkgbG93ZXJjYXNlIHRoZSBzY2hlbWUuXG4gIHJldHVybiB0aGlzLnNjaGVtZV8gJiYgZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuc2NoZW1lXykudG9Mb3dlckNhc2UoKTtcbn07XG5VUkkucHJvdG90eXBlLmdldFJhd1NjaGVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2NoZW1lXztcbn07XG5VUkkucHJvdG90eXBlLnNldFNjaGVtZSA9IGZ1bmN0aW9uIChuZXdTY2hlbWUpIHtcbiAgdGhpcy5zY2hlbWVfID0gZW5jb2RlSWZFeGlzdHMyKFxuICAgICAgbmV3U2NoZW1lLCBVUklfRElTQUxMT1dFRF9JTl9TQ0hFTUVfT1JfQ1JFREVOVElBTFNfKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuVVJJLnByb3RvdHlwZS5zZXRSYXdTY2hlbWUgPSBmdW5jdGlvbiAobmV3U2NoZW1lKSB7XG4gIHRoaXMuc2NoZW1lXyA9IG5ld1NjaGVtZSA/IG5ld1NjaGVtZSA6IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblVSSS5wcm90b3R5cGUuaGFzU2NoZW1lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbCAhPT0gdGhpcy5zY2hlbWVfO1xufTtcblxuXG5VUkkucHJvdG90eXBlLmdldENyZWRlbnRpYWxzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jcmVkZW50aWFsc18gJiYgZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuY3JlZGVudGlhbHNfKTtcbn07XG5VUkkucHJvdG90eXBlLmdldFJhd0NyZWRlbnRpYWxzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jcmVkZW50aWFsc187XG59O1xuVVJJLnByb3RvdHlwZS5zZXRDcmVkZW50aWFscyA9IGZ1bmN0aW9uIChuZXdDcmVkZW50aWFscykge1xuICB0aGlzLmNyZWRlbnRpYWxzXyA9IGVuY29kZUlmRXhpc3RzMihcbiAgICAgIG5ld0NyZWRlbnRpYWxzLCBVUklfRElTQUxMT1dFRF9JTl9TQ0hFTUVfT1JfQ1JFREVOVElBTFNfKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5VUkkucHJvdG90eXBlLnNldFJhd0NyZWRlbnRpYWxzID0gZnVuY3Rpb24gKG5ld0NyZWRlbnRpYWxzKSB7XG4gIHRoaXMuY3JlZGVudGlhbHNfID0gbmV3Q3JlZGVudGlhbHMgPyBuZXdDcmVkZW50aWFscyA6IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblVSSS5wcm90b3R5cGUuaGFzQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBudWxsICE9PSB0aGlzLmNyZWRlbnRpYWxzXztcbn07XG5cblxuVVJJLnByb3RvdHlwZS5nZXREb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRvbWFpbl8gJiYgZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuZG9tYWluXyk7XG59O1xuVVJJLnByb3RvdHlwZS5nZXRSYXdEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRvbWFpbl87XG59O1xuVVJJLnByb3RvdHlwZS5zZXREb21haW4gPSBmdW5jdGlvbiAobmV3RG9tYWluKSB7XG4gIHJldHVybiB0aGlzLnNldFJhd0RvbWFpbihuZXdEb21haW4gJiYgZW5jb2RlVVJJQ29tcG9uZW50KG5ld0RvbWFpbikpO1xufTtcblVSSS5wcm90b3R5cGUuc2V0UmF3RG9tYWluID0gZnVuY3Rpb24gKG5ld0RvbWFpbikge1xuICB0aGlzLmRvbWFpbl8gPSBuZXdEb21haW4gPyBuZXdEb21haW4gOiBudWxsO1xuICAvLyBNYWludGFpbiB0aGUgaW52YXJpYW50IHRoYXQgcGF0aHMgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2ggd2hlbiB0aGUgVVJJXG4gIC8vIGlzIG5vdCBwYXRoLXJlbGF0aXZlLlxuICByZXR1cm4gdGhpcy5zZXRSYXdQYXRoKHRoaXMucGF0aF8pO1xufTtcblVSSS5wcm90b3R5cGUuaGFzRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbCAhPT0gdGhpcy5kb21haW5fO1xufTtcblxuXG5VUkkucHJvdG90eXBlLmdldFBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBvcnRfICYmIGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLnBvcnRfKTtcbn07XG5VUkkucHJvdG90eXBlLnNldFBvcnQgPSBmdW5jdGlvbiAobmV3UG9ydCkge1xuICBpZiAobmV3UG9ydCkge1xuICAgIG5ld1BvcnQgPSBOdW1iZXIobmV3UG9ydCk7XG4gICAgaWYgKG5ld1BvcnQgIT09IChuZXdQb3J0ICYgMHhmZmZmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcG9ydCBudW1iZXIgJyArIG5ld1BvcnQpO1xuICAgIH1cbiAgICB0aGlzLnBvcnRfID0gJycgKyBuZXdQb3J0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMucG9ydF8gPSBudWxsO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblVSSS5wcm90b3R5cGUuaGFzUG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG51bGwgIT09IHRoaXMucG9ydF87XG59O1xuXG5cblVSSS5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGF0aF8gJiYgZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMucGF0aF8pO1xufTtcblVSSS5wcm90b3R5cGUuZ2V0UmF3UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGF0aF87XG59O1xuVVJJLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24gKG5ld1BhdGgpIHtcbiAgcmV0dXJuIHRoaXMuc2V0UmF3UGF0aChlbmNvZGVJZkV4aXN0czIobmV3UGF0aCwgVVJJX0RJU0FMTE9XRURfSU5fUEFUSF8pKTtcbn07XG5VUkkucHJvdG90eXBlLnNldFJhd1BhdGggPSBmdW5jdGlvbiAobmV3UGF0aCkge1xuICBpZiAobmV3UGF0aCkge1xuICAgIG5ld1BhdGggPSBTdHJpbmcobmV3UGF0aCk7XG4gICAgdGhpcy5wYXRoXyA9IFxuICAgICAgLy8gUGF0aHMgbXVzdCBzdGFydCB3aXRoICcvJyB1bmxlc3MgdGhpcyBpcyBhIHBhdGgtcmVsYXRpdmUgVVJMLlxuICAgICAgKCF0aGlzLmRvbWFpbl8gfHwgL15cXC8vLnRlc3QobmV3UGF0aCkpID8gbmV3UGF0aCA6ICcvJyArIG5ld1BhdGg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wYXRoXyA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuVVJJLnByb3RvdHlwZS5oYXNQYXRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbCAhPT0gdGhpcy5wYXRoXztcbn07XG5cblxuVVJJLnByb3RvdHlwZS5nZXRRdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRnJvbSBodHRwOi8vd3d3LnczLm9yZy9BZGRyZXNzaW5nL1VSTC80X1VSSV9SZWNvbW1lbnRhdGlvbnMuaHRtbFxuICAvLyBXaXRoaW4gdGhlIHF1ZXJ5IHN0cmluZywgdGhlIHBsdXMgc2lnbiBpcyByZXNlcnZlZCBhcyBzaG9ydGhhbmQgbm90YXRpb25cbiAgLy8gZm9yIGEgc3BhY2UuXG4gIHJldHVybiB0aGlzLnF1ZXJ5XyAmJiBkZWNvZGVVUklDb21wb25lbnQodGhpcy5xdWVyeV8pLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xufTtcblVSSS5wcm90b3R5cGUuZ2V0UmF3UXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnF1ZXJ5Xztcbn07XG5VUkkucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24gKG5ld1F1ZXJ5KSB7XG4gIHRoaXMucGFyYW1DYWNoZV8gPSBudWxsO1xuICB0aGlzLnF1ZXJ5XyA9IGVuY29kZUlmRXhpc3RzKG5ld1F1ZXJ5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuVVJJLnByb3RvdHlwZS5zZXRSYXdRdWVyeSA9IGZ1bmN0aW9uIChuZXdRdWVyeSkge1xuICB0aGlzLnBhcmFtQ2FjaGVfID0gbnVsbDtcbiAgdGhpcy5xdWVyeV8gPSBuZXdRdWVyeSA/IG5ld1F1ZXJ5IDogbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuVVJJLnByb3RvdHlwZS5oYXNRdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG51bGwgIT09IHRoaXMucXVlcnlfO1xufTtcblxuLyoqXG4gKiBzZXRzIHRoZSBxdWVyeSBnaXZlbiBhIGxpc3Qgb2Ygc3RyaW5ncyBvZiB0aGUgZm9ybVxuICogWyBrZXkwLCB2YWx1ZTAsIGtleTEsIHZhbHVlMSwgLi4uIF0uXG4gKlxuICogPHA+PGNvZGU+dXJpLnNldEFsbFBhcmFtZXRlcnMoWydhJywgJ2InLCAnYycsICdkJ10pLmdldFF1ZXJ5KCk8L2NvZGU+XG4gKiB3aWxsIHlpZWxkIDxjb2RlPidhPWImYz1kJzwvY29kZT4uXG4gKi9cblVSSS5wcm90b3R5cGUuc2V0QWxsUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKCEocGFyYW1zIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICYmIChwYXJhbXMgaW5zdGFuY2VvZiBPYmplY3RcbiAgICAgICAgICAgIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXJhbXMpICE9PSAnW29iamVjdCBBcnJheV0nKSkge1xuICAgICAgdmFyIG5ld1BhcmFtcyA9IFtdO1xuICAgICAgdmFyIGkgPSAtMTtcbiAgICAgIGZvciAodmFyIGsgaW4gcGFyYW1zKSB7XG4gICAgICAgIHZhciB2ID0gcGFyYW1zW2tdO1xuICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgbmV3UGFyYW1zWysraV0gPSBrO1xuICAgICAgICAgIG5ld1BhcmFtc1srK2ldID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFyYW1zID0gbmV3UGFyYW1zO1xuICAgIH1cbiAgfVxuICB0aGlzLnBhcmFtQ2FjaGVfID0gbnVsbDtcbiAgdmFyIHF1ZXJ5QnVmID0gW107XG4gIHZhciBzZXBhcmF0b3IgPSAnJztcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbXMubGVuZ3RoOykge1xuICAgIHZhciBrID0gcGFyYW1zW2orK107XG4gICAgdmFyIHYgPSBwYXJhbXNbaisrXTtcbiAgICBxdWVyeUJ1Zi5wdXNoKHNlcGFyYXRvciwgZW5jb2RlVVJJQ29tcG9uZW50KGsudG9TdHJpbmcoKSkpO1xuICAgIHNlcGFyYXRvciA9ICcmJztcbiAgICBpZiAodikge1xuICAgICAgcXVlcnlCdWYucHVzaCgnPScsIGVuY29kZVVSSUNvbXBvbmVudCh2LnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5xdWVyeV8gPSBxdWVyeUJ1Zi5qb2luKCcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuVVJJLnByb3RvdHlwZS5jaGVja1BhcmFtZXRlckNhY2hlXyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnBhcmFtQ2FjaGVfKSB7XG4gICAgdmFyIHEgPSB0aGlzLnF1ZXJ5XztcbiAgICBpZiAoIXEpIHtcbiAgICAgIHRoaXMucGFyYW1DYWNoZV8gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNnaVBhcmFtcyA9IHEuc3BsaXQoL1smXFw/XS8pO1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgdmFyIGsgPSAtMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2dpUGFyYW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtID0gY2dpUGFyYW1zW2ldLm1hdGNoKC9eKFtePV0qKSg/Oj0oLiopKT8kLyk7XG4gICAgICAgIC8vIEZyb20gaHR0cDovL3d3dy53My5vcmcvQWRkcmVzc2luZy9VUkwvNF9VUklfUmVjb21tZW50YXRpb25zLmh0bWxcbiAgICAgICAgLy8gV2l0aGluIHRoZSBxdWVyeSBzdHJpbmcsIHRoZSBwbHVzIHNpZ24gaXMgcmVzZXJ2ZWQgYXMgc2hvcnRoYW5kXG4gICAgICAgIC8vIG5vdGF0aW9uIGZvciBhIHNwYWNlLlxuICAgICAgICBvdXRbKytrXSA9IGRlY29kZVVSSUNvbXBvbmVudChtWzFdKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgb3V0Wysra10gPSBkZWNvZGVVUklDb21wb25lbnQobVsyXSB8fCAnJykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmFtQ2FjaGVfID0gb3V0O1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogc2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBuYW1lZCBjZ2kgcGFyYW1ldGVycy5cbiAqXG4gKiA8cD5TbywgPGNvZGU+dXJpLnBhcnNlKCdmb28/YT1iJmM9ZCZlPWYnKS5zZXRQYXJhbWV0ZXJWYWx1ZXMoJ2MnLCBbJ25ldyddKVxuICogPC9jb2RlPiB5aWVsZHMgPHR0PmZvbz9hPWImYz1uZXcmZT1mPC90dD4uPC9wPlxuICpcbiAqIEBwYXJhbSBrZXkge3N0cmluZ31cbiAqIEBwYXJhbSB2YWx1ZXMge0FycmF5LjxzdHJpbmc+fSB0aGUgbmV3IHZhbHVlcy4gIElmIHZhbHVlcyBpcyBhIHNpbmdsZSBzdHJpbmdcbiAqICAgdGhlbiBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgdGhlIHNvbGUgdmFsdWUuXG4gKi9cblVSSS5wcm90b3R5cGUuc2V0UGFyYW1ldGVyVmFsdWVzID0gZnVuY3Rpb24gKGtleSwgdmFsdWVzKSB7XG4gIC8vIGJlIG5pY2UgYW5kIGF2b2lkIHN1YnRsZSBidWdzIHdoZXJlIFtdIG9wZXJhdG9yIG9uIHN0cmluZyBwZXJmb3JtcyBjaGFyQXRcbiAgLy8gb24gc29tZSBicm93c2VycyBhbmQgY3Jhc2hlcyBvbiBJRVxuICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZXMgPSBbIHZhbHVlcyBdO1xuICB9XG5cbiAgdGhpcy5jaGVja1BhcmFtZXRlckNhY2hlXygpO1xuICB2YXIgbmV3VmFsdWVJbmRleCA9IDA7XG4gIHZhciBwYyA9IHRoaXMucGFyYW1DYWNoZV87XG4gIHZhciBwYXJhbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgcGMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoa2V5ID09PSBwY1tpXSkge1xuICAgICAgaWYgKG5ld1ZhbHVlSW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGtleSwgdmFsdWVzW25ld1ZhbHVlSW5kZXgrK10pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMucHVzaChwY1tpXSwgcGNbaSArIDFdKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKG5ld1ZhbHVlSW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgcGFyYW1zLnB1c2goa2V5LCB2YWx1ZXNbbmV3VmFsdWVJbmRleCsrXSk7XG4gIH1cbiAgdGhpcy5zZXRBbGxQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblVSSS5wcm90b3R5cGUucmVtb3ZlUGFyYW1ldGVyID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5zZXRQYXJhbWV0ZXJWYWx1ZXMoa2V5LCBbXSk7XG59O1xuLyoqXG4gKiByZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGUgcXVlcnkgcGFydCBvZiB0aGUgdXJpIGFzIGEgbGlzdCBvZlxuICoga2V5cyBhbmQgdmFsdWVzIGxpa2UgWyBrZXkwLCB2YWx1ZTAsIGtleTEsIHZhbHVlMSwgLi4uIF0uXG4gKlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gKi9cblVSSS5wcm90b3R5cGUuZ2V0QWxsUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaGVja1BhcmFtZXRlckNhY2hlXygpO1xuICByZXR1cm4gdGhpcy5wYXJhbUNhY2hlXy5zbGljZSgwLCB0aGlzLnBhcmFtQ2FjaGVfLmxlbmd0aCk7XG59O1xuLyoqXG4gKiByZXR1cm5zIHRoZSB2YWx1ZTxiPnM8L2I+IGZvciBhIGdpdmVuIGNnaSBwYXJhbWV0ZXIgYXMgYSBsaXN0IG9mIGRlY29kZWRcbiAqIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAqL1xuVVJJLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJWYWx1ZXMgPSBmdW5jdGlvbiAocGFyYW1OYW1lVW5lc2NhcGVkKSB7XG4gIHRoaXMuY2hlY2tQYXJhbWV0ZXJDYWNoZV8oKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFyYW1DYWNoZV8ubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAocGFyYW1OYW1lVW5lc2NhcGVkID09PSB0aGlzLnBhcmFtQ2FjaGVfW2ldKSB7XG4gICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcmFtQ2FjaGVfW2kgKyAxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuLyoqXG4gKiByZXR1cm5zIGEgbWFwIG9mIGNnaSBwYXJhbWV0ZXIgbmFtZXMgdG8gKG5vbi1lbXB0eSkgbGlzdHMgb2YgdmFsdWVzLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsQXJyYXkuPHN0cmluZz4+fVxuICovXG5VUkkucHJvdG90eXBlLmdldFBhcmFtZXRlck1hcCA9IGZ1bmN0aW9uIChwYXJhbU5hbWVVbmVzY2FwZWQpIHtcbiAgdGhpcy5jaGVja1BhcmFtZXRlckNhY2hlXygpO1xuICB2YXIgcGFyYW1NYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcmFtQ2FjaGVfLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGtleSA9IHRoaXMucGFyYW1DYWNoZV9baSsrXSxcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJhbUNhY2hlX1tpKytdO1xuICAgIGlmICghKGtleSBpbiBwYXJhbU1hcCkpIHtcbiAgICAgIHBhcmFtTWFwW2tleV0gPSBbdmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbU1hcFtrZXldLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1NYXA7XG59O1xuLyoqXG4gKiByZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBmb3IgYSBnaXZlbiBjZ2kgcGFyYW1ldGVyIG9yIG51bGwgaWYgdGhlIGdpdmVuXG4gKiBwYXJhbWV0ZXIgbmFtZSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIElmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZSBkb2VzIGFwcGVhciwgYnV0IGhhcyBubyAnPHR0Pj08L3R0PicgZm9sbG93aW5nXG4gKiBpdCwgdGhlbiB0aGUgZW1wdHkgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuVVJJLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJWYWx1ZSA9IGZ1bmN0aW9uIChwYXJhbU5hbWVVbmVzY2FwZWQpIHtcbiAgdGhpcy5jaGVja1BhcmFtZXRlckNhY2hlXygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFyYW1DYWNoZV8ubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAocGFyYW1OYW1lVW5lc2NhcGVkID09PSB0aGlzLnBhcmFtQ2FjaGVfW2ldKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbUNhY2hlX1tpICsgMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuVVJJLnByb3RvdHlwZS5nZXRGcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZnJhZ21lbnRfICYmIGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLmZyYWdtZW50Xyk7XG59O1xuVVJJLnByb3RvdHlwZS5nZXRSYXdGcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZnJhZ21lbnRfO1xufTtcblVSSS5wcm90b3R5cGUuc2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAobmV3RnJhZ21lbnQpIHtcbiAgdGhpcy5mcmFnbWVudF8gPSBuZXdGcmFnbWVudCA/IGVuY29kZVVSSUNvbXBvbmVudChuZXdGcmFnbWVudCkgOiBudWxsO1xuICByZXR1cm4gdGhpcztcbn07XG5VUkkucHJvdG90eXBlLnNldFJhd0ZyYWdtZW50ID0gZnVuY3Rpb24gKG5ld0ZyYWdtZW50KSB7XG4gIHRoaXMuZnJhZ21lbnRfID0gbmV3RnJhZ21lbnQgPyBuZXdGcmFnbWVudCA6IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblVSSS5wcm90b3R5cGUuaGFzRnJhZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBudWxsICE9PSB0aGlzLmZyYWdtZW50Xztcbn07XG5cbmZ1bmN0aW9uIG51bGxJZkFic2VudChtYXRjaFBhcnQpIHtcbiAgcmV0dXJuICgnc3RyaW5nJyA9PSB0eXBlb2YgbWF0Y2hQYXJ0KSAmJiAobWF0Y2hQYXJ0Lmxlbmd0aCA+IDApXG4gICAgICAgICA/IG1hdGNoUGFydFxuICAgICAgICAgOiBudWxsO1xufVxuXG5cblxuXG4vKipcbiAqIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gKlxuICogPHA+aHR0cDovL3d3dy5nYml2LmNvbS9wcm90b2NvbHMvdXJpL3JmYy9yZmMzOTg2Lmh0bWwjUkZDMjIzNCBzYXlzXG4gKiBBcyB0aGUgXCJmaXJzdC1tYXRjaC13aW5zXCIgYWxnb3JpdGhtIGlzIGlkZW50aWNhbCB0byB0aGUgXCJncmVlZHlcIlxuICogZGlzYW1iaWd1YXRpb24gbWV0aG9kIHVzZWQgYnkgUE9TSVggcmVndWxhciBleHByZXNzaW9ucywgaXQgaXMgbmF0dXJhbCBhbmRcbiAqIGNvbW1vbnBsYWNlIHRvIHVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgcGFyc2luZyB0aGUgcG90ZW50aWFsIGZpdmVcbiAqIGNvbXBvbmVudHMgb2YgYSBVUkkgcmVmZXJlbmNlLlxuICpcbiAqIDxwPlRoZSBmb2xsb3dpbmcgbGluZSBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZy1kb3duIGFcbiAqIHdlbGwtZm9ybWVkIFVSSSByZWZlcmVuY2UgaW50byBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiA8cHJlPlxuICogXigoW146Lz8jXSspOik/KC8vKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpP1xuICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxuICogPC9wcmU+XG4gKlxuICogPHA+VGhlIG51bWJlcnMgaW4gdGhlIHNlY29uZCBsaW5lIGFib3ZlIGFyZSBvbmx5IHRvIGFzc2lzdCByZWFkYWJpbGl0eTsgdGhleVxuICogaW5kaWNhdGUgdGhlIHJlZmVyZW5jZSBwb2ludHMgZm9yIGVhY2ggc3ViZXhwcmVzc2lvbiAoaS5lLiwgZWFjaCBwYWlyZWRcbiAqIHBhcmVudGhlc2lzKS4gV2UgcmVmZXIgdG8gdGhlIHZhbHVlIG1hdGNoZWQgZm9yIHN1YmV4cHJlc3Npb24gPG4+IGFzICQ8bj4uXG4gKiBGb3IgZXhhbXBsZSwgbWF0Y2hpbmcgdGhlIGFib3ZlIGV4cHJlc3Npb24gdG9cbiAqIDxwcmU+XG4gKiAgICAgaHR0cDovL3d3dy5pY3MudWNpLmVkdS9wdWIvaWV0Zi91cmkvI1JlbGF0ZWRcbiAqIDwvcHJlPlxuICogcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHN1YmV4cHJlc3Npb24gbWF0Y2hlczpcbiAqIDxwcmU+XG4gKiAgICAkMSA9IGh0dHA6XG4gKiAgICAkMiA9IGh0dHBcbiAqICAgICQzID0gLy93d3cuaWNzLnVjaS5lZHVcbiAqICAgICQ0ID0gd3d3Lmljcy51Y2kuZWR1XG4gKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvXG4gKiAgICAkNiA9IDx1bmRlZmluZWQ+XG4gKiAgICAkNyA9IDx1bmRlZmluZWQ+XG4gKiAgICAkOCA9ICNSZWxhdGVkXG4gKiAgICAkOSA9IFJlbGF0ZWRcbiAqIDwvcHJlPlxuICogd2hlcmUgPHVuZGVmaW5lZD4gaW5kaWNhdGVzIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBub3QgcHJlc2VudCwgYXMgaXMgdGhlXG4gKiBjYXNlIGZvciB0aGUgcXVlcnkgY29tcG9uZW50IGluIHRoZSBhYm92ZSBleGFtcGxlLiBUaGVyZWZvcmUsIHdlIGNhblxuICogZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgZml2ZSBjb21wb25lbnRzIGFzXG4gKiA8cHJlPlxuICogICAgc2NoZW1lICAgID0gJDJcbiAqICAgIGF1dGhvcml0eSA9ICQ0XG4gKiAgICBwYXRoICAgICAgPSAkNVxuICogICAgcXVlcnkgICAgID0gJDdcbiAqICAgIGZyYWdtZW50ICA9ICQ5XG4gKiA8L3ByZT5cbiAqXG4gKiA8cD5tc2FtdWVsOiBJIGhhdmUgbW9kaWZpZWQgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBzbGlnaHRseSB0byBleHBvc2UgdGhlXG4gKiBjcmVkZW50aWFscywgZG9tYWluLCBhbmQgcG9ydCBzZXBhcmF0ZWx5IGZyb20gdGhlIGF1dGhvcml0eS5cbiAqIFRoZSBtb2RpZmllZCB2ZXJzaW9uIHlpZWxkc1xuICogPHByZT5cbiAqICAgICQxID0gaHR0cCAgICAgICAgICAgICAgc2NoZW1lXG4gKiAgICAkMiA9IDx1bmRlZmluZWQ+ICAgICAgIGNyZWRlbnRpYWxzIC1cXFxuICogICAgJDMgPSB3d3cuaWNzLnVjaS5lZHUgICBkb21haW4gICAgICAgfCBhdXRob3JpdHlcbiAqICAgICQ0ID0gPHVuZGVmaW5lZD4gICAgICAgcG9ydCAgICAgICAgLS9cbiAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS8gICAgcGF0aFxuICogICAgJDYgPSA8dW5kZWZpbmVkPiAgICAgICBxdWVyeSB3aXRob3V0ID9cbiAqICAgICQ3ID0gUmVsYXRlZCAgICAgICAgICAgZnJhZ21lbnQgd2l0aG91dCAjXG4gKiA8L3ByZT5cbiAqL1xudmFyIFVSSV9SRV8gPSBuZXcgUmVnRXhwKFxuICAgICAgXCJeXCIgK1xuICAgICAgXCIoPzpcIiArXG4gICAgICAgIFwiKFteOi8/I10rKVwiICsgICAgICAgICAvLyBzY2hlbWVcbiAgICAgIFwiOik/XCIgK1xuICAgICAgXCIoPzovL1wiICtcbiAgICAgICAgXCIoPzooW14vPyNdKilAKT9cIiArICAgIC8vIGNyZWRlbnRpYWxzXG4gICAgICAgIFwiKFteLz8jOkBdKilcIiArICAgICAgICAvLyBkb21haW5cbiAgICAgICAgXCIoPzo6KFswLTldKykpP1wiICsgICAgIC8vIHBvcnRcbiAgICAgIFwiKT9cIiArXG4gICAgICBcIihbXj8jXSspP1wiICsgICAgICAgICAgICAvLyBwYXRoXG4gICAgICBcIig/OlxcXFw/KFteI10qKSk/XCIgKyAgICAgIC8vIHF1ZXJ5XG4gICAgICBcIig/OiMoLiopKT9cIiArICAgICAgICAgICAvLyBmcmFnbWVudFxuICAgICAgXCIkXCJcbiAgICAgICk7XG5cbnZhciBVUklfRElTQUxMT1dFRF9JTl9TQ0hFTUVfT1JfQ1JFREVOVElBTFNfID0gL1sjXFwvXFw/QF0vZztcbnZhciBVUklfRElTQUxMT1dFRF9JTl9QQVRIXyA9IC9bXFwjXFw/XS9nO1xuXG5VUkkucGFyc2UgPSBwYXJzZTtcblVSSS5jcmVhdGUgPSBjcmVhdGU7XG5VUkkucmVzb2x2ZSA9IHJlc29sdmU7XG5VUkkuY29sbGFwc2VfZG90cyA9IGNvbGxhcHNlX2RvdHM7ICAvLyBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuXG4vLyBsaWdodHdlaWdodCBzdHJpbmctYmFzZWQgYXBpIGZvciBsb2FkTW9kdWxlTWFrZXJcblVSSS51dGlscyA9IHtcbiAgbWltZVR5cGVPZjogZnVuY3Rpb24gKHVyaSkge1xuICAgIHZhciB1cmlPYmogPSBwYXJzZSh1cmkpO1xuICAgIGlmICgvXFwuaHRtbCQvLnRlc3QodXJpT2JqLmdldFBhdGgoKSkpIHtcbiAgICAgIHJldHVybiAndGV4dC9odG1sJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JztcbiAgICB9XG4gIH0sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIChiYXNlLCB1cmkpIHtcbiAgICBpZiAoYmFzZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocGFyc2UoYmFzZSksIHBhcnNlKHVyaSkpLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJyArIHVyaTtcbiAgICB9XG4gIH1cbn07XG5cblxucmV0dXJuIFVSSTtcbn0pKCk7XG5cbi8vIENvcHlyaWdodCBHb29nbGUgSW5jLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbmNlIFZlcnNpb24gMi4wXG4vLyBBdXRvZ2VuZXJhdGVkIGF0IE1vbiBGZWIgMjUgMTM6MDU6NDIgRVNUIDIwMTNcbi8vIEBvdmVycmlkZXMgd2luZG93XG4vLyBAcHJvdmlkZXMgaHRtbDRcbnZhciBodG1sNCA9IHt9O1xuaHRtbDQuYXR5cGUgPSB7XG4gICdOT05FJzogMCxcbiAgJ1VSSSc6IDEsXG4gICdVUklfRlJBR01FTlQnOiAxMSxcbiAgJ1NDUklQVCc6IDIsXG4gICdTVFlMRSc6IDMsXG4gICdIVE1MJzogMTIsXG4gICdJRCc6IDQsXG4gICdJRFJFRic6IDUsXG4gICdJRFJFRlMnOiA2LFxuICAnR0xPQkFMX05BTUUnOiA3LFxuICAnTE9DQUxfTkFNRSc6IDgsXG4gICdDTEFTU0VTJzogOSxcbiAgJ0ZSQU1FX1RBUkdFVCc6IDEwLFxuICAnTUVESUFfUVVFUlknOiAxM1xufTtcbmh0bWw0WyAnYXR5cGUnIF0gPSBodG1sNC5hdHlwZTtcbmh0bWw0LkFUVFJJQlMgPSB7XG4gICcqOjpjbGFzcyc6IDksXG4gICcqOjpkaXInOiAwLFxuICAnKjo6ZHJhZ2dhYmxlJzogMCxcbiAgJyo6OmhpZGRlbic6IDAsXG4gICcqOjppZCc6IDQsXG4gICcqOjppbmVydCc6IDAsXG4gICcqOjppdGVtcHJvcCc6IDAsXG4gICcqOjppdGVtcmVmJzogNixcbiAgJyo6Oml0ZW1zY29wZSc6IDAsXG4gICcqOjpsYW5nJzogMCxcbiAgJyo6Om9uYmx1cic6IDIsXG4gICcqOjpvbmNoYW5nZSc6IDIsXG4gICcqOjpvbmNsaWNrJzogMixcbiAgJyo6Om9uZGJsY2xpY2snOiAyLFxuICAnKjo6b25mb2N1cyc6IDIsXG4gICcqOjpvbmtleWRvd24nOiAyLFxuICAnKjo6b25rZXlwcmVzcyc6IDIsXG4gICcqOjpvbmtleXVwJzogMixcbiAgJyo6Om9ubG9hZCc6IDIsXG4gICcqOjpvbm1vdXNlZG93bic6IDIsXG4gICcqOjpvbm1vdXNlbW92ZSc6IDIsXG4gICcqOjpvbm1vdXNlb3V0JzogMixcbiAgJyo6Om9ubW91c2VvdmVyJzogMixcbiAgJyo6Om9ubW91c2V1cCc6IDIsXG4gICcqOjpvbnJlc2V0JzogMixcbiAgJyo6Om9uc2Nyb2xsJzogMixcbiAgJyo6Om9uc2VsZWN0JzogMixcbiAgJyo6Om9uc3VibWl0JzogMixcbiAgJyo6Om9udW5sb2FkJzogMixcbiAgJyo6OnNwZWxsY2hlY2snOiAwLFxuICAnKjo6c3R5bGUnOiAzLFxuICAnKjo6dGl0bGUnOiAwLFxuICAnKjo6dHJhbnNsYXRlJzogMCxcbiAgJ2E6OmFjY2Vzc2tleSc6IDAsXG4gICdhOjpjb29yZHMnOiAwLFxuICAnYTo6aHJlZic6IDEsXG4gICdhOjpocmVmbGFuZyc6IDAsXG4gICdhOjpuYW1lJzogNyxcbiAgJ2E6Om9uYmx1cic6IDIsXG4gICdhOjpvbmZvY3VzJzogMixcbiAgJ2E6OnNoYXBlJzogMCxcbiAgJ2E6OnRhYmluZGV4JzogMCxcbiAgJ2E6OnRhcmdldCc6IDEwLFxuICAnYTo6dHlwZSc6IDAsXG4gICdhcmVhOjphY2Nlc3NrZXknOiAwLFxuICAnYXJlYTo6YWx0JzogMCxcbiAgJ2FyZWE6OmNvb3Jkcyc6IDAsXG4gICdhcmVhOjpocmVmJzogMSxcbiAgJ2FyZWE6Om5vaHJlZic6IDAsXG4gICdhcmVhOjpvbmJsdXInOiAyLFxuICAnYXJlYTo6b25mb2N1cyc6IDIsXG4gICdhcmVhOjpzaGFwZSc6IDAsXG4gICdhcmVhOjp0YWJpbmRleCc6IDAsXG4gICdhcmVhOjp0YXJnZXQnOiAxMCxcbiAgJ2F1ZGlvOjpjb250cm9scyc6IDAsXG4gICdhdWRpbzo6bG9vcCc6IDAsXG4gICdhdWRpbzo6bWVkaWFncm91cCc6IDUsXG4gICdhdWRpbzo6bXV0ZWQnOiAwLFxuICAnYXVkaW86OnByZWxvYWQnOiAwLFxuICAnYmRvOjpkaXInOiAwLFxuICAnYmxvY2txdW90ZTo6Y2l0ZSc6IDEsXG4gICdicjo6Y2xlYXInOiAwLFxuICAnYnV0dG9uOjphY2Nlc3NrZXknOiAwLFxuICAnYnV0dG9uOjpkaXNhYmxlZCc6IDAsXG4gICdidXR0b246Om5hbWUnOiA4LFxuICAnYnV0dG9uOjpvbmJsdXInOiAyLFxuICAnYnV0dG9uOjpvbmZvY3VzJzogMixcbiAgJ2J1dHRvbjo6dGFiaW5kZXgnOiAwLFxuICAnYnV0dG9uOjp0eXBlJzogMCxcbiAgJ2J1dHRvbjo6dmFsdWUnOiAwLFxuICAnY2FudmFzOjpoZWlnaHQnOiAwLFxuICAnY2FudmFzOjp3aWR0aCc6IDAsXG4gICdjYXB0aW9uOjphbGlnbic6IDAsXG4gICdjb2w6OmFsaWduJzogMCxcbiAgJ2NvbDo6Y2hhcic6IDAsXG4gICdjb2w6OmNoYXJvZmYnOiAwLFxuICAnY29sOjpzcGFuJzogMCxcbiAgJ2NvbDo6dmFsaWduJzogMCxcbiAgJ2NvbDo6d2lkdGgnOiAwLFxuICAnY29sZ3JvdXA6OmFsaWduJzogMCxcbiAgJ2NvbGdyb3VwOjpjaGFyJzogMCxcbiAgJ2NvbGdyb3VwOjpjaGFyb2ZmJzogMCxcbiAgJ2NvbGdyb3VwOjpzcGFuJzogMCxcbiAgJ2NvbGdyb3VwOjp2YWxpZ24nOiAwLFxuICAnY29sZ3JvdXA6OndpZHRoJzogMCxcbiAgJ2NvbW1hbmQ6OmNoZWNrZWQnOiAwLFxuICAnY29tbWFuZDo6Y29tbWFuZCc6IDUsXG4gICdjb21tYW5kOjpkaXNhYmxlZCc6IDAsXG4gICdjb21tYW5kOjppY29uJzogMSxcbiAgJ2NvbW1hbmQ6OmxhYmVsJzogMCxcbiAgJ2NvbW1hbmQ6OnJhZGlvZ3JvdXAnOiAwLFxuICAnY29tbWFuZDo6dHlwZSc6IDAsXG4gICdkYXRhOjp2YWx1ZSc6IDAsXG4gICdkZWw6OmNpdGUnOiAxLFxuICAnZGVsOjpkYXRldGltZSc6IDAsXG4gICdkZXRhaWxzOjpvcGVuJzogMCxcbiAgJ2Rpcjo6Y29tcGFjdCc6IDAsXG4gICdkaXY6OmFsaWduJzogMCxcbiAgJ2RsOjpjb21wYWN0JzogMCxcbiAgJ2ZpZWxkc2V0OjpkaXNhYmxlZCc6IDAsXG4gICdmb250Ojpjb2xvcic6IDAsXG4gICdmb250OjpmYWNlJzogMCxcbiAgJ2ZvbnQ6OnNpemUnOiAwLFxuICAnZm9ybTo6YWNjZXB0JzogMCxcbiAgJ2Zvcm06OmFjdGlvbic6IDEsXG4gICdmb3JtOjphdXRvY29tcGxldGUnOiAwLFxuICAnZm9ybTo6ZW5jdHlwZSc6IDAsXG4gICdmb3JtOjptZXRob2QnOiAwLFxuICAnZm9ybTo6bmFtZSc6IDcsXG4gICdmb3JtOjpub3ZhbGlkYXRlJzogMCxcbiAgJ2Zvcm06Om9ucmVzZXQnOiAyLFxuICAnZm9ybTo6b25zdWJtaXQnOiAyLFxuICAnZm9ybTo6dGFyZ2V0JzogMTAsXG4gICdoMTo6YWxpZ24nOiAwLFxuICAnaDI6OmFsaWduJzogMCxcbiAgJ2gzOjphbGlnbic6IDAsXG4gICdoNDo6YWxpZ24nOiAwLFxuICAnaDU6OmFsaWduJzogMCxcbiAgJ2g2OjphbGlnbic6IDAsXG4gICdocjo6YWxpZ24nOiAwLFxuICAnaHI6Om5vc2hhZGUnOiAwLFxuICAnaHI6OnNpemUnOiAwLFxuICAnaHI6OndpZHRoJzogMCxcbiAgJ2lmcmFtZTo6YWxpZ24nOiAwLFxuICAnaWZyYW1lOjpmcmFtZWJvcmRlcic6IDAsXG4gICdpZnJhbWU6OmhlaWdodCc6IDAsXG4gICdpZnJhbWU6Om1hcmdpbmhlaWdodCc6IDAsXG4gICdpZnJhbWU6Om1hcmdpbndpZHRoJzogMCxcbiAgJ2lmcmFtZTo6d2lkdGgnOiAwLFxuICAnaW1nOjphbGlnbic6IDAsXG4gICdpbWc6OmFsdCc6IDAsXG4gICdpbWc6OmJvcmRlcic6IDAsXG4gICdpbWc6OmhlaWdodCc6IDAsXG4gICdpbWc6OmhzcGFjZSc6IDAsXG4gICdpbWc6OmlzbWFwJzogMCxcbiAgJ2ltZzo6bmFtZSc6IDcsXG4gICdpbWc6OnNyYyc6IDEsXG4gICdpbWc6OnVzZW1hcCc6IDExLFxuICAnaW1nOjp2c3BhY2UnOiAwLFxuICAnaW1nOjp3aWR0aCc6IDAsXG4gICdpbnB1dDo6YWNjZXB0JzogMCxcbiAgJ2lucHV0OjphY2Nlc3NrZXknOiAwLFxuICAnaW5wdXQ6OmFsaWduJzogMCxcbiAgJ2lucHV0OjphbHQnOiAwLFxuICAnaW5wdXQ6OmF1dG9jb21wbGV0ZSc6IDAsXG4gICdpbnB1dDo6Y2hlY2tlZCc6IDAsXG4gICdpbnB1dDo6ZGlzYWJsZWQnOiAwLFxuICAnaW5wdXQ6OmlucHV0bW9kZSc6IDAsXG4gICdpbnB1dDo6aXNtYXAnOiAwLFxuICAnaW5wdXQ6Omxpc3QnOiA1LFxuICAnaW5wdXQ6Om1heCc6IDAsXG4gICdpbnB1dDo6bWF4bGVuZ3RoJzogMCxcbiAgJ2lucHV0OjptaW4nOiAwLFxuICAnaW5wdXQ6Om11bHRpcGxlJzogMCxcbiAgJ2lucHV0OjpuYW1lJzogOCxcbiAgJ2lucHV0OjpvbmJsdXInOiAyLFxuICAnaW5wdXQ6Om9uY2hhbmdlJzogMixcbiAgJ2lucHV0OjpvbmZvY3VzJzogMixcbiAgJ2lucHV0OjpvbnNlbGVjdCc6IDIsXG4gICdpbnB1dDo6cGxhY2Vob2xkZXInOiAwLFxuICAnaW5wdXQ6OnJlYWRvbmx5JzogMCxcbiAgJ2lucHV0OjpyZXF1aXJlZCc6IDAsXG4gICdpbnB1dDo6c2l6ZSc6IDAsXG4gICdpbnB1dDo6c3JjJzogMSxcbiAgJ2lucHV0OjpzdGVwJzogMCxcbiAgJ2lucHV0Ojp0YWJpbmRleCc6IDAsXG4gICdpbnB1dDo6dHlwZSc6IDAsXG4gICdpbnB1dDo6dXNlbWFwJzogMTEsXG4gICdpbnB1dDo6dmFsdWUnOiAwLFxuICAnaW5zOjpjaXRlJzogMSxcbiAgJ2luczo6ZGF0ZXRpbWUnOiAwLFxuICAnbGFiZWw6OmFjY2Vzc2tleSc6IDAsXG4gICdsYWJlbDo6Zm9yJzogNSxcbiAgJ2xhYmVsOjpvbmJsdXInOiAyLFxuICAnbGFiZWw6Om9uZm9jdXMnOiAyLFxuICAnbGVnZW5kOjphY2Nlc3NrZXknOiAwLFxuICAnbGVnZW5kOjphbGlnbic6IDAsXG4gICdsaTo6dHlwZSc6IDAsXG4gICdsaTo6dmFsdWUnOiAwLFxuICAnbWFwOjpuYW1lJzogNyxcbiAgJ21lbnU6OmNvbXBhY3QnOiAwLFxuICAnbWVudTo6bGFiZWwnOiAwLFxuICAnbWVudTo6dHlwZSc6IDAsXG4gICdtZXRlcjo6aGlnaCc6IDAsXG4gICdtZXRlcjo6bG93JzogMCxcbiAgJ21ldGVyOjptYXgnOiAwLFxuICAnbWV0ZXI6Om1pbic6IDAsXG4gICdtZXRlcjo6dmFsdWUnOiAwLFxuICAnb2w6OmNvbXBhY3QnOiAwLFxuICAnb2w6OnJldmVyc2VkJzogMCxcbiAgJ29sOjpzdGFydCc6IDAsXG4gICdvbDo6dHlwZSc6IDAsXG4gICdvcHRncm91cDo6ZGlzYWJsZWQnOiAwLFxuICAnb3B0Z3JvdXA6OmxhYmVsJzogMCxcbiAgJ29wdGlvbjo6ZGlzYWJsZWQnOiAwLFxuICAnb3B0aW9uOjpsYWJlbCc6IDAsXG4gICdvcHRpb246OnNlbGVjdGVkJzogMCxcbiAgJ29wdGlvbjo6dmFsdWUnOiAwLFxuICAnb3V0cHV0Ojpmb3InOiA2LFxuICAnb3V0cHV0OjpuYW1lJzogOCxcbiAgJ3A6OmFsaWduJzogMCxcbiAgJ3ByZTo6d2lkdGgnOiAwLFxuICAncHJvZ3Jlc3M6Om1heCc6IDAsXG4gICdwcm9ncmVzczo6bWluJzogMCxcbiAgJ3Byb2dyZXNzOjp2YWx1ZSc6IDAsXG4gICdxOjpjaXRlJzogMSxcbiAgJ3NlbGVjdDo6YXV0b2NvbXBsZXRlJzogMCxcbiAgJ3NlbGVjdDo6ZGlzYWJsZWQnOiAwLFxuICAnc2VsZWN0OjptdWx0aXBsZSc6IDAsXG4gICdzZWxlY3Q6Om5hbWUnOiA4LFxuICAnc2VsZWN0OjpvbmJsdXInOiAyLFxuICAnc2VsZWN0OjpvbmNoYW5nZSc6IDIsXG4gICdzZWxlY3Q6Om9uZm9jdXMnOiAyLFxuICAnc2VsZWN0OjpyZXF1aXJlZCc6IDAsXG4gICdzZWxlY3Q6OnNpemUnOiAwLFxuICAnc2VsZWN0Ojp0YWJpbmRleCc6IDAsXG4gICdzb3VyY2U6OnR5cGUnOiAwLFxuICAndGFibGU6OmFsaWduJzogMCxcbiAgJ3RhYmxlOjpiZ2NvbG9yJzogMCxcbiAgJ3RhYmxlOjpib3JkZXInOiAwLFxuICAndGFibGU6OmNlbGxwYWRkaW5nJzogMCxcbiAgJ3RhYmxlOjpjZWxsc3BhY2luZyc6IDAsXG4gICd0YWJsZTo6ZnJhbWUnOiAwLFxuICAndGFibGU6OnJ1bGVzJzogMCxcbiAgJ3RhYmxlOjpzdW1tYXJ5JzogMCxcbiAgJ3RhYmxlOjp3aWR0aCc6IDAsXG4gICd0Ym9keTo6YWxpZ24nOiAwLFxuICAndGJvZHk6OmNoYXInOiAwLFxuICAndGJvZHk6OmNoYXJvZmYnOiAwLFxuICAndGJvZHk6OnZhbGlnbic6IDAsXG4gICd0ZDo6YWJicic6IDAsXG4gICd0ZDo6YWxpZ24nOiAwLFxuICAndGQ6OmF4aXMnOiAwLFxuICAndGQ6OmJnY29sb3InOiAwLFxuICAndGQ6OmNoYXInOiAwLFxuICAndGQ6OmNoYXJvZmYnOiAwLFxuICAndGQ6OmNvbHNwYW4nOiAwLFxuICAndGQ6OmhlYWRlcnMnOiA2LFxuICAndGQ6OmhlaWdodCc6IDAsXG4gICd0ZDo6bm93cmFwJzogMCxcbiAgJ3RkOjpyb3dzcGFuJzogMCxcbiAgJ3RkOjpzY29wZSc6IDAsXG4gICd0ZDo6dmFsaWduJzogMCxcbiAgJ3RkOjp3aWR0aCc6IDAsXG4gICd0ZXh0YXJlYTo6YWNjZXNza2V5JzogMCxcbiAgJ3RleHRhcmVhOjphdXRvY29tcGxldGUnOiAwLFxuICAndGV4dGFyZWE6OmNvbHMnOiAwLFxuICAndGV4dGFyZWE6OmRpc2FibGVkJzogMCxcbiAgJ3RleHRhcmVhOjppbnB1dG1vZGUnOiAwLFxuICAndGV4dGFyZWE6Om5hbWUnOiA4LFxuICAndGV4dGFyZWE6Om9uYmx1cic6IDIsXG4gICd0ZXh0YXJlYTo6b25jaGFuZ2UnOiAyLFxuICAndGV4dGFyZWE6Om9uZm9jdXMnOiAyLFxuICAndGV4dGFyZWE6Om9uc2VsZWN0JzogMixcbiAgJ3RleHRhcmVhOjpwbGFjZWhvbGRlcic6IDAsXG4gICd0ZXh0YXJlYTo6cmVhZG9ubHknOiAwLFxuICAndGV4dGFyZWE6OnJlcXVpcmVkJzogMCxcbiAgJ3RleHRhcmVhOjpyb3dzJzogMCxcbiAgJ3RleHRhcmVhOjp0YWJpbmRleCc6IDAsXG4gICd0ZXh0YXJlYTo6d3JhcCc6IDAsXG4gICd0Zm9vdDo6YWxpZ24nOiAwLFxuICAndGZvb3Q6OmNoYXInOiAwLFxuICAndGZvb3Q6OmNoYXJvZmYnOiAwLFxuICAndGZvb3Q6OnZhbGlnbic6IDAsXG4gICd0aDo6YWJicic6IDAsXG4gICd0aDo6YWxpZ24nOiAwLFxuICAndGg6OmF4aXMnOiAwLFxuICAndGg6OmJnY29sb3InOiAwLFxuICAndGg6OmNoYXInOiAwLFxuICAndGg6OmNoYXJvZmYnOiAwLFxuICAndGg6OmNvbHNwYW4nOiAwLFxuICAndGg6OmhlYWRlcnMnOiA2LFxuICAndGg6OmhlaWdodCc6IDAsXG4gICd0aDo6bm93cmFwJzogMCxcbiAgJ3RoOjpyb3dzcGFuJzogMCxcbiAgJ3RoOjpzY29wZSc6IDAsXG4gICd0aDo6dmFsaWduJzogMCxcbiAgJ3RoOjp3aWR0aCc6IDAsXG4gICd0aGVhZDo6YWxpZ24nOiAwLFxuICAndGhlYWQ6OmNoYXInOiAwLFxuICAndGhlYWQ6OmNoYXJvZmYnOiAwLFxuICAndGhlYWQ6OnZhbGlnbic6IDAsXG4gICd0cjo6YWxpZ24nOiAwLFxuICAndHI6OmJnY29sb3InOiAwLFxuICAndHI6OmNoYXInOiAwLFxuICAndHI6OmNoYXJvZmYnOiAwLFxuICAndHI6OnZhbGlnbic6IDAsXG4gICd0cmFjazo6ZGVmYXVsdCc6IDAsXG4gICd0cmFjazo6a2luZCc6IDAsXG4gICd0cmFjazo6bGFiZWwnOiAwLFxuICAndHJhY2s6OnNyY2xhbmcnOiAwLFxuICAndWw6OmNvbXBhY3QnOiAwLFxuICAndWw6OnR5cGUnOiAwLFxuICAndmlkZW86OmNvbnRyb2xzJzogMCxcbiAgJ3ZpZGVvOjpoZWlnaHQnOiAwLFxuICAndmlkZW86Omxvb3AnOiAwLFxuICAndmlkZW86Om1lZGlhZ3JvdXAnOiA1LFxuICAndmlkZW86Om11dGVkJzogMCxcbiAgJ3ZpZGVvOjpwb3N0ZXInOiAxLFxuICAndmlkZW86OnByZWxvYWQnOiAwLFxuICAndmlkZW86OndpZHRoJzogMFxufTtcbmh0bWw0WyAnQVRUUklCUycgXSA9IGh0bWw0LkFUVFJJQlM7XG5odG1sNC5lZmxhZ3MgPSB7XG4gICdPUFRJT05BTF9FTkRUQUcnOiAxLFxuICAnRU1QVFknOiAyLFxuICAnQ0RBVEEnOiA0LFxuICAnUkNEQVRBJzogOCxcbiAgJ1VOU0FGRSc6IDE2LFxuICAnRk9MREFCTEUnOiAzMixcbiAgJ1NDUklQVCc6IDY0LFxuICAnU1RZTEUnOiAxMjgsXG4gICdWSVJUVUFMSVpFRCc6IDI1NlxufTtcbmh0bWw0WyAnZWZsYWdzJyBdID0gaHRtbDQuZWZsYWdzO1xuLy8gdGhlc2UgYXJlIGJpdG1hc2tzIG9mIHRoZSBlZmxhZ3MgYWJvdmUuXG5odG1sNC5FTEVNRU5UUyA9IHtcbiAgJ2EnOiAwLFxuICAnYWJicic6IDAsXG4gICdhY3JvbnltJzogMCxcbiAgJ2FkZHJlc3MnOiAwLFxuICAnYXBwbGV0JzogMjcyLFxuICAnYXJlYSc6IDIsXG4gICdhcnRpY2xlJzogMCxcbiAgJ2FzaWRlJzogMCxcbiAgJ2F1ZGlvJzogMCxcbiAgJ2InOiAwLFxuICAnYmFzZSc6IDI3NCxcbiAgJ2Jhc2Vmb250JzogMjc0LFxuICAnYmRpJzogMCxcbiAgJ2Jkbyc6IDAsXG4gICdiaWcnOiAwLFxuICAnYmxvY2txdW90ZSc6IDAsXG4gICdib2R5JzogMzA1LFxuICAnYnInOiAyLFxuICAnYnV0dG9uJzogMCxcbiAgJ2NhbnZhcyc6IDAsXG4gICdjYXB0aW9uJzogMCxcbiAgJ2NlbnRlcic6IDAsXG4gICdjaXRlJzogMCxcbiAgJ2NvZGUnOiAwLFxuICAnY29sJzogMixcbiAgJ2NvbGdyb3VwJzogMSxcbiAgJ2NvbW1hbmQnOiAyLFxuICAnZGF0YSc6IDAsXG4gICdkYXRhbGlzdCc6IDAsXG4gICdkZCc6IDEsXG4gICdkZWwnOiAwLFxuICAnZGV0YWlscyc6IDAsXG4gICdkZm4nOiAwLFxuICAnZGlhbG9nJzogMjcyLFxuICAnZGlyJzogMCxcbiAgJ2Rpdic6IDAsXG4gICdkbCc6IDAsXG4gICdkdCc6IDEsXG4gICdlbSc6IDAsXG4gICdmaWVsZHNldCc6IDAsXG4gICdmaWdjYXB0aW9uJzogMCxcbiAgJ2ZpZ3VyZSc6IDAsXG4gICdmb250JzogMCxcbiAgJ2Zvb3Rlcic6IDAsXG4gICdmb3JtJzogMCxcbiAgJ2ZyYW1lJzogMjc0LFxuICAnZnJhbWVzZXQnOiAyNzIsXG4gICdoMSc6IDAsXG4gICdoMic6IDAsXG4gICdoMyc6IDAsXG4gICdoNCc6IDAsXG4gICdoNSc6IDAsXG4gICdoNic6IDAsXG4gICdoZWFkJzogMzA1LFxuICAnaGVhZGVyJzogMCxcbiAgJ2hncm91cCc6IDAsXG4gICdocic6IDIsXG4gICdodG1sJzogMzA1LFxuICAnaSc6IDAsXG4gICdpZnJhbWUnOiAxNixcbiAgJ2ltZyc6IDIsXG4gICdpbnB1dCc6IDIsXG4gICdpbnMnOiAwLFxuICAnaXNpbmRleCc6IDI3NCxcbiAgJ2tiZCc6IDAsXG4gICdrZXlnZW4nOiAyNzQsXG4gICdsYWJlbCc6IDAsXG4gICdsZWdlbmQnOiAwLFxuICAnbGknOiAxLFxuICAnbGluayc6IDI3NCxcbiAgJ21hcCc6IDAsXG4gICdtYXJrJzogMCxcbiAgJ21lbnUnOiAwLFxuICAnbWV0YSc6IDI3NCxcbiAgJ21ldGVyJzogMCxcbiAgJ25hdic6IDAsXG4gICdub2JyJzogMCxcbiAgJ25vZW1iZWQnOiAyNzYsXG4gICdub2ZyYW1lcyc6IDI3NixcbiAgJ25vc2NyaXB0JzogMjc2LFxuICAnb2JqZWN0JzogMjcyLFxuICAnb2wnOiAwLFxuICAnb3B0Z3JvdXAnOiAwLFxuICAnb3B0aW9uJzogMSxcbiAgJ291dHB1dCc6IDAsXG4gICdwJzogMSxcbiAgJ3BhcmFtJzogMjc0LFxuICAncHJlJzogMCxcbiAgJ3Byb2dyZXNzJzogMCxcbiAgJ3EnOiAwLFxuICAncyc6IDAsXG4gICdzYW1wJzogMCxcbiAgJ3NjcmlwdCc6IDg0LFxuICAnc2VjdGlvbic6IDAsXG4gICdzZWxlY3QnOiAwLFxuICAnc21hbGwnOiAwLFxuICAnc291cmNlJzogMixcbiAgJ3NwYW4nOiAwLFxuICAnc3RyaWtlJzogMCxcbiAgJ3N0cm9uZyc6IDAsXG4gICdzdHlsZSc6IDE0OCxcbiAgJ3N1Yic6IDAsXG4gICdzdW1tYXJ5JzogMCxcbiAgJ3N1cCc6IDAsXG4gICd0YWJsZSc6IDAsXG4gICd0Ym9keSc6IDEsXG4gICd0ZCc6IDEsXG4gICd0ZXh0YXJlYSc6IDgsXG4gICd0Zm9vdCc6IDEsXG4gICd0aCc6IDEsXG4gICd0aGVhZCc6IDEsXG4gICd0aW1lJzogMCxcbiAgJ3RpdGxlJzogMjgwLFxuICAndHInOiAxLFxuICAndHJhY2snOiAyLFxuICAndHQnOiAwLFxuICAndSc6IDAsXG4gICd1bCc6IDAsXG4gICd2YXInOiAwLFxuICAndmlkZW8nOiAwLFxuICAnd2JyJzogMlxufTtcbmh0bWw0WyAnRUxFTUVOVFMnIF0gPSBodG1sNC5FTEVNRU5UUztcbmh0bWw0LkVMRU1FTlRfRE9NX0lOVEVSRkFDRVMgPSB7XG4gICdhJzogJ0hUTUxBbmNob3JFbGVtZW50JyxcbiAgJ2FiYnInOiAnSFRNTEVsZW1lbnQnLFxuICAnYWNyb255bSc6ICdIVE1MRWxlbWVudCcsXG4gICdhZGRyZXNzJzogJ0hUTUxFbGVtZW50JyxcbiAgJ2FwcGxldCc6ICdIVE1MQXBwbGV0RWxlbWVudCcsXG4gICdhcmVhJzogJ0hUTUxBcmVhRWxlbWVudCcsXG4gICdhcnRpY2xlJzogJ0hUTUxFbGVtZW50JyxcbiAgJ2FzaWRlJzogJ0hUTUxFbGVtZW50JyxcbiAgJ2F1ZGlvJzogJ0hUTUxBdWRpb0VsZW1lbnQnLFxuICAnYic6ICdIVE1MRWxlbWVudCcsXG4gICdiYXNlJzogJ0hUTUxCYXNlRWxlbWVudCcsXG4gICdiYXNlZm9udCc6ICdIVE1MQmFzZUZvbnRFbGVtZW50JyxcbiAgJ2JkaSc6ICdIVE1MRWxlbWVudCcsXG4gICdiZG8nOiAnSFRNTEVsZW1lbnQnLFxuICAnYmlnJzogJ0hUTUxFbGVtZW50JyxcbiAgJ2Jsb2NrcXVvdGUnOiAnSFRNTFF1b3RlRWxlbWVudCcsXG4gICdib2R5JzogJ0hUTUxCb2R5RWxlbWVudCcsXG4gICdicic6ICdIVE1MQlJFbGVtZW50JyxcbiAgJ2J1dHRvbic6ICdIVE1MQnV0dG9uRWxlbWVudCcsXG4gICdjYW52YXMnOiAnSFRNTENhbnZhc0VsZW1lbnQnLFxuICAnY2FwdGlvbic6ICdIVE1MVGFibGVDYXB0aW9uRWxlbWVudCcsXG4gICdjZW50ZXInOiAnSFRNTEVsZW1lbnQnLFxuICAnY2l0ZSc6ICdIVE1MRWxlbWVudCcsXG4gICdjb2RlJzogJ0hUTUxFbGVtZW50JyxcbiAgJ2NvbCc6ICdIVE1MVGFibGVDb2xFbGVtZW50JyxcbiAgJ2NvbGdyb3VwJzogJ0hUTUxUYWJsZUNvbEVsZW1lbnQnLFxuICAnY29tbWFuZCc6ICdIVE1MQ29tbWFuZEVsZW1lbnQnLFxuICAnZGF0YSc6ICdIVE1MRWxlbWVudCcsXG4gICdkYXRhbGlzdCc6ICdIVE1MRGF0YUxpc3RFbGVtZW50JyxcbiAgJ2RkJzogJ0hUTUxFbGVtZW50JyxcbiAgJ2RlbCc6ICdIVE1MTW9kRWxlbWVudCcsXG4gICdkZXRhaWxzJzogJ0hUTUxEZXRhaWxzRWxlbWVudCcsXG4gICdkZm4nOiAnSFRNTEVsZW1lbnQnLFxuICAnZGlhbG9nJzogJ0hUTUxEaWFsb2dFbGVtZW50JyxcbiAgJ2Rpcic6ICdIVE1MRGlyZWN0b3J5RWxlbWVudCcsXG4gICdkaXYnOiAnSFRNTERpdkVsZW1lbnQnLFxuICAnZGwnOiAnSFRNTERMaXN0RWxlbWVudCcsXG4gICdkdCc6ICdIVE1MRWxlbWVudCcsXG4gICdlbSc6ICdIVE1MRWxlbWVudCcsXG4gICdmaWVsZHNldCc6ICdIVE1MRmllbGRTZXRFbGVtZW50JyxcbiAgJ2ZpZ2NhcHRpb24nOiAnSFRNTEVsZW1lbnQnLFxuICAnZmlndXJlJzogJ0hUTUxFbGVtZW50JyxcbiAgJ2ZvbnQnOiAnSFRNTEZvbnRFbGVtZW50JyxcbiAgJ2Zvb3Rlcic6ICdIVE1MRWxlbWVudCcsXG4gICdmb3JtJzogJ0hUTUxGb3JtRWxlbWVudCcsXG4gICdmcmFtZSc6ICdIVE1MRnJhbWVFbGVtZW50JyxcbiAgJ2ZyYW1lc2V0JzogJ0hUTUxGcmFtZVNldEVsZW1lbnQnLFxuICAnaDEnOiAnSFRNTEhlYWRpbmdFbGVtZW50JyxcbiAgJ2gyJzogJ0hUTUxIZWFkaW5nRWxlbWVudCcsXG4gICdoMyc6ICdIVE1MSGVhZGluZ0VsZW1lbnQnLFxuICAnaDQnOiAnSFRNTEhlYWRpbmdFbGVtZW50JyxcbiAgJ2g1JzogJ0hUTUxIZWFkaW5nRWxlbWVudCcsXG4gICdoNic6ICdIVE1MSGVhZGluZ0VsZW1lbnQnLFxuICAnaGVhZCc6ICdIVE1MSGVhZEVsZW1lbnQnLFxuICAnaGVhZGVyJzogJ0hUTUxFbGVtZW50JyxcbiAgJ2hncm91cCc6ICdIVE1MRWxlbWVudCcsXG4gICdocic6ICdIVE1MSFJFbGVtZW50JyxcbiAgJ2h0bWwnOiAnSFRNTEh0bWxFbGVtZW50JyxcbiAgJ2knOiAnSFRNTEVsZW1lbnQnLFxuICAnaWZyYW1lJzogJ0hUTUxJRnJhbWVFbGVtZW50JyxcbiAgJ2ltZyc6ICdIVE1MSW1hZ2VFbGVtZW50JyxcbiAgJ2lucHV0JzogJ0hUTUxJbnB1dEVsZW1lbnQnLFxuICAnaW5zJzogJ0hUTUxNb2RFbGVtZW50JyxcbiAgJ2lzaW5kZXgnOiAnSFRNTFVua25vd25FbGVtZW50JyxcbiAgJ2tiZCc6ICdIVE1MRWxlbWVudCcsXG4gICdrZXlnZW4nOiAnSFRNTEtleWdlbkVsZW1lbnQnLFxuICAnbGFiZWwnOiAnSFRNTExhYmVsRWxlbWVudCcsXG4gICdsZWdlbmQnOiAnSFRNTExlZ2VuZEVsZW1lbnQnLFxuICAnbGknOiAnSFRNTExJRWxlbWVudCcsXG4gICdsaW5rJzogJ0hUTUxMaW5rRWxlbWVudCcsXG4gICdtYXAnOiAnSFRNTE1hcEVsZW1lbnQnLFxuICAnbWFyayc6ICdIVE1MRWxlbWVudCcsXG4gICdtZW51JzogJ0hUTUxNZW51RWxlbWVudCcsXG4gICdtZXRhJzogJ0hUTUxNZXRhRWxlbWVudCcsXG4gICdtZXRlcic6ICdIVE1MTWV0ZXJFbGVtZW50JyxcbiAgJ25hdic6ICdIVE1MRWxlbWVudCcsXG4gICdub2JyJzogJ0hUTUxFbGVtZW50JyxcbiAgJ25vZW1iZWQnOiAnSFRNTEVsZW1lbnQnLFxuICAnbm9mcmFtZXMnOiAnSFRNTEVsZW1lbnQnLFxuICAnbm9zY3JpcHQnOiAnSFRNTEVsZW1lbnQnLFxuICAnb2JqZWN0JzogJ0hUTUxPYmplY3RFbGVtZW50JyxcbiAgJ29sJzogJ0hUTUxPTGlzdEVsZW1lbnQnLFxuICAnb3B0Z3JvdXAnOiAnSFRNTE9wdEdyb3VwRWxlbWVudCcsXG4gICdvcHRpb24nOiAnSFRNTE9wdGlvbkVsZW1lbnQnLFxuICAnb3V0cHV0JzogJ0hUTUxPdXRwdXRFbGVtZW50JyxcbiAgJ3AnOiAnSFRNTFBhcmFncmFwaEVsZW1lbnQnLFxuICAncGFyYW0nOiAnSFRNTFBhcmFtRWxlbWVudCcsXG4gICdwcmUnOiAnSFRNTFByZUVsZW1lbnQnLFxuICAncHJvZ3Jlc3MnOiAnSFRNTFByb2dyZXNzRWxlbWVudCcsXG4gICdxJzogJ0hUTUxRdW90ZUVsZW1lbnQnLFxuICAncyc6ICdIVE1MRWxlbWVudCcsXG4gICdzYW1wJzogJ0hUTUxFbGVtZW50JyxcbiAgJ3NjcmlwdCc6ICdIVE1MU2NyaXB0RWxlbWVudCcsXG4gICdzZWN0aW9uJzogJ0hUTUxFbGVtZW50JyxcbiAgJ3NlbGVjdCc6ICdIVE1MU2VsZWN0RWxlbWVudCcsXG4gICdzbWFsbCc6ICdIVE1MRWxlbWVudCcsXG4gICdzb3VyY2UnOiAnSFRNTFNvdXJjZUVsZW1lbnQnLFxuICAnc3Bhbic6ICdIVE1MU3BhbkVsZW1lbnQnLFxuICAnc3RyaWtlJzogJ0hUTUxFbGVtZW50JyxcbiAgJ3N0cm9uZyc6ICdIVE1MRWxlbWVudCcsXG4gICdzdHlsZSc6ICdIVE1MU3R5bGVFbGVtZW50JyxcbiAgJ3N1Yic6ICdIVE1MRWxlbWVudCcsXG4gICdzdW1tYXJ5JzogJ0hUTUxFbGVtZW50JyxcbiAgJ3N1cCc6ICdIVE1MRWxlbWVudCcsXG4gICd0YWJsZSc6ICdIVE1MVGFibGVFbGVtZW50JyxcbiAgJ3Rib2R5JzogJ0hUTUxUYWJsZVNlY3Rpb25FbGVtZW50JyxcbiAgJ3RkJzogJ0hUTUxUYWJsZURhdGFDZWxsRWxlbWVudCcsXG4gICd0ZXh0YXJlYSc6ICdIVE1MVGV4dEFyZWFFbGVtZW50JyxcbiAgJ3Rmb290JzogJ0hUTUxUYWJsZVNlY3Rpb25FbGVtZW50JyxcbiAgJ3RoJzogJ0hUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50JyxcbiAgJ3RoZWFkJzogJ0hUTUxUYWJsZVNlY3Rpb25FbGVtZW50JyxcbiAgJ3RpbWUnOiAnSFRNTFRpbWVFbGVtZW50JyxcbiAgJ3RpdGxlJzogJ0hUTUxUaXRsZUVsZW1lbnQnLFxuICAndHInOiAnSFRNTFRhYmxlUm93RWxlbWVudCcsXG4gICd0cmFjayc6ICdIVE1MVHJhY2tFbGVtZW50JyxcbiAgJ3R0JzogJ0hUTUxFbGVtZW50JyxcbiAgJ3UnOiAnSFRNTEVsZW1lbnQnLFxuICAndWwnOiAnSFRNTFVMaXN0RWxlbWVudCcsXG4gICd2YXInOiAnSFRNTEVsZW1lbnQnLFxuICAndmlkZW8nOiAnSFRNTFZpZGVvRWxlbWVudCcsXG4gICd3YnInOiAnSFRNTEVsZW1lbnQnXG59O1xuaHRtbDRbICdFTEVNRU5UX0RPTV9JTlRFUkZBQ0VTJyBdID0gaHRtbDQuRUxFTUVOVF9ET01fSU5URVJGQUNFUztcbmh0bWw0LnVlZmZlY3RzID0ge1xuICAnTk9UX0xPQURFRCc6IDAsXG4gICdTQU1FX0RPQ1VNRU5UJzogMSxcbiAgJ05FV19ET0NVTUVOVCc6IDJcbn07XG5odG1sNFsgJ3VlZmZlY3RzJyBdID0gaHRtbDQudWVmZmVjdHM7XG5odG1sNC5VUklFRkZFQ1RTID0ge1xuICAnYTo6aHJlZic6IDIsXG4gICdhcmVhOjpocmVmJzogMixcbiAgJ2Jsb2NrcXVvdGU6OmNpdGUnOiAwLFxuICAnY29tbWFuZDo6aWNvbic6IDEsXG4gICdkZWw6OmNpdGUnOiAwLFxuICAnZm9ybTo6YWN0aW9uJzogMixcbiAgJ2ltZzo6c3JjJzogMSxcbiAgJ2lucHV0OjpzcmMnOiAxLFxuICAnaW5zOjpjaXRlJzogMCxcbiAgJ3E6OmNpdGUnOiAwLFxuICAndmlkZW86OnBvc3Rlcic6IDFcbn07XG5odG1sNFsgJ1VSSUVGRkVDVFMnIF0gPSBodG1sNC5VUklFRkZFQ1RTO1xuaHRtbDQubHR5cGVzID0ge1xuICAnVU5TQU5EQk9YRUQnOiAyLFxuICAnU0FOREJPWEVEJzogMSxcbiAgJ0RBVEEnOiAwXG59O1xuaHRtbDRbICdsdHlwZXMnIF0gPSBodG1sNC5sdHlwZXM7XG5odG1sNC5MT0FERVJUWVBFUyA9IHtcbiAgJ2E6OmhyZWYnOiAyLFxuICAnYXJlYTo6aHJlZic6IDIsXG4gICdibG9ja3F1b3RlOjpjaXRlJzogMixcbiAgJ2NvbW1hbmQ6Omljb24nOiAxLFxuICAnZGVsOjpjaXRlJzogMixcbiAgJ2Zvcm06OmFjdGlvbic6IDIsXG4gICdpbWc6OnNyYyc6IDEsXG4gICdpbnB1dDo6c3JjJzogMSxcbiAgJ2luczo6Y2l0ZSc6IDIsXG4gICdxOjpjaXRlJzogMixcbiAgJ3ZpZGVvOjpwb3N0ZXInOiAxXG59O1xuaHRtbDRbICdMT0FERVJUWVBFUycgXSA9IGh0bWw0LkxPQURFUlRZUEVTO1xuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMDYgR29vZ2xlIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIEFuIEhUTUwgc2FuaXRpemVyIHRoYXQgY2FuIHNhdGlzZnkgYSB2YXJpZXR5IG9mIHNlY3VyaXR5IHBvbGljaWVzLlxuICpcbiAqIDxwPlxuICogVGhlIEhUTUwgc2FuaXRpemVyIGlzIGJ1aWx0IGFyb3VuZCBhIFNBWCBwYXJzZXIgYW5kIEhUTUwgZWxlbWVudCBhbmRcbiAqIGF0dHJpYnV0ZXMgc2NoZW1hcy5cbiAqXG4gKiBJZiB0aGUgY3NzcGFyc2VyIGlzIGxvYWRlZCwgaW5saW5lIHN0eWxlcyBhcmUgc2FuaXRpemVkIHVzaW5nIHRoZVxuICogY3NzIHByb3BlcnR5IGFuZCB2YWx1ZSBzY2hlbWFzLiAgRWxzZSB0aGV5IGFyZSByZW1vdmUgZHVyaW5nXG4gKiBzYW5pdGl6YXRpb24uXG4gKlxuICogSWYgaXQgZXhpc3RzLCB1c2VzIHBhcnNlQ3NzRGVjbGFyYXRpb25zLCBzYW5pdGl6ZUNzc1Byb3BlcnR5LCAgY3NzU2NoZW1hXG4gKlxuICogQGF1dGhvciBtaWtlc2FtdWVsQGdtYWlsLmNvbVxuICogQGF1dGhvciBqYXN2aXJAZ21haWwuY29tXG4gKiBcXEByZXF1aXJlcyBodG1sNCwgVVJJXG4gKiBcXEBvdmVycmlkZXMgd2luZG93XG4gKiBcXEBwcm92aWRlcyBodG1sLCBodG1sX3Nhbml0aXplXG4gKi9cblxuLy8gVGhlIFR1cmtpc2ggaSBzZWVtcyB0byBiZSBhIG5vbi1pc3N1ZSwgYnV0IGFib3J0IGluIGNhc2UgaXQgaXMuXG5pZiAoJ0knLnRvTG93ZXJDYXNlKCkgIT09ICdpJykgeyB0aHJvdyAnSS9pIHByb2JsZW0nOyB9XG5cbi8qKlxuICogXFxAbmFtZXNwYWNlXG4gKi9cbnZhciBodG1sID0gKGZ1bmN0aW9uKGh0bWw0KSB7XG5cbiAgLy8gRm9yIGNsb3N1cmUgY29tcGlsZXJcbiAgdmFyIHBhcnNlQ3NzRGVjbGFyYXRpb25zLCBzYW5pdGl6ZUNzc1Byb3BlcnR5LCBjc3NTY2hlbWE7XG4gIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHdpbmRvdykge1xuICAgIHBhcnNlQ3NzRGVjbGFyYXRpb25zID0gd2luZG93WydwYXJzZUNzc0RlY2xhcmF0aW9ucyddO1xuICAgIHNhbml0aXplQ3NzUHJvcGVydHkgPSB3aW5kb3dbJ3Nhbml0aXplQ3NzUHJvcGVydHknXTtcbiAgICBjc3NTY2hlbWEgPSB3aW5kb3dbJ2Nzc1NjaGVtYSddO1xuICB9XG5cbiAgLy8gVGhlIGtleXMgb2YgdGhpcyBvYmplY3QgbXVzdCBiZSAncXVvdGVkJyBvciBKU0NvbXBpbGVyIHdpbGwgbWFuZ2xlIHRoZW0hXG4gIC8vIFRoaXMgaXMgYSBwYXJ0aWFsIGxpc3QgLS0gbG9va3VwRW50aXR5KCkgdXNlcyB0aGUgaG9zdCBicm93c2VyJ3MgcGFyc2VyXG4gIC8vICh3aGVuIGF2YWlsYWJsZSkgdG8gaW1wbGVtZW50IGZ1bGwgZW50aXR5IGxvb2t1cC5cbiAgLy8gTm90ZSB0aGF0IGVudGl0aWVzIGFyZSBpbiBnZW5lcmFsIGNhc2Utc2Vuc2l0aXZlOyB0aGUgdXBwZXJjYXNlIG9uZXMgYXJlXG4gIC8vIGV4cGxpY2l0bHkgZGVmaW5lZCBieSBIVE1MNSAocHJlc3VtYWJseSBhcyBjb21wYXRpYmlsaXR5KS5cbiAgdmFyIEVOVElUSUVTID0ge1xuICAgICdsdCc6ICc8JyxcbiAgICAnTFQnOiAnPCcsXG4gICAgJ2d0JzogJz4nLFxuICAgICdHVCc6ICc+JyxcbiAgICAnYW1wJzogJyYnLFxuICAgICdBTVAnOiAnJicsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogJ1xcJycsXG4gICAgJ25ic3AnOiAnXFx1MDBBMCdcbiAgfTtcblxuICAvLyBQYXR0ZXJucyBmb3IgdHlwZXMgb2YgZW50aXR5L2NoYXJhY3RlciByZWZlcmVuY2UgbmFtZXMuXG4gIHZhciBkZWNpbWFsRXNjYXBlUmUgPSAvXiMoXFxkKykkLztcbiAgdmFyIGhleEVzY2FwZVJlID0gL14jeChbMC05QS1GYS1mXSspJC87XG4gIC8vIGNvbnRhaW5zIGV2ZXJ5IGVudGl0eSBwZXIgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDExMy9uYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlcy5odG1sXG4gIHZhciBzYWZlRW50aXR5TmFtZVJlID0gL15bQS1aYS16XVtBLXphLXowLTldKyQvO1xuICAvLyBVc2VkIGFzIGEgaG9vayB0byBpbnZva2UgdGhlIGJyb3dzZXIncyBlbnRpdHkgcGFyc2luZy4gPHRleHRhcmVhPiBpcyB1c2VkXG4gIC8vIGJlY2F1c2UgaXRzIGNvbnRlbnQgaXMgcGFyc2VkIGZvciBlbnRpdGllcyBidXQgbm90IHRhZ3MuXG4gIC8vIFRPRE8oa3ByZWlkKTogVGhpcyByZXRyaWV2YWwgaXMgYSBrbHVkZ2UgYW5kIGxlYWRzIHRvIHNpbGVudCBsb3NzIG9mXG4gIC8vIGZ1bmN0aW9uYWxpdHkgaWYgdGhlIGRvY3VtZW50IGlzbid0IGF2YWlsYWJsZS5cbiAgdmFyIGVudGl0eUxvb2t1cEVsZW1lbnQgPVxuICAgICAgKCd1bmRlZmluZWQnICE9PSB0eXBlb2Ygd2luZG93ICYmIHdpbmRvd1snZG9jdW1lbnQnXSlcbiAgICAgICAgICA/IHdpbmRvd1snZG9jdW1lbnQnXS5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpIDogbnVsbDtcbiAgLyoqXG4gICAqIERlY29kZXMgYW4gSFRNTCBlbnRpdHkuXG4gICAqXG4gICAqIHtcXEB1cGRvY1xuICAgKiAkIGxvb2t1cEVudGl0eSgnbHQnKVxuICAgKiAjICc8J1xuICAgKiAkIGxvb2t1cEVudGl0eSgnR1QnKVxuICAgKiAjICc+J1xuICAgKiAkIGxvb2t1cEVudGl0eSgnYW1wJylcbiAgICogIyAnJidcbiAgICogJCBsb29rdXBFbnRpdHkoJ25ic3AnKVxuICAgKiAjICdcXHhBMCdcbiAgICogJCBsb29rdXBFbnRpdHkoJ2Fwb3MnKVxuICAgKiAjIFwiJ1wiXG4gICAqICQgbG9va3VwRW50aXR5KCdxdW90JylcbiAgICogIyAnXCInXG4gICAqICQgbG9va3VwRW50aXR5KCcjeGEnKVxuICAgKiAjICdcXG4nXG4gICAqICQgbG9va3VwRW50aXR5KCcjMTAnKVxuICAgKiAjICdcXG4nXG4gICAqICQgbG9va3VwRW50aXR5KCcjeDBhJylcbiAgICogIyAnXFxuJ1xuICAgKiAkIGxvb2t1cEVudGl0eSgnIzAxMCcpXG4gICAqICMgJ1xcbidcbiAgICogJCBsb29rdXBFbnRpdHkoJyN4MDBBJylcbiAgICogIyAnXFxuJ1xuICAgKiAkIGxvb2t1cEVudGl0eSgnUGknKSAgICAgIC8vIEtub3duIGZhaWx1cmVcbiAgICogIyAnXFx1MDNBMCdcbiAgICogJCBsb29rdXBFbnRpdHkoJ3BpJykgICAgICAvLyBLbm93biBmYWlsdXJlXG4gICAqICMgJ1xcdTAzQzAnXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgJyYnIGFuZCB0aGUgJzsnLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGEgc2luZ2xlIHVuaWNvZGUgY29kZS1wb2ludCBhcyBhIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGxvb2t1cEVudGl0eShuYW1lKSB7XG4gICAgLy8gVE9ETzogZW50aXR5IGxvb2t1cCBhcyBzcGVjaWZpZWQgYnkgSFRNTDUgYWN0dWFsbHkgZGVwZW5kcyBvbiB0aGVcbiAgICAvLyBwcmVzZW5jZSBvZiB0aGUgXCI7XCIuXG4gICAgaWYgKEVOVElUSUVTLmhhc093blByb3BlcnR5KG5hbWUpKSB7IHJldHVybiBFTlRJVElFU1tuYW1lXTsgfVxuICAgIHZhciBtID0gbmFtZS5tYXRjaChkZWNpbWFsRXNjYXBlUmUpO1xuICAgIGlmIChtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChtWzFdLCAxMCkpO1xuICAgIH0gZWxzZSBpZiAoISEobSA9IG5hbWUubWF0Y2goaGV4RXNjYXBlUmUpKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobVsxXSwgMTYpKTtcbiAgICB9IGVsc2UgaWYgKGVudGl0eUxvb2t1cEVsZW1lbnQgJiYgc2FmZUVudGl0eU5hbWVSZS50ZXN0KG5hbWUpKSB7XG4gICAgICBlbnRpdHlMb29rdXBFbGVtZW50LmlubmVySFRNTCA9ICcmJyArIG5hbWUgKyAnOyc7XG4gICAgICB2YXIgdGV4dCA9IGVudGl0eUxvb2t1cEVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICBFTlRJVElFU1tuYW1lXSA9IHRleHQ7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcmJyArIG5hbWUgKyAnOyc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlT25lRW50aXR5KF8sIG5hbWUpIHtcbiAgICByZXR1cm4gbG9va3VwRW50aXR5KG5hbWUpO1xuICB9XG5cbiAgdmFyIG51bFJlID0gL1xcMC9nO1xuICBmdW5jdGlvbiBzdHJpcE5VTHMocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UobnVsUmUsICcnKTtcbiAgfVxuXG4gIHZhciBFTlRJVFlfUkVfMSA9IC8mKCNbMC05XSt8I1t4WF1bMC05QS1GYS1mXSt8XFx3Kyk7L2c7XG4gIHZhciBFTlRJVFlfUkVfMiA9IC9eKCNbMC05XSt8I1t4WF1bMC05QS1GYS1mXSt8XFx3Kyk7LztcbiAgLyoqXG4gICAqIFRoZSBwbGFpbiB0ZXh0IG9mIGEgY2h1bmsgb2YgSFRNTCBDREFUQSB3aGljaCBwb3NzaWJseSBjb250YWluaW5nLlxuICAgKlxuICAgKiB7XFxAdXBkb2NcbiAgICogJCB1bmVzY2FwZUVudGl0aWVzKCcnKVxuICAgKiAjICcnXG4gICAqICQgdW5lc2NhcGVFbnRpdGllcygnaGVsbG8gV29ybGQhJylcbiAgICogIyAnaGVsbG8gV29ybGQhJ1xuICAgKiAkIHVuZXNjYXBlRW50aXRpZXMoJzEgJmx0OyAyICZhbXA7JkFNUDsgNCAmZ3Q7IDMmIzEwOycpXG4gICAqICMgJzEgPCAyICYmIDQgPiAzXFxuJ1xuICAgKiAkIHVuZXNjYXBlRW50aXRpZXMoJyZsdDsmbHQgPC0gdW5maW5pc2hlZCBlbnRpdHkmZ3Q7JylcbiAgICogIyAnPCZsdCA8LSB1bmZpbmlzaGVkIGVudGl0eT4nXG4gICAqICQgdW5lc2NhcGVFbnRpdGllcygnL2Zvbz9iYXI9YmF6JmNvcHk9dHJ1ZScpICAvLyAmIG9mdGVuIHVuZXNjYXBlZCBpbiBVUkxTXG4gICAqICMgJy9mb28/YmFyPWJheiZjb3B5PXRydWUnXG4gICAqICQgdW5lc2NhcGVFbnRpdGllcygncGk9JnBpOyYjeDNjMDssIFBpPSZQaTtcXHUwM0EwJykgLy8gRklYTUU6IGtub3duIGZhaWx1cmVcbiAgICogIyAncGk9XFx1MDNDMFxcdTAzYzAsIFBpPVxcdTAzQTBcXHUwM0EwJ1xuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIGEgY2h1bmsgb2YgSFRNTCBDREFUQS4gIEl0IG11c3Qgbm90IHN0YXJ0IG9yIGVuZCBpbnNpZGVcbiAgICogICAgIGFuIEhUTUwgZW50aXR5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5lc2NhcGVFbnRpdGllcyhzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShFTlRJVFlfUkVfMSwgZGVjb2RlT25lRW50aXR5KTtcbiAgfVxuXG4gIHZhciBhbXBSZSA9IC8mL2c7XG4gIHZhciBsb29zZUFtcFJlID0gLyYoW15hLXojXXwjKD86W14wLTl4XXx4KD86W14wLTlhLWZdfCQpfCQpfCQpL2dpO1xuICB2YXIgbHRSZSA9IC9bPF0vZztcbiAgdmFyIGd0UmUgPSAvPi9nO1xuICB2YXIgcXVvdFJlID0gL1xcXCIvZztcblxuICAvKipcbiAgICogRXNjYXBlcyBIVE1MIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgKlxuICAgKiB7XFxAdXBkb2NcbiAgICogJCBlc2NhcGVBdHRyaWIoJycpXG4gICAqICMgJydcbiAgICogJCBlc2NhcGVBdHRyaWIoJ1wiPDwmPT0mPj5cIicpICAvLyBEbyBub3QganVzdCBlc2NhcGUgdGhlIGZpcnN0IG9jY3VycmVuY2UuXG4gICAqICMgJyYjMzQ7Jmx0OyZsdDsmYW1wOyYjNjE7JiM2MTsmYW1wOyZndDsmZ3Q7JiMzNDsnXG4gICAqICQgZXNjYXBlQXR0cmliKCdIZWxsbyA8V29ybGQ+IScpXG4gICAqICMgJ0hlbGxvICZsdDtXb3JsZCZndDshJ1xuICAgKiB9XG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVBdHRyaWIocykge1xuICAgIHJldHVybiAoJycgKyBzKS5yZXBsYWNlKGFtcFJlLCAnJmFtcDsnKS5yZXBsYWNlKGx0UmUsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoZ3RSZSwgJyZndDsnKS5yZXBsYWNlKHF1b3RSZSwgJyYjMzQ7Jyk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlIGVudGl0aWVzIGluIFJDREFUQSB0aGF0IGNhbiBiZSBlc2NhcGVkIHdpdGhvdXQgY2hhbmdpbmcgdGhlIG1lYW5pbmcuXG4gICAqIHtcXEB1cGRvY1xuICAgKiAkIG5vcm1hbGl6ZVJDRGF0YSgnMSA8IDIgJiZhbXA7IDMgPiA0ICZhbXA7JiA1ICZsdDsgNyY4JylcbiAgICogIyAnMSAmbHQ7IDIgJmFtcDsmYW1wOyAzICZndDsgNCAmYW1wOyZhbXA7IDUgJmx0OyA3JmFtcDs4J1xuICAgKiB9XG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVSQ0RhdGEocmNkYXRhKSB7XG4gICAgcmV0dXJuIHJjZGF0YVxuICAgICAgICAucmVwbGFjZShsb29zZUFtcFJlLCAnJmFtcDskMScpXG4gICAgICAgIC5yZXBsYWNlKGx0UmUsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoZ3RSZSwgJyZndDsnKTtcbiAgfVxuXG4gIC8vIFRPRE8oZmVsaXg4YSk6IHZhbGlkYXRlIHNhbml0aXplciByZWdleHMgYWdhaW5zdCB0aGUgSFRNTDUgZ3JhbW1hciBhdFxuICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9zeW50YXguaHRtbFxuICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9wYXJzaW5nLmh0bWxcbiAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdG9rZW5pemF0aW9uLmh0bWxcbiAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdHJlZS1jb25zdHJ1Y3Rpb24uaHRtbFxuXG4gIC8vIFdlIGluaXRpYWxseSBzcGxpdCBpbnB1dCBzbyB0aGF0IHBvdGVudGlhbGx5IG1lYW5pbmdmdWwgY2hhcmFjdGVyc1xuICAvLyBsaWtlICc8JyBhbmQgJz4nIGFyZSBzZXBhcmF0ZSB0b2tlbnMsIHVzaW5nIGEgZmFzdCBkdW1iIHByb2Nlc3MgdGhhdFxuICAvLyBpZ25vcmVzIHF1b3RpbmcuICBUaGVuIHdlIHdhbGsgdGhhdCB0b2tlbiBzdHJlYW0sIGFuZCB3aGVuIHdlIHNlZSBhXG4gIC8vICc8JyB0aGF0J3MgdGhlIHN0YXJ0IG9mIGEgdGFnLCB3ZSB1c2UgQVRUUl9SRSB0byBleHRyYWN0IHRhZ1xuICAvLyBhdHRyaWJ1dGVzIGZyb20gdGhlIG5leHQgdG9rZW4uICBUaGF0IHRva2VuIHdpbGwgbmV2ZXIgaGF2ZSBhICc+J1xuICAvLyBjaGFyYWN0ZXIuICBIb3dldmVyLCBpdCBtaWdodCBoYXZlIGFuIHVuYmFsYW5jZWQgcXVvdGUgY2hhcmFjdGVyLCBhbmRcbiAgLy8gd2hlbiB3ZSBzZWUgdGhhdCwgd2UgY29tYmluZSBhZGRpdGlvbmFsIHRva2VucyB0byBiYWxhbmNlIHRoZSBxdW90ZS5cblxuICB2YXIgQVRUUl9SRSA9IG5ldyBSZWdFeHAoXG4gICAgJ15cXFxccyonICtcbiAgICAnKFstLjpcXFxcd10rKScgKyAgICAgICAgICAgICAvLyAxID0gQXR0cmlidXRlIG5hbWVcbiAgICAnKD86JyArIChcbiAgICAgICdcXFxccyooPSlcXFxccyonICsgICAgICAgICAgIC8vIDIgPSBJcyB0aGVyZSBhIHZhbHVlP1xuICAgICAgJygnICsgKCAgICAgICAgICAgICAgICAgICAvLyAzID0gQXR0cmlidXRlIHZhbHVlXG4gICAgICAgIC8vIFRPRE8oZmVsaXg4YSk6IG1heWJlIHVzZSBiYWNrcmVmIHRvIG1hdGNoIHF1b3Rlc1xuICAgICAgICAnKFxcXCIpW15cXFwiXSooXFxcInwkKScgKyAgICAvLyA0LCA1ID0gRG91YmxlLXF1b3RlZCBzdHJpbmdcbiAgICAgICAgJ3wnICtcbiAgICAgICAgJyhcXCcpW15cXCddKihcXCd8JCknICsgICAgLy8gNiwgNyA9IFNpbmdsZS1xdW90ZWQgc3RyaW5nXG4gICAgICAgICd8JyArXG4gICAgICAgIC8vIFBvc2l0aXZlIGxvb2thaGVhZCB0byBwcmV2ZW50IGludGVycHJldGF0aW9uIG9mXG4gICAgICAgIC8vIDxmb28gYT0gYj1jPiBhcyA8Zm9vIGE9J2I9Yyc+XG4gICAgICAgIC8vIFRPRE8oZmVsaXg4YSk6IG1pZ2h0IGJlIGFibGUgdG8gZHJvcCB0aGlzIGNhc2VcbiAgICAgICAgJyg/PVthLXpdWy1cXFxcd10qXFxcXHMqPSknICtcbiAgICAgICAgJ3wnICtcbiAgICAgICAgLy8gVW5xdW90ZWQgdmFsdWUgdGhhdCBpc24ndCBhbiBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAvLyAoc2luY2Ugd2UgZGlkbid0IG1hdGNoIHRoZSBwb3NpdGl2ZSBsb29rYWhlYWQgYWJvdmUpXG4gICAgICAgICdbXlxcXCJcXCdcXFxcc10qJyApICtcbiAgICAgICcpJyApICtcbiAgICAnKT8nLFxuICAgICdpJyk7XG5cbiAgLy8gZmFsc2Ugb24gSUU8PTgsIHRydWUgb24gbW9zdCBvdGhlciBicm93c2Vyc1xuICB2YXIgc3BsaXRXaWxsQ2FwdHVyZSA9ICgnYSxiJy5zcGxpdCgvKCwpLykubGVuZ3RoID09PSAzKTtcblxuICAvLyBiaXRtYXNrIGZvciB0YWdzIHdpdGggc3BlY2lhbCBwYXJzaW5nLCBsaWtlIDxzY3JpcHQ+IGFuZCA8dGV4dGFyZWE+XG4gIHZhciBFRkxBR1NfVEVYVCA9IGh0bWw0LmVmbGFnc1snQ0RBVEEnXSB8IGh0bWw0LmVmbGFnc1snUkNEQVRBJ107XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgU0FYLWxpa2UgZXZlbnQgaGFuZGxlciwgcHJvZHVjZSBhIGZ1bmN0aW9uIHRoYXQgZmVlZHMgdGhvc2VcbiAgICogZXZlbnRzIGFuZCBhIHBhcmFtZXRlciB0byB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICpcbiAgICogVGhlIGV2ZW50IGhhbmRsZXIgaGFzIHRoZSBmb3JtOntAY29kZVxuICAgKiB7XG4gICAqICAgLy8gTmFtZSBpcyBhbiB1cHBlci1jYXNlIEhUTUwgdGFnIG5hbWUuICBBdHRyaWJzIGlzIGFuIGFycmF5IG9mXG4gICAqICAgLy8gYWx0ZXJuYXRpbmcgdXBwZXItY2FzZSBhdHRyaWJ1dGUgbmFtZXMsIGFuZCBhdHRyaWJ1dGUgdmFsdWVzLiAgVGhlXG4gICAqICAgLy8gYXR0cmlicyBhcnJheSBpcyByZXVzZWQgYnkgdGhlIHBhcnNlci4gIFBhcmFtIGlzIHRoZSB2YWx1ZSBwYXNzZWQgdG9cbiAgICogICAvLyB0aGUgc2F4UGFyc2VyLlxuICAgKiAgIHN0YXJ0VGFnOiBmdW5jdGlvbiAobmFtZSwgYXR0cmlicywgcGFyYW0pIHsgLi4uIH0sXG4gICAqICAgZW5kVGFnOiAgIGZ1bmN0aW9uIChuYW1lLCBwYXJhbSkgeyAuLi4gfSxcbiAgICogICBwY2RhdGE6ICAgZnVuY3Rpb24gKHRleHQsIHBhcmFtKSB7IC4uLiB9LFxuICAgKiAgIHJjZGF0YTogICBmdW5jdGlvbiAodGV4dCwgcGFyYW0pIHsgLi4uIH0sXG4gICAqICAgY2RhdGE6ICAgIGZ1bmN0aW9uICh0ZXh0LCBwYXJhbSkgeyAuLi4gfSxcbiAgICogICBzdGFydERvYzogZnVuY3Rpb24gKHBhcmFtKSB7IC4uLiB9LFxuICAgKiAgIGVuZERvYzogICBmdW5jdGlvbiAocGFyYW0pIHsgLi4uIH1cbiAgICogfX1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXIgYSByZWNvcmQgY29udGFpbmluZyBldmVudCBoYW5kbGVycy5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24oc3RyaW5nLCBPYmplY3QpfSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjaHVuayBvZiBIVE1MXG4gICAqICAgICBhbmQgYSBwYXJhbWV0ZXIuICBUaGUgcGFyYW1ldGVyIGlzIHBhc3NlZCBvbiB0byB0aGUgaGFuZGxlciBtZXRob2RzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVNheFBhcnNlcihoYW5kbGVyKSB7XG4gICAgLy8gQWNjZXB0IHF1b3RlZCBvciB1bnF1b3RlZCBrZXlzIChDbG9zdXJlIGNvbXBhdClcbiAgICB2YXIgaGNvcHkgPSB7XG4gICAgICBjZGF0YTogaGFuZGxlci5jZGF0YSB8fCBoYW5kbGVyWydjZGF0YSddLFxuICAgICAgY29tbWVudDogaGFuZGxlci5jb21tZW50IHx8IGhhbmRsZXJbJ2NvbW1lbnQnXSxcbiAgICAgIGVuZERvYzogaGFuZGxlci5lbmREb2MgfHwgaGFuZGxlclsnZW5kRG9jJ10sXG4gICAgICBlbmRUYWc6IGhhbmRsZXIuZW5kVGFnIHx8IGhhbmRsZXJbJ2VuZFRhZyddLFxuICAgICAgcGNkYXRhOiBoYW5kbGVyLnBjZGF0YSB8fCBoYW5kbGVyWydwY2RhdGEnXSxcbiAgICAgIHJjZGF0YTogaGFuZGxlci5yY2RhdGEgfHwgaGFuZGxlclsncmNkYXRhJ10sXG4gICAgICBzdGFydERvYzogaGFuZGxlci5zdGFydERvYyB8fCBoYW5kbGVyWydzdGFydERvYyddLFxuICAgICAgc3RhcnRUYWc6IGhhbmRsZXIuc3RhcnRUYWcgfHwgaGFuZGxlclsnc3RhcnRUYWcnXVxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGh0bWxUZXh0LCBwYXJhbSkge1xuICAgICAgcmV0dXJuIHBhcnNlKGh0bWxUZXh0LCBoY29weSwgcGFyYW0pO1xuICAgIH07XG4gIH1cblxuICAvLyBQYXJzaW5nIHN0cmF0ZWd5IGlzIHRvIHNwbGl0IGlucHV0IGludG8gcGFydHMgdGhhdCBtaWdodCBiZSBsZXhpY2FsbHlcbiAgLy8gbWVhbmluZ2Z1bCAoZXZlcnkgXCI+XCIgYmVjb21lcyBhIHNlcGFyYXRlIHBhcnQpLCBhbmQgdGhlbiByZWNvbWJpbmVcbiAgLy8gcGFydHMgaWYgd2UgZGlzY292ZXIgdGhleSdyZSBpbiBhIGRpZmZlcmVudCBjb250ZXh0LlxuXG4gIC8vIFRPRE8oZmVsaXg4YSk6IFNpZ25pZmljYW50IHBlcmZvcm1hbmNlIHJlZ3Jlc3Npb25zIGZyb20gLWxlZ2FjeSxcbiAgLy8gdGVzdGVkIG9uXG4gIC8vICAgIENocm9tZSAxOC4wXG4gIC8vICAgIEZpcmVmb3ggMTEuMFxuICAvLyAgICBJRSA2LCA3LCA4LCA5XG4gIC8vICAgIE9wZXJhIDExLjYxXG4gIC8vICAgIFNhZmFyaSA1LjEuM1xuICAvLyBNYW55IG9mIHRoZXNlIGFyZSB1bnVzdWFsIHBhdHRlcm5zIHRoYXQgYXJlIGxpbmVhcmx5IHNsb3dlciBhbmQgc3RpbGxcbiAgLy8gcHJldHR5IGZhc3QgKGVnIDFtcyB0byA1bXMpLCBzbyBub3QgbmVjZXNzYXJpbHkgd29ydGggZml4aW5nLlxuXG4gIC8vIFRPRE8oZmVsaXg4YSk6IFwiPHNjcmlwdD4gJiYgJiYgJiYgLi4uIDxcXC9zY3JpcHQ+XCIgaXMgc2xvd2VyIG9uIGFsbFxuICAvLyBicm93c2Vycy4gIFRoZSBob3RzcG90IGlzIGh0bWxTcGxpdC5cblxuICAvLyBUT0RPKGZlbGl4OGEpOiBcIjxwIHRpdGxlPSc+Pj4+Li4uJz48XFwvcD5cIiBpcyBzbG93ZXIgb24gYWxsIGJyb3dzZXJzLlxuICAvLyBUaGlzIGlzIHBhcnRseSBodG1sU3BsaXQsIGJ1dCB0aGUgaG90c3BvdCBpcyBwYXJzZVRhZ0FuZEF0dHJzLlxuXG4gIC8vIFRPRE8oZmVsaXg4YSk6IFwiPGE+PFxcL2E+PGE+PFxcL2E+Li4uXCIgaXMgc2xvd2VyIG9uIElFOS5cbiAgLy8gXCI8YT4xPFxcL2E+PGE+MTxcXC9hPi4uLlwiIGlzIGZhc3RlciwgXCI8YT48XFwvYT4yPGE+PFxcL2E+Mi4uLlwiIGlzIGZhc3Rlci5cblxuICAvLyBUT0RPKGZlbGl4OGEpOiBcIjxwPHA8cC4uLlwiIGlzIHNsb3dlciBvbiBJRVs2LThdXG5cbiAgdmFyIGNvbnRpbnVhdGlvbk1hcmtlciA9IHt9O1xuICBmdW5jdGlvbiBwYXJzZShodG1sVGV4dCwgaGFuZGxlciwgcGFyYW0pIHtcbiAgICB2YXIgbSwgcCwgdGFnTmFtZTtcbiAgICB2YXIgcGFydHMgPSBodG1sU3BsaXQoaHRtbFRleHQpO1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIG5vTW9yZUdUOiBmYWxzZSxcbiAgICAgIG5vTW9yZUVuZENvbW1lbnRzOiBmYWxzZVxuICAgIH07XG4gICAgcGFyc2VDUFMoaGFuZGxlciwgcGFydHMsIDAsIHN0YXRlLCBwYXJhbSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb250aW51YXRpb25NYWtlcihoLCBwYXJ0cywgaW5pdGlhbCwgc3RhdGUsIHBhcmFtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHBhcnNlQ1BTKGgsIHBhcnRzLCBpbml0aWFsLCBzdGF0ZSwgcGFyYW0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUNQUyhoLCBwYXJ0cywgaW5pdGlhbCwgc3RhdGUsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChoLnN0YXJ0RG9jICYmIGluaXRpYWwgPT0gMCkgeyBoLnN0YXJ0RG9jKHBhcmFtKTsgfVxuICAgICAgdmFyIG0sIHAsIHRhZ05hbWU7XG4gICAgICBmb3IgKHZhciBwb3MgPSBpbml0aWFsLCBlbmQgPSBwYXJ0cy5sZW5ndGg7IHBvcyA8IGVuZDspIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBwYXJ0c1twb3MrK107XG4gICAgICAgIHZhciBuZXh0ID0gcGFydHNbcG9zXTtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50KSB7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgIGlmIChFTlRJVFlfUkVfMi50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgICBpZiAoaC5wY2RhdGEpIHtcbiAgICAgICAgICAgICAgaC5wY2RhdGEoJyYnICsgbmV4dCwgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlcixcbiAgICAgICAgICAgICAgICBjb250aW51YXRpb25NYWtlcihoLCBwYXJ0cywgcG9zLCBzdGF0ZSwgcGFyYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaC5wY2RhdGEpIHsgaC5wY2RhdGEoXCImYW1wO1wiLCBwYXJhbSwgY29udGludWF0aW9uTWFya2VyLFxuICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbk1ha2VyKGgsIHBhcnRzLCBwb3MsIHN0YXRlLCBwYXJhbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPFxcLyc6XG4gICAgICAgICAgaWYgKG0gPSAvXihbLVxcdzpdKylbXlxcJ1xcXCJdKi8uZXhlYyhuZXh0KSkge1xuICAgICAgICAgICAgaWYgKG1bMF0ubGVuZ3RoID09PSBuZXh0Lmxlbmd0aCAmJiBwYXJ0c1twb3MgKyAxXSA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIC8vIGZhc3QgY2FzZSwgbm8gYXR0cmlidXRlIHBhcnNpbmcgbmVlZGVkXG4gICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICB0YWdOYW1lID0gbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoaC5lbmRUYWcpIHtcbiAgICAgICAgICAgICAgICBoLmVuZFRhZyh0YWdOYW1lLCBwYXJhbSwgY29udGludWF0aW9uTWFya2VyLFxuICAgICAgICAgICAgICAgICAgY29udGludWF0aW9uTWFrZXIoaCwgcGFydHMsIHBvcywgc3RhdGUsIHBhcmFtKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHNsb3cgY2FzZSwgbmVlZCB0byBwYXJzZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIC8vIFRPRE8oZmVsaXg4YSk6IGRvIHdlIHJlYWxseSBjYXJlIGFib3V0IG1pc3BhcnNpbmcgdGhpcz9cbiAgICAgICAgICAgICAgcG9zID0gcGFyc2VFbmRUYWcoXG4gICAgICAgICAgICAgICAgcGFydHMsIHBvcywgaCwgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlciwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaC5wY2RhdGEpIHtcbiAgICAgICAgICAgICAgaC5wY2RhdGEoJyZsdDsvJywgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlcixcbiAgICAgICAgICAgICAgICBjb250aW51YXRpb25NYWtlcihoLCBwYXJ0cywgcG9zLCBzdGF0ZSwgcGFyYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGlmIChtID0gL14oWy1cXHc6XSspXFxzKlxcLz8vLmV4ZWMobmV4dCkpIHtcbiAgICAgICAgICAgIGlmIChtWzBdLmxlbmd0aCA9PT0gbmV4dC5sZW5ndGggJiYgcGFydHNbcG9zICsgMV0gPT09ICc+Jykge1xuICAgICAgICAgICAgICAvLyBmYXN0IGNhc2UsIG5vIGF0dHJpYnV0ZSBwYXJzaW5nIG5lZWRlZFxuICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgdGFnTmFtZSA9IG1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKGguc3RhcnRUYWcpIHtcbiAgICAgICAgICAgICAgICBoLnN0YXJ0VGFnKHRhZ05hbWUsIFtdLCBwYXJhbSwgY29udGludWF0aW9uTWFya2VyLFxuICAgICAgICAgICAgICAgICAgY29udGludWF0aW9uTWFrZXIoaCwgcGFydHMsIHBvcywgc3RhdGUsIHBhcmFtKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gdGFncyBsaWtlIDxzY3JpcHQ+IGFuZCA8dGV4dGFyZWE+IGhhdmUgc3BlY2lhbCBwYXJzaW5nXG4gICAgICAgICAgICAgIHZhciBlZmxhZ3MgPSBodG1sNC5FTEVNRU5UU1t0YWdOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKGVmbGFncyAmIEVGTEFHU19URVhUKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHsgbmFtZTogdGFnTmFtZSwgbmV4dDogcG9zLCBlZmxhZ3M6IGVmbGFncyB9O1xuICAgICAgICAgICAgICAgIHBvcyA9IHBhcnNlVGV4dChcbiAgICAgICAgICAgICAgICAgIHBhcnRzLCB0YWcsIGgsIHBhcmFtLCBjb250aW51YXRpb25NYXJrZXIsIHN0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2xvdyBjYXNlLCBuZWVkIHRvIHBhcnNlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgcG9zID0gcGFyc2VTdGFydFRhZyhcbiAgICAgICAgICAgICAgICBwYXJ0cywgcG9zLCBoLCBwYXJhbSwgY29udGludWF0aW9uTWFya2VyLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoLnBjZGF0YSkge1xuICAgICAgICAgICAgICBoLnBjZGF0YSgnJmx0OycsIHBhcmFtLCBjb250aW51YXRpb25NYXJrZXIsXG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uTWFrZXIoaCwgcGFydHMsIHBvcywgc3RhdGUsIHBhcmFtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8XFwhLS0nOlxuICAgICAgICAgIC8vIFRoZSBwYXRob2xvZ2ljYWwgY2FzZSBpcyBuIGNvcGllcyBvZiAnPFxcIS0tJyB3aXRob3V0ICctLT4nLCBhbmRcbiAgICAgICAgICAvLyByZXBlYXRlZCBmYWlsdXJlIHRvIGZpbmQgJy0tPicgaXMgcXVhZHJhdGljLiAgV2UgYXZvaWQgdGhhdCBieVxuICAgICAgICAgIC8vIHJlbWVtYmVyaW5nIHdoZW4gc2VhcmNoIGZvciAnLS0+JyBmYWlscy5cbiAgICAgICAgICBpZiAoIXN0YXRlLm5vTW9yZUVuZENvbW1lbnRzKSB7XG4gICAgICAgICAgICAvLyBBIGNvbW1lbnQgPFxcIS0teC0tPiBpcyBzcGxpdCBpbnRvIHRocmVlIHRva2VuczpcbiAgICAgICAgICAgIC8vICAgJzxcXCEtLScsICd4LS0nLCAnPidcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gZmluZCB0aGUgbmV4dCAnPicgdG9rZW4gdGhhdCBoYXMgYSBwcmVjZWRpbmcgJy0tJy5cbiAgICAgICAgICAgIC8vIHBvcyBpcyBhdCB0aGUgJ3gtLScuXG4gICAgICAgICAgICBmb3IgKHAgPSBwb3MgKyAxOyBwIDwgZW5kOyBwKyspIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzW3BdID09PSAnPicgJiYgLy0tJC8udGVzdChwYXJ0c1twIC0gMV0pKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCA8IGVuZCkge1xuICAgICAgICAgICAgICBpZiAoaC5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBwYXJ0cy5zbGljZShwb3MsIHApLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIGguY29tbWVudChcbiAgICAgICAgICAgICAgICAgIGNvbW1lbnQuc3Vic3RyKDAsIGNvbW1lbnQubGVuZ3RoIC0gMiksIHBhcmFtLFxuICAgICAgICAgICAgICAgICAgY29udGludWF0aW9uTWFya2VyLFxuICAgICAgICAgICAgICAgICAgY29udGludWF0aW9uTWFrZXIoaCwgcGFydHMsIHAgKyAxLCBzdGF0ZSwgcGFyYW0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb3MgPSBwICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLm5vTW9yZUVuZENvbW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLm5vTW9yZUVuZENvbW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoaC5wY2RhdGEpIHtcbiAgICAgICAgICAgICAgaC5wY2RhdGEoJyZsdDshLS0nLCBwYXJhbSwgY29udGludWF0aW9uTWFya2VyLFxuICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbk1ha2VyKGgsIHBhcnRzLCBwb3MsIHN0YXRlLCBwYXJhbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPFxcISc6XG4gICAgICAgICAgaWYgKCEvXlxcdy8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgaWYgKGgucGNkYXRhKSB7XG4gICAgICAgICAgICAgIGgucGNkYXRhKCcmbHQ7IScsIHBhcmFtLCBjb250aW51YXRpb25NYXJrZXIsXG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uTWFrZXIoaCwgcGFydHMsIHBvcywgc3RhdGUsIHBhcmFtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpbWlsYXIgdG8gbm9Nb3JlRW5kQ29tbWVudCBsb2dpY1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5ub01vcmVHVCkge1xuICAgICAgICAgICAgICBmb3IgKHAgPSBwb3MgKyAxOyBwIDwgZW5kOyBwKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbcF0gPT09ICc+JykgeyBicmVhazsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gcCArIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubm9Nb3JlR1QgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUubm9Nb3JlR1QpIHtcbiAgICAgICAgICAgICAgaWYgKGgucGNkYXRhKSB7XG4gICAgICAgICAgICAgICAgaC5wY2RhdGEoJyZsdDshJywgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlcixcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbk1ha2VyKGgsIHBhcnRzLCBwb3MsIHN0YXRlLCBwYXJhbSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8Pyc6XG4gICAgICAgICAgLy8gc2ltaWxhciB0byBub01vcmVFbmRDb21tZW50IGxvZ2ljXG4gICAgICAgICAgaWYgKCFzdGF0ZS5ub01vcmVHVCkge1xuICAgICAgICAgICAgZm9yIChwID0gcG9zICsgMTsgcCA8IGVuZDsgcCsrKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1twXSA9PT0gJz4nKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCA8IGVuZCkge1xuICAgICAgICAgICAgICBwb3MgPSBwICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLm5vTW9yZUdUID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLm5vTW9yZUdUKSB7XG4gICAgICAgICAgICBpZiAoaC5wY2RhdGEpIHtcbiAgICAgICAgICAgICAgaC5wY2RhdGEoJyZsdDs/JywgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlcixcbiAgICAgICAgICAgICAgICBjb250aW51YXRpb25NYWtlcihoLCBwYXJ0cywgcG9zLCBzdGF0ZSwgcGFyYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChoLnBjZGF0YSkge1xuICAgICAgICAgICAgaC5wY2RhdGEoXCImZ3Q7XCIsIHBhcmFtLCBjb250aW51YXRpb25NYXJrZXIsXG4gICAgICAgICAgICAgIGNvbnRpbnVhdGlvbk1ha2VyKGgsIHBhcnRzLCBwb3MsIHN0YXRlLCBwYXJhbSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaC5wY2RhdGEpIHtcbiAgICAgICAgICAgIGgucGNkYXRhKGN1cnJlbnQsIHBhcmFtLCBjb250aW51YXRpb25NYXJrZXIsXG4gICAgICAgICAgICAgIGNvbnRpbnVhdGlvbk1ha2VyKGgsIHBhcnRzLCBwb3MsIHN0YXRlLCBwYXJhbSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGguZW5kRG9jKSB7IGguZW5kRG9jKHBhcmFtKTsgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlICE9PSBjb250aW51YXRpb25NYXJrZXIpIHsgdGhyb3cgZTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNwbGl0IHN0ciBpbnRvIHBhcnRzIGZvciB0aGUgaHRtbCBwYXJzZXIuXG4gIGZ1bmN0aW9uIGh0bWxTcGxpdChzdHIpIHtcbiAgICAvLyBjYW4ndCBob2lzdCB0aGlzIG91dCBvZiB0aGUgZnVuY3Rpb24gYmVjYXVzZSBvZiB0aGUgcmUuZXhlYyBsb29wLlxuICAgIHZhciByZSA9IC8oPFxcL3w8XFwhLS18PFshP118WyY8Pl0pL2c7XG4gICAgc3RyICs9ICcnO1xuICAgIGlmIChzcGxpdFdpbGxDYXB0dXJlKSB7XG4gICAgICByZXR1cm4gc3RyLnNwbGl0KHJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICB2YXIgbGFzdFBvcyA9IDA7XG4gICAgICB2YXIgbTtcbiAgICAgIHdoaWxlICgobSA9IHJlLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICAgICAgcGFydHMucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIG0uaW5kZXgpKTtcbiAgICAgICAgcGFydHMucHVzaChtWzBdKTtcbiAgICAgICAgbGFzdFBvcyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goc3RyLnN1YnN0cmluZyhsYXN0UG9zKSk7XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcocGFydHMsIHBvcywgaCwgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlciwgc3RhdGUpIHtcbiAgICB2YXIgdGFnID0gcGFyc2VUYWdBbmRBdHRycyhwYXJ0cywgcG9zKTtcbiAgICAvLyBkcm9wIHVuY2xvc2VkIHRhZ3NcbiAgICBpZiAoIXRhZykgeyByZXR1cm4gcGFydHMubGVuZ3RoOyB9XG4gICAgaWYgKGguZW5kVGFnKSB7XG4gICAgICBoLmVuZFRhZyh0YWcubmFtZSwgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlcixcbiAgICAgICAgY29udGludWF0aW9uTWFrZXIoaCwgcGFydHMsIHBvcywgc3RhdGUsIHBhcmFtKSk7XG4gICAgfVxuICAgIHJldHVybiB0YWcubmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcocGFydHMsIHBvcywgaCwgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlciwgc3RhdGUpIHtcbiAgICB2YXIgdGFnID0gcGFyc2VUYWdBbmRBdHRycyhwYXJ0cywgcG9zKTtcbiAgICAvLyBkcm9wIHVuY2xvc2VkIHRhZ3NcbiAgICBpZiAoIXRhZykgeyByZXR1cm4gcGFydHMubGVuZ3RoOyB9XG4gICAgaWYgKGguc3RhcnRUYWcpIHtcbiAgICAgIGguc3RhcnRUYWcodGFnLm5hbWUsIHRhZy5hdHRycywgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlcixcbiAgICAgICAgY29udGludWF0aW9uTWFrZXIoaCwgcGFydHMsIHRhZy5uZXh0LCBzdGF0ZSwgcGFyYW0pKTtcbiAgICB9XG4gICAgLy8gdGFncyBsaWtlIDxzY3JpcHQ+IGFuZCA8dGV4dGFyZWE+IGhhdmUgc3BlY2lhbCBwYXJzaW5nXG4gICAgaWYgKHRhZy5lZmxhZ3MgJiBFRkxBR1NfVEVYVCkge1xuICAgICAgcmV0dXJuIHBhcnNlVGV4dChwYXJ0cywgdGFnLCBoLCBwYXJhbSwgY29udGludWF0aW9uTWFya2VyLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0YWcubmV4dDtcbiAgICB9XG4gIH1cblxuICB2YXIgZW5kVGFnUmUgPSB7fTtcblxuICAvLyBUYWdzIGxpa2UgPHNjcmlwdD4gYW5kIDx0ZXh0YXJlYT4gYXJlIGZsYWdnZWQgYXMgQ0RBVEEgb3IgUkNEQVRBLFxuICAvLyB3aGljaCBtZWFucyBldmVyeXRoaW5nIGlzIHRleHQgdW50aWwgd2Ugc2VlIHRoZSBjb3JyZWN0IGNsb3NpbmcgdGFnLlxuICBmdW5jdGlvbiBwYXJzZVRleHQocGFydHMsIHRhZywgaCwgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlciwgc3RhdGUpIHtcbiAgICB2YXIgZW5kID0gcGFydHMubGVuZ3RoO1xuICAgIGlmICghZW5kVGFnUmUuaGFzT3duUHJvcGVydHkodGFnLm5hbWUpKSB7XG4gICAgICBlbmRUYWdSZVt0YWcubmFtZV0gPSBuZXcgUmVnRXhwKCdeJyArIHRhZy5uYW1lICsgJyg/OltcXFxcc1xcXFwvXXwkKScsICdpJyk7XG4gICAgfVxuICAgIHZhciByZSA9IGVuZFRhZ1JlW3RhZy5uYW1lXTtcbiAgICB2YXIgZmlyc3QgPSB0YWcubmV4dDtcbiAgICB2YXIgcCA9IHRhZy5uZXh0ICsgMTtcbiAgICBmb3IgKDsgcCA8IGVuZDsgcCsrKSB7XG4gICAgICBpZiAocGFydHNbcCAtIDFdID09PSAnPFxcLycgJiYgcmUudGVzdChwYXJ0c1twXSkpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHAgPCBlbmQpIHsgcCAtPSAxOyB9XG4gICAgdmFyIGJ1ZiA9IHBhcnRzLnNsaWNlKGZpcnN0LCBwKS5qb2luKCcnKTtcbiAgICBpZiAodGFnLmVmbGFncyAmIGh0bWw0LmVmbGFnc1snQ0RBVEEnXSkge1xuICAgICAgaWYgKGguY2RhdGEpIHtcbiAgICAgICAgaC5jZGF0YShidWYsIHBhcmFtLCBjb250aW51YXRpb25NYXJrZXIsXG4gICAgICAgICAgY29udGludWF0aW9uTWFrZXIoaCwgcGFydHMsIHAsIHN0YXRlLCBwYXJhbSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnLmVmbGFncyAmIGh0bWw0LmVmbGFnc1snUkNEQVRBJ10pIHtcbiAgICAgIGlmIChoLnJjZGF0YSkge1xuICAgICAgICBoLnJjZGF0YShub3JtYWxpemVSQ0RhdGEoYnVmKSwgcGFyYW0sIGNvbnRpbnVhdGlvbk1hcmtlcixcbiAgICAgICAgICBjb250aW51YXRpb25NYWtlcihoLCBwYXJ0cywgcCwgc3RhdGUsIHBhcmFtKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYnVnJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgcGFydHNbcG9zLTFdIGlzIGVpdGhlciBcIjxcIiBvciBcIjxcXC9cIi5cbiAgZnVuY3Rpb24gcGFyc2VUYWdBbmRBdHRycyhwYXJ0cywgcG9zKSB7XG4gICAgdmFyIG0gPSAvXihbLVxcdzpdKykvLmV4ZWMocGFydHNbcG9zXSk7XG4gICAgdmFyIHRhZyA9IHt9O1xuICAgIHRhZy5uYW1lID0gbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIHRhZy5lZmxhZ3MgPSBodG1sNC5FTEVNRU5UU1t0YWcubmFtZV07XG4gICAgdmFyIGJ1ZiA9IHBhcnRzW3Bvc10uc3Vic3RyKG1bMF0ubGVuZ3RoKTtcbiAgICAvLyBGaW5kIHRoZSBuZXh0ICc+Jy4gIFdlIG9wdGltaXN0aWNhbGx5IGFzc3VtZSB0aGlzICc+JyBpcyBub3QgaW4gYVxuICAgIC8vIHF1b3RlZCBjb250ZXh0LCBhbmQgZnVydGhlciBkb3duIHdlIGZpeCB0aGluZ3MgdXAgaWYgaXQgdHVybnMgb3V0IHRvXG4gICAgLy8gYmUgcXVvdGVkLlxuICAgIHZhciBwID0gcG9zICsgMTtcbiAgICB2YXIgZW5kID0gcGFydHMubGVuZ3RoO1xuICAgIGZvciAoOyBwIDwgZW5kOyBwKyspIHtcbiAgICAgIGlmIChwYXJ0c1twXSA9PT0gJz4nKSB7IGJyZWFrOyB9XG4gICAgICBidWYgKz0gcGFydHNbcF07XG4gICAgfVxuICAgIGlmIChlbmQgPD0gcCkgeyByZXR1cm4gdm9pZCAwOyB9XG4gICAgdmFyIGF0dHJzID0gW107XG4gICAgd2hpbGUgKGJ1ZiAhPT0gJycpIHtcbiAgICAgIG0gPSBBVFRSX1JFLmV4ZWMoYnVmKTtcbiAgICAgIGlmICghbSkge1xuICAgICAgICAvLyBObyBhdHRyaWJ1dGUgZm91bmQ6IHNraXAgZ2FyYmFnZVxuICAgICAgICBidWYgPSBidWYucmVwbGFjZSgvXltcXHNcXFNdW15hLXpcXHNdKi8sICcnKTtcblxuICAgICAgfSBlbHNlIGlmICgobVs0XSAmJiAhbVs1XSkgfHwgKG1bNl0gJiYgIW1bN10pKSB7XG4gICAgICAgIC8vIFVudGVybWluYXRlZCBxdW90ZTogc2x1cnAgdG8gdGhlIG5leHQgdW5xdW90ZWQgJz4nXG4gICAgICAgIHZhciBxdW90ZSA9IG1bNF0gfHwgbVs2XTtcbiAgICAgICAgdmFyIHNhd1F1b3RlID0gZmFsc2U7XG4gICAgICAgIHZhciBhYnVmID0gW2J1ZiwgcGFydHNbcCsrXV07XG4gICAgICAgIGZvciAoOyBwIDwgZW5kOyBwKyspIHtcbiAgICAgICAgICBpZiAoc2F3UXVvdGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1twXSA9PT0gJz4nKSB7IGJyZWFrOyB9XG4gICAgICAgICAgfSBlbHNlIGlmICgwIDw9IHBhcnRzW3BdLmluZGV4T2YocXVvdGUpKSB7XG4gICAgICAgICAgICBzYXdRdW90ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFidWYucHVzaChwYXJ0c1twXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2x1cnAgZmFpbGVkOiBsb3NlIHRoZSBnYXJiYWdlXG4gICAgICAgIGlmIChlbmQgPD0gcCkgeyBicmVhazsgfVxuICAgICAgICAvLyBPdGhlcndpc2UgcmV0cnkgYXR0cmlidXRlIHBhcnNpbmdcbiAgICAgICAgYnVmID0gYWJ1Zi5qb2luKCcnKTtcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gYXR0cmlidXRlXG4gICAgICAgIHZhciBhTmFtZSA9IG1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGFWYWx1ZSA9IG1bMl0gPyBkZWNvZGVWYWx1ZShtWzNdKSA6ICcnO1xuICAgICAgICBhdHRycy5wdXNoKGFOYW1lLCBhVmFsdWUpO1xuICAgICAgICBidWYgPSBidWYuc3Vic3RyKG1bMF0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGFnLmF0dHJzID0gYXR0cnM7XG4gICAgdGFnLm5leHQgPSBwICsgMTtcbiAgICByZXR1cm4gdGFnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlVmFsdWUodikge1xuICAgIHZhciBxID0gdi5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChxID09PSAweDIyIHx8IHEgPT09IDB4MjcpIHsgLy8gXCIgb3IgJ1xuICAgICAgdiA9IHYuc3Vic3RyKDEsIHYubGVuZ3RoIC0gMik7XG4gICAgfVxuICAgIHJldHVybiB1bmVzY2FwZUVudGl0aWVzKHN0cmlwTlVMcyh2KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc3RyaXBzIHVuc2FmZSB0YWdzIGFuZCBhdHRyaWJ1dGVzIGZyb20gaHRtbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIEFycmF5LjxzdHJpbmc+KTogP0FycmF5LjxzdHJpbmc+fSB0YWdQb2xpY3lcbiAgICogICAgIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyAodGFnTmFtZSwgYXR0cmlic1tdKSwgd2hlcmUgdGFnTmFtZSBpcyBhIGtleSBpblxuICAgKiAgICAgaHRtbDQuRUxFTUVOVFMgYW5kIGF0dHJpYnMgaXMgYW4gYXJyYXkgb2YgYWx0ZXJuYXRpbmcgYXR0cmlidXRlIG5hbWVzXG4gICAqICAgICBhbmQgdmFsdWVzLiAgSXQgc2hvdWxkIHJldHVybiBhIHJlY29yZCAoYXMgZm9sbG93cyksIG9yIG51bGwgdG8gZGVsZXRlXG4gICAqICAgICB0aGUgZWxlbWVudC4gIEl0J3Mgb2theSBmb3IgdGFnUG9saWN5IHRvIG1vZGlmeSB0aGUgYXR0cmlicyBhcnJheSxcbiAgICogICAgIGJ1dCB0aGUgc2FtZSBhcnJheSBpcyByZXVzZWQsIHNvIGl0IHNob3VsZCBub3QgYmUgaGVsZCBiZXR3ZWVuIGNhbGxzLlxuICAgKiAgICAgUmVjb3JkIGtleXM6XG4gICAqICAgICAgICBhdHRyaWJzOiAocmVxdWlyZWQpIFNhbml0aXplZCBhdHRyaWJ1dGVzIGFycmF5LlxuICAgKiAgICAgICAgdGFnTmFtZTogUmVwbGFjZW1lbnQgdGFnIG5hbWUuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKHN0cmluZywgQXJyYXkpfSBBIGZ1bmN0aW9uIHRoYXQgc2FuaXRpemVzIGEgc3RyaW5nIG9mXG4gICAqICAgICBIVE1MIGFuZCBhcHBlbmRzIHJlc3VsdCBzdHJpbmdzIHRvIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUh0bWxTYW5pdGl6ZXIodGFnUG9saWN5KSB7XG4gICAgdmFyIHN0YWNrO1xuICAgIHZhciBpZ25vcmluZztcbiAgICB2YXIgZW1pdCA9IGZ1bmN0aW9uICh0ZXh0LCBvdXQpIHtcbiAgICAgIGlmICghaWdub3JpbmcpIHsgb3V0LnB1c2godGV4dCk7IH1cbiAgICB9O1xuICAgIHJldHVybiBtYWtlU2F4UGFyc2VyKHtcbiAgICAgICdzdGFydERvYyc6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgc3RhY2sgPSBbXTtcbiAgICAgICAgaWdub3JpbmcgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICAnc3RhcnRUYWcnOiBmdW5jdGlvbih0YWdOYW1lT3JpZywgYXR0cmlicywgb3V0KSB7XG4gICAgICAgIGlmIChpZ25vcmluZykgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKCFodG1sNC5FTEVNRU5UUy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lT3JpZykpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBlZmxhZ3NPcmlnID0gaHRtbDQuRUxFTUVOVFNbdGFnTmFtZU9yaWddO1xuICAgICAgICBpZiAoZWZsYWdzT3JpZyAmIGh0bWw0LmVmbGFnc1snRk9MREFCTEUnXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWNpc2lvbiA9IHRhZ1BvbGljeSh0YWdOYW1lT3JpZywgYXR0cmlicyk7XG4gICAgICAgIGlmICghZGVjaXNpb24pIHtcbiAgICAgICAgICBpZ25vcmluZyA9ICEoZWZsYWdzT3JpZyAmIGh0bWw0LmVmbGFnc1snRU1QVFknXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWNpc2lvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhZ1BvbGljeSBkaWQgbm90IHJldHVybiBvYmplY3QgKG9sZCBBUEk/KScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnYXR0cmlicycgaW4gZGVjaXNpb24pIHtcbiAgICAgICAgICBhdHRyaWJzID0gZGVjaXNpb25bJ2F0dHJpYnMnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhZ1BvbGljeSBnYXZlIG5vIGF0dHJpYnMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWZsYWdzUmVwO1xuICAgICAgICB2YXIgdGFnTmFtZVJlcDtcbiAgICAgICAgaWYgKCd0YWdOYW1lJyBpbiBkZWNpc2lvbikge1xuICAgICAgICAgIHRhZ05hbWVSZXAgPSBkZWNpc2lvblsndGFnTmFtZSddO1xuICAgICAgICAgIGVmbGFnc1JlcCA9IGh0bWw0LkVMRU1FTlRTW3RhZ05hbWVSZXBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhZ05hbWVSZXAgPSB0YWdOYW1lT3JpZztcbiAgICAgICAgICBlZmxhZ3NSZXAgPSBlZmxhZ3NPcmlnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8obWlrZXNhbXVlbCk6IHJlbHlpbmcgb24gdGFnUG9saWN5IG5vdCB0byBpbnNlcnQgdW5zYWZlXG4gICAgICAgIC8vIGF0dHJpYnV0ZSBuYW1lcy5cblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIG9wdGlvbmFsLWVuZC10YWcgZWxlbWVudCBhbmQgZWl0aGVyIHRoaXMgZWxlbWVudCBvciBpdHNcbiAgICAgICAgLy8gcHJldmlvdXMgbGlrZSBzaWJsaW5nIHdhcyByZXdyaXR0ZW4sIHRoZW4gaW5zZXJ0IGEgY2xvc2UgdGFnIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIHN0cnVjdHVyZS5cbiAgICAgICAgaWYgKGVmbGFnc09yaWcgJiBodG1sNC5lZmxhZ3NbJ09QVElPTkFMX0VORFRBRyddKSB7XG4gICAgICAgICAgdmFyIG9uU3RhY2sgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAob25TdGFjayAmJiBvblN0YWNrLm9yaWcgPT09IHRhZ05hbWVPcmlnICYmXG4gICAgICAgICAgICAgIChvblN0YWNrLnJlcCAhPT0gdGFnTmFtZVJlcCB8fCB0YWdOYW1lT3JpZyAhPT0gdGFnTmFtZVJlcCkpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCgnPFxcLycsIG9uU3RhY2sucmVwLCAnPicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKGVmbGFnc09yaWcgJiBodG1sNC5lZmxhZ3NbJ0VNUFRZJ10pKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCh7b3JpZzogdGFnTmFtZU9yaWcsIHJlcDogdGFnTmFtZVJlcH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LnB1c2goJzwnLCB0YWdOYW1lUmVwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhdHRyaWJzLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgICAgIHZhciBhdHRyaWJOYW1lID0gYXR0cmlic1tpXSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhdHRyaWJzW2kgKyAxXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3V0LnB1c2goJyAnLCBhdHRyaWJOYW1lLCAnPVwiJywgZXNjYXBlQXR0cmliKHZhbHVlKSwgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKCc+Jyk7XG5cbiAgICAgICAgaWYgKChlZmxhZ3NPcmlnICYgaHRtbDQuZWZsYWdzWydFTVBUWSddKVxuICAgICAgICAgICAgJiYgIShlZmxhZ3NSZXAgJiBodG1sNC5lZmxhZ3NbJ0VNUFRZJ10pKSB7XG4gICAgICAgICAgLy8gcmVwbGFjZW1lbnQgaXMgbm9uLWVtcHR5LCBzeW50aGVzaXplIGVuZCB0YWdcbiAgICAgICAgICBvdXQucHVzaCgnPFxcLycsIHRhZ05hbWVSZXAsICc+Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnZW5kVGFnJzogZnVuY3Rpb24odGFnTmFtZSwgb3V0KSB7XG4gICAgICAgIGlmIChpZ25vcmluZykge1xuICAgICAgICAgIGlnbm9yaW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaHRtbDQuRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBlZmxhZ3MgPSBodG1sNC5FTEVNRU5UU1t0YWdOYW1lXTtcbiAgICAgICAgaWYgKCEoZWZsYWdzICYgKGh0bWw0LmVmbGFnc1snRU1QVFknXSB8IGh0bWw0LmVmbGFnc1snRk9MREFCTEUnXSkpKSB7XG4gICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgIGlmIChlZmxhZ3MgJiBodG1sNC5lZmxhZ3NbJ09QVElPTkFMX0VORFRBRyddKSB7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gc3RhY2subGVuZ3RoOyAtLWluZGV4ID49IDA7KSB7XG4gICAgICAgICAgICAgIHZhciBzdGFja0VsT3JpZ1RhZyA9IHN0YWNrW2luZGV4XS5vcmlnO1xuICAgICAgICAgICAgICBpZiAoc3RhY2tFbE9yaWdUYWcgPT09IHRhZ05hbWUpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgaWYgKCEoaHRtbDQuRUxFTUVOVFNbc3RhY2tFbE9yaWdUYWddICZcbiAgICAgICAgICAgICAgICAgICAgaHRtbDQuZWZsYWdzWydPUFRJT05BTF9FTkRUQUcnXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwb3Agbm9uIG9wdGlvbmFsIGVuZCB0YWdzIGxvb2tpbmcgZm9yIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSBzdGFjay5sZW5ndGg7IC0taW5kZXggPj0gMDspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2luZGV4XS5vcmlnID09PSB0YWdOYW1lKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHsgcmV0dXJuOyB9ICAvLyBOb3Qgb3BlbmVkLlxuICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IC0taSA+IGluZGV4Oykge1xuICAgICAgICAgICAgdmFyIHN0YWNrRWxSZXBUYWcgPSBzdGFja1tpXS5yZXA7XG4gICAgICAgICAgICBpZiAoIShodG1sNC5FTEVNRU5UU1tzdGFja0VsUmVwVGFnXSAmXG4gICAgICAgICAgICAgICAgICBodG1sNC5lZmxhZ3NbJ09QVElPTkFMX0VORFRBRyddKSkge1xuICAgICAgICAgICAgICBvdXQucHVzaCgnPFxcLycsIHN0YWNrRWxSZXBUYWcsICc+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCA8IHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFnTmFtZSA9IHN0YWNrW2luZGV4XS5yZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGluZGV4O1xuICAgICAgICAgIG91dC5wdXNoKCc8XFwvJywgdGFnTmFtZSwgJz4nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdwY2RhdGEnOiBlbWl0LFxuICAgICAgJ3JjZGF0YSc6IGVtaXQsXG4gICAgICAnY2RhdGEnOiBlbWl0LFxuICAgICAgJ2VuZERvYyc6IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICBmb3IgKDsgc3RhY2subGVuZ3RoOyBzdGFjay5sZW5ndGgtLSkge1xuICAgICAgICAgIG91dC5wdXNoKCc8XFwvJywgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ucmVwLCAnPicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgQUxMT1dFRF9VUklfU0NIRU1FUyA9IC9eKD86aHR0cHM/fG1haWx0b3xkYXRhKSQvaTtcblxuICBmdW5jdGlvbiBzYWZlVXJpKHVyaSwgZWZmZWN0LCBsdHlwZSwgaGludHMsIG5haXZlVXJpUmV3cml0ZXIpIHtcbiAgICBpZiAoIW5haXZlVXJpUmV3cml0ZXIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0cnkge1xuICAgICAgdmFyIHBhcnNlZCA9IFVSSS5wYXJzZSgnJyArIHVyaSk7XG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmICghcGFyc2VkLmhhc1NjaGVtZSgpIHx8XG4gICAgICAgICAgICBBTExPV0VEX1VSSV9TQ0hFTUVTLnRlc3QocGFyc2VkLmdldFNjaGVtZSgpKSkge1xuICAgICAgICAgIHZhciBzYWZlID0gbmFpdmVVcmlSZXdyaXRlcihwYXJzZWQsIGVmZmVjdCwgbHR5cGUsIGhpbnRzKTtcbiAgICAgICAgICByZXR1cm4gc2FmZSA/IHNhZmUudG9TdHJpbmcoKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBsb2cobG9nZ2VyLCB0YWdOYW1lLCBhdHRyaWJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoIWF0dHJpYk5hbWUpIHtcbiAgICAgIGxvZ2dlcih0YWdOYW1lICsgXCIgcmVtb3ZlZFwiLCB7XG4gICAgICAgIGNoYW5nZTogXCJyZW1vdmVkXCIsXG4gICAgICAgIHRhZ05hbWU6IHRhZ05hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IFwiY2hhbmdlZFwiO1xuICAgICAgaWYgKG9sZFZhbHVlICYmICFuZXdWYWx1ZSkge1xuICAgICAgICBjaGFuZ2VkID0gXCJyZW1vdmVkXCI7XG4gICAgICB9IGVsc2UgaWYgKCFvbGRWYWx1ZSAmJiBuZXdWYWx1ZSkgIHtcbiAgICAgICAgY2hhbmdlZCA9IFwiYWRkZWRcIjtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcih0YWdOYW1lICsgXCIuXCIgKyBhdHRyaWJOYW1lICsgXCIgXCIgKyBjaGFuZ2VkLCB7XG4gICAgICAgIGNoYW5nZTogY2hhbmdlZCxcbiAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgYXR0cmliTmFtZTogYXR0cmliTmFtZSxcbiAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb2t1cEF0dHJpYnV0ZShtYXAsIHRhZ05hbWUsIGF0dHJpYk5hbWUpIHtcbiAgICB2YXIgYXR0cmliS2V5O1xuICAgIGF0dHJpYktleSA9IHRhZ05hbWUgKyAnOjonICsgYXR0cmliTmFtZTtcbiAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGF0dHJpYktleSkpIHtcbiAgICAgIHJldHVybiBtYXBbYXR0cmliS2V5XTtcbiAgICB9XG4gICAgYXR0cmliS2V5ID0gJyo6OicgKyBhdHRyaWJOYW1lO1xuICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkoYXR0cmliS2V5KSkge1xuICAgICAgcmV0dXJuIG1hcFthdHRyaWJLZXldO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVR5cGUodGFnTmFtZSwgYXR0cmliTmFtZSkge1xuICAgIHJldHVybiBsb29rdXBBdHRyaWJ1dGUoaHRtbDQuQVRUUklCUywgdGFnTmFtZSwgYXR0cmliTmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TG9hZGVyVHlwZSh0YWdOYW1lLCBhdHRyaWJOYW1lKSB7XG4gICAgcmV0dXJuIGxvb2t1cEF0dHJpYnV0ZShodG1sNC5MT0FERVJUWVBFUywgdGFnTmFtZSwgYXR0cmliTmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VXJpRWZmZWN0KHRhZ05hbWUsIGF0dHJpYk5hbWUpIHtcbiAgICByZXR1cm4gbG9va3VwQXR0cmlidXRlKGh0bWw0LlVSSUVGRkVDVFMsIHRhZ05hbWUsIGF0dHJpYk5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhbml0aXplcyBhdHRyaWJ1dGVzIG9uIGFuIEhUTUwgdGFnLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBBbiBIVE1MIHRhZyBuYW1lIGluIGxvd2VyY2FzZS5cbiAgICogQHBhcmFtIHtBcnJheS48P3N0cmluZz59IGF0dHJpYnMgQW4gYXJyYXkgb2YgYWx0ZXJuYXRpbmcgbmFtZXMgYW5kIHZhbHVlcy5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP3N0cmluZyk6ID9zdHJpbmd9IG9wdF9uYWl2ZVVyaVJld3JpdGVyIEEgdHJhbnNmb3JtIHRvXG4gICAqICAgICBhcHBseSB0byBVUkkgYXR0cmlidXRlczsgaXQgY2FuIHJldHVybiBhIG5ldyBzdHJpbmcgdmFsdWUsIG9yIG51bGwgdG9cbiAgICogICAgIGRlbGV0ZSB0aGUgYXR0cmlidXRlLiAgSWYgdW5zcGVjaWZpZWQsIFVSSSBhdHRyaWJ1dGVzIGFyZSBkZWxldGVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9zdHJpbmcpOiA/c3RyaW5nfSBvcHRfbm1Ub2tlblBvbGljeSBBIHRyYW5zZm9ybSB0byBhcHBseVxuICAgKiAgICAgdG8gYXR0cmlidXRlcyBjb250YWluaW5nIEhUTUwgbmFtZXMsIGVsZW1lbnQgSURzLCBhbmQgc3BhY2Utc2VwYXJhdGVkXG4gICAqICAgICBsaXN0cyBvZiBjbGFzc2VzOyBpdCBjYW4gcmV0dXJuIGEgbmV3IHN0cmluZyB2YWx1ZSwgb3IgbnVsbCB0byBkZWxldGVcbiAgICogICAgIHRoZSBhdHRyaWJ1dGUuICBJZiB1bnNwZWNpZmllZCwgdGhlc2UgYXR0cmlidXRlcyBhcmUga2VwdCB1bmNoYW5nZWQuXG4gICAqIEByZXR1cm4ge0FycmF5Ljw/c3RyaW5nPn0gVGhlIHNhbml0aXplZCBhdHRyaWJ1dGVzIGFzIGEgbGlzdCBvZiBhbHRlcm5hdGluZ1xuICAgKiAgICAgbmFtZXMgYW5kIHZhbHVlcywgd2hlcmUgYSBudWxsIHZhbHVlIG1lYW5zIHRvIG9taXQgdGhlIGF0dHJpYnV0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHNhbml0aXplQXR0cmlicyh0YWdOYW1lLCBhdHRyaWJzLFxuICAgIG9wdF9uYWl2ZVVyaVJld3JpdGVyLCBvcHRfbm1Ub2tlblBvbGljeSwgb3B0X2xvZ2dlcikge1xuICAgIC8vIFRPRE8oZmVsaXg4YSk6IGl0J3Mgb2Jub3hpb3VzIHRoYXQgZG9tYWRvIGR1cGxpY2F0ZXMgbXVjaCBvZiB0aGlzXG4gICAgLy8gVE9ETyhmZWxpeDhhKTogbWF5YmUgY29uc2lzdGVudGx5IGVuZm9yY2UgY29uc3RyYWludHMgbGlrZSB0YXJnZXQ9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgYXR0cmliTmFtZSA9IGF0dHJpYnNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJzW2kgKyAxXTtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgdmFyIGF0eXBlID0gbnVsbCwgYXR0cmliS2V5O1xuICAgICAgaWYgKChhdHRyaWJLZXkgPSB0YWdOYW1lICsgJzo6JyArIGF0dHJpYk5hbWUsXG4gICAgICAgICAgIGh0bWw0LkFUVFJJQlMuaGFzT3duUHJvcGVydHkoYXR0cmliS2V5KSkgfHxcbiAgICAgICAgICAoYXR0cmliS2V5ID0gJyo6OicgKyBhdHRyaWJOYW1lLFxuICAgICAgICAgICBodG1sNC5BVFRSSUJTLmhhc093blByb3BlcnR5KGF0dHJpYktleSkpKSB7XG4gICAgICAgIGF0eXBlID0gaHRtbDQuQVRUUklCU1thdHRyaWJLZXldO1xuICAgICAgfVxuICAgICAgaWYgKGF0eXBlICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAoYXR5cGUpIHtcbiAgICAgICAgICBjYXNlIGh0bWw0LmF0eXBlWydOT05FJ106IGJyZWFrO1xuICAgICAgICAgIGNhc2UgaHRtbDQuYXR5cGVbJ1NDUklQVCddOlxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG9wdF9sb2dnZXIpIHtcbiAgICAgICAgICAgICAgbG9nKG9wdF9sb2dnZXIsIHRhZ05hbWUsIGF0dHJpYk5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGh0bWw0LmF0eXBlWydTVFlMRSddOlxuICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgcGFyc2VDc3NEZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAob3B0X2xvZ2dlcikge1xuICAgICAgICAgICAgICAgIGxvZyhvcHRfbG9nZ2VyLCB0YWdOYW1lLCBhdHRyaWJOYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuXHQgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNhbml0aXplZERlY2xhcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgcGFyc2VDc3NEZWNsYXJhdGlvbnMoXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb246IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtUHJvcCA9IHByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSBjc3NTY2hlbWFbbm9ybVByb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzYW5pdGl6ZUNzc1Byb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybVByb3AsIHNjaGVtYSwgdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0X25haXZlVXJpUmV3cml0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzYWZlVXJpKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsIGh0bWw0LnVlZmZlY3RzLlNBTUVfRE9DVU1FTlQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw0Lmx0eXBlcy5TQU5EQk9YRUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRZUEVcIjogXCJDU1NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNTU19QUk9QXCI6IG5vcm1Qcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdF9uYWl2ZVVyaVJld3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgc2FuaXRpemVkRGVjbGFyYXRpb25zLnB1c2gocHJvcGVydHkgKyAnOiAnICsgdG9rZW5zLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplZERlY2xhcmF0aW9ucy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgc2FuaXRpemVkRGVjbGFyYXRpb25zLmpvaW4oJyA7ICcpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChvcHRfbG9nZ2VyKSB7XG4gICAgICAgICAgICAgIGxvZyhvcHRfbG9nZ2VyLCB0YWdOYW1lLCBhdHRyaWJOYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBodG1sNC5hdHlwZVsnSUQnXTpcbiAgICAgICAgICBjYXNlIGh0bWw0LmF0eXBlWydJRFJFRiddOlxuICAgICAgICAgIGNhc2UgaHRtbDQuYXR5cGVbJ0lEUkVGUyddOlxuICAgICAgICAgIGNhc2UgaHRtbDQuYXR5cGVbJ0dMT0JBTF9OQU1FJ106XG4gICAgICAgICAgY2FzZSBodG1sNC5hdHlwZVsnTE9DQUxfTkFNRSddOlxuICAgICAgICAgIGNhc2UgaHRtbDQuYXR5cGVbJ0NMQVNTRVMnXTpcbiAgICAgICAgICAgIHZhbHVlID0gb3B0X25tVG9rZW5Qb2xpY3kgPyBvcHRfbm1Ub2tlblBvbGljeSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRfbG9nZ2VyKSB7XG4gICAgICAgICAgICAgIGxvZyhvcHRfbG9nZ2VyLCB0YWdOYW1lLCBhdHRyaWJOYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBodG1sNC5hdHlwZVsnVVJJJ106XG4gICAgICAgICAgICB2YWx1ZSA9IHNhZmVVcmkodmFsdWUsXG4gICAgICAgICAgICAgIGdldFVyaUVmZmVjdCh0YWdOYW1lLCBhdHRyaWJOYW1lKSxcbiAgICAgICAgICAgICAgZ2V0TG9hZGVyVHlwZSh0YWdOYW1lLCBhdHRyaWJOYW1lKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiVFlQRVwiOiBcIk1BUktVUFwiLFxuICAgICAgICAgICAgICAgIFwiWE1MX0FUVFJcIjogYXR0cmliTmFtZSxcbiAgICAgICAgICAgICAgICBcIlhNTF9UQUdcIjogdGFnTmFtZVxuICAgICAgICAgICAgICB9LCBvcHRfbmFpdmVVcmlSZXdyaXRlcik7XG4gICAgICAgICAgICAgIGlmIChvcHRfbG9nZ2VyKSB7XG4gICAgICAgICAgICAgIGxvZyhvcHRfbG9nZ2VyLCB0YWdOYW1lLCBhdHRyaWJOYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBodG1sNC5hdHlwZVsnVVJJX0ZSQUdNRU5UJ106XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgJyMnID09PSB2YWx1ZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7ICAvLyByZW1vdmUgdGhlIGxlYWRpbmcgJyMnXG4gICAgICAgICAgICAgIHZhbHVlID0gb3B0X25tVG9rZW5Qb2xpY3kgPyBvcHRfbm1Ub2tlblBvbGljeSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcjJyArIHZhbHVlOyAgLy8gcmVzdG9yZSB0aGUgbGVhZGluZyAnIydcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdF9sb2dnZXIpIHtcbiAgICAgICAgICAgICAgbG9nKG9wdF9sb2dnZXIsIHRhZ05hbWUsIGF0dHJpYk5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG9wdF9sb2dnZXIpIHtcbiAgICAgICAgICAgICAgbG9nKG9wdF9sb2dnZXIsIHRhZ05hbWUsIGF0dHJpYk5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAob3B0X2xvZ2dlcikge1xuICAgICAgICAgIGxvZyhvcHRfbG9nZ2VyLCB0YWdOYW1lLCBhdHRyaWJOYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhdHRyaWJzW2kgKyAxXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlicztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGFnIHBvbGljeSB0aGF0IG9taXRzIGFsbCB0YWdzIG1hcmtlZCBVTlNBRkUgaW4gaHRtbDQtZGVmcy5qc1xuICAgKiBhbmQgYXBwbGllcyB0aGUgZGVmYXVsdCBhdHRyaWJ1dGUgc2FuaXRpemVyIHdpdGggdGhlIHN1cHBsaWVkIHBvbGljeSBmb3JcbiAgICogVVJJIGF0dHJpYnV0ZXMgYW5kIE5NVE9LRU4gYXR0cmlidXRlcy5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP3N0cmluZyk6ID9zdHJpbmd9IG9wdF9uYWl2ZVVyaVJld3JpdGVyIEEgdHJhbnNmb3JtIHRvXG4gICAqICAgICBhcHBseSB0byBVUkkgYXR0cmlidXRlcy4gIElmIG5vdCBnaXZlbiwgVVJJIGF0dHJpYnV0ZXMgYXJlIGRlbGV0ZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oP3N0cmluZyk6ID9zdHJpbmd9IG9wdF9ubVRva2VuUG9saWN5IEEgdHJhbnNmb3JtIHRvIGFwcGx5XG4gICAqICAgICB0byBhdHRyaWJ1dGVzIGNvbnRhaW5pbmcgSFRNTCBuYW1lcywgZWxlbWVudCBJRHMsIGFuZCBzcGFjZS1zZXBhcmF0ZWRcbiAgICogICAgIGxpc3RzIG9mIGNsYXNzZXMuICBJZiBub3QgZ2l2ZW4sIHN1Y2ggYXR0cmlidXRlcyBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKHN0cmluZywgQXJyYXkuPD9zdHJpbmc+KX0gQSB0YWdQb2xpY3kgc3VpdGFibGUgZm9yXG4gICAqICAgICBwYXNzaW5nIHRvIGh0bWwuc2FuaXRpemUuXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlVGFnUG9saWN5KFxuICAgIG9wdF9uYWl2ZVVyaVJld3JpdGVyLCBvcHRfbm1Ub2tlblBvbGljeSwgb3B0X2xvZ2dlcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YWdOYW1lLCBhdHRyaWJzKSB7XG4gICAgICBpZiAoIShodG1sNC5FTEVNRU5UU1t0YWdOYW1lXSAmIGh0bWw0LmVmbGFnc1snVU5TQUZFJ10pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJ2F0dHJpYnMnOiBzYW5pdGl6ZUF0dHJpYnModGFnTmFtZSwgYXR0cmlicyxcbiAgICAgICAgICAgIG9wdF9uYWl2ZVVyaVJld3JpdGVyLCBvcHRfbm1Ub2tlblBvbGljeSwgb3B0X2xvZ2dlcilcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRfbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nKG9wdF9sb2dnZXIsIHRhZ05hbWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW5pdGl6ZXMgSFRNTCB0YWdzIGFuZCBhdHRyaWJ1dGVzIGFjY29yZGluZyB0byBhIGdpdmVuIHBvbGljeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0SHRtbCBUaGUgSFRNTCB0byBzYW5pdGl6ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIEFycmF5Ljw/c3RyaW5nPil9IHRhZ1BvbGljeSBBIGZ1bmN0aW9uIHRoYXRcbiAgICogICAgIGRlY2lkZXMgd2hpY2ggdGFncyB0byBhY2NlcHQgYW5kIHNhbml0aXplcyB0aGVpciBhdHRyaWJ1dGVzIChzZWVcbiAgICogICAgIG1ha2VIdG1sU2FuaXRpemVyIGFib3ZlIGZvciBkZXRhaWxzKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc2FuaXRpemVkIEhUTUwuXG4gICAqL1xuICBmdW5jdGlvbiBzYW5pdGl6ZVdpdGhQb2xpY3koaW5wdXRIdG1sLCB0YWdQb2xpY3kpIHtcbiAgICB2YXIgb3V0cHV0QXJyYXkgPSBbXTtcbiAgICBtYWtlSHRtbFNhbml0aXplcih0YWdQb2xpY3kpKGlucHV0SHRtbCwgb3V0cHV0QXJyYXkpO1xuICAgIHJldHVybiBvdXRwdXRBcnJheS5qb2luKCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpcHMgdW5zYWZlIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgZnJvbSBIVE1MLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRIdG1sIFRoZSBIVE1MIHRvIHNhbml0aXplLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbig/c3RyaW5nKTogP3N0cmluZ30gb3B0X25haXZlVXJpUmV3cml0ZXIgQSB0cmFuc2Zvcm0gdG9cbiAgICogICAgIGFwcGx5IHRvIFVSSSBhdHRyaWJ1dGVzLiAgSWYgbm90IGdpdmVuLCBVUkkgYXR0cmlidXRlcyBhcmUgZGVsZXRlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbig/c3RyaW5nKTogP3N0cmluZ30gb3B0X25tVG9rZW5Qb2xpY3kgQSB0cmFuc2Zvcm0gdG8gYXBwbHlcbiAgICogICAgIHRvIGF0dHJpYnV0ZXMgY29udGFpbmluZyBIVE1MIG5hbWVzLCBlbGVtZW50IElEcywgYW5kIHNwYWNlLXNlcGFyYXRlZFxuICAgKiAgICAgbGlzdHMgb2YgY2xhc3Nlcy4gIElmIG5vdCBnaXZlbiwgc3VjaCBhdHRyaWJ1dGVzIGFyZSBsZWZ0IHVuY2hhbmdlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHNhbml0aXplKGlucHV0SHRtbCxcbiAgICBvcHRfbmFpdmVVcmlSZXdyaXRlciwgb3B0X25tVG9rZW5Qb2xpY3ksIG9wdF9sb2dnZXIpIHtcbiAgICB2YXIgdGFnUG9saWN5ID0gbWFrZVRhZ1BvbGljeShcbiAgICAgIG9wdF9uYWl2ZVVyaVJld3JpdGVyLCBvcHRfbm1Ub2tlblBvbGljeSwgb3B0X2xvZ2dlcik7XG4gICAgcmV0dXJuIHNhbml0aXplV2l0aFBvbGljeShpbnB1dEh0bWwsIHRhZ1BvbGljeSk7XG4gIH1cblxuICAvLyBFeHBvcnQgYm90aCBxdW90ZWQgYW5kIHVucXVvdGVkIG5hbWVzIGZvciBDbG9zdXJlIGxpbmthZ2UuXG4gIHZhciBodG1sID0ge307XG4gIGh0bWwuZXNjYXBlQXR0cmliID0gaHRtbFsnZXNjYXBlQXR0cmliJ10gPSBlc2NhcGVBdHRyaWI7XG4gIGh0bWwubWFrZUh0bWxTYW5pdGl6ZXIgPSBodG1sWydtYWtlSHRtbFNhbml0aXplciddID0gbWFrZUh0bWxTYW5pdGl6ZXI7XG4gIGh0bWwubWFrZVNheFBhcnNlciA9IGh0bWxbJ21ha2VTYXhQYXJzZXInXSA9IG1ha2VTYXhQYXJzZXI7XG4gIGh0bWwubWFrZVRhZ1BvbGljeSA9IGh0bWxbJ21ha2VUYWdQb2xpY3knXSA9IG1ha2VUYWdQb2xpY3k7XG4gIGh0bWwubm9ybWFsaXplUkNEYXRhID0gaHRtbFsnbm9ybWFsaXplUkNEYXRhJ10gPSBub3JtYWxpemVSQ0RhdGE7XG4gIGh0bWwuc2FuaXRpemUgPSBodG1sWydzYW5pdGl6ZSddID0gc2FuaXRpemU7XG4gIGh0bWwuc2FuaXRpemVBdHRyaWJzID0gaHRtbFsnc2FuaXRpemVBdHRyaWJzJ10gPSBzYW5pdGl6ZUF0dHJpYnM7XG4gIGh0bWwuc2FuaXRpemVXaXRoUG9saWN5ID0gaHRtbFsnc2FuaXRpemVXaXRoUG9saWN5J10gPSBzYW5pdGl6ZVdpdGhQb2xpY3k7XG4gIGh0bWwudW5lc2NhcGVFbnRpdGllcyA9IGh0bWxbJ3VuZXNjYXBlRW50aXRpZXMnXSA9IHVuZXNjYXBlRW50aXRpZXM7XG4gIHJldHVybiBodG1sO1xufSkoaHRtbDQpO1xuXG52YXIgaHRtbF9zYW5pdGl6ZSA9IGh0bWxbJ3Nhbml0aXplJ107XG5cbi8vIExvb3NlbiByZXN0cmljdGlvbnMgb2YgQ2FqYSdzXG4vLyBodG1sLXNhbml0aXplciB0byBhbGxvdyBmb3Igc3R5bGluZ1xuaHRtbDQuQVRUUklCU1snKjo6c3R5bGUnXSA9IDA7XG5odG1sNC5FTEVNRU5UU1snc3R5bGUnXSA9IDA7XG5odG1sNC5BVFRSSUJTWydhOjp0YXJnZXQnXSA9IDA7XG5odG1sNC5FTEVNRU5UU1sndmlkZW8nXSA9IDA7XG5odG1sNC5BVFRSSUJTWyd2aWRlbzo6c3JjJ10gPSAwO1xuaHRtbDQuQVRUUklCU1sndmlkZW86OnBvc3RlciddID0gMDtcbmh0bWw0LkFUVFJJQlNbJ3ZpZGVvOjpjb250cm9scyddID0gMDtcbmh0bWw0LkVMRU1FTlRTWydhdWRpbyddID0gMDtcbmh0bWw0LkFUVFJJQlNbJ2F1ZGlvOjpzcmMnXSA9IDA7XG5odG1sNC5BVFRSSUJTWyd2aWRlbzo6YXV0b3BsYXknXSA9IDA7XG5odG1sNC5BVFRSSUJTWyd2aWRlbzo6Y29udHJvbHMnXSA9IDA7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaHRtbF9zYW5pdGl6ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwicmVxdWlyZSgnbWFwYm94LmpzJylcbnF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpLFxuICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyksXG4gIGN0ciA9IHJlcXVpcmUoJ0B0dXJmL2NlbnRyb2lkJyksXG4gIGJ1ZiA9IHJlcXVpcmUoJ0B0dXJmL2J1ZmZlcicpXG53aW5kb3cucGFyc2VkVXJsID0gdXJsLnBhcnNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB0cnVlLCB0cnVlKVxud2luZG93LnNlYXJjaFBhcmFtcyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHBhcnNlZFVybC5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbndpbmRvdy5xID0gcXVlcnlzdHJpbmc7XG53aW5kb3cuY2VudCA9IGN0clxud2luZG93LmJ1ZmYgPSBidWZcbi8vIHJlcXVpcmUoJ2xlYWZsZXQtYWpheCcpO1xuLy8gZXhwb3NlIGZvciBkZWJ1Z2dpbmdcbndpbmRvdy5pZFRvRmVhdHVyZSA9IHtwbGFjZXM6e319XG53aW5kb3cuZXZlbnRzT2JqID0geydkYXRlVGltZUZvcm1hdCc6ICdpc284NjAxJywnZXZlbnRzJzpbIF19O1xud2luZG93Lm15TGF5ZXIgPSB7fVxud2luZG93LnBvaW50RmVhdHVyZXMgPSBbXVxud2luZG93LmxpbmVGZWF0dXJlcyA9IFtdXG53aW5kb3cudGwgPSB7fVxud2luZG93LnRsTWlkcG9pbnQgPSAnJ1xuXG4kKGZ1bmN0aW9uKCkge1xuICBzdGFydE1hcE0oc2VhcmNoUGFyYW1zWydkJ10pXG4gICQoXCIjbWVudVwiKS5jbGljayhmdW5jdGlvbigpe1xuICAgICQoXCIjZGF0YVwiKS50b2dnbGUoXCJmYXN0XCIpXG4gIH0pXG4gICQoXCIuZGF0YS1oZWFkZXJcIikuaHRtbChzZWFyY2hQYXJhbXNbJ2QnXSlcbn0pO1xuXG53aW5kb3cubWlkcG9pbnQgPSBmdW5jdGlvbih0cyx0eXBlKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdtaWRwb2ludCgpJyx0cyx0eXBlKVxuICBpZih0eXBlID09ICdzdGFydCcpIHtcbiAgICB2YXIgbWlkID0gbmV3IERhdGUodHNbMF0pXG4gIH0gZWxzZSBpZih0eXBlID09ICdtaWQnKSB7XG4gICAgbGV0IHN0YXJ0ID0gbmV3IERhdGUodHNbMF0pXG4gICAgbGV0IGVuZCA9IHRzWzNdID09ICgnJyB8fCB1bmRlZmluZWQpID8gbmV3IERhdGUoRGF0ZS5ub3coKSkgOiBuZXcgRGF0ZSh0c1szXSlcbiAgICB2YXIgbWlkID0gbmV3IERhdGUoKHN0YXJ0LmdldFRpbWUoKSArIGVuZC5nZXRUaW1lKCkpIC8gMik7XG4gIH1cbiAgcmV0dXJuIG1pZFxufVxud2luZG93LmluaXRUaW1lbGluZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICBjb25zb2xlLmxvZygndGxNaWRwb2ludCcsdGxNaWRwb2ludClcbiAgLy8gbGV0IHNvdXJjZUZpbGUgPSAnZGF0YS8nICsgZmlsZVxuICAvLyBjb25zb2xlLmxvZygnaW4gaW5pdFRpbWVsaW5lKCknLCBKU09OLnN0cmluZ2lmeShldmVudHMuZXZlbnRzWzBdKSlcbiAgd2luZG93LmV2ZW50U3JjID0gbmV3IFRpbWVsaW5lLkRlZmF1bHRFdmVudFNvdXJjZSgwKTtcbiAgLy8gRXhhbXBsZSBvZiBjaGFuZ2luZyB0aGUgdGhlbWUgZnJvbSB0aGUgZGVmYXVsdHNcbiAgLy8gVGhlIGRlZmF1bHQgdGhlbWUgaXMgZGVmaW5lZCBpblxuICAvLyBodHRwOi8vc2ltaWxlLXdpZGdldHMuZ29vZ2xlY29kZS5jb20vc3ZuL3RpbWVsaW5lL3RhZ3MvbGF0ZXN0L3NyYy93ZWJhcHAvYXBpL3NjcmlwdHMvdGhlbWVzLmpzXG4gIHZhciB0aGVtZSA9IFRpbWVsaW5lLkNsYXNzaWNUaGVtZS5jcmVhdGUoKTtcbiAgdGhlbWUuZXZlbnQuYnViYmxlLndpZHRoID0gMzUwO1xuICB0aGVtZS5ldmVudC5idWJibGUuaGVpZ2h0ID0gMzAwO1xuXG4gIC8vIHZhciBkID0gVGltZWxpbmUuRGF0ZVRpbWUucGFyc2VHcmVnb3JpYW5EYXRlVGltZShcIjIwMTYtMTAtMDFcIilcbiAgdmFyIGQgPSBUaW1lbGluZS5EYXRlVGltZS5wYXJzZUdyZWdvcmlhbkRhdGVUaW1lKHRsTWlkcG9pbnQpXG4gIHZhciBiYW5kSW5mb3MgPSBbXG4gICAgICBUaW1lbGluZS5jcmVhdGVCYW5kSW5mbyh7XG4gICAgICAgICAgd2lkdGg6ICAgICAgICAgIFwiNzUlXCIsXG4gICAgICAgICAgLy8gaW50ZXJ2YWxVbml0OiAgIFRpbWVsaW5lLkRhdGVUaW1lLkRBWSxcbiAgICAgICAgICBpbnRlcnZhbFVuaXQ6ICAgVGltZWxpbmUuRGF0ZVRpbWUuWUVBUixcbiAgICAgICAgICAvLyBpbnRlcnZhbFVuaXQ6ICAgVGltZWxpbmUuRGF0ZVRpbWUuREVDQURFLFxuICAgICAgICAgIC8vIGludGVydmFsVW5pdDogICBUaW1lbGluZS5EYXRlVGltZS5XRUVLLFxuICAgICAgICAgIC8vIGludGVydmFsVW5pdDogICBUaW1lbGluZS5EYXRlVGltZS5DRU5UVVJZLFxuICAgICAgICAgIGludGVydmFsUGl4ZWxzOiA1MCxcbiAgICAgICAgICBldmVudFNvdXJjZTogICAgZXZlbnRTcmMsXG4gICAgICAgICAgZGF0ZTogICAgICAgICAgIGQsXG4gICAgICAgICAgdGhlbWU6ICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgIGxheW91dDogICAgICAgICAnb3JpZ2luYWwnICAvLyBvcmlnaW5hbCwgb3ZlcnZpZXcsIGRldGFpbGVkXG4gICAgICB9KSxcbiAgICAgIFRpbWVsaW5lLmNyZWF0ZUJhbmRJbmZvKHtcbiAgICAgICAgICB3aWR0aDogICAgICAgICAgXCIyNSVcIixcbiAgICAgICAgICAvLyBpbnRlcnZhbFVuaXQ6ICAgVGltZWxpbmUuRGF0ZVRpbWUuV0VFSyxcbiAgICAgICAgICAvLyBpbnRlcnZhbFVuaXQ6ICAgVGltZWxpbmUuRGF0ZVRpbWUuREVDQURFLFxuICAgICAgICAgIC8vIGludGVydmFsVW5pdDogICBUaW1lbGluZS5EYXRlVGltZS5NT05USCxcbiAgICAgICAgICBpbnRlcnZhbFVuaXQ6ICAgVGltZWxpbmUuRGF0ZVRpbWUuQ0VOVFVSWSxcbiAgICAgICAgICAvLyBpbnRlcnZhbFVuaXQ6ICAgVGltZWxpbmUuRGF0ZVRpbWUuTUlMTEVOSVVNLFxuICAgICAgICAgIGludGVydmFsUGl4ZWxzOiAxMjAsXG4gICAgICAgICAgZXZlbnRTb3VyY2U6ICAgIGV2ZW50U3JjLFxuICAgICAgICAgIGRhdGU6ICAgICAgICAgICBkLFxuICAgICAgICAgIHRoZW1lOiAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICBsYXlvdXQ6ICAgICAgICAgJ292ZXJ2aWV3JyAgLy8gb3JpZ2luYWwsIG92ZXJ2aWV3LCBkZXRhaWxlZFxuICAgICAgfSlcbiAgXTtcbiAgYmFuZEluZm9zWzFdLnN5bmNXaXRoID0gMDtcbiAgYmFuZEluZm9zWzFdLmhpZ2hsaWdodCA9IHRydWU7XG5cbiAgdGwgPSBUaW1lbGluZS5jcmVhdGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0bFwiKSwgYmFuZEluZm9zLCBUaW1lbGluZS5IT1JJWk9OVEFMKTtcbiAgLy8gZnJvbSBhIGZpbGVcbiAgLy8gdGwubG9hZEpTT04oXCJkYXRhL2V1cm9fcG9sYW5kLnRsLmpzb25cIiwgZnVuY3Rpb24oanNvbiwgdXJsKSB7XG4gIC8vICAgZXZlbnRTcmMubG9hZEpTT04oanNvbiwgdXJsKTtcbiAgLy8gfSk7XG4gIC8vIGZyb20gdGhlIGR5bmFtaWMgb2JqZWN0OyBubyBpZGVhIHdoeSBpdCBuZWVkcyBhIGR1bW15IHVybFxuICBldmVudFNyYy5sb2FkSlNPTihldmVudHMsICdkdW1teVVybCcpO1xufVxuXG52YXIgcmVzaXplVGltZXJJRCA9IG51bGw7XG5cbmZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgIGlmIChyZXNpemVUaW1lcklEID09IG51bGwpIHtcbiAgICAgICAgcmVzaXplVGltZXJJRCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzaXplVGltZXJJRCA9IG51bGw7XG4gICAgICAgICAgICB0bC5sYXlvdXQoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2hlbihwbGFjZSl7XG4gIC8vIGRvZXMgVG9wb3RpbWUgcGxhY2UgcmVjb3JkIGhhdmUgdmFsaWQgd2hlbiBvYmplY3Q/XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXZlbnQocGxhY2Upe1xuICAvLyBjb25zb2xlLmxvZyhwbGFjZSlcbiAgLy8gbmVlZCB2YWxpZGF0ZSBmdW5jdGlvbiBoZXJlXG4gIC8vIGlmKHZhbGlkYXRlV2hlbihwbGFjZSk9PXRydWUge30pXG4gIHZhciBldmVudCA9IHt9O1xuICBldmVudFsnaWQnXSA9IHBsYWNlLnByb3BlcnRpZXMuaWQ7XG4gIGV2ZW50Wyd0aXRsZSddID0gcGxhY2UucHJvcGVydGllcy5sYWJlbDtcbiAgZXZlbnRbJ2Rlc2NyaXB0aW9uJ10gPSAhcGxhY2UucHJvcGVydGllcy5kZXNjcmlwdGlvbiA/IFwiXCIgOiBwbGFjZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xuICAvLyBhc3N1bWluZyB2YWxpZDsgd2Uga25vdyBpdCdzIHRoZXJlIGluIHRveSBleGFtcGxlXG4gIGV2ZW50WydzdGFydCddID0gcGxhY2Uud2hlbi50aW1lc3BhbnNbMF0uc3RhcnQuZWFybGllc3Q7XG4gIGV2ZW50WydsYXRlc3RTdGFydCddID0gIXBsYWNlLndoZW4udGltZXNwYW5zWzBdLnN0YXJ0LmxhdGVzdCA/IFwiXCIgOnBsYWNlLndoZW4udGltZXNwYW5zWzBdLnN0YXJ0LmxhdGVzdDtcbiAgZXZlbnRbJ2VuZCddID0gcGxhY2Uud2hlbi50aW1lc3BhbnNbMF0uZW5kLmxhdGVzdDtcbiAgZXZlbnRbJ2VhcmxpZXN0RW5kJ10gPSAhcGxhY2Uud2hlbi50aW1lc3BhbnNbMF0uZW5kLmxhdGVzdCA/IFwiXCIgOnBsYWNlLndoZW4udGltZXNwYW5zWzBdLmVuZC5sYXRlc3Q7XG4gIGV2ZW50WydkdXJhdGlvbkV2ZW50J10gPSBcInRydWVcIjtcbiAgZXZlbnRbJ2xpbmsnXSA9IFwiXCI7XG4gIGV2ZW50WydpbWFnZSddID0gXCJcIjtcblxuICByZXR1cm4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2VnbWVudEV2ZW50KGZlYXQpe1xuICBjb25zb2xlLmxvZygnIGluIGJ1aWxkU2VnbWVudEV2ZW50KCknLGZlYXQud2hlbi50aW1lc3BhbilcbiAgLy8gbmVlZCB2YWxpZGF0ZSBmdW5jdGlvbiBoZXJlXG4gIC8vIGlmKHZhbGlkYXRlV2hlbihwbGFjZSk9PXRydWUge30pXG4gIHZhciBldmVudCA9IHt9O1xuICBldmVudFsnaWQnXSA9IGZlYXQucHJvcGVydGllcy5zZWdtZW50X2lkO1xuICBldmVudFsndGl0bGUnXSA9IGZlYXQucHJvcGVydGllcy5sYWJlbDtcbiAgZXZlbnRbJ2Rlc2NyaXB0aW9uJ10gPSAhZmVhdC5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uID8gXCJcIiA6IGZlYXQucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcbiAgLy8gYXNzdW1pbmcgdmFsaWQ7IHdlIGtub3cgaXQncyB0aGVyZSBpbiB0b3kgZXhhbXBsZVxuICBldmVudFsnc3RhcnQnXSA9IGZlYXQud2hlbi50aW1lc3BhblswXTtcbiAgZXZlbnRbJ2xhdGVzdFN0YXJ0J10gPSBmZWF0LndoZW4udGltZXNwYW5bMV0gPT0gXCJcIiA/IFwiXCIgOmZlYXQud2hlbi50aW1lc3BhblsxXTtcbiAgZXZlbnRbJ2VhcmxpZXN0RW5kJ10gPSBmZWF0LndoZW4udGltZXNwYW5bMl0gPT0gXCJcIiA/IFwiXCIgOmZlYXQud2hlbi50aW1lc3BhblsyXTtcbiAgZXZlbnRbJ2VuZCddID0gZmVhdC53aGVuLnRpbWVzcGFuWzNdID09IFwiXCIgPyBcIlwiIDpmZWF0LndoZW4udGltZXNwYW5bM107XG4gIGV2ZW50WydkdXJhdGlvbkV2ZW50J10gPSBcInRydWVcIjtcbiAgZXZlbnRbJ2xpbmsnXSA9IFwiXCI7XG4gIGV2ZW50WydpbWFnZSddID0gXCJcIjtcbiAgLy8gY29uc29sZS5sb2coJ2J1aWx0ICcsIGV2ZW50KVxuICByZXR1cm4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29sbGVjdGlvblBlcmlvZChjb2xsKXtcbiAgd2luZG93LnRzID0gY29sbC53aGVuLnRpbWVzcGFuXG4gIHZhciBldmVudCA9IHt9O1xuICBldmVudFsnaWQnXSA9ICdMaW5rZWRQbGFjZXMwMDEnO1xuICBldmVudFsndGl0bGUnXSA9ICd2YWxpZCBwZXJpb2QsICcrY29sbC5hdHRyaWJ1dGVzLnRpdGxlO1xuICBldmVudFsnZGVzY3JpcHRpb24nXSA9IHRzWzRdO1xuICBldmVudFsnc3RhcnQnXSA9IHRzWzBdO1xuICBldmVudFsnbGF0ZXN0U3RhcnQnXSA9IHRzWzFdID09IFwiXCIgPyBcIlwiIDp0c1sxXTtcbiAgZXZlbnRbJ2VhcmxpZXN0RW5kJ10gPSB0c1syXSA9PSBcIlwiID8gXCJcIiA6dHNbMl07XG4gIGV2ZW50WydlbmQnXSA9IHRzWzNdID09IFwiXCIgPyBcIlwiIDp0c1szXTtcbiAgZXZlbnRbJ2R1cmF0aW9uRXZlbnQnXSA9IFwidHJ1ZVwiO1xuICBldmVudFsnbGluayddID0gXCJcIjtcbiAgLy8gZXZlbnRbJ2xpbmsnXSA9IGNvbGwuYXR0cmlidXRlcy51cmk7XG4gIGV2ZW50WydpbWFnZSddID0gXCJcIjtcbiAgY29uc29sZS5sb2coJ2V2ZW50JywgSlNPTi5zdHJpbmdpZnkoZXZlbnQpKVxuICB0bE1pZHBvaW50ID0gbWlkcG9pbnQodHMsJ3N0YXJ0JylcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG52YXIgbWFwU3R5bGVzID0ge1xuICBhcmVhczoge1xuICAgICAgXCJjb2xvclwiOiBcIiM5OTMzMzNcIixcbiAgICAgIFwid2VpZ2h0XCI6IDEsXG4gICAgICBcIm9wYWNpdHlcIjogLjgsXG4gICAgICBcImZpbGxDb2xvclwiOiBcIm9yYW5nZVwiLFxuICAgICAgXCJmaWxsT3BhY2l0eVwiOiAwLjMsXG4gICAgfSxcbiAgcG9pbnRzOiB7XG4gICAgXCJjb2xvclwiOiBcIiMwMDBcIixcbiAgICBcImZpbGxDb2xvclwiOiBcIiM5OTAwMDBcIixcbiAgICBcIm1hcmtlci1zaXplXCI6IFwic21hbGxcIixcbiAgICBcIm1hcmtlci1jb2xvclwiOiBcIiMwMDY2MDBcIlxuICB9LFxuICBsaW5lczoge1xuICAgICAgXCJjb2xvclwiOiBcIiNGQjJFMzVcIixcbiAgICAgIFwid2VpZ2h0XCI6IDIsXG4gICAgICBcIm9wYWNpdHlcIjogMC42XG4gIH0sXG4gIHNlZ21lbnRzOiB7XG4gICAgICBcImNvbG9yXCI6IFwiZ3JlZW5cIixcbiAgICAgIFwid2VpZ2h0XCI6IDMsXG4gICAgICBcIm9wYWNpdHlcIjogMC42XG4gIH1cbn1cblxudmFyIGdlb2pzb25NYXJrZXJPcHRpb25zID0ge1xuICAgIHJhZGl1czogOCxcbiAgICBmaWxsQ29sb3I6IFwiI2ZmNzgwMFwiLFxuICAgIGNvbG9yOiBcIiMwMDBcIixcbiAgICB3ZWlnaHQ6IDEsXG4gICAgb3BhY2l0eTogMSxcbiAgICBmaWxsT3BhY2l0eTogMC44XG59O1xuXG5mdW5jdGlvbiB3cml0ZVBvcHVwKGxheWVyKSB7XG4gIGNvbnNvbGUubG9nKGxheWVyKVxufVxuZnVuY3Rpb24gc3VtbWFyaXplRXZlbnRzKGV2ZW50c09iail7XG4gIC8vIGdldCBib3VuZHMsIG1pZHBvaW50LCBncmFudWxhcml0eVxuICAvLyBtdWx0aS1kYXksIC13ZWVrLCAtbW9udGgsIC15ZWFyXG4gIGNvbnNvbGUubG9nKGV2ZW50c09iailcbn1cbmZ1bmN0aW9uIHN0YXJ0TWFwTShkYXRhc2V0KXtcbiAgLy8gbWFwYm94LmpzIChub24tZ2wpXG4gIEwubWFwYm94LmFjY2Vzc1Rva2VuID0gJ3BrLmV5SjFJam9pYTJkbGIyZHlZWEJvWlhJaUxDSmhJam9pVW1WcmFsQlBjeUo5Lm1KZWdBSTFSNktSMjF4X0NWVlRscXcnO1xuXG4gIC8vIEFXTUMgdGlsZXMgaW4gbWFwYm94XG4gIHdpbmRvdy50dG1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ2lzYXdueXUubWFwLWtubWN0bGtoJylcblxuICAvKiAgcmVhZCBhIHNpbmdsZSBGZWF0dXJlQ29sbGVjdGlvbiBvZlxuICAgICAgUGxhY2VzIChnZW9tZXRyeS50eXBlID09IFBvaW50KSwgYW5kXG4gICAgICBSb3V0ZXMgKGdlb21ldHJ5LnR5cGUgPT0gR2VvbWV0cnlDb2xsZWN0aW9uIG9yIHVuZGVmaW5lZClcbiAgICAgICAgLSByb3V0ZSBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldID09IExpbmVTdHJpbmcgb3IgTXVsdGlMaW5lU3RyaW5nXG4gICovXG4gIGxldCBmZWF0dXJlTGF5ZXIgPSBMLm1hcGJveC5mZWF0dXJlTGF5ZXIoKVxuICAgIC5sb2FkVVJMKCdkYXRhLycgKyBkYXRhc2V0ICsgJy5nZW9qc29uJylcbiAgICAub24oJ3JlYWR5JywgZnVuY3Rpb24oKXtcbiAgICAgIGNvbnNvbGUubG9nKGZlYXR1cmVMYXllcilcbiAgICAgIC8vIGdldCBDb2xsZWN0aW9uIGF0dHJpYnV0ZXNcbiAgICAgIHdpbmRvdy5jb2xsZWN0aW9uID0gZmVhdHVyZUxheWVyLl9nZW9qc29uXG4gICAgICAvLyBzZXQgdGltZWxpbmUgbWlkcG9pbnRcbiAgICAgIHRsTWlkcG9pbnQgPSBtaWRwb2ludChjb2xsZWN0aW9uLndoZW4udGltZXNwYW4sJ21pZCcpXG5cbiAgICAgIC8vIGJ1aWxkIHNlcGFyYXRlIEwuZmVhdHVyZUdyb3VwIGZvciBwb2ludHMgJiBsaW5lc1xuICAgICAgZmVhdHVyZUxheWVyLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG4gICAgICAgIGxldCBnZW9tRiA9IGxheWVyLmZlYXR1cmUuZ2VvbWV0cnlcbiAgICAgICAgbGV0IHdoZW5GID0gbGF5ZXIuZmVhdHVyZS53aGVuXG4gICAgICAgIC8qICBmZWF0dXJlIGNhc2VzOlxuICAgICAgICAgICAgUGxhY2UgaWYoZ2VvbUYudHlwZSA9PSAnUG9pbnQnKVxuICAgICAgICAqL1xuICAgICAgICAvLyBwdXQgcGxhY2VzIGZlYXR1cmVzIHBvaW50RmVhdHVyZXMgYXJyYXlcbiAgICAgICAgaWYoZ2VvbUYudHlwZSA9PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICBsZXQgbGF0bG5nID0gbmV3IEwuTGF0TG5nKGdlb21GLmNvb3JkaW5hdGVzWzFdLGdlb21GLmNvb3JkaW5hdGVzWzBdKVxuICAgICAgICAgICAgbGV0IHBsYWNlRmVhdHVyZSA9IG5ldyBMLkNpcmNsZU1hcmtlcihsYXRsbmcsIHtcbiAgICAgICAgICAgICAgY29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiAnI2ZmZmYwMCcsXG4gICAgICAgICAgICAgIHJhZGl1czogNCxcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcbiAgICAgICAgICAgICAgd2VpZ2h0OiAxXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGxhY2VGZWF0dXJlLmJpbmRQb3B1cChsYXllci5mZWF0dXJlLnByb3BlcnRpZXMudG9wb255bSlcbiAgICAgICAgICAgIHBvaW50RmVhdHVyZXMucHVzaChwbGFjZUZlYXR1cmUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHJlc3QgYXJlIHJvdXRlcyB3aXRoIHNlZ21lbnRzIGluIGEgR2VvbWV0cnlDb2xsZWN0aW9uXG4gICAgICAgIGVsc2UgaWYoZ2VvbUYudHlwZSA9PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsYXllci5mZWF0dXJlJywgbGF5ZXIuZmVhdHVyZSlcbiAgICAgICAgICAvLyogVE9ETzogY3JlYXRlIGZlYXR1cmUgZm9yIGVhY2ggZ2VvbWV0cnlcbiAgICAgICAgICBmb3IoaSBpbiBnZW9tRi5nZW9tZXRyaWVzKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhnZW9tRi5nZW9tZXRyaWVzW2ldKVxuICAgICAgICAgICAgICBsZXQgd2hlbk9iaiA9IGdlb21GLmdlb21ldHJpZXNbaV0ud2hlblxuICAgICAgICAgICAgICBsZXQgZmVhdCA9IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjpcIkZlYXR1cmVcIixcbiAgICAgICAgICAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOmdlb21GLmdlb21ldHJpZXNbaV0udHlwZSxcbiAgICAgICAgICAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjpnZW9tRi5nZW9tZXRyaWVzW2ldLmNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwid2hlblwiOiB3aGVuT2JqLFxuICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiBnZW9tRi5nZW9tZXRyaWVzW2ldLnByb3BlcnRpZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZmVhdCcsIGZlYXQpXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd3aGVuT2JqJywgd2hlbk9iailcbiAgICAgICAgICAgICAgc2VnbWVudCA9IG5ldyBMLkdlb0pTT04oZmVhdCwge1xuICAgICAgICAgICAgICAgICAgc3R5bGU6IG1hcFN0eWxlcy5zZWdtZW50c1xuICAgICAgICAgICAgICAgIH0pLmJpbmRQb3B1cCgnPGI+JytmZWF0LnByb3BlcnRpZXMubGFiZWwrJzwvYj48YnIvPihzZWdtZW50ICcrXG4gICAgICAgICAgICAgICAgICBmZWF0LnByb3BlcnRpZXMuc2VnbWVudF9pZCsnKScpXG5cbiAgICAgICAgICAgICAgbGluZUZlYXR1cmVzLnB1c2goc2VnbWVudClcblxuICAgICAgICAgICAgICAvLyogYnVpbGQgZXZlbnQgb2JqZWN0IGZvciB0aW1lbGluZVxuICAgICAgICAgICAgICBpZiAod2hlbk9iaiAhPSAoe30gfHwgJycpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24uYXR0cmlidXRlcy5zZWdtZW50VHlwZSA9PSAnam91cm5leScpIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50c09iai5ldmVudHMucHVzaChidWlsZFNlZ21lbnRFdmVudChmZWF0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGV2ZW50c09iai5ldmVudHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIGEgcGVyaW9kXG4gICAgICAgICAgICBldmVudHNPYmouZXZlbnRzLnB1c2goYnVpbGRDb2xsZWN0aW9uUGVyaW9kKGNvbGxlY3Rpb24pKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2J1aWQnLGJ1aWxkQ29sbGVjdGlvblBlcmlvZChjb2xsZWN0aW9uKSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwZXJpb2QgZXZlbnRzT2JqJywgZXZlbnRzT2JqLmV2ZW50c1swXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2cod2hlbkYgPT0gdW5kZWZpbmVkID8gJ3doZW5GIHVuZGVmJyA6IHdoZW5GKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLy8gY29uc29sZS5sb2coc3VtbWFyaXplRXZlbnRzKGV2ZW50c09iaikpXG4gICAgICB3aW5kb3cucGxhY2VzID0gTC5mZWF0dXJlR3JvdXAocG9pbnRGZWF0dXJlcykuYWRkVG8odHRtYXApXG4gICAgICB0dG1hcC5maXRCb3VuZHMocGxhY2VzLmdldEJvdW5kcygpKVxuICAgICAgd2luZG93LnNlZ21lbnRzID0gTC5mZWF0dXJlR3JvdXAobGluZUZlYXR1cmVzKS5hZGRUbyh0dG1hcClcbiAgICAgIGluaXRUaW1lbGluZShldmVudHNPYmopXG4gICAgfSlcblxuXG4vKiB4dWFuemFuZ1xuICAgICAgICBcIndoZW5cIjoge1xuICAgICAgICAgIFwiZm9sbG93c1wiOiBcIjIwNjA0XCIsXG4gICAgICAgICAgXCJkdXJhdGlvblwiOiBcIj9cIixcbiAgICAgICAgICBcInRpbWVzcGFuXCI6IFtcbiAgICAgICAgICAgIFwiWzA2NDUtMDEtMDFcIixcbiAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCIwNjQ1LTEyLTMxXCIsXG4gICAgICAgICAgICBcIl1cIlxuICAgICAgICAgIF1cbiAgICAgICAgfVxuKi9cblxuLyogcG9sYW5kc1xuICAgICAgICBcIndoZW5cIjoge1xuICAgICAgICAgIFwidGltZXNwYW5zXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgXCJsYWJlbFwiOiBcImluIDgwMFwiLFxuICAgICAgICAgICAgICBcInN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgICBcImVhcmxpZXN0XCI6IFwiMDc1MC0wMS0wMVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiZW5kXCI6IHtcbiAgICAgICAgICAgICAgICBcImxhdGVzdFwiOiBcIjA4NTAtMTItMzFcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4qL1xuICAgICAgICAvLyBpZiAoZ2VvbUYudHlwZSA9J0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZygnY29sbGVjdGlvbiB3LycsIGdlb21GLmdlb21ldHJpZXMubGVuZ3RoLCAnIHNlZ21lbnRzOyB3aGVuID0gJywgd2hlbkYpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2cobGF5ZXIuZmVhdHVyZS53aGVuKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygpXG5cblxuICAgICAgICAvLyBidWlsZCB0ZW1wb3JhbCBvYmplY3QgYW5kIHBhc3MgdG8gdGltZWxpbmVcbiAgICAgICAgLy8gZXZlbnRzT2JqLmV2ZW50cy5wdXNoKGJ1aWxkRXZlbnQobGF5ZXIuZmVhdHVyZSkpO1xuICAgIC8vICAgICBpZFRvRmVhdHVyZVsncGxhY2VzJ11bbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmlkXSA9IGxheWVyLl9sZWFmbGV0X2lkO1xuICAgIC8vICAgfSlcbiAgICAvLyAgIGluaXRUaW1lbGluZShldmVudHNPYmopO1xuICAgIC8vICAgLy8gaW5pdFRpbWVsaW5lKCcnKTtcbiAgICAvLyB9KVxuICAgIC8vIC5hZGRUbyh0dG1hcCk7XG5cbi8vIH1cblxuXG4vLyBvcGVuIHBvcHVwXG4vLyBmZWF0dXJlTGF5ZXIuX2xheWVyc1s5Ml0ub3BlblBvcHVwKClcbi8vIHN0eWxlXG4vLyBmZWF0dXJlTGF5ZXIuX2xheWVyc1tpZFRvRmVhdHVyZVsncGxhY2VzJ11bJ3BvbDAzJ11dLnNldFN0eWxlKHtmaWxsQ29sb3IgOidibHVlJ30pXG5cbi8vIGV2ZW50IGZvcm1hdFxuLy8ge1xuLy8gJ2RhdGVUaW1lRm9ybWF0JzogJ2lzbzg2MDEnLFxuLy8gJ2V2ZW50cycgOlxuLy8gICBbXG4vLyAgICAgeydzdGFydCc6ICcxOTAwJywgJ2xhdGVzdFN0YXJ0JzogJzE5MDEnLCAnZWFybGllc3RFbmQnOiAnMTkwMycsICdlbmQnOiAnMTkwMicsXG4vLyAgICAgJ3RpdGxlJzogJ1Rlc3QgNmc6IEJhZCBkYXRlczogZWFybGllc3RFbmQgPiBlbmQnLFxuLy8gICAgICdkZXNjcmlwdGlvbic6ICdUZXN0IDZnOiBCYWQgZGF0ZXM6IGVhcmxpZXN0RW5kID4gZW5kJyxcbi8vICAgICAnZHVyYXRpb25FdmVudCc6IHRydWUsICdpbWFnZSc6Jzx1cmw+JywgJ2xpbmsnOic8dXJsPidcbi8vICAgICB9LFxuLy8gICAgIHt9XG4vLyAgIF1cbn1cbi8vIGZ1bmN0aW9uIHN0YXJ0TWFwTCgpe1xuLy8gICAvLyBMZWFmbGV0IHN0eWxlXG4vLyAgIGxldCB0dG1hcCA9IEwubWFwKCdtYXAnKVxuLy8gICAgIC5zZXRWaWV3KFs1MC4wNjQxOTE3MzY2NTkxMDQsIDE1LjU1NjY0MDYyNDk5OTk5OF0sIDQpO1xuLy8gICB3aW5kb3cuZmVhdHVyZUxheWVyID0gTC5nZW9Kc29uLmFqYXgoJ2RhdGEvcG9sYW5kcy50dF9mZWF0dXJlLXdoZW4uanNvbicse1xuLy8gICAgIG9uRWFjaEZlYXR1cmU6IGZ1bmN0aW9uKGZlYXR1cmUsIGxheWVyKXtcbi8vICAgICAgIGxheWVyLmJpbmRQb3B1cCgnZm9vLCBkYW1taXQnKVxuLy8gICAgIH1cbi8vICAgfSlcbi8vICAgLmFkZFRvKHR0bWFwKTtcbi8vXG4vLyAgIGluaXRUaW1lbGluZShldmVudHNPYmopO1xuLy8gfVxuIl19
